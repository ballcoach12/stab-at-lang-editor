import { lf as Yn, o as O, w as xe, bc as Qn, L as k, t as Ct, V as Xn, a0 as Ve, a2 as Ue, H as mt, $ as ge, G as ao, b6 as ii, c4 as Ho, x as ft, lD as zo, lE as Zn, au as Nt, lF as er, B as o, _ as I, a as h, ae as de, aM as Bi, aL as T, ad as Fi, ab as qo, bW as Ni, e as ce, aP as Ze, E as R, k7 as Yt, b3 as oi, a5 as tr, ba as ir, lG as or, aR as co, du as nr, bi as v, c3 as y, aj as L, lH as De, ak as C, aG as l, ac as _, ai as c, aK as et, bM as g, aE as E, aB as Ko, n as Vi, lI as At, lJ as rr, lx as jo, lK as We, af as sr, fS as ar, lL as $o, bx as Ui, ag as Vt, lM as ni, fH as Jo, bN as dr, bf as cr, bP as lr, lN as ur, lO as hr, dP as pr, c_ as gr, e3 as lo, lP as mr, eb as fr, lQ as Er, lR as vr, s as br, m as ie, aI as tt, aa as Pe, j5 as _e, lS as Sr, lT as yr, bC as Wi, eV as Qt, eX as uo, eW as ri, eU as Cr, g as it, bF as wr, dy as Ge, dj as Ut, eO as Ir, jr as wt, lU as ho, kl as oe, lV as Mr, iB as Ar, gr as Yo, lW as si, lX as Dr, d8 as Qo, cP as Se, aH as kr, D as K, lY as Lr, lZ as J, bB as Wt, bE as Xo, f as Hi, ji as zi, l_ as Rr, l$ as Tr, jo as xr, bU as Pr, jb as ae, dq as fe, dr as X, z as ee, S as Dt, m0 as po, fb as go, cK as mo, dQ as _r, m1 as Gr, U as G, m2 as fo, m3 as Or, jq as ot, dS as nt, bz as Zo, m4 as Br, m5 as Fr, m6 as Nr, m7 as Vr, m8 as Ur, m9 as Wr, ma as Hr, mb as en, ho as Ce, mc as ai, md as di, me as zr, kN as Et, hh as qi, mf as qr, at as je, mg as Kr, mh as Eo, hC as he, hg as jr, dx as tn, mi as Q, mj as $r, fg as It, cS as Jr, bv as Ki, jx as Yr, aX as Qr, d as He, j1 as Xr, an as on, eC as Zr, jy as ji, lo as es, jz as ts, mk as is, jU as Xt, N as V, hY as os, ml as vt, gp as ns, av as pe, dD as $i, ah as rs, a9 as ss, bV as as, jv as ds, mm as rt, hv as cs, mn as ls, mo as us, eT as st, mp as vo, k as $e, mq as ci, mr as bo, gu as Ji, hM as at, hu as hs, ms as So, mt as ps, bw as gs, mu as yo, mv as nn, mw as Co, mx as rn, my as wo, mz as sn, mA as ms, mB as fs, mC as Es, mD as vs, mE as bs, mF as Ss, mG as ys, mH as Cs, mI as ws, mJ as Is, mK as Ms, mL as As, mM as an, mN as dn, mO as Ds, mP as ks, mQ as Ls, mR as Rs, mS as Ts, mT as xs, mU as Yi, mV as Ps, mW as _s, mX as Gs, mY as Os, mZ as Bs, m_ as Fs, m$ as Ns, n0 as Vs, n1 as Us, n2 as Ws, n3 as Hs, n4 as zs, n5 as qs, n6 as Ks, n7 as js, n8 as $s, n9 as Js, na as Ys, nb as Qs, nc as Xs, nd as Zs, ne as ea, nf as ta, ng as ia, nh as oa, ni as na, nj as ra, nk as sa, nl as aa, nm as da, nn as ca, no as la, np as ua, nq as ha, nr as pa, ns as ga, nt as ma, nu as fa, nv as Ea, nw as va, nx as ba, ny as Sa, nz as ya, nA as Ca, nB as wa, nC as Ia, nD as Ma, nE as Aa, nF as Da, nG as ka, nH as La, nI as Ra, nJ as Ta, nK as xa, nL as Pa, nM as _a, nN as Ga, nO as Oa, nP as Ba, nQ as Fa, nR as Na, nS as cn, nT as ln, nU as un, nV as hn, nW as pn, nX as gn, nY as mn, nZ as fn, n_ as Va, n$ as Ua, o0 as Wa, o1 as Ha, o2 as za, o3 as qa, o4 as Ka, by as En, o5 as ja, ex as vn, dO as Ht, o6 as bn, o7 as zt, o8 as dt, o9 as qt, oa as ct, ob as Sn, oc as B, eZ as Oe, gV as yn, f7 as $a, od as Cn, dJ as wn, oe as lt, gW as Qi, gX as ut, gO as In, dL as Mn, of as An, dH as Ja, og as Dn, dK as Be, oh as Kt, oi as kn, dM as Ln, oj as Rn, dN as ht, ok as Ya, ol as Qa, om as Xa, on as Za, f6 as jt, oo as ed, op as td, oq as Fe, or as Tn, os as id, ot as od, ou as nd, ov as rd, ow as sd, hQ as me, hR as ze, ox as li, jD as xn, dv as ad, oy as dd, bG as Pn, e7 as cd, h as _n, oz as Gn, ld as Io, fw as ld, oA as ud, ao as hd, kk as pd, oB as On, jQ as Zt, jW as gd, jP as md, gt as Bn, ap as Mo, oC as Ao, lv as fd, le as Xi, gi as Zi, oD as Ed, b as vd, lB as w, oE as ui, fh as bd, eQ as Do, eR as ko } from "./index-7e82f14c.js";
import { S as Sd } from "./simpleIconLabel-cbc6bc36.js";
class eo extends Ze {
  constructor(e) {
    var t;
    super(e.id, e.name, (t = e.classNames) == null ? void 0 : t.join(" "), !0), this._activity = e, this._onDidChangeActivity = this._register(new R()), this.onDidChangeActivity = this._onDidChangeActivity.event, this._onDidChangeBadge = this._register(new R()), this.onDidChangeBadge = this._onDidChangeBadge.event;
  }
  get activity() {
    return this._activity;
  }
  set activity(e) {
    this._label = e.name, this._activity = e, this._onDidChangeActivity.fire(this);
  }
  activate() {
    this.checked || this._setChecked(!0);
  }
  deactivate() {
    this.checked && this._setChecked(!1);
  }
  getBadge() {
    return this.badge;
  }
  getClass() {
    return this.clazz;
  }
  setBadge(e, t) {
    this.badge = e, this.clazz = t, this._onDidChangeBadge.fire(this);
  }
  dispose() {
    this._onDidChangeActivity.dispose(), this._onDidChangeBadge.dispose(), super.dispose();
  }
}
var be;
let kt = (be = class extends Yn {
  constructor(e, t, i, n, r, s, a) {
    super(null, e, t), this.badgesEnabled = i, this.themeService = n, this.hoverService = r, this.configurationService = s, this.keybindingService = a, this.badgeDisposable = this._register(new O()), this.hoverDisposables = this._register(new xe()), this.showHoverScheduler = new Qn(() => this.showHover(), 0), this.options = t, this._register(this.themeService.onDidColorThemeChange(this.onThemeChange, this)), this._register(e.onDidChangeActivity(this.updateActivity, this)), this._register(k.filter(a.onDidUpdateKeybindings, () => this.keybindingLabel !== this.computeKeybindingLabel())(() => this.updateTitle())), this._register(e.onDidChangeBadge(this.updateBadge, this)), this._register(Ct(() => this.showHoverScheduler.cancel()));
  }
  get activity() {
    return this._action.activity;
  }
  updateStyles() {
    const e = this.themeService.getColorTheme(), t = this.options.colors(e);
    if (this.label) {
      if (this.options.icon) {
        const i = this._action.checked ? t.activeForegroundColor : t.inactiveForegroundColor;
        this.activity.iconUrl ? (this.label.style.backgroundColor = i ? i.toString() : "", this.label.style.color = "") : (this.label.style.color = i ? i.toString() : "", this.label.style.backgroundColor = "");
      } else {
        const i = this._action.checked ? t.activeForegroundColor : t.inactiveForegroundColor, n = this._action.checked ? t.activeBorderBottomColor : null;
        this.label.style.color = i ? i.toString() : "", this.label.style.borderBottomColor = n ? n.toString() : "";
      }
      this.container.style.setProperty("--insert-border-color", t.dragAndDropBorder ? t.dragAndDropBorder.toString() : "");
    }
    if (this.badgeContent) {
      const i = t.badgeForeground, n = t.badgeBackground, r = e.getColor(Xn);
      this.badgeContent.style.color = i ? i.toString() : "", this.badgeContent.style.backgroundColor = n ? n.toString() : "", this.badgeContent.style.borderStyle = r ? "solid" : "", this.badgeContent.style.borderWidth = r ? "1px" : "", this.badgeContent.style.borderColor = r ? r.toString() : "";
    }
  }
  render(e) {
    super.render(e), this.container = e, this.options.icon && this.container.classList.add("icon"), this.options.hasPopup ? (this.container.setAttribute("role", "button"), this.container.setAttribute("aria-haspopup", "true")) : this.container.setAttribute("role", "tab"), this._register(Ve(this.container, Ue.MOUSE_DOWN, () => {
      this.container.classList.add("clicked");
    })), this._register(Ve(this.container, Ue.MOUSE_UP, () => {
      this.mouseUpTimeout && clearTimeout(this.mouseUpTimeout), this.mouseUpTimeout = setTimeout(() => {
        this.container.classList.remove("clicked");
      }, 800);
    })), this.label = mt(e, ge("a")), this.badge = mt(e, ge(".badge")), this.badgeContent = mt(this.badge, ge(".badge-content")), mt(e, ge(".active-item-indicator")), ao(this.badge), this.updateActivity(), this.updateStyles(), this.updateHover();
  }
  onThemeChange(e) {
    this.updateStyles();
  }
  updateActivity() {
    this.updateLabel(), this.updateTitle(), this.updateBadge(), this.updateStyles();
  }
  updateBadge() {
    const e = this.action;
    if (!this.badge || !this.badgeContent || !(e instanceof eo))
      return;
    const t = e.getBadge(), i = e.getClass();
    this.badgeDisposable.clear(), ii(this.badgeContent), ao(this.badge);
    const n = this.badgesEnabled(this.activity.id);
    if (t && n) {
      if (t instanceof Ho) {
        if (t.number) {
          let r = t.number.toString();
          if (t.number > 999) {
            const s = t.number / 1e3, a = Math.floor(s);
            s > a ? r = `${a}K+` : r = `${s}K`;
          }
          this.badgeContent.textContent = r, ft(this.badge);
        }
      } else if (t instanceof zo)
        this.badgeContent.textContent = t.text, ft(this.badge);
      else if (t instanceof Zn) {
        const r = Nt.asClassNameArray(t.icon);
        this.badgeContent.classList.add(...r), ft(this.badge);
      } else
        t instanceof er && ft(this.badge);
      if (i) {
        const r = i.split(" ");
        this.badge.classList.add(...r), this.badgeDisposable.value = Ct(() => this.badge.classList.remove(...r));
      }
    }
    this.updateTitle();
  }
  updateLabel() {
    this.label.className = "action-label", this.activity.classNames && this.label.classList.add(...this.activity.classNames), this.options.icon || (this.label.textContent = this.action.label);
  }
  updateTitle() {
    const e = this.computeTitle();
    [this.label, this.badge, this.container].forEach((t) => {
      t && (t.setAttribute("aria-label", e), t.setAttribute("title", ""), t.removeAttribute("title"));
    });
  }
  computeTitle() {
    this.keybindingLabel = this.computeKeybindingLabel();
    let e = this.keybindingLabel ? o("titleKeybinding", "{0} ({1})", this.activity.name, this.keybindingLabel) : this.activity.name;
    const t = this.action.getBadge();
    return t != null && t.getDescription() && (e = o("badgeTitle", "{0} - {1}", e, t.getDescription())), e;
  }
  computeKeybindingLabel() {
    const e = this.activity.keybindingId ? this.keybindingService.lookupKeybinding(this.activity.keybindingId) : null;
    return e == null ? void 0 : e.getLabel();
  }
  updateHover() {
    this.hoverDisposables.clear(), this.updateTitle(), this.hoverDisposables.add(Ve(this.container, Ue.MOUSE_OVER, () => {
      this.showHoverScheduler.isScheduled() || (Date.now() - be.hoverLeaveTime < 200 ? this.showHover(!0) : this.showHoverScheduler.schedule(this.configurationService.getValue("workbench.hover.delay")));
    }, !0)), this.hoverDisposables.add(Ve(this.container, Ue.MOUSE_LEAVE, (e) => {
      e.target === this.container && (be.hoverLeaveTime = Date.now(), this.hoverService.hideHover(), this.showHoverScheduler.cancel());
    }, !0)), this.hoverDisposables.add(Ct(() => {
      this.hoverService.hideHover(), this.showHoverScheduler.cancel();
    }));
  }
  showHover(e = !1) {
    if (this.lastHover && !this.lastHover.isDisposed)
      return;
    const t = this.options.hoverOptions.position();
    this.lastHover = this.hoverService.showHover({
      target: this.container,
      hoverPosition: t,
      content: this.computeTitle(),
      showPointer: !0,
      compact: !0,
      hideOnKeyDown: !0,
      skipFadeInAnimation: e
    });
  }
  dispose() {
    super.dispose(), this.mouseUpTimeout && clearTimeout(this.mouseUpTimeout), this.badge.remove();
  }
}, be.hoverLeaveTime = 0, be);
kt = I([
  h(3, de),
  h(4, Bi),
  h(5, T),
  h(6, Fi)
], kt);
class Sc extends eo {
  constructor(e) {
    super({
      id: "additionalComposites.action",
      name: o("additionalViews", "Additional Views"),
      classNames: Nt.asClassNameArray(v.more)
    }), this.showMenu = e;
  }
  async run() {
    this.showMenu();
  }
}
let Lo = class extends kt {
  constructor(e, t, i, n, r, s, a, d, u, m, f, S) {
    super(e, { icon: !0, colors: s, hasPopup: !0, hoverOptions: a }, () => !0, u, m, f, S), this.getOverflowingComposites = t, this.getActiveCompositeId = i, this.getBadge = n, this.getCompositeOpenAction = r, this.contextMenuService = d, this.actions = [];
  }
  showMenu() {
    this.actions && Yt(this.actions), this.actions = this.getActions(), this.contextMenuService.showContextMenu({
      getAnchor: () => this.container,
      getActions: () => this.actions,
      getCheckedActionsRepresentation: () => "radio",
      onHide: () => Yt(this.actions)
    });
  }
  getActions() {
    return this.getOverflowingComposites().map((e) => {
      const t = this.getCompositeOpenAction(e.id);
      t.checked = this.getActiveCompositeId() === t.id;
      const i = this.getBadge(e.id);
      let n;
      return i instanceof Ho ? n = i.number : i instanceof zo && (n = i.text), n ? t.label = o("numberBadge", "{0} ({1})", e.name, n) : t.label = e.name || "", t;
    });
  }
  dispose() {
    super.dispose(), this.actions && (this.actions = Yt(this.actions));
  }
};
Lo = I([
  h(7, qo),
  h(8, de),
  h(9, Bi),
  h(10, T),
  h(11, Fi)
], Lo);
let hi = class extends Ze {
  constructor(e) {
    super("activitybar.manage.extension", o("manageExtension", "Manage Extension")), this.commandService = e;
  }
  run(e) {
    return this.commandService.executeCommand("_extensions.manage", e);
  }
};
hi = I([
  h(0, Ni)
], hi);
let Ro = class Mt extends kt {
  constructor(e, t, i, n, r, s, a, d, u, m, f, S, b, A) {
    super(t, e, d.areBadgesEnabled.bind(d), S, b, A, m), this.compositeActivityAction = t, this.toggleCompositePinnedAction = i, this.toggleCompositeBadgeAction = n, this.compositeContextMenuActionsProvider = r, this.contextMenuActionsProvider = s, this.dndHandler = a, this.compositeBar = d, this.contextMenuService = u, Mt.manageExtensionAction || (Mt.manageExtensionAction = f.createInstance(hi));
  }
  render(e) {
    super.render(e), this.updateChecked(), this.updateEnabled(), this._register(Ve(this.container, Ue.CONTEXT_MENU, (i) => {
      oi.stop(i, !0), this.showContextMenu(e);
    }));
    let t;
    this._register(tr.INSTANCE.registerDraggable(this.container, () => ({ type: "composite", id: this.activity.id }), {
      onDragOver: (i) => {
        const n = i.dragAndDropData.getData().id !== this.activity.id && this.dndHandler.onDragOver(i.dragAndDropData, this.activity.id, i.eventData);
        ir(i.eventData.dataTransfer, "move", n), t = this.updateFromDragging(e, n, i.eventData);
      },
      onDragLeave: (i) => {
        t = this.updateFromDragging(e, !1, i.eventData);
      },
      onDragEnd: (i) => {
        t = this.updateFromDragging(e, !1, i.eventData);
      },
      onDrop: (i) => {
        oi.stop(i.eventData, !0), this.dndHandler.drop(i.dragAndDropData, this.activity.id, i.eventData, t), t = this.updateFromDragging(e, !1, i.eventData);
      },
      onDragStart: (i) => {
        i.dragAndDropData.getData().id === this.activity.id && (i.eventData.dataTransfer && (i.eventData.dataTransfer.effectAllowed = "move"), this.blur());
      }
    })), [this.badge, this.label].forEach((i) => this._register(new or(i, () => {
      this.action.checked || this.action.run();
    }))), this.updateStyles();
  }
  updateFromDragging(e, t, i) {
    const n = e.getBoundingClientRect(), r = i.clientX, s = i.clientY, a = n.bottom - n.top, d = n.right - n.left, u = s <= n.top + a * 0.4, m = s > n.bottom - a * 0.4, f = s <= n.top + a * 0.5, S = r <= n.left + d * 0.4, b = r > n.right - d * 0.4, A = r <= n.left + d * 0.5, x = e.classList, D = {
      vertical: x.contains("top") ? "top" : x.contains("bottom") ? "bottom" : void 0,
      horizontal: x.contains("left") ? "left" : x.contains("right") ? "right" : void 0
    }, j = u || f && !D.vertical || !m && D.vertical === "top", P = m || !f && !D.vertical || !u && D.vertical === "bottom", W = S || A && !D.horizontal || !b && D.horizontal === "left", le = b || !A && !D.horizontal || !S && D.horizontal === "right";
    if (e.classList.toggle("top", t && j), e.classList.toggle("bottom", t && P), e.classList.toggle("left", t && W), e.classList.toggle("right", t && le), !!t)
      return { verticallyBefore: j, horizontallyBefore: W };
  }
  showContextMenu(e) {
    const t = [this.toggleCompositePinnedAction, this.toggleCompositeBadgeAction], i = this.compositeContextMenuActionsProvider(this.activity.id);
    i.length && t.push(...i), this.compositeActivityAction.activity.extensionId && (t.push(new co()), t.push(Mt.manageExtensionAction)), this.compositeBar.isPinned(this.activity.id) ? (this.toggleCompositePinnedAction.label = o("hide", "Hide '{0}'", this.activity.name), this.toggleCompositePinnedAction.checked = !1) : this.toggleCompositePinnedAction.label = o("keep", "Keep '{0}'", this.activity.name), this.compositeBar.areBadgesEnabled(this.activity.id) ? this.toggleCompositeBadgeAction.label = o("hideBadge", "Hide Badge") : this.toggleCompositeBadgeAction.label = o("showBadge", "Show Badge");
    const s = this.contextMenuActionsProvider();
    s.length && (t.push(new co()), t.push(...s));
    const a = nr(e), d = {
      x: Math.floor(a.left + a.width / 2),
      y: a.top + a.height
    };
    this.contextMenuService.showContextMenu({
      getAnchor: () => d,
      getActions: () => t,
      getActionsContext: () => this.activity.id
    });
  }
  updateChecked() {
    this.action.checked ? (this.container.classList.add("checked"), this.container.setAttribute("aria-label", this.container.title), this.container.setAttribute("aria-expanded", "true"), this.container.setAttribute("aria-selected", "true")) : (this.container.classList.remove("checked"), this.container.setAttribute("aria-label", this.container.title), this.container.setAttribute("aria-expanded", "false"), this.container.setAttribute("aria-selected", "false")), this.updateStyles();
  }
  updateEnabled() {
    this.element && (this.action.enabled ? this.element.classList.remove("disabled") : this.element.classList.add("disabled"));
  }
  dispose() {
    super.dispose(), this.label.remove();
  }
};
Ro = I([
  h(8, qo),
  h(9, Fi),
  h(10, ce),
  h(11, de),
  h(12, Bi),
  h(13, T)
], Ro);
class yd extends Ze {
  constructor(e, t) {
    super("show.toggleCompositePinned", e ? e.name : o("toggle", "Toggle View Pinned")), this.activity = e, this.compositeBar = t, this.checked = !!this.activity && this.compositeBar.isPinned(this.activity.id);
  }
  async run(e) {
    const t = this.activity ? this.activity.id : e;
    this.compositeBar.isPinned(t) ? this.compositeBar.unpin(t) : this.compositeBar.pin(t);
  }
}
class wc extends Ze {
  constructor(e, t) {
    super("show.toggleCompositeBadge", e ? e.name : o("toggleBadge", "Toggle View Badge")), this.activity = e, this.compositeBar = t, this.checked = !1;
  }
  async run(e) {
    const t = this.activity ? this.activity.id : e;
    this.compositeBar.toggleBadgeEnablement(t);
  }
}
const Cd = y("auxiliarybar-right-layout-icon", v.layoutSidebarRight, o(
  "toggleAuxiliaryIconRight",
  "Icon to toggle the auxiliary bar off in its right position."
)), wd = y("auxiliarybar-right-off-layout-icon", v.layoutSidebarRightOff, o(
  "toggleAuxiliaryIconRightOn",
  "Icon to toggle the auxiliary bar on in its right position."
)), Id = y("auxiliarybar-left-layout-icon", v.layoutSidebarLeft, o(
  "toggleAuxiliaryIconLeft",
  "Icon to toggle the auxiliary bar in its left position."
)), Md = y("auxiliarybar-left-off-layout-icon", v.layoutSidebarLeftOff, o(
  "toggleAuxiliaryIconLeftOn",
  "Icon to toggle the auxiliary bar on in its left position."
)), we = class we extends L {
  constructor() {
    super({
      id: we.ID,
      title: { value: we.LABEL, original: "Toggle Secondary Side Bar Visibility" },
      toggled: {
        condition: De,
        title: o("secondary sidebar", "Secondary Side Bar"),
        mnemonicTitle: o(
          { key: "secondary sidebar mnemonic", comment: ["&& denotes a mnemonic"] },
          "Secondary Si&&de Bar"
        )
      },
      category: C.View,
      f1: !0,
      keybinding: {
        weight: 200,
        primary: 2592
      },
      menu: [
        {
          id: l.LayoutControlMenuSubmenu,
          group: "0_workbench_layout",
          order: 1
        },
        {
          id: l.MenubarAppearanceMenu,
          group: "2_workbench_layout",
          order: 2
        }
      ]
    });
  }
  async run(e) {
    const t = e.get(_);
    t.setPartHidden(t.isVisible("workbench.parts.auxiliarybar"), "workbench.parts.auxiliarybar");
  }
};
we.ID = "workbench.action.toggleAuxiliaryBar", we.LABEL = o("toggleAuxiliaryBar", "Toggle Secondary Side Bar Visibility");
let Ee = we;
c(Ee);
var re;
c((re = class extends L {
  constructor() {
    super({
      id: re.ID,
      title: { value: re.LABEL, original: "Focus into Secondary Side Bar" },
      category: C.View,
      f1: !0
    });
  }
  async run(e) {
    const t = e.get(et), i = e.get(_);
    i.isVisible("workbench.parts.auxiliarybar") || i.setPartHidden(!1, "workbench.parts.auxiliarybar");
    const n = t.getActivePaneComposite(2);
    n == null || n.focus();
  }
}, re.ID = "workbench.action.focusAuxiliaryBar", re.LABEL = o("focusAuxiliaryBar", "Focus into Secondary Side Bar"), re));
g.appendMenuItems([
  {
    id: l.LayoutControlMenu,
    item: {
      group: "0_workbench_toggles",
      command: {
        id: Ee.ID,
        title: o("toggleSecondarySideBar", "Toggle Secondary Side Bar"),
        toggled: { condition: De, icon: Id },
        icon: Md
      },
      when: E.and(E.or(E.equals("config.workbench.layoutControl.type", "toggles"), E.equals("config.workbench.layoutControl.type", "both")), E.equals("config.workbench.sideBar.location", "right")),
      order: 0
    }
  },
  {
    id: l.LayoutControlMenu,
    item: {
      group: "0_workbench_toggles",
      command: {
        id: Ee.ID,
        title: o("toggleSecondarySideBar", "Toggle Secondary Side Bar"),
        toggled: { condition: De, icon: Cd },
        icon: wd
      },
      when: E.and(E.or(E.equals("config.workbench.layoutControl.type", "toggles"), E.equals("config.workbench.layoutControl.type", "both")), E.equals("config.workbench.sideBar.location", "left")),
      order: 2
    }
  },
  {
    id: l.ViewTitleContext,
    item: {
      group: "3_workbench_layout_move",
      command: {
        id: Ee.ID,
        title: { value: o("hideAuxiliaryBar", "Hide Secondary Side Bar"), original: "Hide Secondary Side Bar" }
      },
      when: E.and(De, E.equals(
        "viewLocation",
        Ko(2)
      )),
      order: 2
    }
  }
]);
var Ad = ".monaco-workbench.nopanel .part.panel{display:none!important;visibility:hidden!important}.monaco-workbench .part.panel.bottom .composite.title{border-top-style:solid;border-top-width:1px}.monaco-workbench.noeditorarea .part.panel.bottom .composite.title{border-top-width:0}.monaco-workbench .part.panel.right{border-left-style:solid;border-left-width:1px}.monaco-workbench.noeditorarea .part.panel.right{border-left-width:0}.monaco-workbench .part.panel.left{border-right-style:solid;border-right-width:1px}.monaco-workbench.noeditorarea .part.panel.left{border-right-width:0}.monaco-workbench .part.panel>.content .monaco-editor,.monaco-workbench .part.panel>.content .monaco-editor .margin,.monaco-workbench .part.panel>.content .monaco-editor .monaco-editor-background{background-color:var(--vscode-panel-background)}.monaco-workbench .part.panel>.title>.panel-switcher-container>.monaco-action-bar .action-item:focus .action-label,.monaco-workbench .part.panel>.title>.panel-switcher-container>.monaco-action-bar .action-item:hover .action-label{color:var(--vscode-panelTitle-activeForeground)!important}.monaco-workbench .part.panel .monaco-inputbox{border-color:var(--vscode-panelInput-border,transparent)!important}.monaco-workbench .part.basepanel>.title>.panel-switcher-container>.monaco-action-bar .action-item:focus .active-item-indicator:before{border-top-color:var(--vscode-focusBorder)!important}.monaco-workbench .part.panel>.title>.panel-switcher-container>.monaco-action-bar .action-item:focus{outline:none}.monaco-workbench .part.basepanel>.title>.panel-switcher-container>.monaco-action-bar .action-item.checked.clicked:focus .active-item-indicator:before,.monaco-workbench .part.basepanel>.title>.panel-switcher-container>.monaco-action-bar .action-item.checked:not(:focus) .active-item-indicator:before{border-top-color:var(--vscode-panelTitle-activeBorder)!important}.monaco-workbench .part.basepanel>.title>.panel-switcher-container>.monaco-action-bar .action-item.checked .action-label,.monaco-workbench .part.basepanel>.title>.panel-switcher-container>.monaco-action-bar .action-item:hover .action-label{outline:var(--vscode-contrastActiveBorder,unset) solid 1px!important}.monaco-workbench .part.basepanel>.title>.panel-switcher-container>.monaco-action-bar .action-item:not(.checked):hover .action-label{outline:var(--vscode-contrastActiveBorder,unset) dashed 1px!important}";
Vi(Ad, {});
y("panel-maximize", v.chevronUp, o("maximizeIcon", "Icon to maximize a panel."));
y("panel-restore", v.chevronDown, o("restoreIcon", "Icon to restore a panel."));
const Dd = y("panel-close", v.close, o("closeIcon", "Icon to close a panel.")), kd = y("panel-layout-icon", v.layoutPanel, o("togglePanelOffIcon", "Icon to toggle the panel off when it is on.")), Ld = y("panel-layout-icon-off", v.layoutPanelOff, o("togglePanelOnIcon", "Icon to toggle the panel on when it is off.")), Ie = class Ie extends L {
  constructor() {
    super({
      id: Ie.ID,
      title: { value: Ie.LABEL, original: "Toggle Panel Visibility" },
      toggled: {
        condition: At,
        title: o("toggle panel", "Panel"),
        mnemonicTitle: o(
          { key: "toggle panel mnemonic", comment: ["&& denotes a mnemonic"] },
          "&&Panel"
        )
      },
      f1: !0,
      category: C.View,
      keybinding: { primary: 2088, weight: 200 },
      menu: [
        {
          id: l.MenubarAppearanceMenu,
          group: "2_workbench_layout",
          order: 5
        },
        {
          id: l.LayoutControlMenuSubmenu,
          group: "0_workbench_layout",
          order: 4
        }
      ]
    });
  }
  async run(e) {
    const t = e.get(_);
    t.setPartHidden(t.isVisible("workbench.parts.panel"), "workbench.parts.panel");
  }
};
Ie.ID = "workbench.action.togglePanel", Ie.LABEL = o("togglePanelVisibility", "Toggle Panel Visibility");
let ke = Ie;
c(ke);
var Le;
c((Le = class extends L {
  constructor() {
    super({
      id: "workbench.action.focusPanel",
      title: { value: o("focusPanel", "Focus into Panel"), original: "Focus into Panel" },
      category: C.View,
      f1: !0
    });
  }
  async run(e) {
    const t = e.get(_), i = e.get(et);
    t.isVisible("workbench.parts.panel") || t.setPartHidden(!1, "workbench.parts.panel");
    const n = i.getActivePaneComposite(1);
    n == null || n.focus();
  }
}, Le.ID = "workbench.action.focusPanel", Le.LABEL = o("focusPanel", "Focus into Panel"), Le));
const ei = {
  LEFT: "workbench.action.positionPanelLeft",
  RIGHT: "workbench.action.positionPanelRight",
  BOTTOM: "workbench.action.positionPanelBottom"
}, bt = {
  LEFT: "workbench.action.alignPanelLeft",
  RIGHT: "workbench.action.alignPanelRight",
  CENTER: "workbench.action.alignPanelCenter",
  JUSTIFY: "workbench.action.alignPanelJustify"
};
function Fn(p, e, t, i, n) {
  return {
    id: p,
    title: e,
    shortLabel: t,
    value: i,
    when: n
  };
}
function ti(p, e, t, i) {
  return Fn(p, e, t, i, rr.notEqualsTo(jo(i)));
}
function St(p, e, t, i) {
  return Fn(p, e, t, i, We.notEqualsTo(i));
}
const Rd = [
  ti(ei.LEFT, { value: o("positionPanelLeft", "Move Panel Left"), original: "Move Panel Left" }, o("positionPanelLeftShort", "Left"), 0),
  ti(ei.RIGHT, { value: o("positionPanelRight", "Move Panel Right"), original: "Move Panel Right" }, o("positionPanelRightShort", "Right"), 1),
  ti(ei.BOTTOM, { value: o("positionPanelBottom", "Move Panel To Bottom"), original: "Move Panel To Bottom" }, o("positionPanelBottomShort", "Bottom"), 2)
], Td = [
  St(bt.LEFT, { value: o("alignPanelLeft", "Set Panel Alignment to Left"), original: "Set Panel Alignment to Left" }, o("alignPanelLeftShort", "Left"), "left"),
  St(bt.RIGHT, { value: o("alignPanelRight", "Set Panel Alignment to Right"), original: "Set Panel Alignment to Right" }, o("alignPanelRightShort", "Right"), "right"),
  St(bt.CENTER, { value: o("alignPanelCenter", "Set Panel Alignment to Center"), original: "Set Panel Alignment to Center" }, o("alignPanelCenterShort", "Center"), "center"),
  St(bt.JUSTIFY, { value: o("alignPanelJustify", "Set Panel Alignment to Justify"), original: "Set Panel Alignment to Justify" }, o("alignPanelJustifyShort", "Justify"), "justify")
];
g.appendMenuItem(l.MenubarAppearanceMenu, {
  submenu: l.PanelPositionMenu,
  title: o("positionPanel", "Panel Position"),
  group: "3_workbench_layout_move",
  order: 4
});
Rd.forEach((p) => {
  const { id: e, title: t, shortLabel: i, value: n, when: r } = p;
  c(class extends L {
    constructor() {
      super({
        id: e,
        title: t,
        category: C.View,
        f1: !0
      });
    }
    run(s) {
      s.get(_).setPanelPosition(n === void 0 ? 2 : n);
    }
  }), g.appendMenuItem(l.PanelPositionMenu, {
    command: {
      id: e,
      title: i,
      toggled: r.negate()
    },
    order: 5
  });
});
g.appendMenuItem(l.MenubarAppearanceMenu, {
  submenu: l.PanelAlignmentMenu,
  title: o("alignPanel", "Align Panel"),
  group: "3_workbench_layout_move",
  order: 5
});
Td.forEach((p) => {
  const { id: e, title: t, shortLabel: i, value: n, when: r } = p;
  c(class extends L {
    constructor() {
      super({
        id: e,
        title: t,
        category: C.View,
        toggled: r.negate(),
        f1: !0
      });
    }
    run(s) {
      s.get(_).setPanelAlignment(n === void 0 ? "center" : n);
    }
  }), g.appendMenuItem(l.PanelAlignmentMenu, {
    command: {
      id: e,
      title: i,
      toggled: r.negate()
    },
    order: 5
  });
});
let pi = class extends eo {
  constructor(e, t, i) {
    super(e), this.viewContainerLocation = t, this.paneCompositeService = i;
  }
  async run() {
    await this.paneCompositeService.openPaneComposite(this.activity.id, this.viewContainerLocation, !0), this.activate();
  }
  setActivity(e) {
    this.activity = e;
  }
};
pi = I([
  h(2, et)
], pi);
let To = class extends pi {
  constructor(e, t, i) {
    super({ id: e, name: e }, t, i);
  }
};
To = I([
  h(2, et)
], To);
class Ac extends yd {
  constructor(e, t) {
    super({ id: e, name: e, classNames: void 0 }, t);
  }
  setActivity(e) {
    this.label = e.name;
  }
}
class Nn extends L {
  constructor(e, t) {
    super({
      id: e,
      title: t,
      category: C.View,
      f1: !0
    });
  }
  async run(e, t) {
    const i = e.get(et), n = i.getPinnedPaneCompositeIds(1), r = i.getActivePaneComposite(1);
    if (!r)
      return;
    let s;
    for (let a = 0; a < n.length; a++)
      if (n[a] === r.getId()) {
        s = n[(a + n.length + t) % n.length];
        break;
      }
    typeof s == "string" && await i.openPaneComposite(s, 1, !0);
  }
}
c(class extends Nn {
  constructor() {
    super("workbench.action.previousPanelView", {
      value: o("previousPanelView", "Previous Panel View"),
      original: "Previous Panel View"
    });
  }
  run(p) {
    return super.run(p, -1);
  }
});
c(class extends Nn {
  constructor() {
    super("workbench.action.nextPanelView", {
      value: o("nextPanelView", "Next Panel View"),
      original: "Next Panel View"
    });
  }
  run(p) {
    return super.run(p, 1);
  }
});
c(class extends L {
  constructor() {
    super({
      id: "workbench.action.closeAuxiliaryBar",
      title: { value: o("closeSecondarySideBar", "Close Secondary Side Bar"), original: "Close Secondary Side Bar" },
      category: C.View,
      icon: Dd,
      menu: [{
        id: l.CommandPalette,
        when: De
      }, {
        id: l.AuxiliaryBarTitle,
        group: "navigation",
        order: 2
      }]
    });
  }
  run(p) {
    p.get(_).setPartHidden(!0, "workbench.parts.auxiliarybar");
  }
});
g.appendMenuItems([
  {
    id: l.LayoutControlMenu,
    item: {
      group: "0_workbench_toggles",
      command: {
        id: ke.ID,
        title: o("togglePanel", "Toggle Panel"),
        icon: Ld,
        toggled: { condition: At, icon: kd }
      },
      when: E.or(E.equals("config.workbench.layoutControl.type", "toggles"), E.equals("config.workbench.layoutControl.type", "both")),
      order: 1
    }
  },
  {
    id: l.ViewTitleContext,
    item: {
      group: "3_workbench_layout_move",
      command: {
        id: ke.ID,
        title: { value: o("hidePanel", "Hide Panel"), original: "Hide Panel" }
      },
      when: E.and(At, E.equals(
        "viewLocation",
        Ko(1)
      )),
      order: 2
    }
  }
]);
class $t extends L {
  constructor(e, t, i) {
    super(i), this.source = e, this.destination = t;
  }
  run(e, ...t) {
    const i = e.get(sr), n = e.get(_), r = e.get(ar), s = i.getViewContainersByLocation(this.source), a = i.getViewContainersByLocation(this.destination);
    if (s.length) {
      const d = r.getVisibleViewContainer(this.source);
      s.forEach((u) => i.moveViewContainerToLocation(u, this.destination)), n.setPartHidden(!1, this.destination === 1 ? "workbench.parts.panel" : "workbench.parts.auxiliarybar"), d && a.length === 0 && r.openViewContainer(d.id, !0);
    }
  }
}
const Tt = class Tt extends $t {
  constructor() {
    super(1, 2, {
      id: Tt.ID,
      title: {
        value: o("movePanelToSecondarySideBar", "Move Panel Views To Secondary Side Bar"),
        original: "Move Panel Views To Secondary Side Bar"
      },
      category: C.View,
      f1: !1
    });
  }
};
Tt.ID = "workbench.action.movePanelToSidePanel";
let gi = Tt;
const xt = class xt extends $t {
  constructor() {
    super(1, 2, {
      id: xt.ID,
      title: {
        value: o("movePanelToSecondarySideBar", "Move Panel Views To Secondary Side Bar"),
        original: "Move Panel Views To Secondary Side Bar"
      },
      category: C.View,
      f1: !0
    });
  }
};
xt.ID = "workbench.action.movePanelToSecondarySideBar";
let mi = xt;
c(gi);
c(mi);
const Pt = class Pt extends $t {
  constructor() {
    super(2, 1, {
      id: Pt.ID,
      title: {
        value: o("moveSidePanelToPanel", "Move Secondary Side Bar Views To Panel"),
        original: "Move Secondary Side Bar Views To Panel"
      },
      category: C.View,
      f1: !1
    });
  }
};
Pt.ID = "workbench.action.moveSidePanelToPanel";
let fi = Pt;
const _t = class _t extends $t {
  constructor() {
    super(2, 1, {
      id: _t.ID,
      title: {
        value: o("moveSidePanelToPanel", "Move Secondary Side Bar Views To Panel"),
        original: "Move Secondary Side Bar Views To Panel"
      },
      category: C.View,
      f1: !0
    });
  }
};
_t.ID = "workbench.action.moveSecondarySideBarToPanel";
let Ei = _t;
c(fi);
c(Ei);
const xd = y("menuBar", v.layoutMenubar, o("menuBarIcon", "Represents the menu bar")), Pd = y("activity-bar-left", v.layoutActivitybarLeft, o("activityBarLeft", "Represents the activity bar in the left position")), _d = y("activity-bar-right", v.layoutActivitybarRight, o("activityBarRight", "Represents the activity bar in the right position")), vi = y("panel-left", v.layoutSidebarLeft, o("panelLeft", "Represents a side bar in the left position"));
y("panel-left-off", v.layoutSidebarLeftOff, o("panelLeftOff", "Represents a side bar in the left position toggled off"));
const bi = y("panel-right", v.layoutSidebarRight, o("panelRight", "Represents side bar in the right position"));
y("panel-right-off", v.layoutSidebarRightOff, o("panelRightOff", "Represents side bar in the right position toggled off"));
const Gd = y("panel-bottom", v.layoutPanel, o("panelBottom", "Represents the bottom panel")), Od = y("statusBar", v.layoutStatusbar, o("statusBarIcon", "Represents the status bar")), Bd = y("panel-align-left", v.layoutPanelLeft, o("panelBottomLeft", "Represents the bottom panel alignment set to the left")), Fd = y("panel-align-right", v.layoutPanelRight, o(
  "panelBottomRight",
  "Represents the bottom panel alignment set to the right"
)), Nd = y("panel-align-center", v.layoutPanelCenter, o(
  "panelBottomCenter",
  "Represents the bottom panel alignment set to the center"
)), Vd = y("panel-align-justify", v.layoutPanelJustify, o(
  "panelBottomJustify",
  "Represents the bottom panel alignment set to justified"
)), Ud = y("fullscreen", v.screenFull, o("fullScreenIcon", "Represents full screen")), Wd = y("centerLayoutIcon", v.layoutCentered, o("centerLayoutIcon", "Represents centered layout mode")), Hd = y("zenMode", v.target, o("zenModeIcon", "Represents zen mode")), Me = class Me extends L {
  constructor() {
    super({
      id: Me.ID,
      title: {
        value: o("toggleActivityBar", "Toggle Activity Bar Visibility"),
        mnemonicTitle: o(
          { key: "miActivityBar", comment: ["&& denotes a mnemonic"] },
          "&&Activity Bar"
        ),
        original: "Toggle Activity Bar Visibility"
      },
      category: C.View,
      f1: !0,
      toggled: E.equals("config.workbench.activityBar.visible", !0),
      menu: [{
        id: l.MenubarAppearanceMenu,
        group: "2_workbench_layout",
        order: 4
      }]
    });
  }
  run(e) {
    const t = e.get(_), i = e.get(T), r = !t.isVisible("workbench.parts.activitybar");
    i.updateValue(Me.activityBarVisibleKey, r);
  }
};
Me.ID = "workbench.action.toggleActivityBarVisibility", Me.activityBarVisibleKey = "workbench.activityBar.visible";
let Si = Me;
const Vn = "workbench.sideBar.location";
class Un extends L {
  constructor(e, t, i) {
    super({
      id: e,
      title: t,
      f1: !1
    }), this.position = i;
  }
  async run(e) {
    const t = e.get(_), i = e.get(T);
    if (t.getSideBarPosition() !== this.position)
      return i.updateValue(Vn, jo(this.position));
  }
}
const Gt = class Gt extends Un {
  constructor() {
    super(Gt.ID, {
      value: o("moveSidebarRight", "Move Primary Side Bar Right"),
      original: "Move Primary Side Bar Right"
    }, 1);
  }
};
Gt.ID = "workbench.action.moveSideBarRight";
let yi = Gt;
const Ot = class Ot extends Un {
  constructor() {
    super(Ot.ID, {
      value: o("moveSidebarLeft", "Move Primary Side Bar Left"),
      original: "Move Primary Side Bar Left"
    }, 0);
  }
};
Ot.ID = "workbench.action.moveSideBarLeft";
let Ci = Ot;
const qe = class qe extends L {
  static getLabel(e) {
    return e.getSideBarPosition() === 0 ? o("moveSidebarRight", "Move Primary Side Bar Right") : o("moveSidebarLeft", "Move Primary Side Bar Left");
  }
  constructor() {
    super({
      id: qe.ID,
      title: { value: o("toggleSidebarPosition", "Toggle Primary Side Bar Position"), original: "Toggle Primary Side Bar Position" },
      category: C.View,
      f1: !0
    });
  }
  run(e) {
    const t = e.get(_), i = e.get(T), r = t.getSideBarPosition() === 0 ? "right" : "left";
    return i.updateValue(Vn, r);
  }
};
qe.ID = "workbench.action.toggleSidebarPosition", qe.LABEL = o("toggleSidebarPosition", "Toggle Primary Side Bar Position");
let xo = qe;
y("configure-layout-icon", v.layout, o("cofigureLayoutIcon", "Icon represents workbench layout configuration."));
const Bt = class Bt extends L {
  constructor() {
    super({
      id: Bt.ID,
      title: { value: o("toggleSidebar", "Toggle Primary Side Bar Visibility"), original: "Toggle Primary Side Bar Visibility" },
      toggled: {
        condition: $o,
        title: o("primary sidebar", "Primary Side Bar"),
        mnemonicTitle: o(
          { key: "primary sidebar mnemonic", comment: ["&& denotes a mnemonic"] },
          "&&Primary Side Bar"
        )
      },
      category: C.View,
      f1: !0,
      keybinding: {
        weight: 200,
        primary: 2080
      },
      menu: [
        {
          id: l.LayoutControlMenuSubmenu,
          group: "0_workbench_layout",
          order: 0
        },
        {
          id: l.MenubarAppearanceMenu,
          group: "2_workbench_layout",
          order: 1
        }
      ]
    });
  }
  run(e) {
    const t = e.get(_);
    t.setPartHidden(t.isVisible("workbench.parts.sidebar"), "workbench.parts.sidebar");
  }
};
Bt.ID = "workbench.action.toggleSidebarVisibility";
let wi = Bt;
const Ae = class Ae extends L {
  constructor() {
    super({
      id: Ae.ID,
      title: {
        value: o("toggleStatusbar", "Toggle Status Bar Visibility"),
        mnemonicTitle: o({ key: "miStatusbar", comment: ["&& denotes a mnemonic"] }, "S&&tatus Bar"),
        original: "Toggle Status Bar Visibility"
      },
      category: C.View,
      f1: !0,
      toggled: E.equals("config.workbench.statusBar.visible", !0),
      menu: [{
        id: l.MenubarAppearanceMenu,
        group: "2_workbench_layout",
        order: 3
      }]
    });
  }
  run(e) {
    const t = e.get(_), i = e.get(T), r = !t.isVisible("workbench.parts.statusbar");
    return i.updateValue(Ae.statusbarVisibleKey, r);
  }
};
Ae.ID = "workbench.action.toggleStatusbarVisibility", Ae.statusbarVisibleKey = "workbench.statusBar.visible";
let Ii = Ae;
const Ft = class Ft extends L {
  constructor() {
    super({
      id: Ft.ID,
      title: {
        value: o("toggleTabs", "Toggle Tab Visibility"),
        original: "Toggle Tab Visibility"
      },
      category: C.View,
      f1: !0
    });
  }
  run(e) {
    const t = e.get(T), n = !t.getValue("workbench.editor.showTabs");
    return t.updateValue("workbench.editor.showTabs", n);
  }
};
Ft.ID = "workbench.action.toggleTabsVisibility";
let Je = Ft;
c(Je);
Ui.registerCommandAndKeybindingRule({
  id: "workbench.action.exitZenMode",
  weight: 100 - 1e3,
  handler(p) {
    const e = p.get(_), t = p.get(Vt);
    ni.getValue(t) && e.toggleZenMode();
  },
  when: ni,
  primary: Jo(9, 9)
});
const ro = class ro extends L {
  resizePart(e, t, i, n) {
    let r;
    if (n === void 0) {
      const s = i.hasFocus("workbench.parts.editor"), a = i.hasFocus("workbench.parts.sidebar"), d = i.hasFocus("workbench.parts.panel"), u = i.hasFocus("workbench.parts.auxiliarybar");
      a ? r = "workbench.parts.sidebar" : d ? r = "workbench.parts.panel" : s ? r = "workbench.parts.editor" : u && (r = "workbench.parts.auxiliarybar");
    } else
      r = n;
    r && i.resizePart(r, e, t);
  }
};
ro.RESIZE_INCREMENT = 60;
let Po = ro;
const ye = (p, e, t, i) => ({
  id: p,
  active: e,
  label: t,
  visualIcon: i,
  activeIcon: v.eye,
  inactiveIcon: v.eyeClosed,
  activeAriaLabel: o("selectToHide", "Select to Hide"),
  inactiveAriaLabel: o("selectToShow", "Select to Show"),
  useButtons: !0
}), Z = (p, e, t, i) => ({
  id: p,
  active: e,
  label: t,
  visualIcon: i,
  activeIcon: v.check,
  activeAriaLabel: o("active", "Active"),
  useButtons: !1
}), zd = E.and(dr.toNegated(), E.notEquals("config.window.menuBarVisibility", "hidden"), E.notEquals("config.window.menuBarVisibility", "toggle"), E.notEquals("config.window.menuBarVisibility", "compact")), to = [];
(!cr || !lr) && to.push(ye("workbench.action.toggleMenuBar", zd, o("menuBar", "Menu Bar"), xd));
to.push(ye(Si.ID, E.equals("config.workbench.activityBar.visible", !0), o("activityBar", "Activity Bar"), { whenA: E.equals("config.workbench.sideBar.location", "left"), iconA: Pd, iconB: _d }), ye(wi.ID, $o, o("sideBar", "Primary Side Bar"), { whenA: E.equals("config.workbench.sideBar.location", "left"), iconA: vi, iconB: bi }), ye(Ee.ID, De, o("secondarySideBar", "Secondary Side Bar"), { whenA: E.equals("config.workbench.sideBar.location", "left"), iconA: bi, iconB: vi }), ye(ke.ID, At, o("panel", "Panel"), Gd), ye(Ii.ID, E.equals("config.workbench.statusBar.visible", !0), o("statusBar", "Status Bar"), Od));
const qd = [
  Z(Ci.ID, E.equals("config.workbench.sideBar.location", "left"), o("leftSideBar", "Left"), vi),
  Z(yi.ID, E.equals("config.workbench.sideBar.location", "right"), o("rightSideBar", "Right"), bi)
], Kd = [
  Z("workbench.action.alignPanelLeft", We.isEqualTo("left"), o("leftPanel", "Left"), Bd),
  Z("workbench.action.alignPanelRight", We.isEqualTo("right"), o("rightPanel", "Right"), Fd),
  Z("workbench.action.alignPanelCenter", We.isEqualTo("center"), o("centerPanel", "Center"), Nd),
  Z("workbench.action.alignPanelJustify", We.isEqualTo("justify"), o("justifyPanel", "Justify"), Vd)
], jd = [
  Z("workbench.action.toggleFullScreen", ur, o("fullscreen", "Full Screen"), Ud),
  Z("workbench.action.toggleZenMode", ni, o("zenMode", "Zen Mode"), Hd),
  Z("workbench.action.toggleCenteredLayout", hr, o("centeredLayout", "Centered Layout"), Wd)
], $d = /* @__PURE__ */ new Set();
for (const { active: p } of [...to, ...qd, ...Kd, ...jd])
  for (const e of p.keys())
    $d.add(e);
var Jd = ".monaco-editor-pane-placeholder{align-items:center;box-sizing:border-box;display:flex;flex-direction:column;gap:10px;justify-content:center;padding:0 16px}.monaco-editor-pane-placeholder:focus{outline:none!important}.monaco-editor-pane-placeholder .editor-placeholder-icon-container .codicon{font-size:48px}.monaco-editor-pane-placeholder .editor-placeholder-icon-container .codicon.codicon-error{color:var(--vscode-editorError-foreground)}.monaco-editor-pane-placeholder .editor-placeholder-icon-container .codicon.codicon-warning{color:var(--vscode-editorWarning-foreground)}.monaco-editor-pane-placeholder .editor-placeholder-icon-container .codicon.codicon-info,.monaco-editor-pane-placeholder .editor-placeholder-icon-container .codicon.codicon-workspace-untrusted{color:var(--vscode-editorInfo-foreground)}.monaco-editor-pane-placeholder.max-height-200px .editor-placeholder-icon-container{display:none}.monaco-editor-pane-placeholder .editor-placeholder-label-container{font-size:14px;max-width:450px;text-align:center;word-break:break-word}.monaco-editor-pane-placeholder .editor-placeholder-buttons-container{display:flex}.monaco-editor-pane-placeholder .editor-placeholder-buttons-container>.monaco-button{font-size:14px;margin:4px 5px;outline-offset:2px!important;padding:6px 11px;width:fit-content}";
Vi(Jd, {});
var Re;
let Ye = (Re = class extends pr {
  constructor(e, t, i, n) {
    super(e, t, i, n), this.inputDisposable = this._register(new O());
  }
  createEditor(e) {
    this.container = document.createElement("div"), this.container.className = "monaco-editor-pane-placeholder", this.container.style.outline = "none", this.container.tabIndex = 0, this.scrollbar = this._register(new gr(
      this.container,
      { horizontal: 1, vertical: 1 }
    )), e.appendChild(this.scrollbar.getDomNode());
  }
  async setInput(e, t, i, n) {
    await super.setInput(e, t, i, n), !n.isCancellationRequested && (this.inputDisposable.value = await this.renderInput(e, t));
  }
  async renderInput(e, t) {
    const [i, n] = lo(this.container, this.scrollbar);
    ii(i);
    const r = new xe(), { icon: s, label: a, actions: d } = await this.getContents(e, t, r), u = mr(a, Re.PLACEHOLDER_LABEL_MAX_LENGTH), m = i.appendChild(ge(".editor-placeholder-icon-container")), f = new Sd(m);
    f.text = s;
    const S = i.appendChild(ge(".editor-placeholder-label-container")), b = document.createElement("span");
    if (b.textContent = u, S.appendChild(b), i.setAttribute("aria-label", `${fr(e, void 0, this.group, void 0)}, ${u}`), d.length) {
      const A = i.appendChild(ge(".editor-placeholder-buttons-container")), x = r.add(new Er(A));
      for (let D = 0; D < d.length; D++) {
        const j = r.add(x.addButton({
          ...vr,
          secondary: D !== 0
        }));
        j.label = d[D].label, r.add(j.onDidClick((P) => {
          P && oi.stop(P, !0), d[D].run();
        }));
      }
    }
    return n.scanDomNode(), r;
  }
  clearInput() {
    this.container && ii(this.container), this.inputDisposable.clear(), super.clearInput();
  }
  layout(e) {
    const [t, i] = lo(this.container, this.scrollbar);
    br(t, e.width, e.height), i.scanDomNode(), t.classList.toggle("max-height-200px", e.height <= 200);
  }
  focus() {
    ie(this.container).focus();
  }
  dispose() {
    var e;
    (e = this.container) == null || e.remove(), super.dispose();
  }
}, Re.PLACEHOLDER_LABEL_MAX_LENGTH = 1024, Re);
Ye = I([
  h(1, tt),
  h(2, de),
  h(3, Pe)
], Ye);
var N;
let _o = (N = class extends Ye {
  constructor(e, t, i, n, r) {
    super(N.ID, e, t, r), this.commandService = i, this.workspaceService = n;
  }
  getTitle() {
    return N.LABEL;
  }
  async getContents() {
    return {
      icon: "$(workspace-untrusted)",
      label: Sr(yr(this.workspaceService.getWorkspace())) ? o(
        "requiresFolderTrustText",
        "The file is not displayed in the editor because trust has not been granted to the folder."
      ) : o(
        "requiresWorkspaceTrustText",
        "The file is not displayed in the editor because trust has not been granted to the workspace."
      ),
      actions: [
        {
          label: o("manageTrust", "Manage Workspace Trust"),
          run: () => this.commandService.executeCommand("workbench.trust.manage")
        }
      ]
    };
  }
}, N.ID = "workbench.editors.workspaceTrustRequiredEditor", N.LABEL = o("trustRequiredEditor", "Workspace Trust Required"), N.DESCRIPTOR = _e.create(N, N.ID, N.LABEL), N);
_o = I([
  h(0, tt),
  h(1, de),
  h(2, Ni),
  h(3, Wi),
  h(4, Pe)
], _o);
var z;
let Go = (z = class extends Ye {
  constructor(e, t, i, n, r) {
    super(z.ID, e, t, i), this.fileService = n, this.dialogService = r;
  }
  async getContents(e, t, i) {
    const n = e.resource, r = this.group, s = t.error, a = (s == null ? void 0 : s.fileOperationResult) === 1;
    let d;
    a ? d = o(
      "unavailableResourceErrorEditorText",
      "The editor could not be opened because the file was not found."
    ) : Qt(s) && s.forceMessage ? d = s.message : s ? d = o(
      "unknownErrorEditorTextWithError",
      "The editor could not be opened due to an unexpected error: {0}",
      uo(s)
    ) : d = o(
      "unknownErrorEditorTextWithoutError",
      "The editor could not be opened due to an unexpected error."
    );
    let u = "$(error)";
    Qt(s) && (s.forceSeverity === ri.Info ? u = "$(info)" : s.forceSeverity === ri.Warning && (u = "$(warning)"));
    let m;
    return Qt(s) && s.actions.length > 0 ? m = s.actions.map((f) => ({
      label: f.label,
      run: () => {
        const S = f.run();
        S instanceof Promise && S.catch((b) => this.dialogService.error(uo(b)));
      }
    })) : r && (m = [
      {
        label: o("retry", "Try Again"),
        run: () => r.openEditor(e, { ...t, source: Cr.USER })
      }
    ]), r && a && n && this.fileService.hasProvider(n) && i.add(this.fileService.onDidFilesChange((f) => {
      f.contains(n, 1, 0) && r.openEditor(e, t);
    })), { icon: u, label: d, actions: m ?? [] };
  }
}, z.ID = "workbench.editors.errorEditor", z.LABEL = o("errorEditor", "Error Editor"), z.DESCRIPTOR = _e.create(z, z.ID, z.LABEL), z);
Go = I([
  h(0, tt),
  h(1, de),
  h(2, Pe),
  h(3, it),
  h(4, wr)
], Go);
function Oo(p, e, t) {
  const i = p.get(Ge), n = p.get(T), r = Yd(e, t, i, n);
  let s;
  return i.activeGroup !== r && e.options && !e.options.inactive && e.options.preserveFocus && typeof e.options.activation != "number" && t !== Ut && (s = Ir.ACTIVATE), [r, s];
}
function Yd(p, e, t, i) {
  let n;
  const r = wt(p) ? p.editor : p, s = p.options;
  if (e && typeof e != "number")
    n = e;
  else if (typeof e == "number" && e >= 0)
    n = t.getGroup(e);
  else if (e === Ut) {
    const a = ho(i);
    let d = t.findGroup({ direction: a });
    (!d || yt(d, r)) && (d = t.addGroup(t.activeGroup, a)), n = d;
  } else if (!s || typeof s.index != "number") {
    const a = t.getGroups(1);
    if (s != null && s.revealIfVisible) {
      for (const d of a)
        if (Qd(d, r)) {
          n = d;
          break;
        }
    }
    if (!n && (s != null && s.revealIfOpened || i.getValue("workbench.editor.revealIfOpen") || oe(r) && r.hasCapability(8))) {
      let d, u;
      for (const m of a)
        if (Wn(m, r) && (u || (u = m), !d && m.isActive(r) && (d = m)), u && d)
          break;
      n = d || u;
    }
  }
  if (!n) {
    let a = t.activeGroup;
    if (yt(a, r)) {
      for (const d of t.getGroups(1))
        if (!yt(d, r)) {
          a = d;
          break;
        }
      yt(a, r) ? n = t.addGroup(a, ho(i)) : n = a;
    } else
      n = a;
  }
  return n;
}
function yt(p, e) {
  return !(!p.isLocked || Wn(p, e));
}
function Qd(p, e) {
  return p.activeEditor ? p.activeEditor.matches(e) : !1;
}
function Wn(p, e) {
  for (const t of p.editors)
    if (t.matches(e))
      return !0;
  return !1;
}
let Mi = class extends Mr {
  constructor(e, t, i) {
    super(), this.resource = e, this.name = t, this.fileService = i, this.mime = Ar.binary;
  }
  getName() {
    return this.name;
  }
  getSize() {
    return this.size;
  }
  getMime() {
    return this.mime;
  }
  getETag() {
    return this.etag;
  }
  async resolve() {
    if (this.fileService.hasProvider(this.resource)) {
      const e = await this.fileService.stat(this.resource);
      this.etag = e.etag, typeof e.size == "number" && (this.size = e.size);
    }
    return super.resolve();
  }
};
Mi = I([
  h(2, it)
], Mi);
let ne = class extends Ye {
  constructor(e, t, i, n, r) {
    super(e, i, n, r), this.callbacks = t, this._onDidChangeMetadata = this._register(new R()), this.onDidChangeMetadata = this._onDidChangeMetadata.event, this._onDidOpenInPlace = this._register(new R()), this.onDidOpenInPlace = this._onDidOpenInPlace.event;
  }
  getTitle() {
    return this.input ? this.input.getName() : o("binaryEditor", "Binary Viewer");
  }
  async getContents(e, t) {
    const i = await e.resolve(t);
    if (!(i instanceof Mi))
      throw new Error("Unable to open file as binary");
    const n = i.getSize();
    return this.handleMetadataChanged(typeof n == "number" ? Yo.formatSize(n) : ""), {
      icon: "$(warning)",
      label: o(
        "binaryError",
        "The file is not displayed in the text editor because it is either binary or uses an unsupported text encoding."
      ),
      actions: [
        {
          label: o("openAnyway", "Open Anyway"),
          run: async () => {
            await this.callbacks.openInternal(e, t), this._onDidOpenInPlace.fire();
          }
        }
      ]
    };
  }
  handleMetadataChanged(e) {
    this.metadata = e, this._onDidChangeMetadata.fire();
  }
  getMetadata() {
    return this.metadata;
  }
};
ne = I([
  h(4, Pe)
], ne);
var Xe;
let ve = (Xe = class extends si {
  constructor(e, t, i, n, r, s, a, d) {
    super(e, t, i, n, r, s, a, d);
  }
  getMetadata() {
    const e = this.getPrimaryEditorPane(), t = this.getSecondaryEditorPane();
    if (e instanceof ne && t instanceof ne)
      return o(
        "metadataDiff",
        "{0} ↔ {1}",
        t.getMetadata(),
        e.getMetadata()
      );
  }
}, Xe.ID = Dr, Xe);
ve = I([
  h(0, tt),
  h(1, ce),
  h(2, de),
  h(3, Pe),
  h(4, T),
  h(5, Qo),
  h(6, Se),
  h(7, Ge)
], ve);
var Xd = ".monaco-workbench .screen-reader-detected-explanation{cursor:default;padding:1em;right:6px;top:30px;width:420px}.monaco-workbench .screen-reader-detected-explanation .cancel{border:none;cursor:pointer;height:22px;padding:.5em;position:absolute;right:0;top:0;width:22px}.monaco-workbench .screen-reader-detected-explanation h2{font-size:1.8em;font-weight:400;margin:0;padding:0}.monaco-workbench .screen-reader-detected-explanation p{font-size:1.2em}.monaco-workbench .screen-reader-detected-explanation hr{border:0;height:2px}.monaco-workbench .screen-reader-detected-explanation .buttons{display:flex}.monaco-workbench .screen-reader-detected-explanation .buttons a{font-size:13px;margin-right:5px;max-width:fit-content;padding-left:12px;padding-right:12px}";
Vi(Xd, {});
const Zd = new kr("editorTabFocusMode", !1, !0);
let Ai = class extends K {
  constructor(e, t) {
    super(), this._onDidChange = this._register(new R()), this.onDidChange = this._onDidChange.event, this._editorContext = Zd.bindTo(e), this._terminalContext = Lr.bindTo(e);
    const i = t.getValue("editor.tabFocusMode"), n = t.getValue("terminal.integrated.tabFocusMode") ?? i;
    this._editorContext.set(i), this._terminalContext.set(n), J.setTabFocusMode(i, "editorFocus"), J.setTabFocusMode(n, "terminalFocus");
    const r = /* @__PURE__ */ new Set();
    r.add("focusedView"), this._register(e.onDidChangeContext((s) => {
      if (s.affectsSome(r)) {
        const a = e.getContextKeyValue("focusedView") === "terminal", d = a ? "terminalFocus" : "editorFocus";
        if (this._previousViewContext === d)
          return;
        a ? this._editorContext.reset() : this._terminalContext.reset(), this._previousViewContext = d, this._onDidChange.fire();
      }
    })), this._register(t.onDidChangeConfiguration((s) => {
      if (s.affectsConfiguration("editor.tabFocusMode")) {
        const a = t.getValue("editor.tabFocusMode");
        J.setTabFocusMode(a, "editorFocus"), this._editorContext.set(a), t.getValue("terminal.integrated.tabFocusMode") === null && (t.updateValue("terminal.integrated.tabFocusMode", a), J.setTabFocusMode(a, "terminalFocus"), this._terminalContext.set(a)), this._onDidChange.fire();
      } else if (s.affectsConfiguration("terminal.integrated.tabFocusMode")) {
        const a = t.getValue("terminal.integrated.tabFocusMode") ?? t.getValue("editor.tabFocusMode");
        t.updateValue("terminal.integrated.tabFocusMode", a), J.setTabFocusMode(a, "terminalFocus"), this._terminalContext.set(a), this._onDidChange.fire();
      }
    })), J.onDidChangeTabFocus(() => {
      const s = e.getContextKeyValue("focusedView") === "terminal" ? "terminalFocus" : "editorFocus";
      s === "terminalFocus" ? this._terminalContext.set(J.getTabFocusMode(s)) : this._editorContext.set(J.getTabFocusMode(s));
    });
  }
};
Ai = I([
  h(0, Vt),
  h(1, T)
], Ai);
class ec {
  constructor(e, t) {
    this.primary = e, this.secondary = t;
  }
  getEncoding() {
    return this.primary.getEncoding();
  }
  async setEncoding(e, t) {
    await It.settled([this.primary, this.secondary].map((i) => i.setEncoding(e, t)));
  }
}
class tc {
  constructor(e, t) {
    this.primary = e, this.secondary = t;
  }
  setLanguageId(e, t) {
    [this.primary, this.secondary].forEach((i) => i.setLanguageId(e, t));
  }
}
function Qe(p) {
  if (p instanceof ot)
    return p;
  if (p instanceof nt) {
    const t = Qe(p.primary), i = Qe(p.secondary);
    return t && i ? new ec(t, i) : t;
  }
  const e = p;
  return $r(e.setEncoding, e.getEncoding) ? e : null;
}
function Lt(p) {
  if (p instanceof ot)
    return p;
  if (p instanceof nt) {
    const t = Lt(p.primary), i = Lt(p.secondary);
    return t && i ? new tc(t, i) : t;
  }
  const e = p;
  return typeof e.setLanguageId == "function" ? e : null;
}
class ic {
  constructor() {
    this.indentation = !1, this.selectionStatus = !1, this.languageId = !1, this.languageStatus = !1, this.encoding = !1, this.EOL = !1, this.tabFocusMode = !1, this.columnSelectionMode = !1, this.metadata = !1;
  }
  combine(e) {
    this.indentation = this.indentation || e.indentation, this.selectionStatus = this.selectionStatus || e.selectionStatus, this.languageId = this.languageId || e.languageId, this.languageStatus = this.languageStatus || e.languageStatus, this.encoding = this.encoding || e.encoding, this.EOL = this.EOL || e.EOL, this.tabFocusMode = this.tabFocusMode || e.tabFocusMode, this.columnSelectionMode = this.columnSelectionMode || e.columnSelectionMode, this.metadata = this.metadata || e.metadata;
  }
  hasChanges() {
    return this.indentation || this.selectionStatus || this.languageId || this.languageStatus || this.encoding || this.EOL || this.tabFocusMode || this.columnSelectionMode || this.metadata;
  }
}
class oc {
  get selectionStatus() {
    return this._selectionStatus;
  }
  get languageId() {
    return this._languageId;
  }
  get encoding() {
    return this._encoding;
  }
  get EOL() {
    return this._EOL;
  }
  get indentation() {
    return this._indentation;
  }
  get tabFocusMode() {
    return this._tabFocusMode;
  }
  get columnSelectionMode() {
    return this._columnSelectionMode;
  }
  get metadata() {
    return this._metadata;
  }
  update(e) {
    const t = new ic();
    switch (e.type) {
      case "selectionStatus":
        this._selectionStatus !== e.selectionStatus && (this._selectionStatus = e.selectionStatus, t.selectionStatus = !0);
        break;
      case "indentation":
        this._indentation !== e.indentation && (this._indentation = e.indentation, t.indentation = !0);
        break;
      case "languageId":
        this._languageId !== e.languageId && (this._languageId = e.languageId, t.languageId = !0);
        break;
      case "encoding":
        this._encoding !== e.encoding && (this._encoding = e.encoding, t.encoding = !0);
        break;
      case "EOL":
        this._EOL !== e.EOL && (this._EOL = e.EOL, t.EOL = !0);
        break;
      case "tabFocusMode":
        this._tabFocusMode !== e.tabFocusMode && (this._tabFocusMode = e.tabFocusMode, t.tabFocusMode = !0);
        break;
      case "columnSelectionMode":
        this._columnSelectionMode !== e.columnSelectionMode && (this._columnSelectionMode = e.columnSelectionMode, t.columnSelectionMode = !0);
        break;
      case "metadata":
        this._metadata !== e.metadata && (this._metadata = e.metadata, t.metadata = !0);
        break;
    }
    return t;
  }
}
const nc = o("singleSelectionRange", "Ln {0}, Col {1} ({2} selected)"), rc = o("singleSelection", "Ln {0}, Col {1}"), sc = o("multiSelectionRange", "{0} selections ({1} characters selected)"), ac = o("multiSelection", "{0} selections"), Hn = o("endOfLineLineFeed", "LF"), zn = o("endOfLineCarriageReturnLineFeed", "CRLF");
let Di = class extends K {
  constructor(e, t, i, n, r, s, a) {
    super(), this.editorService = e, this.quickInputService = t, this.languageService = i, this.textFileService = n, this.statusbarService = r, this.instantiationService = s, this.contextKeyService = a, this.tabFocusModeElement = this._register(new O()), this.columnSelectionModeElement = this._register(new O()), this.indentationElement = this._register(new O()), this.selectionElement = this._register(new O()), this.encodingElement = this._register(new O()), this.eolElement = this._register(new O()), this.languageElement = this._register(new O()), this.metadataElement = this._register(new O()), this.currentProblemStatus = this._register(this.instantiationService.createInstance(ki)), this.state = new oc(), this.activeEditorListeners = this._register(new xe()), this.delayedRender = this._register(new O()), this.toRender = null, this.tabFocusMode = s.createInstance(Ai), this.registerCommands(), this.registerListeners();
  }
  registerListeners() {
    this._register(this.editorService.onDidActiveEditorChange(() => this.updateStatusBar())), this._register(this.textFileService.untitled.onDidChangeEncoding((e) => this.onResourceEncodingChange(e.resource))), this._register(this.textFileService.files.onDidChangeEncoding((e) => this.onResourceEncodingChange(e.resource))), this._register(k.runAndSubscribe(J.onDidChangeTabFocus, () => this.onTabFocusModeChange())), this._register(this.tabFocusMode.onDidChange(() => this.onTabFocusModeChange()));
  }
  registerCommands() {
    Zo.registerCommand({ id: "changeEditorIndentation", handler: () => this.showIndentationPicker() });
  }
  async showIndentationPicker() {
    var n;
    const e = ae(this.editorService.activeTextEditorControl);
    if (!e)
      return this.quickInputService.pick([{ label: o("noEditor", "No text editor active at this time") }]);
    if ((n = this.editorService.activeEditor) != null && n.isReadonly())
      return this.quickInputService.pick([{ label: o("noWritableCodeEditor", "The active code editor is read-only.") }]);
    const t = [
      ie(e.getAction(Br.ID)),
      ie(e.getAction(Fr.ID)),
      ie(e.getAction(Nr.ID)),
      ie(e.getAction(Vr.ID)),
      ie(e.getAction(Ur.ID)),
      ie(e.getAction(Wr.ID)),
      ie(e.getAction(Hr.ID))
    ].map((r) => ({
      id: r.id,
      label: r.label,
      detail: en.isDefaultVariant() || r.label === r.alias ? void 0 : r.alias,
      run: () => {
        e.focus(), r.run();
      }
    }));
    t.splice(3, 0, { type: "separator", label: o("indentConvert", "convert file") }), t.unshift({ type: "separator", label: o("indentView", "change view") });
    const i = await this.quickInputService.pick(t, { placeHolder: o("pickAction", "Select Action"), matchOnDetail: !0 });
    return i == null ? void 0 : i.run();
  }
  updateTabFocusModeElement(e) {
    if (e) {
      if (!this.tabFocusModeElement.value) {
        const t = o("tabFocusModeEnabled", "Tab Moves Focus");
        this.tabFocusModeElement.value = this.statusbarService.addEntry({
          name: o("status.editor.tabFocusMode", "Accessibility Mode"),
          text: t,
          ariaLabel: t,
          tooltip: o("disableTabMode", "Disable Accessibility Mode"),
          command: "editor.action.toggleTabFocusMode",
          backgroundColor: Ce(ai),
          color: Ce(di)
        }, "status.editor.tabFocusMode", 1, 100.7);
      }
    } else
      this.tabFocusModeElement.clear();
  }
  updateColumnSelectionModeElement(e) {
    if (e) {
      if (!this.columnSelectionModeElement.value) {
        const t = o("columnSelectionModeEnabled", "Column Selection");
        this.columnSelectionModeElement.value = this.statusbarService.addEntry({
          name: o("status.editor.columnSelectionMode", "Column Selection Mode"),
          text: t,
          ariaLabel: t,
          tooltip: o("disableColumnSelectionMode", "Disable Column Selection Mode"),
          command: "editor.action.toggleColumnSelection",
          backgroundColor: Ce(ai),
          color: Ce(di)
        }, "status.editor.columnSelectionMode", 1, 100.8);
      }
    } else
      this.columnSelectionModeElement.clear();
  }
  updateSelectionElement(e) {
    if (!e) {
      this.selectionElement.clear();
      return;
    }
    const t = {
      name: o("status.editor.selection", "Editor Selection"),
      text: e,
      ariaLabel: e,
      tooltip: o("gotoLine", "Go to Line/Column"),
      command: "workbench.action.gotoLine"
    };
    this.updateElement(this.selectionElement, t, "status.editor.selection", 1, 100.5);
  }
  updateIndentationElement(e) {
    if (!e) {
      this.indentationElement.clear();
      return;
    }
    const t = {
      name: o("status.editor.indentation", "Editor Indentation"),
      text: e,
      ariaLabel: e,
      tooltip: o("selectIndentation", "Select Indentation"),
      command: "changeEditorIndentation"
    };
    this.updateElement(this.indentationElement, t, "status.editor.indentation", 1, 100.4);
  }
  updateEncodingElement(e) {
    if (!e) {
      this.encodingElement.clear();
      return;
    }
    const t = {
      name: o("status.editor.encoding", "Editor Encoding"),
      text: e,
      ariaLabel: e,
      tooltip: o("selectEncoding", "Select Encoding"),
      command: "workbench.action.editor.changeEncoding"
    };
    this.updateElement(this.encodingElement, t, "status.editor.encoding", 1, 100.3);
  }
  updateEOLElement(e) {
    if (!e) {
      this.eolElement.clear();
      return;
    }
    const t = {
      name: o("status.editor.eol", "Editor End of Line"),
      text: e,
      ariaLabel: e,
      tooltip: o("selectEOL", "Select End of Line Sequence"),
      command: "workbench.action.editor.changeEOL"
    };
    this.updateElement(this.eolElement, t, "status.editor.eol", 1, 100.2);
  }
  updateLanguageIdElement(e) {
    if (!e) {
      this.languageElement.clear();
      return;
    }
    const t = {
      name: o("status.editor.mode", "Editor Language"),
      text: e,
      ariaLabel: e,
      tooltip: o("selectLanguageMode", "Select Language Mode"),
      command: "workbench.action.editor.changeLanguageMode"
    };
    this.updateElement(this.languageElement, t, "status.editor.mode", 1, 100.1);
  }
  updateMetadataElement(e) {
    if (!e) {
      this.metadataElement.clear();
      return;
    }
    const t = {
      name: o("status.editor.info", "File Information"),
      text: e,
      ariaLabel: e,
      tooltip: o("fileInfo", "File Information")
    };
    this.updateElement(this.metadataElement, t, "status.editor.info", 1, 100);
  }
  updateElement(e, t, i, n, r) {
    e.value ? e.value.update(t) : e.value = this.statusbarService.addEntry(t, i, n, r);
  }
  updateState(e) {
    const t = this.state.update(e);
    t.hasChanges() && (this.toRender ? this.toRender.combine(t) : (this.toRender = t, this.delayedRender.value = zr(() => {
      this.delayedRender.clear();
      const i = this.toRender;
      this.toRender = null, i && this.doRenderNow(i);
    })));
  }
  doRenderNow(e) {
    this.updateTabFocusModeElement(!!this.state.tabFocusMode), this.updateColumnSelectionModeElement(!!this.state.columnSelectionMode), this.updateIndentationElement(this.state.indentation), this.updateSelectionElement(this.state.selectionStatus), this.updateEncodingElement(this.state.encoding), this.updateEOLElement(this.state.EOL ? this.state.EOL === `\r
` ? zn : Hn : void 0), this.updateLanguageIdElement(this.state.languageId), this.updateMetadataElement(this.state.metadata);
  }
  getSelectionLabel(e) {
    if (!(!e || !e.selections)) {
      if (e.selections.length === 1)
        return e.charactersSelected ? Et(nc, e.selections[0].positionLineNumber, e.selections[0].positionColumn, e.charactersSelected) : Et(rc, e.selections[0].positionLineNumber, e.selections[0].positionColumn);
      if (e.charactersSelected)
        return Et(sc, e.selections.length, e.charactersSelected);
      if (e.selections.length > 0)
        return Et(ac, e.selections.length);
    }
  }
  updateStatusBar() {
    const e = this.editorService.activeEditor, t = this.editorService.activeEditorPane, i = t ? ee(ae(t.getControl())) : void 0;
    if (this.onColumnSelectionModeChange(i), this.onSelectionChange(i), this.onLanguageChange(i, e), this.onEOLChange(i), this.onEncodingChange(t, i), this.onIndentationChange(i), this.onMetadataChange(t), this.currentProblemStatus.update(i), this.activeEditorListeners.clear(), t && this.activeEditorListeners.add(t.onDidChangeControl(() => {
      this.updateStatusBar();
    })), i)
      this.activeEditorListeners.add(i.onDidChangeConfiguration((n) => {
        n.hasChanged(21) && this.onColumnSelectionModeChange(i);
      })), this.activeEditorListeners.add(k.defer(i.onDidChangeCursorPosition)(() => {
        this.onSelectionChange(i), this.currentProblemStatus.update(i);
      })), this.activeEditorListeners.add(i.onDidChangeModelLanguage(() => {
        this.onLanguageChange(i, e);
      })), this.activeEditorListeners.add(k.accumulate(i.onDidChangeModelContent)((n) => {
        this.onEOLChange(i), this.currentProblemStatus.update(i);
        const r = i.getSelections();
        if (r) {
          for (const s of n)
            for (const a of s.changes)
              if (r.some((d) => qi.areIntersecting(d, a.range))) {
                this.onSelectionChange(i);
                break;
              }
        }
      })), this.activeEditorListeners.add(i.onDidChangeModelOptions(() => {
        this.onIndentationChange(i);
      }));
    else if (t instanceof ne || t instanceof ve) {
      const n = [];
      if (t instanceof ve) {
        const r = t.getPrimaryEditorPane();
        r instanceof ne && n.push(r);
        const s = t.getSecondaryEditorPane();
        s instanceof ne && n.push(s);
      } else
        n.push(t);
      for (const r of n)
        this.activeEditorListeners.add(r.onDidChangeMetadata(() => {
          this.onMetadataChange(t);
        })), this.activeEditorListeners.add(r.onDidOpenInPlace(() => {
          this.updateStatusBar();
        }));
    }
  }
  onLanguageChange(e, t) {
    const i = { type: "languageId", languageId: void 0 };
    if (e && t && Lt(t)) {
      const n = e.getModel();
      if (n) {
        const r = n.getLanguageId();
        i.languageId = ee(this.languageService.getLanguageName(r));
      }
    }
    this.updateState(i);
  }
  onIndentationChange(e) {
    const t = { type: "indentation", indentation: void 0 };
    if (e) {
      const i = e.getModel();
      if (i) {
        const n = i.getOptions();
        t.indentation = n.insertSpaces ? n.tabSize === n.indentSize ? o("spacesSize", "Spaces: {0}", n.indentSize) : o(
          "spacesAndTabsSize",
          "Spaces: {0} (Tab Size: {1})",
          n.indentSize,
          n.tabSize
        ) : o(
          { key: "tabSize", comment: ["Tab corresponds to the tab key"] },
          "Tab Size: {0}",
          n.tabSize
        );
      }
    }
    this.updateState(t);
  }
  onMetadataChange(e) {
    const t = { type: "metadata", metadata: void 0 };
    (e instanceof ne || e instanceof ve) && (t.metadata = e.getMetadata()), this.updateState(t);
  }
  onColumnSelectionModeChange(e) {
    const t = { type: "columnSelectionMode", columnSelectionMode: !1 };
    e != null && e.getOption(21) && (t.columnSelectionMode = !0), this.updateState(t);
  }
  onSelectionChange(e) {
    const t = /* @__PURE__ */ Object.create(null);
    if (e) {
      t.selections = e.getSelections() || [], t.charactersSelected = 0;
      const i = e.getModel();
      if (i)
        for (const n of t.selections)
          typeof t.charactersSelected != "number" && (t.charactersSelected = 0), t.charactersSelected += i.getCharacterCountInRange(n);
      if (t.selections.length === 1) {
        const n = e.getPosition(), r = new qr(
          t.selections[0].selectionStartLineNumber,
          t.selections[0].selectionStartColumn,
          t.selections[0].positionLineNumber,
          n ? e.getStatusbarColumn(n) : t.selections[0].positionColumn
        );
        t.selections[0] = r;
      }
    }
    this.updateState({ type: "selectionStatus", selectionStatus: this.getSelectionLabel(t) });
  }
  onEOLChange(e) {
    const t = { type: "EOL", EOL: void 0 };
    if (e && !e.getOption(89)) {
      const i = e.getModel();
      i && (t.EOL = i.getEOL());
    }
    this.updateState(t);
  }
  onEncodingChange(e, t) {
    if (e && !this.isActiveEditor(e))
      return;
    const i = { type: "encoding", encoding: void 0 };
    if (e && (t != null && t.hasModel())) {
      const n = e.input ? Qe(e.input) : null;
      if (n) {
        const r = n.getEncoding(), s = typeof r == "string" ? Q[r] : void 0;
        s ? i.encoding = s.labelShort : i.encoding = r;
      }
    }
    this.updateState(i);
  }
  onResourceEncodingChange(e) {
    const t = this.editorService.activeEditorPane;
    if (t) {
      const i = fe.getCanonicalUri(t.input, { supportSideBySide: X.PRIMARY });
      if (i && je(i, e)) {
        const n = ee(ae(t.getControl()));
        return this.onEncodingChange(t, n);
      }
    }
  }
  onTabFocusModeChange() {
    const e = { type: "tabFocusMode", tabFocusMode: J.getTabFocusMode(this.contextKeyService.getContextKeyValue("focusedView") === "terminal" ? "terminalFocus" : "editorFocus") };
    this.updateState(e);
  }
  isActiveEditor(e) {
    const t = this.editorService.activeEditorPane;
    return !!t && t === e;
  }
};
Di = I([
  h(0, Se),
  h(1, Wt),
  h(2, Xo),
  h(3, Hi),
  h(4, zi),
  h(5, ce),
  h(6, Vt)
], Di);
let ki = class extends K {
  constructor(e, t, i) {
    super(), this.statusbarService = e, this.markerService = t, this.configurationService = i, this.editor = void 0, this.markers = [], this.currentMarker = null, this.statusBarEntryAccessor = this._register(new O()), this._register(t.onMarkerChanged((n) => this.onMarkerChanged(n))), this._register(k.filter(i.onDidChangeConfiguration, (n) => n.affectsConfiguration("problems.showCurrentInStatus"))(() => this.updateStatus()));
  }
  update(e) {
    this.editor = e, this.updateMarkers(), this.updateStatus();
  }
  updateStatus() {
    const e = this.currentMarker;
    if (this.currentMarker = this.getMarker(), this.hasToUpdateStatus(e, this.currentMarker))
      if (this.currentMarker) {
        const t = Kr(this.currentMarker.message)[0], i = `${this.getType(this.currentMarker)} ${t}`;
        this.statusBarEntryAccessor.value || (this.statusBarEntryAccessor.value = this.statusbarService.addEntry({ name: o("currentProblem", "Current Problem"), text: "", ariaLabel: "" }, "statusbar.currentProblem", 0)), this.statusBarEntryAccessor.value.update({ name: o("currentProblem", "Current Problem"), text: i, ariaLabel: i });
      } else
        this.statusBarEntryAccessor.clear();
  }
  hasToUpdateStatus(e, t) {
    return !t || !e ? !0 : Eo.makeKey(e) !== Eo.makeKey(t);
  }
  getType(e) {
    switch (e.severity) {
      case he.Error:
        return "$(error)";
      case he.Warning:
        return "$(warning)";
      case he.Info:
        return "$(info)";
    }
    return "";
  }
  getMarker() {
    if (!this.configurationService.getValue("problems.showCurrentInStatus") || !this.editor || !this.editor.getModel())
      return null;
    const t = this.editor.getPosition();
    return t && this.markers.find((i) => qi.containsPosition(i, t)) || null;
  }
  onMarkerChanged(e) {
    if (!this.editor)
      return;
    const t = this.editor.getModel();
    t && (t && !e.some((i) => je(t.uri, i)) || this.updateMarkers());
  }
  updateMarkers() {
    if (!this.editor)
      return;
    const e = this.editor.getModel();
    e && (e ? (this.markers = this.markerService.read({
      resource: e.uri,
      severities: he.Error | he.Warning | he.Info
    }), this.markers.sort(dc)) : this.markers = [], this.updateStatus());
  }
};
ki = I([
  h(0, zi),
  h(1, Rr),
  h(2, T)
], ki);
function dc(p, e) {
  let t = jr(p.resource.toString(), e.resource.toString());
  return t === 0 && (t = he.compare(p.severity, e.severity)), t === 0 && (t = qi.compareRangesUsingStarts(p, e)), t;
}
var Te;
let Li = (Te = class extends Ze {
  constructor(e, t, i) {
    super(Te.ID, o(
      "showLanguageExtensions",
      "Search Marketplace Extensions for '{0}'...",
      e
    )), this.fileExtension = e, this.commandService = t, this.enabled = i.isEnabled();
  }
  async run() {
    await this.commandService.executeCommand("workbench.extensions.action.showExtensionsForLanguage", this.fileExtension);
  }
}, Te.ID = "workbench.action.showLanguageExtensions", Te);
Li = I([
  h(1, Ni),
  h(2, Tr)
], Li);
const Ke = class Ke extends L {
  constructor() {
    super({
      id: Ke.ID,
      title: { value: o("changeMode", "Change Language Mode"), original: "Change Language Mode" },
      f1: !0,
      keybinding: {
        weight: 200,
        primary: Jo(2089, 43)
      },
      precondition: E.not("notebookEditorFocused")
    });
  }
  async run(e) {
    var so;
    const t = e.get(Wt), i = e.get(Se), n = e.get(Xo), r = e.get(xr), s = e.get(Hi), a = e.get(Pr), d = e.get(ce), u = e.get(T), m = e.get(tt), f = ae(i.activeTextEditorControl);
    if (!f) {
      await t.pick([{ label: o("noEditor", "No text editor active at this time") }]);
      return;
    }
    const S = f.getModel(), b = fe.getOriginalUri(i.activeEditor, { supportSideBySide: X.PRIMARY });
    let A, x;
    S && (x = S.getLanguageId(), A = ee(n.getLanguageName(x)));
    let D = !!b;
    (b == null ? void 0 : b.scheme) === Dt.untitled && !((so = s.untitled.get(b)) != null && so.hasAssociatedFilePath) && (D = !1);
    const P = n.getSortedRegisteredLanguageNames().map(({ languageName: te, languageId: $ }) => {
      const gt = n.getExtensions($).join(" ");
      let H;
      return A === te ? H = o("languageDescription", "({0}) - Configured Language", $) : H = o("languageDescriptionConfigured", "({0})", $), {
        label: te,
        meta: gt,
        iconClasses: po($),
        description: H
      };
    });
    P.unshift({ type: "separator", label: o("languagesPicks", "languages (identifier)") });
    let W, le, Y;
    if (D && b) {
      const te = go(b) || mo(b);
      Y = d.createInstance(Li, te), Y.enabled && P.unshift(Y), le = { label: o(
        "configureModeSettings",
        "Configure '{0}' language based settings...",
        A
      ) }, P.unshift(le), W = { label: o("configureAssociationsExt", "Configure File Association for '{0}'...", te) }, P.unshift(W);
    }
    const Ne = {
      label: o("autoDetect", "Auto Detect")
    };
    P.unshift(Ne);
    const M = await t.pick(P, { placeHolder: o("pickLanguage", "Select Language Mode"), matchOnDescription: !0 });
    if (!M)
      return;
    if (M === Y) {
      Y.run();
      return;
    }
    if (M === W) {
      b && this.configureFileAssociation(b, n, t, u);
      return;
    }
    if (M === le) {
      a.openUserSettings({ jsonEditor: !0, revealSetting: { key: `[${_r(x)}]`, edit: !0 } });
      return;
    }
    const F = i.activeEditor;
    if (F) {
      const te = Lt(F);
      if (te) {
        let $, gt;
        if (M === Ne) {
          if (S) {
            const H = fe.getOriginalUri(F, { supportSideBySide: X.PRIMARY });
            if (H) {
              let ue = ee(n.guessLanguageIdByFilepathOrFirstLine(H, S.getLineContent(1)));
              (!ue || ue === "unknown") && (gt = await r.detectLanguage(H), ue = gt), ue && ($ = n.createById(ue));
            }
          }
        } else {
          const H = n.getLanguageIdByLanguageName(M.label);
          $ = n.createById(H), b && r.detectLanguage(b).then((ue) => {
            const $n = n.getLanguageIdByLanguageName(M.label) || "unknown";
            if (ue === x && x !== $n) {
              const Jn = u.getValue("workbench.editor.preferHistoryBasedLanguageDetection") ? "history" : "classic";
              m.publicLog2(Gr, {
                currentLanguageId: A ?? "unknown",
                nextLanguageId: M.label,
                lineCount: (S == null ? void 0 : S.getLineCount()) ?? -1,
                modelPreference: Jn
              });
            }
          });
        }
        if (typeof $ < "u" && (te.setLanguageId($.languageId, Ke.ID), (b == null ? void 0 : b.scheme) === Dt.untitled)) {
          const H = u.getValue("workbench.editor.preferHistoryBasedLanguageDetection") ? "history" : "classic";
          m.publicLog2("setUntitledDocumentLanguage", {
            to: $.languageId,
            from: x ?? "none",
            modelPreference: H
          });
        }
      }
      f.focus();
    }
  }
  configureFileAssociation(e, t, i, n) {
    const r = go(e), s = mo(e), a = t.guessLanguageIdByFilepathOrFirstLine(G.file(s)), u = t.getSortedRegisteredLanguageNames().map(({ languageName: m, languageId: f }) => ({
      id: f,
      label: m,
      iconClasses: po(f),
      description: f === a ? o("currentAssociation", "Current Association") : void 0
    }));
    setTimeout(async () => {
      const m = await i.pick(u, { placeHolder: o(
        "pickLanguageToConfigure",
        "Select Language Mode to Associate with '{0}'",
        r || s
      ) });
      if (m) {
        const f = n.inspect(fo);
        let S;
        r && s[0] !== "." ? S = `*${r}` : S = s;
        let b = 2;
        f.workspaceValue && f.workspaceValue[S] && (b = 5);
        const A = Or(b === 5 ? f.workspaceValue : f.userValue) || /* @__PURE__ */ Object.create(null);
        A[S] = m.id, n.updateValue(fo, A, b);
      }
    }, 50);
  }
};
Ke.ID = "workbench.action.editor.changeLanguageMode";
let Ri = Ke;
class cc extends L {
  constructor() {
    super({
      id: "workbench.action.editor.changeEOL",
      title: { value: o("changeEndOfLine", "Change End of Line Sequence"), original: "Change End of Line Sequence" },
      f1: !0
    });
  }
  async run(e) {
    var u, m;
    const t = e.get(Se), i = e.get(Wt), n = ae(t.activeTextEditorControl);
    if (!n) {
      await i.pick([{ label: o("noEditor", "No text editor active at this time") }]);
      return;
    }
    if ((u = t.activeEditor) != null && u.isReadonly()) {
      await i.pick([{ label: o("noWritableCodeEditor", "The active code editor is read-only.") }]);
      return;
    }
    let r = n.getModel();
    const s = [
      { label: Hn, eol: 0 },
      { label: zn, eol: 1 }
    ], a = (r == null ? void 0 : r.getEOL()) === `
` ? 0 : 1, d = await i.pick(s, { placeHolder: o("pickEndOfLine", "Select End of Line Sequence"), activeItem: s[a] });
    if (d) {
      const f = ae(t.activeTextEditorControl);
      f != null && f.hasModel() && !((m = t.activeEditor) != null && m.isReadonly()) && (r = f.getModel(), r.pushStackElement(), r.pushEOL(d.eol), r.pushStackElement());
    }
    n.focus();
  }
}
class lc extends L {
  constructor() {
    super({
      id: "workbench.action.editor.changeEncoding",
      title: { value: o("changeEncoding", "Change File Encoding"), original: "Change File Encoding" },
      f1: !0
    });
  }
  async run(e) {
    const t = e.get(Se), i = e.get(Wt), n = e.get(it), r = e.get(Hi), s = e.get(Qo), a = ae(t.activeTextEditorControl);
    if (!a) {
      await i.pick([{ label: o("noEditor", "No text editor active at this time") }]);
      return;
    }
    const d = t.activeEditorPane;
    if (!d) {
      await i.pick([{ label: o("noEditor", "No text editor active at this time") }]);
      return;
    }
    const u = Qe(d.input);
    if (!u) {
      await i.pick([{ label: o("noFileEditor", "No file active at this time") }]);
      return;
    }
    const m = { label: o("saveWithEncoding", "Save with Encoding") }, f = { label: o("reopenWithEncoding", "Reopen with Encoding") };
    if (!en.isDefaultVariant()) {
      const M = "Save with Encoding";
      M !== m.label && (m.detail = M);
      const F = "Reopen with Encoding";
      F !== f.label && (f.detail = F);
    }
    let S;
    if (u instanceof ot ? S = m : d.input.isReadonly() ? S = f : S = await i.pick([f, m], { placeHolder: o("pickAction", "Select Action"), matchOnDetail: !0 }), !S)
      return;
    await tn(50);
    const b = fe.getOriginalUri(d.input, { supportSideBySide: X.PRIMARY });
    if (!b || !n.hasProvider(b) && b.scheme !== Dt.untitled)
      return;
    let A;
    n.hasProvider(b) && (A = (await r.readStream(b, { autoGuessEncoding: !0 })).encoding);
    const x = S === f, D = s.getValue(ee(b), "files.encoding");
    let j, P;
    const W = Object.keys(Q).sort((M, F) => M === D ? -1 : F === D ? 1 : Q[M].order - Q[F].order).filter((M) => M === A && A !== D ? !1 : !x || !Q[M].encodeOnly).map((M, F) => (M === u.getEncoding() ? j = F : Q[M].alias === u.getEncoding() && (P = F), { id: M, label: Q[M].labelLong, description: M })), le = W.slice();
    A && D !== A && Q[A] && (W.unshift({ type: "separator" }), W.unshift({ id: A, label: Q[A].labelLong, description: o("guessedEncoding", "Guessed from content") }));
    const Y = await i.pick(W, {
      placeHolder: x ? o("pickEncodingForReopen", "Select File Encoding to Reopen File") : o("pickEncodingForSave", "Select File Encoding to Save with"),
      activeItem: le[typeof j == "number" ? j : typeof P == "number" ? P : -1]
    });
    if (!Y || !t.activeEditorPane)
      return;
    const Ne = Qe(t.activeEditorPane.input);
    typeof Y.id < "u" && Ne && await Ne.setEncoding(Y.id, x ? 1 : 0), a.focus();
  }
}
let Ti = class extends K {
  constructor(e, t, i, n, r, s) {
    super(), this.filesConfigurationService = e, this.hostService = t, this.editorService = i, this.editorGroupService = n, this.workingCopyService = r, this.logService = s, this.pendingAutoSavesAfterDelay = /* @__PURE__ */ new Map(), this.lastActiveEditor = void 0, this.lastActiveGroupId = void 0, this.lastActiveEditorControlDisposable = this._register(new xe()), this.onAutoSaveConfigurationChange(e.getAutoSaveConfiguration(), !1);
    for (const a of this.workingCopyService.dirtyWorkingCopies)
      this.onDidRegister(a);
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.hostService.onDidChangeFocus((e) => this.onWindowFocusChange(e))), this._register(this.editorService.onDidActiveEditorChange(() => this.onDidActiveEditorChange())), this._register(this.filesConfigurationService.onAutoSaveConfigurationChange((e) => this.onAutoSaveConfigurationChange(e, !0))), this._register(this.workingCopyService.onDidRegister((e) => this.onDidRegister(e))), this._register(this.workingCopyService.onDidUnregister((e) => this.onDidUnregister(e))), this._register(this.workingCopyService.onDidChangeDirty((e) => this.onDidChangeDirty(e))), this._register(this.workingCopyService.onDidChangeContent((e) => this.onDidChangeContent(e)));
  }
  onWindowFocusChange(e) {
    e || this.maybeTriggerAutoSave(4);
  }
  onDidActiveEditorChange() {
    this.lastActiveEditor && typeof this.lastActiveGroupId == "number" && this.maybeTriggerAutoSave(3, { groupId: this.lastActiveGroupId, editor: this.lastActiveEditor });
    const e = this.editorGroupService.activeGroup, t = this.lastActiveEditor = ee(e.activeEditor);
    this.lastActiveGroupId = e.id, this.lastActiveEditorControlDisposable.clear();
    const i = this.editorService.activeEditorPane;
    t && i && this.lastActiveEditorControlDisposable.add(i.onDidBlur(() => {
      this.maybeTriggerAutoSave(3, { groupId: e.id, editor: t });
    }));
  }
  maybeTriggerAutoSave(e, t) {
    if (t != null && t.editor.isReadonly() || t != null && t.editor.hasCapability(4))
      return;
    const i = this.filesConfigurationService.getAutoSaveMode();
    (e === 4 && (i === 3 || i === 4) || e === 3 && i === 3) && (this.logService.trace(`[editor auto save] triggering auto save with reason ${e}`), t ? this.editorService.save(t, { reason: e }) : this.saveAllDirty({ reason: e }));
  }
  onAutoSaveConfigurationChange(e, t) {
    if (this.autoSaveAfterDelay = typeof e.autoSaveDelay == "number" && e.autoSaveDelay >= 0 ? e.autoSaveDelay : void 0, t) {
      let i;
      switch (this.filesConfigurationService.getAutoSaveMode()) {
        case 3:
          i = 3;
          break;
        case 4:
          i = 4;
          break;
        case 1:
        case 2:
          i = 2;
          break;
      }
      i && this.saveAllDirty({ reason: i });
    }
  }
  saveAllDirty(e) {
    for (const t of this.workingCopyService.dirtyWorkingCopies)
      t.capabilities & 2 || t.save(e);
  }
  onDidRegister(e) {
    e.isDirty() && this.scheduleAutoSave(e);
  }
  onDidUnregister(e) {
    this.discardAutoSave(e);
  }
  onDidChangeDirty(e) {
    e.isDirty() ? this.scheduleAutoSave(e) : this.discardAutoSave(e);
  }
  onDidChangeContent(e) {
    e.isDirty() && this.scheduleAutoSave(e);
  }
  scheduleAutoSave(e) {
    if (typeof this.autoSaveAfterDelay != "number" || e.capabilities & 2)
      return;
    this.discardAutoSave(e), this.logService.trace(`[editor auto save] scheduling auto save after ${this.autoSaveAfterDelay}ms`, e.resource.toString(), e.typeId);
    const t = setTimeout(() => {
      this.pendingAutoSavesAfterDelay.delete(e), e.isDirty() && (this.logService.trace("[editor auto save] running auto save", e.resource.toString(), e.typeId), e.save({ reason: 2 }));
    }, this.autoSaveAfterDelay);
    this.pendingAutoSavesAfterDelay.set(e, Ct(() => {
      this.logService.trace("[editor auto save] clearing pending auto save", e.resource.toString(), e.typeId), clearTimeout(t);
    }));
  }
  discardAutoSave(e) {
    He(this.pendingAutoSavesAfterDelay.get(e)), this.pendingAutoSavesAfterDelay.delete(e);
  }
};
Ti = I([
  h(0, Jr),
  h(1, Ki),
  h(2, Se),
  h(3, Ge),
  h(4, Yr),
  h(5, Qr)
], Ti);
let xi = class extends K {
  constructor(e, t, i, n, r) {
    super(), this.environmentService = t, this.pathService = i, this.textEditorService = n, this.untitledTextEditorService = r, this._register(e.registerHandler(this));
  }
  handles(e) {
    return e.resource.scheme === Dt.untitled && e.typeId === ts;
  }
  isOpen(e, t) {
    return this.handles(e) ? t instanceof ot && je(e.resource, t.resource) : !1;
  }
  createEditor(e) {
    let t;
    return this.untitledTextEditorService.isUntitledWithAssociatedResource(e.resource) ? t = is(e.resource, this.environmentService.remoteAuthority, this.pathService.defaultUriScheme) : t = e.resource, this.textEditorService.createTextEditor({ resource: t, forceUntitled: !0 });
  }
};
xi = I([
  h(0, Xr),
  h(1, on),
  h(2, Zr),
  h(3, ji),
  h(4, es)
], xi);
var q;
let Pi = (q = class extends K {
  constructor(e, t, i) {
    super(), this.editorResolverService = e, this.environmentService = i, this.configurationRegistry = V.as(os.Configuration), (async () => (await t.whenInstalledExtensionsRegistered(), this.updateDynamicEditorConfigurations(), this.registerListeners()))();
  }
  registerListeners() {
    k.debounce(this.editorResolverService.onDidChangeEditorRegistrations, (e, t) => t)(() => this.updateDynamicEditorConfigurations());
  }
  updateDynamicEditorConfigurations() {
    const e = [...this.editorResolverService.getEditors(), ...q.AUTO_LOCK_EXTRA_EDITORS].filter((u) => !q.AUTO_LOCK_REMOVE_EDITORS.has(u.id)), t = this.editorResolverService.getEditors().filter((u) => u.priority !== Xt.exclusive).map((u) => u.id), i = /* @__PURE__ */ Object.create(null);
    for (const u of e)
      i[u.id] = {
        type: "boolean",
        default: q.AUTO_LOCK_DEFAULT_ENABLED.has(u.id),
        description: u.label
      };
    const n = /* @__PURE__ */ Object.create(null);
    for (const u of e)
      n[u.id] = q.AUTO_LOCK_DEFAULT_ENABLED.has(u.id);
    const r = this.autoLockConfigurationNode;
    this.autoLockConfigurationNode = {
      ...vt,
      properties: {
        "workbench.editor.autoLockGroups": {
          type: "object",
          description: o(
            "workbench.editor.autoLockGroups",
            "If an editor matching one of the listed types is opened as the first in an editor group and more than one group is open, the group is automatically locked. Locked groups will only be used for opening editors when explicitly chosen by a user gesture (for example drag and drop), but not by default. Consequently, the active editor in a locked group is less likely to be replaced accidentally with a different editor."
          ),
          properties: i,
          default: n,
          additionalProperties: !1
        }
      }
    };
    const s = this.defaultBinaryEditorConfigurationNode;
    this.defaultBinaryEditorConfigurationNode = {
      ...vt,
      properties: {
        "workbench.editor.defaultBinaryEditor": {
          type: "string",
          default: "",
          enum: [...t, ""],
          description: o(
            "workbench.editor.defaultBinaryEditor",
            "The default editor for files detected as binary. If undefined, the user will be presented with a picker."
          )
        }
      }
    };
    const a = this.editorAssociationsConfigurationNode;
    this.editorAssociationsConfigurationNode = {
      ...vt,
      properties: {
        "workbench.editorAssociations": {
          type: "object",
          markdownDescription: o(
            "editor.editorAssociations",
            'Configure [glob patterns](https://aka.ms/vscode-glob-patterns) to editors (for example `"*.hex": "hexEditor.hexedit"`). These have precedence over the default behavior.'
          ),
          patternProperties: {
            ".*": {
              type: "string",
              enum: t
            }
          }
        }
      }
    };
    const d = this.editorLargeFileConfirmationConfigurationNode;
    this.editorLargeFileConfirmationConfigurationNode = {
      ...vt,
      properties: {
        "workbench.editorLargeFileConfirmation": {
          type: "number",
          default: ns(this.environmentService.remoteAuthority) / Yo.MB,
          minimum: 1,
          scope: 4,
          markdownDescription: o(
            "editorLargeFileSizeConfirmation",
            "Controls the minimum size of a file in MB before asking for confirmation when opening in the editor. Note that this setting may not apply to all editor types and environments."
          )
        }
      }
    }, this.configurationRegistry.updateConfigurations({
      add: [
        this.autoLockConfigurationNode,
        this.defaultBinaryEditorConfigurationNode,
        this.editorAssociationsConfigurationNode,
        this.editorLargeFileConfirmationConfigurationNode
      ],
      remove: pe([
        r,
        s,
        a,
        d
      ])
    });
  }
}, q.AUTO_LOCK_DEFAULT_ENABLED = /* @__PURE__ */ new Set(["terminalEditor"]), q.AUTO_LOCK_EXTRA_EDITORS = [
  {
    id: "workbench.input.interactive",
    label: o("interactiveWindow", "Interactive Window"),
    priority: Xt.builtin
  },
  {
    id: "mainThreadWebview-markdown.preview",
    label: o("markdownPreview", "Markdown Preview"),
    priority: Xt.builtin
  }
], q.AUTO_LOCK_REMOVE_EDITORS = /* @__PURE__ */ new Set([
  "vscode-interactive-input",
  "interactive",
  "vscode.markdown.preview.editor"
]), q);
Pi = I([
  h(0, $i),
  h(1, rs),
  h(2, on)
], Pi);
let _i = class extends K {
  constructor(e, t, i, n) {
    super(), this.configurationService = e, this.notificationService = t, this._accessibilityService = i, this.statusbarService = n, this.screenReaderNotification = null, this.promptedScreenReader = !1, this.screenReaderModeElement = this._register(new O()), this._register(this._accessibilityService.onDidChangeScreenReaderOptimized(() => this.onScreenReaderModeChange())), this._register(e.onDidChangeConfiguration((r) => {
      r.affectsConfiguration("editor.accessibilitySupport") && this.onScreenReaderModeChange();
    })), Zo.registerCommand({ id: "showEditorScreenReaderNotification", handler: () => this.showScreenReaderNotification() }), this.updateScreenReaderModeElement(this._accessibilityService.isScreenReaderOptimized());
  }
  showScreenReaderNotification() {
    this.screenReaderNotification || (this.screenReaderNotification = this.notificationService.prompt(ri.Info, o(
      "screenReaderDetectedExplanation.question",
      "Are you using a screen reader to operate VS Code?"
    ), [{
      label: o("screenReaderDetectedExplanation.answerYes", "Yes"),
      run: () => {
        this.configurationService.updateValue("editor.accessibilitySupport", "on", 2);
      }
    }, {
      label: o("screenReaderDetectedExplanation.answerNo", "No"),
      run: () => {
        this.configurationService.updateValue("editor.accessibilitySupport", "off", 2);
      }
    }], {
      sticky: !0,
      priority: ds.URGENT
    }), k.once(this.screenReaderNotification.onDidClose)(() => this.screenReaderNotification = null));
  }
  updateScreenReaderModeElement(e) {
    if (e) {
      if (!this.screenReaderModeElement.value) {
        const t = o("screenReaderDetected", "Screen Reader Optimized");
        this.screenReaderModeElement.value = this.statusbarService.addEntry({
          name: o("status.editor.screenReaderMode", "Screen Reader Mode"),
          text: t,
          ariaLabel: t,
          command: "showEditorScreenReaderNotification",
          backgroundColor: Ce(ai),
          color: Ce(di)
        }, "status.editor.screenReaderMode", 1, 100.6);
      }
    } else
      this.screenReaderModeElement.clear();
  }
  onScreenReaderModeChange() {
    this._accessibilityService.isScreenReaderOptimized() && this.configurationService.getValue("editor.accessibilitySupport") === "auto" && (this.promptedScreenReader || (this.promptedScreenReader = !0, setTimeout(() => this.showScreenReaderNotification(), 100))), this.screenReaderNotification && this.screenReaderNotification.close(), this.updateScreenReaderModeElement(this._accessibilityService.isScreenReaderOptimized());
  }
};
_i = I([
  h(0, T),
  h(1, ss),
  h(2, as),
  h(3, zi)
], _i);
class io extends L {
  constructor() {
    super({
      id: "diffEditor.toggleCollapseUnchangedRegions",
      title: { value: o("toggleCollapseUnchangedRegions", "Toggle Collapse Unchanged Regions"), original: "Toggle Collapse Unchanged Regions" },
      icon: v.map,
      precondition: rt.create("diffEditorVersion", 2)
    });
  }
  run(e, ...t) {
    const i = e.get(T), n = !i.getValue("diffEditor.experimental.collapseUnchangedRegions");
    i.updateValue("diffEditor.experimental.collapseUnchangedRegions", n);
  }
}
c(io);
g.appendMenuItem(l.EditorTitle, {
  command: {
    id: new io().desc.id,
    title: o("collapseUnchangedRegions", "Show Unchanged Regions"),
    icon: v.map
  },
  order: 22,
  group: "navigation",
  when: E.and(E.has("config.diffEditor.experimental.collapseUnchangedRegions"), rt.create("diffEditorVersion", 2))
});
g.appendMenuItem(l.EditorTitle, {
  command: {
    id: new io().desc.id,
    title: o("showUnchangedRegions", "Collapse Unchanged Regions"),
    icon: Nt.modify(v.map, "disabled")
  },
  order: 22,
  group: "navigation",
  when: E.and(E.has("config.diffEditor.experimental.collapseUnchangedRegions").negate(), rt.create("diffEditorVersion", 2))
});
class uc extends L {
  constructor() {
    super({
      id: "diffEditor.toggleShowMovedCodeBlocks",
      title: { value: o("toggleShowMovedCodeBlocks", "Toggle Show Moved Code Blocks"), original: "Toggle Show Moved Code Blocks" },
      precondition: rt.create("diffEditorVersion", 2)
    });
  }
  run(e, ...t) {
    const i = e.get(T), n = !i.getValue("diffEditor.experimental.showMoves");
    i.updateValue("diffEditor.experimental.showMoves", n);
  }
}
c(uc);
const hc = {
  value: o("diffEditor", "Diff Editor"),
  original: "Diff Editor"
};
class pc extends cs {
  constructor() {
    super({
      id: "diffEditor.switchSide",
      title: { value: o("switchSide", "Switch Side"), original: "Switch Side" },
      icon: v.arrowSwap,
      precondition: E.and(rt.create("diffEditorVersion", 2), E.has("isInDiffEditor")),
      f1: !0,
      category: hc
    });
  }
  runEditorCommand(e, t, ...i) {
    const n = ls(e);
    n instanceof us && n.switchSide();
  }
}
c(pc);
V.as(st.EditorPane).registerEditorPane(_e.create(vo, vo.ID, o("textEditor", "Text Editor")), [
  new $e(ot),
  new $e(ci)
]);
V.as(st.EditorPane).registerEditorPane(_e.create(bo, bo.ID, o("textDiffEditor", "Text Diff Editor")), [
  new $e(Ji)
]);
V.as(st.EditorPane).registerEditorPane(_e.create(ve, ve.ID, o("binaryDiffEditor", "Binary Diff Editor")), [
  new $e(Ji)
]);
V.as(st.EditorPane).registerEditorPane(_e.create(si, si.ID, o("sideBySideEditor", "Side by Side Editor")), [
  new $e(nt)
]);
V.as(at.Workbench).registerWorkbenchContribution(Ti, 2);
V.as(at.Workbench).registerWorkbenchContribution(Di, 2);
V.as(at.Workbench).registerWorkbenchContribution(_i, 2);
V.as(at.Workbench).registerWorkbenchContribution(xi, 2);
V.as(at.Workbench).registerWorkbenchContribution(Pi, 2);
hs(So.ID, So, 1);
const oo = V.as(ps.Quickaccess), Jt = "inEditorsPicker", qn = E.and(gs, E.has(Jt));
oo.registerQuickAccessProvider({
  ctor: yo,
  prefix: yo.PREFIX,
  contextKey: Jt,
  placeholder: o("editorQuickAccessPlaceholder", "Type the name of an editor to open it."),
  helpEntries: [{ description: o(
    "activeGroupEditorsByMostRecentlyUsedQuickAccess",
    "Show Editors in Active Group by Most Recently Used"
  ), commandId: nn.ID }]
});
oo.registerQuickAccessProvider({
  ctor: Co,
  prefix: Co.PREFIX,
  contextKey: Jt,
  placeholder: o("editorQuickAccessPlaceholder", "Type the name of an editor to open it."),
  helpEntries: [{ description: o(
    "allEditorsByAppearanceQuickAccess",
    "Show All Opened Editors By Appearance"
  ), commandId: rn.ID }]
});
oo.registerQuickAccessProvider({
  ctor: wo,
  prefix: wo.PREFIX,
  contextKey: Jt,
  placeholder: o("editorQuickAccessPlaceholder", "Type the name of an editor to open it."),
  helpEntries: [{ description: o(
    "allEditorsByMostRecentlyUsedQuickAccess",
    "Show All Opened Editors By Most Recently Used"
  ), commandId: sn.ID }]
});
c(Ri);
c(cc);
c(lc);
c(ms);
c(fs);
c(Es);
c(vs);
c(bs);
c(Ss);
c(ys);
c(Cs);
c(ws);
c(Is);
c(Ms);
c(As);
c(an);
c(dn);
c(rn);
c(sn);
c(nn);
c(Ds);
c(ks);
c(Ls);
c(Rs);
c(Ts);
c(xs);
c(Yi);
c(Ps);
c(_s);
c(Gs);
c(Os);
c(Bs);
c(Fs);
c(Ns);
c(Vs);
c(Us);
c(Ws);
c(Hs);
c(zs);
c(qs);
c(Ks);
c(js);
c($s);
c(Js);
c(Ys);
c(Qs);
c(Xs);
c(Zs);
c(ea);
c(ta);
c(ia);
c(oa);
c(na);
c(ra);
c(sa);
c(aa);
c(da);
c(ca);
c(la);
c(ua);
c(ha);
c(pa);
c(ga);
c(ma);
c(fa);
c(Ea);
c(va);
c(ba);
c(Sa);
c(ya);
c(Ca);
c(wa);
c(Ia);
c(Ma);
c(Aa);
c(Da);
c(ka);
c(La);
c(Ra);
c(Ta);
c(xa);
c(Pa);
c(_a);
c(Ga);
c(Oa);
c(Ba);
c(Fa);
c(Na);
c(cn);
c(ln);
c(un);
c(hn);
c(pn);
c(gn);
c(mn);
c(fn);
c(Va);
c(Ua);
c(Wa);
c(Ha);
c(za);
c(qa);
c(Ka);
const Bo = "workbench.action.quickOpenNavigateNextInEditorPicker";
Ui.registerCommandAndKeybindingRule({
  id: Bo,
  weight: 200 + 50,
  handler: En(Bo, !0),
  when: qn,
  primary: 2050,
  mac: { primary: 258 }
});
const Fo = "workbench.action.quickOpenNavigatePreviousInEditorPicker";
Ui.registerCommandAndKeybindingRule({
  id: Fo,
  weight: 200 + 50,
  handler: En(Fo, !1),
  when: qn,
  primary: 3074,
  mac: { primary: 1282 }
});
ja();
g.appendMenuItem(l.EmptyEditorGroup, { command: { id: vn, title: o("unlockGroupAction", "Unlock Group"), icon: v.lock }, group: "navigation", order: 10, when: Ht });
g.appendMenuItem(l.EmptyEditorGroup, { command: { id: bn, title: o("closeGroupAction", "Close Group"), icon: v.close }, group: "navigation", order: 20 });
g.appendMenuItem(l.EmptyEditorGroupContext, { command: { id: zt, title: o("splitUp", "Split Up") }, group: "2_split", order: 10 });
g.appendMenuItem(l.EmptyEditorGroupContext, { command: { id: dt, title: o("splitDown", "Split Down") }, group: "2_split", order: 20 });
g.appendMenuItem(l.EmptyEditorGroupContext, { command: { id: qt, title: o("splitLeft", "Split Left") }, group: "2_split", order: 30 });
g.appendMenuItem(l.EmptyEditorGroupContext, { command: { id: ct, title: o("splitRight", "Split Right") }, group: "2_split", order: 40 });
g.appendMenuItem(l.EmptyEditorGroupContext, { command: { id: Sn, title: o("toggleLockGroup", "Lock Group"), toggled: Ht }, group: "3_lock", order: 10, when: B });
g.appendMenuItem(l.EmptyEditorGroupContext, { command: { id: bn, title: o("close", "Close") }, group: "4_close", order: 10, when: B });
g.appendMenuItem(l.EditorTabsBarContext, { command: { id: zt, title: o("splitUp", "Split Up") }, group: "2_split", order: 10 });
g.appendMenuItem(l.EditorTabsBarContext, { command: { id: dt, title: o("splitDown", "Split Down") }, group: "2_split", order: 20 });
g.appendMenuItem(l.EditorTabsBarContext, { command: { id: qt, title: o("splitLeft", "Split Left") }, group: "2_split", order: 30 });
g.appendMenuItem(l.EditorTabsBarContext, { command: { id: ct, title: o("splitRight", "Split Right") }, group: "2_split", order: 40 });
g.appendMenuItem(l.EditorTabsBarContext, { command: { id: Je.ID, title: o("toggleTabs", "Enable Tabs"), toggled: E.has("config.workbench.editor.showTabs") }, group: "3_config", order: 10 });
g.appendMenuItem(l.EditorTitleContext, { command: { id: Oe, title: o("close", "Close") }, group: "1_close", order: 10 });
g.appendMenuItem(l.EditorTitleContext, { command: { id: yn, title: o("closeOthers", "Close Others"), precondition: $a.notEqualsTo("1") }, group: "1_close", order: 20 });
g.appendMenuItem(l.EditorTitleContext, { command: { id: Cn, title: o("closeRight", "Close to the Right"), precondition: wn.toNegated() }, group: "1_close", order: 30, when: lt });
g.appendMenuItem(l.EditorTitleContext, { command: { id: Qi, title: o("closeAllSaved", "Close Saved") }, group: "1_close", order: 40 });
g.appendMenuItem(l.EditorTitleContext, { command: { id: ut, title: o("closeAll", "Close All") }, group: "1_close", order: 50 });
g.appendMenuItem(l.EditorTitleContext, { command: { id: In, title: o("reopenWith", "Reopen Editor With...") }, group: "1_open", order: 10, when: Mn });
g.appendMenuItem(l.EditorTitleContext, { command: { id: An, title: o("keepOpen", "Keep Open"), precondition: Ja.toNegated() }, group: "3_preview", order: 10, when: E.has("config.workbench.editor.enablePreview") });
g.appendMenuItem(l.EditorTitleContext, { command: { id: Dn, title: o("pin", "Pin") }, group: "3_preview", order: 20, when: Be.toNegated() });
g.appendMenuItem(l.EditorTitleContext, { command: { id: Kt, title: o("unpin", "Unpin") }, group: "3_preview", order: 20, when: Be });
g.appendMenuItem(l.EditorTitleContext, { command: { id: zt, title: o("splitUp", "Split Up") }, group: "5_split", order: 10 });
g.appendMenuItem(l.EditorTitleContext, { command: { id: dt, title: o("splitDown", "Split Down") }, group: "5_split", order: 20 });
g.appendMenuItem(l.EditorTitleContext, { command: { id: qt, title: o("splitLeft", "Split Left") }, group: "5_split", order: 30 });
g.appendMenuItem(l.EditorTitleContext, { command: { id: ct, title: o("splitRight", "Split Right") }, group: "5_split", order: 40 });
g.appendMenuItem(l.EditorTitleContext, { command: { id: kn, title: o("splitInGroup", "Split in Group") }, group: "6_split_in_group", order: 10, when: Ln });
g.appendMenuItem(l.EditorTitleContext, { command: { id: Rn, title: o("joinInGroup", "Join in Group") }, group: "6_split_in_group", order: 10, when: ht });
g.appendMenuItem(l.EditorTitle, { command: { id: Ya, title: o("inlineView", "Inline View"), toggled: E.equals("config.diffEditor.renderSideBySide", !1) }, group: "1_diff", order: 10, when: E.has("isInDiffEditor") });
g.appendMenuItem(l.EditorTitle, { command: { id: Qa, title: o("showOpenedEditors", "Show Opened Editors") }, group: "3_open", order: 10 });
g.appendMenuItem(l.EditorTitle, { command: { id: ut, title: o("closeAll", "Close All") }, group: "5_close", order: 10 });
g.appendMenuItem(l.EditorTitle, { command: { id: Qi, title: o("closeAllSaved", "Close Saved") }, group: "5_close", order: 20 });
g.appendMenuItem(l.EditorTitle, { command: { id: Je.ID, title: o("toggleTabs", "Enable Tabs"), toggled: E.has("config.workbench.editor.showTabs") }, group: "7_settings", order: 5, when: E.has("config.workbench.editor.showTabs").negate() });
g.appendMenuItem(l.EditorTitle, { command: { id: Xa, title: o("togglePreviewMode", "Enable Preview Editors"), toggled: E.has("config.workbench.editor.enablePreview") }, group: "7_settings", order: 10 });
g.appendMenuItem(l.EditorTitle, { command: { id: Sn, title: o("lockGroup", "Lock Group"), toggled: Ht }, group: "8_lock", order: 10, when: B });
function U(p, e, t, i, n) {
  const r = {
    command: {
      id: p.id,
      title: p.title,
      icon: p.icon,
      precondition: n
    },
    group: "navigation",
    when: e,
    order: t
  };
  i && (r.alt = {
    id: i.id,
    title: i.title,
    icon: i.icon
  }), g.appendMenuItem(l.EditorTitle, r);
}
const no = 1e5, pt = 1e6;
U({
  id: Yi.ID,
  title: o("splitEditorRight", "Split Editor Right"),
  icon: v.splitHorizontal
}, E.not("splitEditorsVertically"), no, {
  id: dt,
  title: o("splitEditorDown", "Split Editor Down"),
  icon: v.splitVertical
});
U({
  id: Yi.ID,
  title: o("splitEditorDown", "Split Editor Down"),
  icon: v.splitVertical
}, E.has("splitEditorsVertically"), no, {
  id: ct,
  title: o("splitEditorRight", "Split Editor Right"),
  icon: v.splitHorizontal
});
U({
  id: Za,
  title: o("toggleSplitEditorInGroupLayout", "Toggle Layout"),
  icon: v.editorLayout
}, ht, no - 1);
U({
  id: Oe,
  title: o("close", "Close"),
  icon: v.close
}, E.and(lt.toNegated(), jt.toNegated(), Be.toNegated()), pt, {
  id: ut,
  title: o("closeAll", "Close All"),
  icon: v.closeAll
});
U({
  id: Oe,
  title: o("close", "Close"),
  icon: v.closeDirty
}, E.and(lt.toNegated(), jt, Be.toNegated()), pt, {
  id: ut,
  title: o("closeAll", "Close All"),
  icon: v.closeAll
});
U({
  id: Kt,
  title: o("unpin", "Unpin"),
  icon: v.pinned
}, E.and(lt.toNegated(), jt.toNegated(), Be), pt, {
  id: Oe,
  title: o("close", "Close"),
  icon: v.close
});
U({
  id: Kt,
  title: o("unpin", "Unpin"),
  icon: v.pinnedDirty
}, E.and(lt.toNegated(), jt, Be), pt, {
  id: Oe,
  title: o("close", "Close"),
  icon: v.close
});
U({
  id: vn,
  title: o("unlockEditorGroup", "Unlock Group"),
  icon: v.lock
}, Ht, pt - 1);
const gc = y("diff-editor-previous-change", v.arrowUp, o(
  "previousChangeIcon",
  "Icon for the previous change action in the diff editor."
)), mc = y("diff-editor-next-change", v.arrowDown, o("nextChangeIcon", "Icon for the next change action in the diff editor.")), Kn = y("diff-editor-toggle-whitespace", v.whitespace, o(
  "toggleWhitespace",
  "Icon for the toggle whitespace action in the diff editor."
));
U({
  id: ed,
  title: o("navigate.prev.label", "Previous Change"),
  icon: gc
}, Fe, 10);
U({
  id: td,
  title: o("navigate.next.label", "Next Change"),
  icon: mc
}, Fe, 11);
U({
  id: Tn,
  title: o(
    "ignoreTrimWhitespace.label",
    "Ignore Leading/Trailing Whitespace Differences"
  ),
  icon: Kn
}, E.and(Fe, E.notEquals("config.diffEditor.ignoreTrimWhitespace", !0)), 20);
U({
  id: Tn,
  title: o("showTrimWhitespace.label", "Show Leading/Trailing Whitespace Differences"),
  icon: Nt.modify(Kn, "disabled")
}, E.and(Fe, E.notEquals("config.diffEditor.ignoreTrimWhitespace", !1)), 20);
g.appendMenuItem(l.CommandPalette, { command: { id: An, title: { value: o("keepEditor", "Keep Editor"), original: "Keep Editor" }, category: C.View }, when: E.has("config.workbench.editor.enablePreview") });
g.appendMenuItem(l.CommandPalette, { command: { id: Dn, title: { value: o("pinEditor", "Pin Editor"), original: "Pin Editor" }, category: C.View } });
g.appendMenuItem(l.CommandPalette, { command: { id: Kt, title: { value: o("unpinEditor", "Unpin Editor"), original: "Unpin Editor" }, category: C.View } });
g.appendMenuItem(l.CommandPalette, { command: { id: Oe, title: { value: o("closeEditor", "Close Editor"), original: "Close Editor" }, category: C.View } });
g.appendMenuItem(l.CommandPalette, { command: { id, title: { value: o("closePinnedEditor", "Close Pinned Editor"), original: "Close Pinned Editor" }, category: C.View } });
g.appendMenuItem(l.CommandPalette, { command: { id: ut, title: { value: o("closeEditorsInGroup", "Close All Editors in Group"), original: "Close All Editors in Group" }, category: C.View } });
g.appendMenuItem(l.CommandPalette, { command: { id: Qi, title: { value: o("closeSavedEditors", "Close Saved Editors in Group"), original: "Close Saved Editors in Group" }, category: C.View } });
g.appendMenuItem(l.CommandPalette, { command: { id: yn, title: { value: o("closeOtherEditors", "Close Other Editors in Group"), original: "Close Other Editors in Group" }, category: C.View } });
g.appendMenuItem(l.CommandPalette, { command: { id: Cn, title: { value: o("closeRightEditors", "Close Editors to the Right in Group"), original: "Close Editors to the Right in Group" }, category: C.View }, when: wn.toNegated() });
g.appendMenuItem(l.CommandPalette, { command: { id: od, title: { value: o("closeEditorGroup", "Close Editor Group"), original: "Close Editor Group" }, category: C.View }, when: B });
g.appendMenuItem(l.CommandPalette, { command: { id: In, title: { value: o("reopenWith", "Reopen Editor With..."), original: "Reopen Editor With..." }, category: C.View }, when: Mn });
g.appendMenuItem(l.MenubarRecentMenu, {
  group: "1_editor",
  command: {
    id: an.ID,
    title: o(
      { key: "miReopenClosedEditor", comment: ["&& denotes a mnemonic"] },
      "&&Reopen Closed Editor"
    ),
    precondition: E.has("canReopenClosedEditor")
  },
  order: 1
});
g.appendMenuItem(l.MenubarRecentMenu, {
  group: "z_clear",
  command: {
    id: dn.ID,
    title: o(
      { key: "miClearRecentOpen", comment: ["&& denotes a mnemonic"] },
      "&&Clear Recently Opened"
    )
  },
  order: 1
});
g.appendMenuItem(l.MenubarViewMenu, {
  group: "2_appearance",
  title: o(
    { key: "miEditorLayout", comment: ["&& denotes a mnemonic"] },
    "Editor &&Layout"
  ),
  submenu: l.MenubarLayoutMenu,
  order: 2
});
g.appendMenuItem(l.MenubarLayoutMenu, {
  group: "1_split",
  command: {
    id: zt,
    title: {
      original: "Split Up",
      value: o("miSplitEditorUpWithoutMnemonic", "Split Up"),
      mnemonicTitle: o(
        { key: "miSplitEditorUp", comment: ["&& denotes a mnemonic"] },
        "Split &&Up"
      )
    }
  },
  order: 1
});
g.appendMenuItem(l.MenubarLayoutMenu, {
  group: "1_split",
  command: {
    id: dt,
    title: {
      original: "Split Down",
      value: o("miSplitEditorDownWithoutMnemonic", "Split Down"),
      mnemonicTitle: o(
        { key: "miSplitEditorDown", comment: ["&& denotes a mnemonic"] },
        "Split &&Down"
      )
    }
  },
  order: 2
});
g.appendMenuItem(l.MenubarLayoutMenu, {
  group: "1_split",
  command: {
    id: qt,
    title: {
      original: "Split Left",
      value: o("miSplitEditorLeftWithoutMnemonic", "Split Left"),
      mnemonicTitle: o(
        { key: "miSplitEditorLeft", comment: ["&& denotes a mnemonic"] },
        "Split &&Left"
      )
    }
  },
  order: 3
});
g.appendMenuItem(l.MenubarLayoutMenu, {
  group: "1_split",
  command: {
    id: ct,
    title: {
      original: "Split Right",
      value: o("miSplitEditorRightWithoutMnemonic", "Split Right"),
      mnemonicTitle: o(
        { key: "miSplitEditorRight", comment: ["&& denotes a mnemonic"] },
        "Split &&Right"
      )
    }
  },
  order: 4
});
g.appendMenuItem(l.MenubarLayoutMenu, {
  group: "2_split_in_group",
  command: {
    id: kn,
    title: {
      original: "Split in Group",
      value: o("miSplitEditorInGroupWithoutMnemonic", "Split in Group"),
      mnemonicTitle: o(
        { key: "miSplitEditorInGroup", comment: ["&& denotes a mnemonic"] },
        "Split in &&Group"
      )
    }
  },
  when: Ln,
  order: 1
});
g.appendMenuItem(l.MenubarLayoutMenu, {
  group: "2_split_in_group",
  command: {
    id: Rn,
    title: {
      original: "Join in Group",
      value: o("miJoinEditorInGroupWithoutMnemonic", "Join in Group"),
      mnemonicTitle: o(
        { key: "miJoinEditorInGroup", comment: ["&& denotes a mnemonic"] },
        "Join in &&Group"
      )
    }
  },
  when: ht,
  order: 1
});
g.appendMenuItem(l.MenubarLayoutMenu, {
  group: "3_layouts",
  command: {
    id: cn.ID,
    title: {
      original: "Single",
      value: o("miSingleColumnEditorLayoutWithoutMnemonic", "Single"),
      mnemonicTitle: o(
        { key: "miSingleColumnEditorLayout", comment: ["&& denotes a mnemonic"] },
        "&&Single"
      )
    }
  },
  order: 1
});
g.appendMenuItem(l.MenubarLayoutMenu, {
  group: "3_layouts",
  command: {
    id: ln.ID,
    title: {
      original: "Two Columns",
      value: o("miTwoColumnsEditorLayoutWithoutMnemonic", "Two Columns"),
      mnemonicTitle: o(
        { key: "miTwoColumnsEditorLayout", comment: ["&& denotes a mnemonic"] },
        "&&Two Columns"
      )
    }
  },
  order: 3
});
g.appendMenuItem(l.MenubarLayoutMenu, {
  group: "3_layouts",
  command: {
    id: un.ID,
    title: {
      original: "Three Columns",
      value: o("miThreeColumnsEditorLayoutWithoutMnemonic", "Three Columns"),
      mnemonicTitle: o(
        { key: "miThreeColumnsEditorLayout", comment: ["&& denotes a mnemonic"] },
        "T&&hree Columns"
      )
    }
  },
  order: 4
});
g.appendMenuItem(l.MenubarLayoutMenu, {
  group: "3_layouts",
  command: {
    id: hn.ID,
    title: {
      original: "Two Rows",
      value: o("miTwoRowsEditorLayoutWithoutMnemonic", "Two Rows"),
      mnemonicTitle: o(
        { key: "miTwoRowsEditorLayout", comment: ["&& denotes a mnemonic"] },
        "T&&wo Rows"
      )
    }
  },
  order: 5
});
g.appendMenuItem(l.MenubarLayoutMenu, {
  group: "3_layouts",
  command: {
    id: pn.ID,
    title: {
      original: "Three Rows",
      value: o("miThreeRowsEditorLayoutWithoutMnemonic", "Three Rows"),
      mnemonicTitle: o(
        { key: "miThreeRowsEditorLayout", comment: ["&& denotes a mnemonic"] },
        "Three &&Rows"
      )
    }
  },
  order: 6
});
g.appendMenuItem(l.MenubarLayoutMenu, {
  group: "3_layouts",
  command: {
    id: gn.ID,
    title: {
      original: "Grid (2x2)",
      value: o("miTwoByTwoGridEditorLayoutWithoutMnemonic", "Grid (2x2)"),
      mnemonicTitle: o(
        { key: "miTwoByTwoGridEditorLayout", comment: ["&& denotes a mnemonic"] },
        "&&Grid (2x2)"
      )
    }
  },
  order: 7
});
g.appendMenuItem(l.MenubarLayoutMenu, {
  group: "3_layouts",
  command: {
    id: mn.ID,
    title: {
      original: "Two Rows Right",
      value: o("miTwoRowsRightEditorLayoutWithoutMnemonic", "Two Rows Right"),
      mnemonicTitle: o(
        { key: "miTwoRowsRightEditorLayout", comment: ["&& denotes a mnemonic"] },
        "Two R&&ows Right"
      )
    }
  },
  order: 8
});
g.appendMenuItem(l.MenubarLayoutMenu, {
  group: "3_layouts",
  command: {
    id: fn.ID,
    title: {
      original: "Two Columns Bottom",
      value: o("miTwoColumnsBottomEditorLayoutWithoutMnemonic", "Two Columns Bottom"),
      mnemonicTitle: o(
        { key: "miTwoColumnsBottomEditorLayout", comment: ["&& denotes a mnemonic"] },
        "Two &&Columns Bottom"
      )
    }
  },
  order: 9
});
g.appendMenuItem(l.MenubarGoMenu, {
  group: "1_history_nav",
  command: {
    id: "workbench.action.navigateToLastEditLocation",
    title: o(
      { key: "miLastEditLocation", comment: ["&& denotes a mnemonic"] },
      "&&Last Edit Location"
    ),
    precondition: E.has("canNavigateToLastEditLocation")
  },
  order: 3
});
g.appendMenuItem(l.MenubarSwitchEditorMenu, {
  group: "1_sideBySide",
  command: {
    id: nd,
    title: o(
      { key: "miFirstSideEditor", comment: ["&& denotes a mnemonic"] },
      "&&First Side in Editor"
    )
  },
  when: E.or(ht, Fe),
  order: 1
});
g.appendMenuItem(l.MenubarSwitchEditorMenu, {
  group: "1_sideBySide",
  command: {
    id: rd,
    title: o(
      { key: "miSecondSideEditor", comment: ["&& denotes a mnemonic"] },
      "&&Second Side in Editor"
    )
  },
  when: E.or(ht, Fe),
  order: 2
});
g.appendMenuItem(l.MenubarSwitchEditorMenu, {
  group: "2_any",
  command: {
    id: "workbench.action.nextEditor",
    title: o(
      { key: "miNextEditor", comment: ["&& denotes a mnemonic"] },
      "&&Next Editor"
    )
  },
  order: 1
});
g.appendMenuItem(l.MenubarSwitchEditorMenu, {
  group: "2_any",
  command: {
    id: "workbench.action.previousEditor",
    title: o(
      { key: "miPreviousEditor", comment: ["&& denotes a mnemonic"] },
      "&&Previous Editor"
    )
  },
  order: 2
});
g.appendMenuItem(l.MenubarSwitchEditorMenu, {
  group: "3_any_used",
  command: {
    id: "workbench.action.openNextRecentlyUsedEditor",
    title: o(
      { key: "miNextRecentlyUsedEditor", comment: ["&& denotes a mnemonic"] },
      "&&Next Used Editor"
    )
  },
  order: 1
});
g.appendMenuItem(l.MenubarSwitchEditorMenu, {
  group: "3_any_used",
  command: {
    id: "workbench.action.openPreviousRecentlyUsedEditor",
    title: o(
      { key: "miPreviousRecentlyUsedEditor", comment: ["&& denotes a mnemonic"] },
      "&&Previous Used Editor"
    )
  },
  order: 2
});
g.appendMenuItem(l.MenubarSwitchEditorMenu, {
  group: "4_group",
  command: {
    id: "workbench.action.nextEditorInGroup",
    title: o(
      { key: "miNextEditorInGroup", comment: ["&& denotes a mnemonic"] },
      "&&Next Editor in Group"
    )
  },
  order: 1
});
g.appendMenuItem(l.MenubarSwitchEditorMenu, {
  group: "4_group",
  command: {
    id: "workbench.action.previousEditorInGroup",
    title: o(
      { key: "miPreviousEditorInGroup", comment: ["&& denotes a mnemonic"] },
      "&&Previous Editor in Group"
    )
  },
  order: 2
});
g.appendMenuItem(l.MenubarSwitchEditorMenu, {
  group: "5_group_used",
  command: {
    id: "workbench.action.openNextRecentlyUsedEditorInGroup",
    title: o(
      { key: "miNextUsedEditorInGroup", comment: ["&& denotes a mnemonic"] },
      "&&Next Used Editor in Group"
    )
  },
  order: 1
});
g.appendMenuItem(l.MenubarSwitchEditorMenu, {
  group: "5_group_used",
  command: {
    id: "workbench.action.openPreviousRecentlyUsedEditorInGroup",
    title: o(
      { key: "miPreviousUsedEditorInGroup", comment: ["&& denotes a mnemonic"] },
      "&&Previous Used Editor in Group"
    )
  },
  order: 2
});
g.appendMenuItem(l.MenubarGoMenu, {
  group: "2_editor_nav",
  title: o(
    { key: "miSwitchEditor", comment: ["&& denotes a mnemonic"] },
    "Switch &&Editor"
  ),
  submenu: l.MenubarSwitchEditorMenu,
  order: 1
});
g.appendMenuItem(l.MenubarSwitchGroupMenu, {
  group: "1_focus_index",
  command: {
    id: "workbench.action.focusFirstEditorGroup",
    title: o(
      { key: "miFocusFirstGroup", comment: ["&& denotes a mnemonic"] },
      "Group &&1"
    )
  },
  order: 1
});
g.appendMenuItem(l.MenubarSwitchGroupMenu, {
  group: "1_focus_index",
  command: {
    id: "workbench.action.focusSecondEditorGroup",
    title: o(
      { key: "miFocusSecondGroup", comment: ["&& denotes a mnemonic"] },
      "Group &&2"
    )
  },
  order: 2
});
g.appendMenuItem(l.MenubarSwitchGroupMenu, {
  group: "1_focus_index",
  command: {
    id: "workbench.action.focusThirdEditorGroup",
    title: o(
      { key: "miFocusThirdGroup", comment: ["&& denotes a mnemonic"] },
      "Group &&3"
    ),
    precondition: B
  },
  order: 3
});
g.appendMenuItem(l.MenubarSwitchGroupMenu, {
  group: "1_focus_index",
  command: {
    id: "workbench.action.focusFourthEditorGroup",
    title: o(
      { key: "miFocusFourthGroup", comment: ["&& denotes a mnemonic"] },
      "Group &&4"
    ),
    precondition: B
  },
  order: 4
});
g.appendMenuItem(l.MenubarSwitchGroupMenu, {
  group: "1_focus_index",
  command: {
    id: "workbench.action.focusFifthEditorGroup",
    title: o(
      { key: "miFocusFifthGroup", comment: ["&& denotes a mnemonic"] },
      "Group &&5"
    ),
    precondition: B
  },
  order: 5
});
g.appendMenuItem(l.MenubarSwitchGroupMenu, {
  group: "2_next_prev",
  command: {
    id: "workbench.action.focusNextGroup",
    title: o({ key: "miNextGroup", comment: ["&& denotes a mnemonic"] }, "&&Next Group"),
    precondition: B
  },
  order: 1
});
g.appendMenuItem(l.MenubarSwitchGroupMenu, {
  group: "2_next_prev",
  command: {
    id: "workbench.action.focusPreviousGroup",
    title: o(
      { key: "miPreviousGroup", comment: ["&& denotes a mnemonic"] },
      "&&Previous Group"
    ),
    precondition: B
  },
  order: 2
});
g.appendMenuItem(l.MenubarSwitchGroupMenu, {
  group: "3_directional",
  command: {
    id: "workbench.action.focusLeftGroup",
    title: o(
      { key: "miFocusLeftGroup", comment: ["&& denotes a mnemonic"] },
      "Group &&Left"
    ),
    precondition: B
  },
  order: 1
});
g.appendMenuItem(l.MenubarSwitchGroupMenu, {
  group: "3_directional",
  command: {
    id: "workbench.action.focusRightGroup",
    title: o(
      { key: "miFocusRightGroup", comment: ["&& denotes a mnemonic"] },
      "Group &&Right"
    ),
    precondition: B
  },
  order: 2
});
g.appendMenuItem(l.MenubarSwitchGroupMenu, {
  group: "3_directional",
  command: {
    id: "workbench.action.focusAboveGroup",
    title: o(
      { key: "miFocusAboveGroup", comment: ["&& denotes a mnemonic"] },
      "Group &&Above"
    ),
    precondition: B
  },
  order: 3
});
g.appendMenuItem(l.MenubarSwitchGroupMenu, {
  group: "3_directional",
  command: {
    id: "workbench.action.focusBelowGroup",
    title: o(
      { key: "miFocusBelowGroup", comment: ["&& denotes a mnemonic"] },
      "Group &&Below"
    ),
    precondition: B
  },
  order: 4
});
g.appendMenuItem(l.MenubarGoMenu, {
  group: "2_editor_nav",
  title: o(
    { key: "miSwitchGroup", comment: ["&& denotes a mnemonic"] },
    "Switch &&Group"
  ),
  submenu: l.MenubarSwitchGroupMenu,
  order: 2
});
let No = class extends sd {
  constructor(e, t, i) {
    super(t), this.editorService = e, this.configurationService = i, this.registerCodeEditorOpenHandler(this.doOpenCodeEditor.bind(this)), this.registerCodeEditorOpenHandler(this.doOpenCodeEditorFromDiff.bind(this));
  }
  getActiveCodeEditor() {
    var i;
    const e = this.editorService.activeTextEditorControl;
    if (me(e))
      return e;
    if (ze(e))
      return e.getModifiedEditor();
    const t = (i = this.editorService.activeEditorPane) == null ? void 0 : i.getControl();
    return li(t) && me(t.activeCodeEditor) ? t.activeCodeEditor : null;
  }
  async doOpenCodeEditorFromDiff(e, t, i) {
    var r;
    const n = this.editorService.activeTextEditorControl;
    if (!i && ze(n) && e.options && e.resource && t === n.getModifiedEditor() && n.getModel() && je(e.resource, (r = n.getModel()) == null ? void 0 : r.modified.uri)) {
      const s = n.getModifiedEditor();
      return xn(e.options, s, 0), s;
    }
    return null;
  }
  async doOpenCodeEditor(e, t, i) {
    var s, a, d, u;
    if (!((a = (s = this.configurationService.getValue().workbench) == null ? void 0 : s.editor) == null ? void 0 : a.enablePreviewFromCodeNavigation) && t && !((d = e.options) != null && d.pinned) && !i && !je((u = t.getModel()) == null ? void 0 : u.uri, e.resource)) {
      for (const m of this.editorService.visibleEditorPanes)
        if (ae(m.getControl()) === t) {
          m.group.pinEditor();
          break;
        }
    }
    const r = await this.editorService.openEditor(e, i ? Ut : ad);
    if (r) {
      const m = r.getControl();
      if (me(m))
        return m;
      if (li(m) && me(m.activeCodeEditor))
        return m.activeCodeEditor;
    }
    return null;
  }
};
No = I([
  h(0, Se),
  h(1, de),
  h(2, T)
], No);
var se;
let Gi = (se = class extends K {
  get count() {
    return this.mostRecentEditorsMap.size;
  }
  get editors() {
    return [...this.mostRecentEditorsMap.values()];
  }
  hasEditor(e) {
    const t = this.editorsPerResourceCounter.get(e.resource);
    return (t == null ? void 0 : t.has(this.toIdentifier(e))) ?? !1;
  }
  hasEditors(e) {
    return this.editorsPerResourceCounter.has(e);
  }
  toIdentifier(e, t) {
    return typeof e != "string" ? this.toIdentifier(e.typeId, e.editorId) : t ? `${e}/${t}` : e;
  }
  constructor(e, t) {
    super(), this.editorGroupsService = e, this.storageService = t, this.keyMap = /* @__PURE__ */ new Map(), this.mostRecentEditorsMap = new dd(), this.editorsPerResourceCounter = new Pn(), this._onDidMostRecentlyActiveEditorsChange = this._register(new R()), this.onDidMostRecentlyActiveEditorsChange = this._onDidMostRecentlyActiveEditorsChange.event, this.registerListeners();
  }
  registerListeners() {
    this._register(this.storageService.onWillSaveState(() => this.saveState())), this._register(this.editorGroupsService.onDidAddGroup((e) => this.onGroupAdded(e))), this._register(this.editorGroupsService.onDidChangeEditorPartOptions((e) => this.onDidChangeEditorPartOptions(e))), this.editorGroupsService.whenReady.then(() => this.loadState());
  }
  onGroupAdded(e) {
    const t = e.getEditors(0);
    for (let i = t.length - 1; i >= 0; i--)
      this.addMostRecentEditor(e, t[i], !1, !0);
    this.editorGroupsService.activeGroup === e && e.activeEditor && this.addMostRecentEditor(e, e.activeEditor, !0, !1), this.registerGroupListeners(e);
  }
  registerGroupListeners(e) {
    const t = new xe();
    t.add(e.onDidModelChange((i) => {
      switch (i.kind) {
        case 0: {
          this.editorGroupsService.activeGroup === e && e.activeEditor && this.addMostRecentEditor(e, e.activeEditor, !0, !1);
          break;
        }
        case 3: {
          i.editor && (this.addMostRecentEditor(e, i.editor, !1, !0), this.ensureOpenedEditorsLimit({ groupId: e.id, editor: i.editor }, e.id));
          break;
        }
      }
    })), t.add(e.onDidCloseEditor((i) => {
      this.removeMostRecentEditor(e, i.editor);
    })), t.add(e.onDidActiveEditorChange((i) => {
      i.editor && this.addMostRecentEditor(e, i.editor, this.editorGroupsService.activeGroup === e, !1);
    })), k.once(e.onWillDispose)(() => He(t));
  }
  onDidChangeEditorPartOptions(e) {
    if (!cd(e.newPartOptions.limit, e.oldPartOptions.limit)) {
      const t = this.editorGroupsService.activeGroup;
      let i;
      t.activeEditor && (i = { editor: t.activeEditor, groupId: t.id }), this.ensureOpenedEditorsLimit(i);
    }
  }
  addMostRecentEditor(e, t, i, n) {
    const r = this.ensureKey(e, t), s = this.mostRecentEditorsMap.first;
    i || !s ? this.mostRecentEditorsMap.set(r, r, s ? 1 : void 0) : (this.mostRecentEditorsMap.set(r, r, 1), this.mostRecentEditorsMap.set(s, s, 1)), n && this.updateEditorResourcesMap(t, !0), this._onDidMostRecentlyActiveEditorsChange.fire();
  }
  updateEditorResourcesMap(e, t) {
    let i, n, r;
    if (e instanceof nt ? (i = e.primary.resource, n = e.primary.typeId, r = e.primary.editorId) : (i = e.resource, n = e.typeId, r = e.editorId), !i)
      return;
    const s = this.toIdentifier(n, r);
    if (t) {
      let a = this.editorsPerResourceCounter.get(i);
      a || (a = /* @__PURE__ */ new Map(), this.editorsPerResourceCounter.set(i, a)), a.set(s, (a.get(s) ?? 0) + 1);
    } else {
      const a = this.editorsPerResourceCounter.get(i);
      if (a) {
        const d = a.get(s) ?? 0;
        d > 1 ? a.set(s, d - 1) : (a.delete(s), a.size === 0 && this.editorsPerResourceCounter.delete(i));
      }
    }
  }
  removeMostRecentEditor(e, t) {
    this.updateEditorResourcesMap(t, !1);
    const i = this.findKey(e, t);
    if (i) {
      this.mostRecentEditorsMap.delete(i);
      const n = this.keyMap.get(e.id);
      n && n.delete(i.editor) && n.size === 0 && this.keyMap.delete(e.id), this._onDidMostRecentlyActiveEditorsChange.fire();
    }
  }
  findKey(e, t) {
    const i = this.keyMap.get(e.id);
    if (i)
      return i.get(t);
  }
  ensureKey(e, t) {
    let i = this.keyMap.get(e.id);
    i || (i = /* @__PURE__ */ new Map(), this.keyMap.set(e.id, i));
    let n = i.get(t);
    return n || (n = { groupId: e.id, editor: t }, i.set(t, n)), n;
  }
  async ensureOpenedEditorsLimit(e, t) {
    var n, r;
    if (!((n = this.editorGroupsService.partOptions.limit) != null && n.enabled) || typeof this.editorGroupsService.partOptions.limit.value != "number" || this.editorGroupsService.partOptions.limit.value <= 0)
      return;
    const i = this.editorGroupsService.partOptions.limit.value;
    if ((r = this.editorGroupsService.partOptions.limit) != null && r.perEditorGroup)
      if (typeof t == "number") {
        const s = this.editorGroupsService.getGroup(t);
        s && await this.doEnsureOpenedEditorsLimit(i, s.getEditors(0).map((a) => ({ editor: a, groupId: t })), e);
      } else
        for (const s of this.editorGroupsService.groups)
          await this.ensureOpenedEditorsLimit(e, s.id);
    else
      await this.doEnsureOpenedEditorsLimit(i, [...this.mostRecentEditorsMap.values()], e);
  }
  async doEnsureOpenedEditorsLimit(e, t, i) {
    var d;
    let n;
    if ((d = this.editorGroupsService.partOptions.limit) != null && d.excludeDirty ? n = t.filter(({ editor: u }) => !(u.isDirty() && !u.isSaving() || u.hasCapability(512))) : n = t, e >= n.length)
      return;
    const r = n.reverse().filter(({ editor: u, groupId: m }) => {
      var f;
      return !(u.isDirty() && !u.isSaving() || u.hasCapability(512) || i && u === i.editor && m === i.groupId || (f = this.editorGroupsService.getGroup(m)) != null && f.isSticky(u));
    });
    let s = n.length - e;
    const a = /* @__PURE__ */ new Map();
    for (const { groupId: u, editor: m } of r) {
      let f = a.get(u);
      if (f || (f = [], a.set(u, f)), f.push(m), s--, s === 0)
        break;
    }
    for (const [u, m] of a) {
      const f = this.editorGroupsService.getGroup(u);
      f && await f.closeEditors(m, { preserveFocus: !0 });
    }
  }
  saveState() {
    this.mostRecentEditorsMap.isEmpty() ? this.storageService.remove(se.STORAGE_KEY, 1) : this.storageService.store(se.STORAGE_KEY, JSON.stringify(this.serialize()), 1, 1);
  }
  serialize() {
    const e = V.as(st.EditorFactory), t = [...this.mostRecentEditorsMap.values()], i = /* @__PURE__ */ new Map();
    return {
      entries: pe(t.map(({ editor: n, groupId: r }) => {
        const s = this.editorGroupsService.getGroup(r);
        if (!s)
          return;
        let a = i.get(s);
        a || (a = s.getEditors(1).filter((u) => {
          const m = e.getEditorSerializer(u);
          return m == null ? void 0 : m.canSerialize(u);
        }), i.set(s, a));
        const d = a.indexOf(n);
        if (d !== -1)
          return { groupId: r, index: d };
      }))
    };
  }
  loadState() {
    const e = this.storageService.get(se.STORAGE_KEY, 1);
    if (e)
      this.deserialize(JSON.parse(e));
    else {
      const t = this.editorGroupsService.getGroups(1);
      for (let i = t.length - 1; i >= 0; i--) {
        const n = t[i], r = n.getEditors(0);
        for (let s = r.length - 1; s >= 0; s--)
          this.addMostRecentEditor(n, r[s], !0, !0);
      }
    }
    for (const t of this.editorGroupsService.groups)
      this.registerGroupListeners(t);
  }
  deserialize(e) {
    const t = [];
    for (const { groupId: i, index: n } of e.entries) {
      const r = this.editorGroupsService.getGroup(i);
      if (!r)
        continue;
      const s = r.getEditorByIndex(n);
      if (!s)
        continue;
      const a = this.ensureKey(r, s);
      t.push([a, a]), this.updateEditorResourcesMap(s, !0);
    }
    this.mostRecentEditorsMap.fromJSON(t);
  }
}, se.STORAGE_KEY = "editors.mru", se);
Gi = I([
  h(0, Ge),
  h(1, Pe)
], Gi);
let Oi = class extends K {
  constructor(e, t, i, n, r, s, a, d, u, m) {
    super(), this.editorGroupService = e, this.instantiationService = t, this.fileService = i, this.configurationService = n, this.contextService = r, this.uriIdentityService = s, this.editorResolverService = a, this.workspaceTrustRequestService = d, this.hostService = u, this.textEditorService = m, this._onDidActiveEditorChange = this._register(new R()), this.onDidActiveEditorChange = this._onDidActiveEditorChange.event, this._onDidVisibleEditorsChange = this._register(new R()), this.onDidVisibleEditorsChange = this._onDidVisibleEditorsChange.event, this._onDidEditorsChange = this._register(new R()), this.onDidEditorsChange = this._onDidEditorsChange.event, this._onDidCloseEditor = this._register(new R()), this.onDidCloseEditor = this._onDidCloseEditor.event, this._onDidOpenEditorFail = this._register(new R()), this.onDidOpenEditorFail = this._onDidOpenEditorFail.event, this._onDidMostRecentlyActiveEditorsChange = this._register(new R()), this.onDidMostRecentlyActiveEditorsChange = this._onDidMostRecentlyActiveEditorsChange.event, this.lastActiveEditor = void 0, this.activeOutOfWorkspaceWatchers = new Pn(), this.closeOnFileDelete = !1, this.editorsObserver = this._register(this.instantiationService.createInstance(Gi)), this.onConfigurationUpdated(), this.registerListeners();
  }
  registerListeners() {
    this.editorGroupService.whenReady.then(() => this.onEditorGroupsReady()), this.editorGroupService.onDidChangeActiveGroup((e) => this.handleActiveEditorChange(e)), this.editorGroupService.onDidAddGroup((e) => this.registerGroupListeners(e)), this.editorsObserver.onDidMostRecentlyActiveEditorsChange(() => this._onDidMostRecentlyActiveEditorsChange.fire()), this._register(this.onDidVisibleEditorsChange(() => this.handleVisibleEditorsChange())), this._register(this.fileService.onDidRunOperation((e) => this.onDidRunFileOperation(e))), this._register(this.fileService.onDidFilesChange((e) => this.onDidFilesChange(e))), this._register(this.configurationService.onDidChangeConfiguration((e) => this.onConfigurationUpdated(e)));
  }
  onEditorGroupsReady() {
    for (const e of this.editorGroupService.groups)
      this.registerGroupListeners(e);
    this.activeEditor && (this.doHandleActiveEditorChangeEvent(), this._onDidVisibleEditorsChange.fire());
  }
  handleActiveEditorChange(e) {
    e === this.editorGroupService.activeGroup && (!this.lastActiveEditor && !e.activeEditor || this.doHandleActiveEditorChangeEvent());
  }
  doHandleActiveEditorChangeEvent() {
    const e = this.editorGroupService.activeGroup;
    this.lastActiveEditor = ee(e.activeEditor), this._onDidActiveEditorChange.fire();
  }
  registerGroupListeners(e) {
    const t = new xe();
    t.add(e.onDidModelChange((i) => {
      this._onDidEditorsChange.fire({ groupId: e.id, event: i });
    })), t.add(e.onDidActiveEditorChange(() => {
      this.handleActiveEditorChange(e), this._onDidVisibleEditorsChange.fire();
    })), t.add(e.onDidCloseEditor((i) => {
      this._onDidCloseEditor.fire(i);
    })), t.add(e.onDidOpenEditorFail((i) => {
      this._onDidOpenEditorFail.fire({ editor: i, groupId: e.id });
    })), k.once(e.onWillDispose)(() => {
      He(t);
    });
  }
  handleVisibleEditorsChange() {
    const e = new Io();
    for (const t of this.visibleEditors) {
      const i = ld(pe([
        fe.getCanonicalUri(t, { supportSideBySide: X.PRIMARY }),
        fe.getCanonicalUri(t, { supportSideBySide: X.SECONDARY })
      ]), (n) => n.toString());
      for (const n of i)
        this.fileService.hasProvider(n) && !this.contextService.isInsideWorkspace(n) && e.add(n);
    }
    for (const t of this.activeOutOfWorkspaceWatchers.keys())
      e.has(t) || (He(this.activeOutOfWorkspaceWatchers.get(t)), this.activeOutOfWorkspaceWatchers.delete(t));
    for (const t of e.keys())
      if (!this.activeOutOfWorkspaceWatchers.get(t)) {
        const i = this.fileService.watch(t);
        this.activeOutOfWorkspaceWatchers.set(t, i);
      }
  }
  async onDidRunFileOperation(e) {
    e.isOperation(2) && this.handleMovedFile(e.resource, e.target.resource), (e.isOperation(1) || e.isOperation(2)) && this.handleDeletedFile(e.resource, !1, e.target ? e.target.resource : void 0);
  }
  onDidFilesChange(e) {
    e.gotDeleted() && this.handleDeletedFile(e, !0);
  }
  async handleMovedFile(e, t) {
    for (const i of this.editorGroupService.groups) {
      const n = [];
      for (const r of i.editors) {
        const s = r.resource;
        if (!s || !this.uriIdentityService.extUri.isEqualOrParent(s, e))
          continue;
        let a;
        if (this.uriIdentityService.extUri.isEqual(e, s))
          a = t;
        else {
          const m = ud(s.path, e.path, this.uriIdentityService.extUri.ignorePathCasing(s));
          a = hd(t, s.path.substr(m + e.path.length + 1));
        }
        const d = await r.rename(i.id, a);
        if (!d)
          return;
        const u = {
          preserveFocus: !0,
          pinned: i.isPinned(r),
          sticky: i.isSticky(r),
          index: i.getIndexOfEditor(r),
          inactive: !i.isActive(r)
        };
        oe(d.editor) ? n.push({
          editor: r,
          replacement: d.editor,
          options: {
            ...d.options,
            ...u
          }
        }) : n.push({
          editor: r,
          replacement: {
            ...d.editor,
            options: {
              ...d.editor.options,
              ...u
            }
          }
        });
      }
      n.length && this.replaceEditors(n, i);
    }
  }
  onConfigurationUpdated(e) {
    var i, n;
    if (e && !e.affectsConfiguration("workbench.editor.closeOnFileDelete"))
      return;
    const t = this.configurationService.getValue();
    typeof ((n = (i = t.workbench) == null ? void 0 : i.editor) == null ? void 0 : n.closeOnFileDelete) == "boolean" ? this.closeOnFileDelete = t.workbench.editor.closeOnFileDelete : this.closeOnFileDelete = !1;
  }
  handleDeletedFile(e, t, i) {
    for (const n of this.getAllNonDirtyEditors({ includeUntitled: !1, supportSideBySide: !0 }))
      (async () => {
        const r = n.resource;
        if (r && (this.closeOnFileDelete || !t)) {
          if (i && this.uriIdentityService.extUri.isEqualOrParent(r, i))
            return;
          let s = !1;
          if (e instanceof pd ? s = e.contains(r, 2) : s = this.uriIdentityService.extUri.isEqualOrParent(r, e), !s)
            return;
          let a = !1;
          t && this.fileService.hasProvider(r) && (await tn(100), a = await this.fileService.exists(r)), !a && !n.isDisposed() && n.dispose();
        }
      })();
  }
  getAllNonDirtyEditors(e) {
    const t = [];
    function i(n) {
      n.hasCapability(4) && !e.includeUntitled || n.isDirty() || t.push(n);
    }
    for (const n of this.editors)
      e.supportSideBySide && n instanceof nt ? (i(n.primary), i(n.secondary)) : i(n);
    return t;
  }
  get activeEditorPane() {
    var e;
    return (e = this.editorGroupService.activeGroup) == null ? void 0 : e.activeEditorPane;
  }
  get activeTextEditorControl() {
    const e = this.activeEditorPane;
    if (e) {
      const t = e.getControl();
      if (me(t) || ze(t))
        return t;
      if (li(t) && me(t.activeCodeEditor))
        return t.activeCodeEditor;
    }
  }
  get activeTextEditorLanguageId() {
    var i;
    let e;
    const t = this.activeTextEditorControl;
    return ze(t) ? e = t.getModifiedEditor() : e = t, (i = e == null ? void 0 : e.getModel()) == null ? void 0 : i.getLanguageId();
  }
  get count() {
    return this.editorsObserver.count;
  }
  get editors() {
    return this.getEditors(1).map(({ editor: e }) => e);
  }
  getEditors(e, t) {
    switch (e) {
      case 0:
        return t != null && t.excludeSticky ? this.editorsObserver.editors.filter(({ groupId: i, editor: n }) => {
          var r;
          return !((r = this.editorGroupService.getGroup(i)) != null && r.isSticky(n));
        }) : this.editorsObserver.editors;
      case 1: {
        const i = [];
        for (const n of this.editorGroupService.getGroups(2))
          i.push(...n.getEditors(1, t).map((r) => ({ editor: r, groupId: n.id })));
        return i;
      }
    }
  }
  get activeEditor() {
    const e = this.editorGroupService.activeGroup;
    return e ? ee(e.activeEditor) : void 0;
  }
  get visibleEditorPanes() {
    return pe(this.editorGroupService.groups.map((e) => e.activeEditorPane));
  }
  get visibleTextEditorControls() {
    const e = [];
    for (const t of this.visibleEditorPanes) {
      const i = t.getControl();
      (me(i) || ze(i)) && e.push(i);
    }
    return e;
  }
  get visibleEditors() {
    return pe(this.editorGroupService.groups.map((e) => e.activeEditor));
  }
  async openEditor(e, t, i) {
    let n, r = oe(e) ? t : e.options, s;
    if (On(t) && (i = t), !oe(e)) {
      const a = await this.editorResolverService.resolveEditor(e, i);
      if (a === 1)
        return;
      Zt(a) && (n = a.editor, r = a.options, s = a.group);
    }
    if (n || (n = oe(e) ? e : await this.textEditorService.resolveTextEditor(e)), !s) {
      let a;
      [s, a] = this.instantiationService.invokeFunction(Oo, { editor: n, options: r }, i), a && (r = { ...r, activation: a });
    }
    return s.openEditor(n, r);
  }
  async openEditors(e, t, i) {
    if (i != null && i.validateTrust && !await this.handleWorkspaceTrust(e))
      return [];
    const n = /* @__PURE__ */ new Map();
    for (const s of e) {
      let a, d;
      if (!wt(s)) {
        const m = await this.editorResolverService.resolveEditor(s, t);
        if (m === 1)
          continue;
        Zt(m) && (a = m, d = m.group);
      }
      a || (a = wt(s) ? s : { editor: await this.textEditorService.resolveTextEditor(s), options: s.options }), d || ([d] = this.instantiationService.invokeFunction(Oo, a, t));
      let u = n.get(d);
      u || (u = [], n.set(d, u)), u.push(a);
    }
    const r = [];
    for (const [s, a] of n)
      r.push(s.openEditors(a));
    return pe(await It.settled(r));
  }
  async handleWorkspaceTrust(e) {
    const { resources: t, diffMode: i, mergeMode: n } = this.extractEditorResources(e);
    switch (await this.workspaceTrustRequestService.requestOpenFilesTrust(t)) {
      case 1:
        return !0;
      case 2:
        return await this.hostService.openWindow(t.map((s) => ({ fileUri: s })), { forceNewWindow: !0, diffMode: i, mergeMode: n }), !1;
      case 3:
        return !1;
    }
  }
  extractEditorResources(e) {
    const t = new Io();
    let i = !1, n = !1;
    for (const r of e)
      if (wt(r)) {
        const s = fe.getOriginalUri(r.editor, { supportSideBySide: X.BOTH });
        G.isUri(s) ? t.add(s) : s && (s.primary && t.add(s.primary), s.secondary && t.add(s.secondary), i = r.editor instanceof Ji);
      } else
        gd(r) && (G.isUri(r.input1) && t.add(r.input1.resource), G.isUri(r.input2) && t.add(r.input2.resource), G.isUri(r.base) && t.add(r.base.resource), G.isUri(r.result) && t.add(r.result.resource), n = !0), md(r) ? (G.isUri(r.original.resource) && t.add(r.original.resource), G.isUri(r.modified.resource) && t.add(r.modified.resource), i = !0) : Bn(r) && t.add(r.resource);
    return {
      resources: Array.from(t.keys()),
      diffMode: i,
      mergeMode: n
    };
  }
  isOpened(e) {
    return this.editorsObserver.hasEditor({
      resource: this.uriIdentityService.asCanonicalUri(e.resource),
      typeId: e.typeId,
      editorId: e.editorId
    });
  }
  isVisible(e) {
    var t;
    for (const i of this.editorGroupService.groups)
      if ((t = i.activeEditor) != null && t.matches(e))
        return !0;
    return !1;
  }
  async closeEditor({ editor: e, groupId: t }, i) {
    const n = this.editorGroupService.getGroup(t);
    await (n == null ? void 0 : n.closeEditor(e, i));
  }
  async closeEditors(e, t) {
    const i = /* @__PURE__ */ new Map();
    for (const { editor: n, groupId: r } of e) {
      const s = this.editorGroupService.getGroup(r);
      if (!s)
        continue;
      let a = i.get(s);
      a || (a = [], i.set(s, a)), a.push(n);
    }
    for (const [n, r] of i)
      await n.closeEditors(r, t);
  }
  findEditors(e, t, i) {
    const n = G.isUri(e) ? e : e.resource, r = G.isUri(e) ? void 0 : e.typeId;
    if ((t == null ? void 0 : t.supportSideBySide) !== X.ANY && (t == null ? void 0 : t.supportSideBySide) !== X.SECONDARY && !this.editorsObserver.hasEditors(n))
      return G.isUri(e) || Mo(i) ? [] : void 0;
    if (Mo(i)) {
      const s = [];
      for (const a of this.editorGroupService.getGroups(1)) {
        const d = [];
        if (G.isUri(e))
          d.push(...this.findEditors(e, t, a));
        else {
          const u = this.findEditors(e, t, a);
          u && d.push(u);
        }
        s.push(...d.map((u) => ({ editor: u, groupId: a.id })));
      }
      return s;
    } else {
      const s = typeof i == "number" ? this.editorGroupService.getGroup(i) : i;
      if (G.isUri(e))
        return s ? s.findEditors(n, t) : [];
      {
        if (!s)
          return;
        const a = s.findEditors(n, t);
        for (const d of a)
          if (d.typeId === r)
            return d;
        return;
      }
    }
  }
  async replaceEditors(e, t) {
    const i = typeof t == "number" ? this.editorGroupService.getGroup(t) : t, n = [];
    for (const r of e) {
      let s;
      if (!oe(r.replacement)) {
        const a = await this.editorResolverService.resolveEditor(r.replacement, i);
        if (a === 1)
          continue;
        Zt(a) && (s = {
          editor: r.editor,
          replacement: a.editor,
          options: a.options,
          forceReplaceDirty: r.forceReplaceDirty
        });
      }
      s || (s = {
        editor: r.editor,
        replacement: Ao(r) ? r.replacement : await this.textEditorService.resolveTextEditor(r.replacement),
        options: Ao(r) ? r.options : r.replacement.options,
        forceReplaceDirty: r.forceReplaceDirty
      }), n.push(s);
    }
    return i == null ? void 0 : i.replaceEditors(n);
  }
  async save(e, t) {
    Array.isArray(e) || (e = [e]);
    const i = this.getUniqueEditors(e), n = [], r = [];
    if (t != null && t.saveAs)
      r.push(...i);
    else
      for (const { groupId: a, editor: d } of i)
        d.hasCapability(4) ? r.push({ groupId: a, editor: d }) : n.push({ groupId: a, editor: d });
    const s = await It.settled(n.map(({ groupId: a, editor: d }) => {
      var u;
      return (t == null ? void 0 : t.reason) === 1 && ((u = this.editorGroupService.getGroup(a)) == null || u.pinEditor(d)), d.save(a, t);
    }));
    for (const { groupId: a, editor: d } of r) {
      if (d.isDisposed())
        continue;
      const u = await this.openEditor(d, a), m = {
        pinned: !0,
        viewState: u == null ? void 0 : u.getViewState()
      }, f = t != null && t.saveAs ? await d.saveAs(a, t) : await d.save(a, t);
      if (s.push(f), !f)
        break;
      if (!d.matches(f)) {
        const S = d.hasCapability(4) ? this.editorGroupService.groups.map((b) => b.id) : [a];
        for (const b of S)
          f instanceof fd ? await this.replaceEditors([{ editor: d, replacement: f, options: m }], b) : await this.replaceEditors([{ editor: d, replacement: { ...f, options: m } }], b);
      }
    }
    return {
      success: s.every((a) => !!a),
      editors: pe(s)
    };
  }
  saveAll(e) {
    return this.save(this.getAllModifiedEditors(e), e);
  }
  async revert(e, t) {
    Array.isArray(e) || (e = [e]);
    const i = this.getUniqueEditors(e);
    return await It.settled(i.map(async ({ groupId: n, editor: r }) => {
      var s;
      return (s = this.editorGroupService.getGroup(n)) == null || s.pinEditor(r), r.revert(n, t);
    })), !i.some(({ editor: n }) => n.isDirty());
  }
  async revertAll(e) {
    return this.revert(this.getAllModifiedEditors(e), e);
  }
  getAllModifiedEditors(e) {
    var i;
    const t = [];
    for (const n of this.editorGroupService.getGroups(1))
      for (const r of n.getEditors(0))
        r.isModified() && ((typeof (e == null ? void 0 : e.includeUntitled) == "boolean" || !((i = e == null ? void 0 : e.includeUntitled) != null && i.includeScratchpad)) && r.hasCapability(512) || !(e != null && e.includeUntitled) && r.hasCapability(4) || e != null && e.excludeSticky && n.isSticky(r) || t.push({ groupId: n.id, editor: r }));
    return t;
  }
  getUniqueEditors(e) {
    const t = [];
    for (const { editor: i, groupId: n } of e)
      t.some((r) => r.editor.matches(i)) || t.push({ editor: i, groupId: n });
    return t;
  }
  dispose() {
    super.dispose(), this.activeOutOfWorkspaceWatchers.forEach((e) => He(e)), this.activeOutOfWorkspaceWatchers.clear();
  }
};
Oi = I([
  h(0, Ge),
  h(1, ce),
  h(2, it),
  h(3, T),
  h(4, Wi),
  h(5, _n),
  h(6, $i),
  h(7, Gn),
  h(8, Ki),
  h(9, ji)
], Oi);
class fc {
  constructor(e) {
    this.editor = e, this.onDidChangeControl = k.None, this.onDidChangeSizeConstraints = k.None, this.onDidFocus = k.None, this.onDidBlur = k.None, this.input = void 0, this.options = void 0, this.group = void 0, this.scopedContextKeyService = void 0, this.getViewState = w, this.isVisible = w, this.hasFocus = w, this.getId = w, this.getTitle = w, this.focus = w;
  }
  get minimumWidth() {
    return Do.width;
  }
  get maximumWidth() {
    return ko.width;
  }
  get minimumHeight() {
    return Do.height;
  }
  get maximumHeight() {
    return ko.height;
  }
  getControl() {
    return this.editor;
  }
}
function Ec(p, e, t) {
  async function i(n, r, s) {
    const a = oe(n) ? r : n.options;
    On(r) && (s = r);
    const d = Bn(n) || oe(n) ? n.resource : void 0;
    if (d == null || !p.canHandleResource(d))
      return e(n, r, s);
    let u;
    if (u = Xi.get(Zi).listCodeEditors().find((f) => f instanceof ui && f.getModel() != null && f.getModel().uri.toString() === d.toString()), u == null) {
      const f = await e(n, r, s);
      if (f != null)
        return f;
      const S = await p.createModelReference(d);
      if (u = await (t == null ? void 0 : t(S, a, s === Ut)), u == null) {
        S.dispose();
        return;
      }
    }
    return a != null && xn(a, u, 1), ((a == null ? void 0 : a.preserveFocus) ?? !1) || (u.focus(), u.getContainerDomNode().scrollIntoView()), new fc(u);
  }
  return i;
}
let Vo = class extends Oi {
  constructor(e, t, i, n, r, s, a, d, u, m, f, S, b) {
    super(i, n, r, s, a, d, u, m, f, S), this._isEditorPartVisible = t, this.openEditor = Ec(b, this.openEditor.bind(this), e);
  }
  get activeTextEditorControl() {
    const e = Xi.get(Zi).getFocusedCodeEditor();
    return e != null && e instanceof Ed ? e : super.activeTextEditorControl;
  }
  async openEditor(e, t, i) {
    if (this._isEditorPartVisible())
      return super.openEditor(e, t, i);
  }
};
Vo = I([
  h(2, Ge),
  h(3, ce),
  h(4, it),
  h(5, T),
  h(6, Wi),
  h(7, _n),
  h(8, $i),
  h(9, Gn),
  h(10, Ki),
  h(11, ji),
  h(12, vd)
], Vo);
class Uo {
  constructor(e, t, i) {
    this.editor = e, this.input = t, this.group = i, this.onDidChangeControl = k.None, this.options = void 0, this.minimumWidth = 0, this.maximumWidth = Number.POSITIVE_INFINITY, this.minimumHeight = 0, this.maximumHeight = Number.POSITIVE_INFINITY, this.onDidChangeSizeConstraints = k.None, this.scopedContextKeyService = void 0, this.onDidFocus = this.editor.onDidFocusEditorWidget, this.onDidBlur = this.editor.onDidBlurEditorWidget;
  }
  getControl() {
    return this.editor;
  }
  getViewState() {
  }
  isVisible() {
    return !0;
  }
  hasFocus() {
    return this.editor.hasWidgetFocus();
  }
  getId() {
    return this.editor.getId();
  }
  getTitle() {
  }
  focus() {
    this.editor.focus();
  }
}
let Rt = class jn extends K {
  constructor(e, t, i) {
    super(), this.editor = e, this.scopedContextKeyService = i, this.active = !1, this.onDidFocus = this.editor.onDidFocusEditorWidget, this.onDidOpenEditorFail = k.None, this.whenRestored = Promise.resolve(), this.disposed = !1, this.notifyIndexChanged = w, this.relayout = w, this.toJSON = w, this.minimumWidth = 0, this.maximumWidth = Number.POSITIVE_INFINITY, this.minimumHeight = 0, this.maximumHeight = Number.POSITIVE_INFINITY, this.onDidChange = this.editor.onDidLayoutChange, this.layout = () => this.editor.layout(), this._onDidModelChange = new R(), this.onDidModelChange = this._onDidModelChange.event, this.onWillDispose = this.editor.onDidDispose, this._onDidActiveEditorChange = new R(), this.onDidActiveEditorChange = this._onDidActiveEditorChange.event, this.onWillCloseEditor = k.None, this._onDidCloseEditor = new R(), this.onDidCloseEditor = this._onDidCloseEditor.event, this.onWillMoveEditor = k.None, this._onWillOpenEditor = new R(), this.onWillOpenEditor = this._onWillOpenEditor.event, this.id = --jn.idCounter, this.index = -1, this.label = `standalone editor ${this.editor.getId()}`, this.ariaLabel = `standalone editor ${this.editor.getId()}`, this.previewEditor = null, this.isLocked = !0, this.stickyCount = 0, this.getEditors = () => this.editors, this.findEditors = (a) => this.pane != null && a.toString() === this.pane.input.resource.toString() ? [this.pane.input] : [], this.getEditorByIndex = (a) => this.pane != null && a === 0 ? this.pane.input : void 0, this.getIndexOfEditor = (a) => this.pane != null && this.pane.input === a ? 0 : -1, this.openEditor = w, this.openEditors = w, this.isPinned = () => !1, this.isSticky = () => !1, this.isActive = () => this.editor.hasWidgetFocus(), this.contains = (a) => this.pane != null && this.pane.input === a, this.moveEditor = w, this.moveEditors = w, this.copyEditor = w, this.copyEditors = w, this.closeEditor = w, this.closeEditors = w, this.closeAllEditors = w, this.replaceEditors = w, this.pinEditor = w, this.stickEditor = w, this.unstickEditor = w, this.lock = w, this.isFirst = w, this.isLast = w;
    const n = (a) => {
      const d = t.createInstance(ci, a, void 0, void 0, void 0, void 0);
      this._onWillOpenEditor.fire({
        editor: d,
        groupId: this.id
      }), this.pane = new Uo(e, d, this), this._onDidModelChange.fire({
        kind: 3,
        editor: d,
        editorIndex: 0
      }), this._onDidActiveEditorChange.fire({
        editor: d
      });
    }, r = (a) => {
      if (this.pane != null && this.pane.input.resource.toString() === a.toString()) {
        const d = this.pane;
        this.pane = void 0, this._onDidModelChange.fire({
          kind: 4,
          editorIndex: 0
        }), this._onDidActiveEditorChange.fire({
          editor: void 0
        }), this._onDidCloseEditor.fire({
          context: bd.UNKNOWN,
          editor: d.input,
          groupId: this.id,
          index: 0,
          sticky: !1
        });
      }
    };
    e.onDidChangeModel((a) => {
      a.oldModelUrl != null && r(a.oldModelUrl), a.newModelUrl != null && n(a.newModelUrl);
    }), this._register({
      dispose: () => {
        const a = e.getModel();
        a != null && r(a.uri);
      }
    });
    const s = e.getModel();
    if (s != null) {
      const a = t.createInstance(ci, s.uri, void 0, void 0, void 0, void 0);
      this.pane = new Uo(e, a, this);
    }
  }
  get titleHeight() {
    return w();
  }
  setActive(e) {
    this.active = e;
  }
  get element() {
    return w();
  }
  get activeEditorPane() {
    return this.pane;
  }
  get activeEditor() {
    var e;
    return ((e = this.pane) == null ? void 0 : e.input) ?? null;
  }
  get count() {
    return this.pane != null ? 1 : 0;
  }
  get isEmpty() {
    return this.pane == null;
  }
  get editors() {
    return this.pane != null ? [this.pane.input] : [];
  }
  focus() {
    this.editor.focus();
  }
};
Rt.idCounter = 0;
Rt = I([
  h(1, ce),
  h(2, Vt)
], Rt);
let Wo = class extends K {
  constructor(e, t) {
    super(), this.delegate = e, this._serviceBrand = void 0, this.additionalGroups = [], this.activeGroupOverride = void 0, this._onDidChangeActiveGroup = new R(), this.onDidChangeActiveGroup = k.any(this._onDidChangeActiveGroup.event, this.delegate.onDidChangeActiveGroup), this._onDidAddGroup = new R(), this.onDidAddGroup = k.any(this._onDidAddGroup.event, this.delegate.onDidAddGroup), this._onDidRemoveGroup = new R(), this.onDidRemoveGroup = k.any(this._onDidRemoveGroup.event, this.delegate.onDidRemoveGroup), this.onDidMoveGroup = this.delegate.onDidMoveGroup, this.onDidActivateGroup = this.delegate.onDidActivateGroup, this.onDidLayout = this.delegate.onDidLayout, this.onDidScroll = this.delegate.onDidScroll, this.onDidChangeGroupIndex = this.delegate.onDidChangeGroupIndex, this.onDidChangeGroupLocked = this.delegate.onDidChangeGroupLocked, this.getLayout = () => this.delegate.getLayout(), this.getGroups = (i) => [...this.additionalGroups, ...this.delegate.getGroups(i)], this.getGroup = (i) => this.delegate.getGroup(i) ?? this.additionalGroups.find((n) => n.id === i), this.activateGroup = (...i) => this.delegate.activateGroup(...i), this.getSize = (...i) => this.delegate.getSize(...i), this.setSize = (...i) => this.delegate.setSize(...i), this.arrangeGroups = (...i) => this.delegate.arrangeGroups(...i), this.applyLayout = (...i) => this.delegate.applyLayout(...i), this.centerLayout = (...i) => this.delegate.centerLayout(...i), this.isLayoutCentered = (...i) => this.delegate.isLayoutCentered(...i), this.setGroupOrientation = (...i) => this.delegate.setGroupOrientation(...i), this.findGroup = (...i) => this.delegate.findGroup(...i), this.addGroup = (...i) => this.delegate.addGroup(...i), this.removeGroup = (...i) => this.delegate.removeGroup(...i), this.moveGroup = (...i) => this.delegate.moveGroup(...i), this.mergeGroup = (...i) => this.delegate.mergeGroup(...i), this.mergeAllGroups = (...i) => this.delegate.mergeAllGroups(...i), this.copyGroup = (...i) => this.delegate.copyGroup(...i), this.enforcePartOptions = (...i) => this.delegate.enforcePartOptions(...i), this.onDidChangeEditorPartOptions = this.delegate.onDidChangeEditorPartOptions, setTimeout(() => {
      const i = Xi.get(Zi), n = (s) => {
        if (s instanceof ui) {
          const a = () => {
            this.activeGroupOverride = this.additionalGroups.find((u) => u.editor === s), this._onDidChangeActiveGroup.fire(this.activeGroup);
          };
          s.onDidFocusEditorText(a), s.onDidFocusEditorWidget(a), s.hasWidgetFocus() && a();
          const d = t.createInstance(Rt, s);
          this.additionalGroups.push(d), this._onDidAddGroup.fire(d);
        }
      }, r = (s) => {
        if (s instanceof ui) {
          const a = this.additionalGroups.find((d) => d.editor === s);
          a != null && (a.dispose(), this.activeGroupOverride === a && (this.activeGroupOverride = void 0, this._onDidChangeActiveGroup.fire(this.activeGroup)), this.additionalGroups = this.additionalGroups.filter((d) => d !== a), this._onDidRemoveGroup.fire(a));
        }
      };
      this._register(i.onCodeEditorAdd(n)), this._register(i.onCodeEditorRemove(r)), i.listCodeEditors().forEach(n);
    });
  }
  get groups() {
    return [...this.additionalGroups, ...this.delegate.groups];
  }
  get activeGroup() {
    return this.activeGroupOverride ?? this.delegate.activeGroup;
  }
  get contentDimension() {
    return this.delegate.contentDimension;
  }
  get sideGroup() {
    return this.delegate.sideGroup;
  }
  get count() {
    return this.delegate.count + this.additionalGroups.length;
  }
  get orientation() {
    return this.delegate.orientation;
  }
  get isReady() {
    return this.delegate.isReady;
  }
  get whenReady() {
    return this.delegate.whenReady;
  }
  get whenRestored() {
    return this.delegate.whenRestored;
  }
  get hasRestorableState() {
    return this.delegate.hasRestorableState;
  }
  get partOptions() {
    return this.delegate.partOptions;
  }
};
Wo = I([
  h(1, ce)
], Wo);
export {
  eo as A,
  Mi as B,
  Sc as C,
  Go as E,
  Vo as M,
  pi as P,
  yd as T,
  _o as W,
  kt as a,
  wc as b,
  Ro as c,
  Lo as d,
  xo as e,
  Si as f,
  Ac as g,
  To as h,
  ke as i,
  Ee as j,
  Oo as k,
  ne as l,
  Ii as m,
  No as n,
  Wo as o
};

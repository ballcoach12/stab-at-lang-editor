import { n as oe, l as H, s as mp, C as bp, E as w, m as L, o as Re, p as Cp, q as fp, r as vp, u as rh, v as Qc, w as Z, $ as Y, x as hi, y as Qi, z as ui, B as u, F as ro, G as gi, H as ae, W as ah, J as Ac, P as Bc, K as Tc, d as le, L as _, N, O as wp, Q as en, V as Oe, X as yp, Y as kp, Z as pi, a0 as S, a1 as kt, a2 as I, a3 as zt, a4 as Ne, a5 as is, a6 as tn, a7 as ch, a8 as Sp, _ as y, a as l, a9 as We, aa as ee, ab as Ie, ac as Pe, ad as be, e as W, ae as z, af as Me, ag as F, ah as ei, ai as P, aj as ye, ak as Ce, al as Lc, am as Ip, an as Tt, ao as on, D as E, ap as Yo, aq as Jp, ar as nt, as as dh, U as A, at as Be, au as pe, av as ti, aw as Vp, ax as tt, ay as Hd, az as Lo, k as T, aA as Fc, aB as Pd, aC as An, t as M, aD as Md, aE as f, aF as Zp, aG as k, aH as K, aI as Xe, aJ as Eo, aK as ii, aL as x, aM as Lt, aN as lt, aO as Wp, aP as j, aQ as ao, aR as Qe, aS as we, aT as _p, aU as lh, aV as Ep, aW as Rp, aX as rt, aY as Gp, aZ as Xc, a_ as hh, a$ as xp, b0 as uh, b1 as co, b2 as Dp, b3 as U, b4 as yt, b5 as ks, b6 as Ut, b7 as Bn, b8 as Ro, b9 as Nt, ba as gh, bb as Np, bc as Ss, bd as Tn, be as Qp, bf as Ze, bg as zd, bh as Ud, bi as he, bj as ki, bk as Ap, bl as nr, bm as Bp, bn as Tp, bo as Zr, bp as ph, bq as Lp, br as mh, bs as Fp, bt as Xp, bu as Kp, bv as Ai, bw as Yp, bx as V, by as bh, bz as Te, bA as Kc, bB as Is, bC as at, bD as Ft, I as Ch, bE as fh, bF as Yc, bG as Et, bH as Hs, bI as Wr, bJ as rr, bK as Ae, bL as Op, bM as G, bN as Hp, bO as _r, bP as Oc, bQ as Pp, bR as ot, bS as xi, bT as Mp, bU as Hc, bV as Pc, bW as Bi, bX as Ho, bY as ri, bZ as sn, b_ as zp, b$ as jd, c0 as Up, c1 as jp, c2 as qp, c3 as lo, c4 as to, c5 as Mc, c6 as vh, c7 as wh, c8 as yh, c9 as os, ca as $p, cb as em, cc as tm, cd as im, ce as om, cf as sm, cg as nm, ch as rm, ci as am, cj as cm, ck as dm, cl as lm, cm as hm, cn as um, co as Ln, cp as gm, cq as Er, cr as pm, cs as mm, ct as qd, cu as bm, cv as Cm, cw as $d, cx as Ti, cy as fm, cz as _i, cA as vm, cB as kh, cC as Ps, cD as wm, cE as Sh, cF as Fn, cG as ym, cH as km, cI as Sm, cJ as Vi, cK as Le, cL as Ih, cM as $e, cN as Fo, g as _e, cO as Xn, cP as D, h as Li, cQ as Jh, cR as Kn, cS as Js, cT as mi, cU as Ht, cV as ve, cW as st, cX as ss, cY as Im, cZ as bi, c_ as Jm, c$ as Vm, d0 as Vh, d1 as Zm, d2 as el, d3 as Wm, d4 as Yn, d5 as Dt, d6 as _m, S as q, d7 as ho, d8 as Go, d9 as Zh, da as Em, db as Rm, dc as Rr, dd as jt, de as Di, df as Gm, dg as On, dh as zc, di as Vs, dj as uo, dk as Uc, dl as Wh, dm as xm, dn as Dm, dp as _h, dq as me, dr as ie, ds as Nm, dt as Gr, du as Qm, dv as Am, dw as Xt, dx as jc, dy as ce, dz as te, dA as B, dB as Bm, dC as Eh, dD as Zs, dE as Hn, dF as Pt, dG as ke, dH as Rh, dI as Gh, dJ as xh, dK as Dh, dL as Nh, dM as Tm, dN as Lm, dO as Qh, dP as xr, dQ as tl, dR as il, dS as li, dT as Ye, dU as Dr, dV as io, dW as Fm, dX as Xm, dY as Km, dZ as Ah, d_ as ar, d$ as cr, e0 as Qt, e1 as Ym, e2 as Om, e3 as Yi, e4 as Ke, e5 as Nr, e6 as Ve, e7 as Bh, e8 as Th, e9 as Qr, ea as Ar, eb as Hm, ec as dr, ed as Pm, ee as Mm, ef as qc, eg as Br, eh as zm, ei as Lh, ej as Um, ek as jm, el as qm, em as $m, en as Fh, eo as Xh, ep as Kh, eq as eb, er as tb, es as ib, et as ob, eu as sb, ev as nb, ew as rb, ex as Yh, ey as nn, ez as Rt, eA as Oh, eB as Hh, eC as Pn, eD as $c, eE as ab, eF as cb, eG as db, eH as lb, eI as hb, eJ as ub, eK as gb, eL as pb, eM as ed, eN as Ph, eO as Zi, eP as mb, eQ as ol, eR as sl, eS as bb, eT as Ci, eU as Mh, eV as nl, eW as ft, eX as go, eY as Cb, eZ as zh, e_ as xo, e$ as lr, f0 as Uh, f1 as jh, f2 as Tr, f3 as qh, f4 as rl, f5 as fb, f6 as vb, f7 as wb, f8 as Lr, f9 as yb, fa as kb, fb as Yt, fc as $h, fd as Sb, fe as Ws, ff as td, fg as eu, fh as Si, fi as Ib, fj as Jb, fk as Vb, fl as Zb, fm as Wb, fn as _b, fo as Eb, fp as Rb, fq as Gb, fr as xb, fs as Db, ft as Fr, fu as al, fv as Nb, fw as oo, fx as Qb, fy as Ab, fz as Bb, fA as Tb, fB as tu, fC as ht, fD as _s, fE as et, fF as ct, fG as id, fH as St, b as Do, fI as rn, fJ as Es, fK as iu, fL as od, fM as ou, fN as su, fO as Fi, fP as Rs, fQ as Gs, fR as nu, fS as Mn, fT as Lb, fU as Fb, fV as ru, fW as Po, fX as sd, fY as au, fZ as cu, f_ as Xb, f$ as nd, g0 as Kb, g1 as du, g2 as rd, g3 as lu, g4 as hu, g5 as Yb, g6 as Ob, g7 as zn, g8 as uu, g9 as Hb, ga as Mt, gb as gu, gc as Pb, gd as Mb, ge as zb, gf as ad, gg as pu, gh as Ub, gi as No, f as Qo, gj as cd, gk as jb, gl as dd, gm as mu, gn as bu, go as qb, gp as $b, gq as eC, gr as Cu, gs as cl, gt as an, gu as ld, gv as fu, gw as It, gx as He, gy as tC, gz as Un, gA as iC, gB as vu, gC as oC, gD as sC, gE as nC, gF as rC, gG as aC, gH as wu, gI as cC, gJ as hd, gK as yu, gL as ku, gM as Su, gN as Iu, gO as dC, gP as ud, gQ as xs, gR as Ju, gS as gd, gT as lC, gU as Xi, gV as hC, gW as uC, gX as gC, gY as pC, gZ as mC, g_ as bC, g$ as CC, h0 as fC, h1 as vC, h2 as wC, h3 as yC, h4 as kC, h5 as SC, h6 as IC, h7 as Vu, h8 as Zu, h9 as JC, ha as VC, hb as ZC, hc as pd, hd as md, he as Wu, hf as Ni, hg as _u, hh as Fe, hi as Eu, hj as Ru, hk as Gu, hl as xu, hm as Du, hn as Nu, ho as Oi, hp as Qu, hq as Au, hr as Bu, hs as Tu, ht as hr, hu as Lu, hv as Kt, hw as cn, hx as Fu, hy as ur, hz as bd, hA as vt, hB as WC, hC as Xr, hD as _C, hE as EC, hF as wt, hG as RC, hH as GC, hI as Xu, hJ as xC, hK as DC, hL as NC, hM as dt, hN as Kr, hO as Fs, hP as QC, hQ as Yr, hR as dl, hS as AC, hT as jn, hU as BC, hV as Ct, hW as TC, hX as LC, hY as Cd, hZ as fd, h_ as FC, h$ as XC, i0 as fi, i1 as vi, i2 as ut, i3 as Ds, i4 as Ns, i5 as Qs, i6 as Ku, i7 as KC, i8 as YC, i9 as OC, ia as HC, ib as Yu, ic as vd, id as Ou, ie as PC, ig as MC, ih as zC, ii as UC, ij as jC, ik as Hu, il as Pu, im as wd, io as qC, ip as Hi, iq as Or, ir as ll, is as Gt, it as Mu, iu as $C, iv as ef, iw as tf, ix as of, iy as Hr, iz as sf, iA as nf, iB as Mo, iC as hl, iD as rf, iE as Xs, iF as Ks, iG as gr, iH as pr, iI as af, iJ as cf, iK as ul, iL as df, iM as gl, iN as lf, iO as As, iP as zu, iQ as hf, iR as uf, iS as Uu, iT as gf, iU as yd, iV as pl, iW as pf, iX as ju, iY as ml, iZ as bl, i_ as ns, i$ as qu, j0 as qe, j1 as kd, j2 as mf, j3 as $u, j4 as bf, j5 as Bs, j6 as rs, j7 as eg, j8 as tg, j9 as Sd, ja as Cf, jb as Id, jc as Pr, jd as Ms, je as Cl, jf as ff, jg as vf, jh as wf, ji as oi, jj as yf, jk as kf, jl as Sf, jm as If, jn as ig, jo as og, jp as Jf, jq as Vf, jr as sg, js as Jd, jt as Zf, ju as Wf, jv as _f, jw as Ef, jx as ng, jy as rg, jz as fl, jA as Rf, jB as Ys, jC as Gf, jD as xf, jE as vl, jF as Df, jG as Nf, jH as ag, jI as Qf, jJ as cg, c as qn, jK as dg, jL as Af, jM as zo, jN as Bf, jO as wl, jP as mr, jQ as yl, jR as br, jS as kl, jT as Tf, jU as xe, jV as ai, jW as Lf, jX as Ff, jY as Xf, jZ as Ao, j_ as zs, j$ as Kf, k0 as Yf, k1 as Sl, k2 as Il, k3 as Of, k4 as Hf, k5 as Pf, k6 as Mf, k7 as zf, k8 as Uf, k9 as jf, ka as qf, kb as $f, kc as ev, kd as tv, ke as iv, kf as ov, kg as sv, kh as nv, ki as rv, kj as Mr, kk as Uo, kl as De, km as av, kn as cv, ko as Jl, kp as Vl, kq as lg, kr as dv, ks as lv, kt as Zl, ku as hv, kv as uv, kw as Cr, kx as gv, ky as pv, kz as mv, kA as bv, kB as Cv, kC as Wl, kD as _l, kE as fv, kF as vv, kG as wv, kH as yv, kI as kv, kJ as fr, kK as Sv, kL as Iv, kM as Jv, kN as Vv, kO as Zv, kP as Wv, kQ as El, kR as _v, kS as Ev, kT as Rv, kU as Gv, kV as xv, kW as vr, kX as Dv, kY as Nv, kZ as Qv, k_ as Av, k$ as Vd, l0 as Bv, l1 as $n, l2 as Tv, l3 as as, l4 as Rl, M as Lv, l5 as Fv, l6 as hg, l7 as Xv, l8 as dn, l9 as zr, la as Kv, lb as Yv, lc as Ov, ld as Hv, le as po, lf as Pv, lg as Mv, lh as Os, li as zv, lj as Uv, lk as jv, ll as qv, lm as $v, ln as ew, lo as tw, lp as iw, lq as ow, lr as sw, ls as nw, lt as rw, lu as aw, lv as cw, lw as dw, lx as lw } from "./index-7e82f14c.js";
import { lA as hJ, lz as uJ, ly as gJ } from "./index-7e82f14c.js";
import { E as cs, V as hw } from "./viewsService-09f61db8.js";
import { A as Us, a as uw, T as Zd, b as Wd, C as Gl, c as gw, d as pw, e as jo, f as xl, P as Dl, g as Nl, h as mw, i as Ql, j as Al, E as bw, W as Cw, k as ug, B as gg, l as fw, m as Bl, n as vw, M as ww, o as yw } from "./editor-189fe1f4.js";
import { g as qo, a as kw } from "./window-d3fbdde0.js";
import "./workbench.contribution-818d3057.js";
import { S as Sw } from "./simpleIconLabel-cbc6bc36.js";
import { D as Iw } from "./style-dc6a4e5c.js";
var Jw = ".monaco-workbench.nosidebar>.part.sidebar{display:none!important;visibility:hidden!important}.monaco-workbench .part.sidebar .title-actions .actions-container{justify-content:flex-end}.monaco-workbench .part.sidebar .title-actions .action-item{margin-right:4px}.monaco-workbench .part.sidebar>.title>.title-label h2{text-transform:uppercase}.monaco-workbench .viewlet .collapsible.header .title{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.monaco-workbench .viewlet .collapsible.header .actions{width:0}.monaco-workbench .viewlet .collapsible.header.focused .actions,.monaco-workbench .viewlet .split-view-view:hover>.header .actions{flex:1;width:auto}.monaco-workbench .viewlet .collapsible.header .actions .action-label{background-position:50%;background-repeat:no-repeat;background-size:16px;height:22px;margin-right:0;width:28px}.monaco-workbench .viewlet .collapsible.header .actions .action-label .label,.monaco-workbench .viewlet .collapsible.header.collapsed .actions{display:none}.monaco-workbench .viewlet .collapsible.header .action-label{background-repeat:no-repeat;height:16px;margin-right:.2em;width:16px}";
oe(Jw, {});
var Vw = ".monaco-workbench .part>.content>.composite{height:100%}.monaco-workbench .part>.composite.title{display:flex}.monaco-workbench .part>.composite.title>.title-actions{flex:1;padding-left:5px}";
oe(Vw, {});
var Zw = `.monaco-workbench .part{box-sizing:border-box;overflow:hidden}.monaco-workbench .part>.drop-block-overlay.visible{visibility:visible}.monaco-workbench .part>.drop-block-overlay{height:100%;opacity:0;position:absolute;top:0;visibility:hidden;width:100%;z-index:12}.monaco-workbench .part>.title{box-sizing:border-box;display:none;display:flex;height:35px;overflow:hidden;padding-left:8px;padding-right:8px}.monaco-workbench .part>.title>.title-label{line-height:35px;overflow:hidden;padding-left:12px;text-overflow:ellipsis;white-space:nowrap}.monaco-workbench .part>.title>.title-label h2{cursor:default;font-size:11px;font-weight:400;margin:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.monaco-workbench .part>.title>.title-label a{cursor:default;font-size:13px;text-decoration:none}.monaco-workbench .part>.title>.title-actions{flex:1;height:35px;padding-left:5px}.monaco-workbench .part>.title>.title-actions .action-label{background-position:50%;background-repeat:no-repeat;background-size:16px;display:block}.monaco-workbench .part>.title>.title-actions .action-label .label{display:none}.monaco-workbench .part>.title>.title-actions .action-label.codicon{color:inherit}.monaco-workbench .part>.content{font-size:13px}.monaco-workbench .part.editor>.content .monaco-progress-container,.monaco-workbench .part>.content>.monaco-progress-container{height:2px;left:0;position:absolute;top:33px;z-index:5}.monaco-workbench
	.part.editor>.content
	.monaco-progress-container
	.progress-bit,.monaco-workbench .part>.content>.monaco-progress-container .progress-bit{height:2px}`;
oe(Zw, {});
class er extends bp {
  get dimension() {
    return this._dimension;
  }
  constructor(e, t, i, o, s) {
    super(e, i, o), this.options = t, this.layoutService = s, this._onDidVisibilityChange = this._register(new w()), this.onDidVisibilityChange = this._onDidVisibilityChange.event, this._onDidChange = this._register(new w()), s.registerPart(this);
  }
  onThemeChange(e) {
    this.parent && super.onThemeChange(e);
  }
  updateStyles() {
    super.updateStyles();
  }
  create(e, t) {
    this.parent = e, this.titleArea = this.createTitleArea(e, t), this.contentArea = this.createContentArea(e, t), this.partLayout = new Ur(this.options, this.contentArea), this.updateStyles();
  }
  getContainer() {
    return this.parent;
  }
  createTitleArea(e, t) {
  }
  getTitleArea() {
    return this.titleArea;
  }
  createContentArea(e, t) {
  }
  getContentArea() {
    return this.contentArea;
  }
  layoutContents(e, t) {
    return L(this.partLayout).layout(e, t);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  layout(e, t, i, o) {
    this._dimension = new H(e, t);
  }
  setVisible(e) {
    this._onDidVisibilityChange.fire(e);
  }
}
const _n = class _n {
  constructor(e, t) {
    this.options = e, this.contentArea = t;
  }
  layout(e, t) {
    let i;
    this.options.hasTitle ? i = new H(e, Math.min(t, _n.TITLE_HEIGHT)) : i = H.None;
    let o = e;
    this.options && typeof this.options.borderWidth == "function" && (o -= this.options.borderWidth());
    const s = new H(o, t - i.height);
    return this.contentArea && mp(this.contentArea, s.width, s.height), { titleSize: i, contentSize: s };
  }
};
_n.TITLE_HEIGHT = 35;
let Ur = _n;
class pg extends er {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m, C, b) {
    super(C, b, r, t, o), this.notificationService = e, this.storageService = t, this.contextMenuService = i, this.keybindingService = s, this.instantiationService = n, this.registry = a, this.activeCompositeSettingsKey = d, this.defaultCompositeId = h, this.nameForTelemetry = g, this.compositeCSSClass = p, this.titleForegroundColor = m, this.onDidCompositeOpen = this._register(new w()), this.onDidCompositeClose = this._register(new w()), this.mapCompositeToCompositeContainer = /* @__PURE__ */ new Map(), this.mapActionsBindingToComposite = /* @__PURE__ */ new Map(), this.instantiatedCompositeItems = /* @__PURE__ */ new Map(), this.actionsListener = this._register(new Re()), this.lastActiveCompositeId = t.get(d, 1, this.defaultCompositeId);
  }
  openComposite(e, t) {
    var i;
    if (((i = this.activeComposite) == null ? void 0 : i.getId()) === e)
      return t && this.activeComposite.focus(), this.activeComposite;
    if (this.element)
      return this.doOpenComposite(e, t);
  }
  doOpenComposite(e, t = !1) {
    var s;
    const i = Cp.nextId();
    this.currentCompositeOpenToken = i, this.activeComposite && this.hideActiveComposite(), this.updateTitle(e);
    const o = this.createComposite(e, !0);
    if (!(this.currentCompositeOpenToken !== i || this.activeComposite && this.activeComposite.getId() !== o.getId()))
      return ((s = this.activeComposite) == null ? void 0 : s.getId()) === o.getId() ? (t && o.focus(), this.onDidCompositeOpen.fire({ composite: o, focus: t }), o) : (this.showComposite(o), t && o.focus(), o && this.onDidCompositeOpen.fire({ composite: o, focus: t }), o);
  }
  createComposite(e, t) {
    const i = this.instantiatedCompositeItems.get(e);
    if (i)
      return i.composite;
    const o = this.registry.getComposite(e);
    if (o) {
      const s = this, n = new fp(
        L(this.progressBar),
        new class extends vp {
          constructor() {
            super(o.id, !!t), this._register(s.onDidCompositeOpen.event((h) => this.onScopeOpened(h.composite.getId()))), this._register(s.onDidCompositeClose.event((h) => this.onScopeClosed(h.getId())));
          }
        }()
      ), r = this.instantiationService.createChild(new rh(
        [Qc, n]
      )), a = o.instantiate(r), d = new Z();
      return this.instantiatedCompositeItems.set(e, { composite: a, disposable: d, progress: n }), d.add(a.onTitleAreaUpdate(() => this.onTitleAreaUpdate(a.getId()), this)), a;
    }
    throw new Error(`Unable to find composite with id ${e}`);
  }
  showComposite(e) {
    this.activeComposite = e;
    const t = this.activeComposite.getId();
    t !== this.defaultCompositeId ? this.storageService.store(this.activeCompositeSettingsKey, t, 1, 1) : this.storageService.remove(this.activeCompositeSettingsKey, 1), this.lastActiveCompositeId = this.activeComposite.getId();
    let i = this.mapCompositeToCompositeContainer.get(e.getId());
    if (i || (i = Y(".composite"), i.classList.add(...this.compositeCSSClass.split(" ")), i.id = e.getId(), e.create(i), e.updateStyles(), this.mapCompositeToCompositeContainer.set(e.getId(), i)), !this.activeComposite || e.getId() !== this.activeComposite.getId())
      return;
    const o = this.getContentArea();
    o == null || o.appendChild(i), hi(i);
    const s = L(this.toolBar);
    s.actionRunner = e.getActionRunner();
    const n = this.registry.getComposite(e.getId());
    n && n.name !== e.getTitle() && this.updateTitle(e.getId(), e.getTitle());
    let r = this.mapActionsBindingToComposite.get(e.getId());
    r || (r = this.collectCompositeActions(e), this.mapActionsBindingToComposite.set(e.getId(), r)), r(), this.actionsListener.value = s.actionRunner.onDidRun((a) => {
      a.error && !Qi(a.error) && this.notificationService.error(a.error);
    }), e.setVisible(!0), !(!this.activeComposite || e.getId() !== this.activeComposite.getId()) && (this.contentAreaSize && e.layout(this.contentAreaSize), this.boundarySashes && e.setBoundarySashes(this.boundarySashes));
  }
  onTitleAreaUpdate(e) {
    var i;
    const t = this.instantiatedCompositeItems.get(e);
    if (t && this.updateTitle(e, t.composite.getTitle()), ((i = this.activeComposite) == null ? void 0 : i.getId()) === e) {
      const o = this.collectCompositeActions(this.activeComposite);
      this.mapActionsBindingToComposite.set(this.activeComposite.getId(), o), o();
    } else
      this.mapActionsBindingToComposite.delete(e);
  }
  updateTitle(e, t) {
    const i = this.registry.getComposite(e);
    if (!i || !this.titleLabel)
      return;
    t || (t = i.name);
    const o = this.keybindingService.lookupKeybinding(e);
    this.titleLabel.updateTitle(e, t, ui(o == null ? void 0 : o.getLabel())), L(this.toolBar).setAriaLabel(u("ariaCompositeToolbarLabel", "{0} actions", t));
  }
  collectCompositeActions(e) {
    const t = e == null ? void 0 : e.getMenuIds(), i = (e == null ? void 0 : e.getActions().slice(0)) || [], o = (e == null ? void 0 : e.getSecondaryActions().slice(0)) || [], s = L(this.toolBar);
    return s.context = this.actionsContextProvider(), () => s.setActions(ro(i), ro(o), t);
  }
  getActiveComposite() {
    return this.activeComposite;
  }
  getLastActiveCompositeId() {
    return this.lastActiveCompositeId;
  }
  hideActiveComposite() {
    var i;
    if (!this.activeComposite)
      return;
    const e = this.activeComposite;
    this.activeComposite = void 0;
    const t = this.mapCompositeToCompositeContainer.get(e.getId());
    return e.setVisible(!1), t && (t.remove(), gi(t)), (i = this.progressBar) == null || i.stop().hide(), this.toolBar && this.collectCompositeActions()(), this.onDidCompositeClose.fire(e), e;
  }
  createTitleArea(e) {
    const t = ae(e, Y(".composite"));
    t.classList.add("title"), this.titleLabel = this.createTitleLabel(t);
    const i = ae(t, Y(".title-actions"));
    return this.toolBar = this._register(this.instantiationService.createInstance(ah, i, {
      actionViewItemProvider: (o) => this.actionViewItemProvider(o),
      orientation: 0,
      getKeyBinding: (o) => this.keybindingService.lookupKeybinding(o.id),
      anchorAlignmentProvider: () => this.getTitleAreaDropDownAnchorAlignment(),
      toggleMenuTitle: u("viewsAndMoreActions", "Views and More Actions..."),
      telemetrySource: this.nameForTelemetry
    })), this.collectCompositeActions()(), t;
  }
  createTitleLabel(e) {
    const t = ae(e, Y(".title-label")), i = ae(t, Y("h2"));
    this.titleLabelElement = i;
    const o = this;
    return {
      updateTitle: (s, n, r) => {
        (!this.activeComposite || this.activeComposite.getId() === s) && (i.innerText = n, i.title = r ? u("titleTooltip", "{0} ({1})", n, r) : n);
      },
      updateStyles: () => {
        i.style.color = o.titleForegroundColor && o.getColor(o.titleForegroundColor) || "";
      }
    };
  }
  updateStyles() {
    super.updateStyles(), L(this.titleLabel).updateStyles();
  }
  actionViewItemProvider(e) {
    return this.activeComposite ? this.activeComposite.getActionViewItem(e) : Ac(this.instantiationService, e);
  }
  actionsContextProvider() {
    return this.activeComposite ? this.activeComposite.getActionsContext() : null;
  }
  createContentArea(e) {
    const t = ae(e, Y(".content"));
    return this.progressBar = this._register(new Bc(t, Tc)), this.progressBar.hide(), t;
  }
  getProgressIndicator(e) {
    const t = this.instantiatedCompositeItems.get(e);
    return t ? t.progress : void 0;
  }
  getTitleAreaDropDownAnchorAlignment() {
    return 1;
  }
  layout(e, t, i, o) {
    var s;
    super.layout(e, t, i, o), this.contentAreaSize = H.lift(super.layoutContents(e, t).contentSize), (s = this.activeComposite) == null || s.layout(this.contentAreaSize);
  }
  setBoundarySashes(e) {
    var t;
    this.boundarySashes = e, (t = this.activeComposite) == null || t.setBoundarySashes(e);
  }
  removeComposite(e) {
    var i;
    if (((i = this.activeComposite) == null ? void 0 : i.getId()) === e)
      return !1;
    this.mapCompositeToCompositeContainer.delete(e), this.mapActionsBindingToComposite.delete(e);
    const t = this.instantiatedCompositeItems.get(e);
    return t && (t.composite.dispose(), le(t.disposable), this.instantiatedCompositeItems.delete(e)), !0;
  }
  dispose() {
    this.mapCompositeToCompositeContainer.clear(), this.mapActionsBindingToComposite.clear(), this.instantiatedCompositeItems.forEach((e) => {
      e.composite.dispose(), le(e.disposable);
    }), this.instantiatedCompositeItems.clear(), super.dispose();
  }
}
var Co;
let jr = (Co = class extends pg {
  get preferredWidth() {
    const e = this.getActivePaneComposite();
    if (!e)
      return;
    const t = e.getOptimalWidth();
    if (typeof t == "number")
      return Math.max(t, 300);
  }
  get onDidPaneCompositeRegister() {
    return this.viewletRegistry.onDidRegister;
  }
  get onDidPaneCompositeOpen() {
    return _.map(this.onDidCompositeOpen.event, (e) => e.composite);
  }
  get onDidPaneCompositeClose() {
    return this.onDidCompositeClose.event;
  }
  constructor(e, t, i, o, s, n, r, a, d, h) {
    super(e, t, i, o, s, n, r, N.as(cs.Viewlets), Co.activeViewletSettingsKey, a.getDefaultViewContainer(0).id, "sideBar", "viewlet", wp, "workbench.parts.sidebar", { hasTitle: !0, borderWidth: () => this.getColor(en) || this.getColor(Oe) ? 1 : 0 }), this.viewDescriptorService = a, this.contextKeyService = d, this.extensionService = h, this.minimumWidth = 170, this.maximumWidth = Number.POSITIVE_INFINITY, this.minimumHeight = 0, this.maximumHeight = Number.POSITIVE_INFINITY, this.priority = 1, this.snap = !0, this._onDidViewletDeregister = this._register(new w()), this.onDidPaneCompositeDeregister = this._onDidViewletDeregister.event, this.viewletRegistry = N.as(cs.Viewlets), this.sideBarFocusContextKey = yp.bindTo(this.contextKeyService), this.activeViewletContextKey = kp.bindTo(this.contextKeyService), this.blockOpeningViewlet = !1, this.registerListeners();
  }
  registerListeners() {
    this._register(this.onDidPaneCompositeOpen((e) => {
      this.activeViewletContextKey.set(e.getId());
    })), this._register(this.onDidPaneCompositeClose((e) => {
      this.activeViewletContextKey.get() === e.getId() && this.activeViewletContextKey.reset();
    })), this._register(this.registry.onDidDeregister(async (e) => {
      var i, o;
      const t = this.viewDescriptorService.getViewContainersByLocation(0).filter((s) => this.viewDescriptorService.getViewContainerModel(s).activeViewDescriptors.length > 0);
      if (t.length) {
        if (((i = this.getActiveComposite()) == null ? void 0 : i.getId()) === e.id) {
          const s = (o = this.viewDescriptorService.getDefaultViewContainer(0)) == null ? void 0 : o.id, n = t.filter((r) => r.id === s)[0] || t[0];
          await this.openPaneComposite(n.id);
        }
      } else
        this.layoutService.setPartHidden(!0, "workbench.parts.sidebar");
      this.removeComposite(e.id), this._onDidViewletDeregister.fire(e);
    }));
  }
  create(e) {
    this.element = e, super.create(e);
    const t = this._register(pi(e));
    this._register(t.onDidFocus(() => this.sideBarFocusContextKey.set(!0))), this._register(t.onDidBlur(() => this.sideBarFocusContextKey.set(!1)));
  }
  createTitleArea(e) {
    const t = super.createTitleArea(e);
    this._register(S(t, I.CONTEXT_MENU, (o) => {
      this.onTitleAreaContextMenu(new kt(o));
    })), this._register(zt.addTarget(t)), this._register(S(t, Ne.Contextmenu, (o) => {
      this.onTitleAreaContextMenu(new kt(o));
    })), this.titleLabelElement.draggable = !0;
    const i = () => ({ type: "composite", id: this.getActivePaneComposite().getId() });
    return this._register(is.INSTANCE.registerDraggable(this.titleLabelElement, i, {})), t;
  }
  updateStyles() {
    super.updateStyles();
    const e = L(this.getContainer());
    e.style.backgroundColor = this.getColor(tn) || "", e.style.color = this.getColor(ch) || "";
    const t = this.getColor(en) || this.getColor(Oe), i = this.layoutService.getSideBarPosition() === 0;
    e.style.borderRightWidth = t && i ? "1px" : "", e.style.borderRightStyle = t && i ? "solid" : "", e.style.borderRightColor = i && t || "", e.style.borderLeftWidth = t && !i ? "1px" : "", e.style.borderLeftStyle = t && !i ? "solid" : "", e.style.borderLeftColor = i ? "" : t || "", e.style.outlineColor = this.getColor(Sp) ?? "";
  }
  layout(e, t, i, o) {
    this.layoutService.isVisible("workbench.parts.sidebar") && super.layout(e, t, i, o);
  }
  getActivePaneComposite() {
    return this.getActiveComposite();
  }
  getLastActivePaneCompositeId() {
    return this.getLastActiveCompositeId();
  }
  hideActivePaneComposite() {
    this.hideActiveComposite();
  }
  async openPaneComposite(e, t) {
    if (typeof e == "string" && this.getPaneComposite(e))
      return this.doOpenViewlet(e, t);
    if (await this.extensionService.whenInstalledExtensionsRegistered(), typeof e == "string" && this.getPaneComposite(e))
      return this.doOpenViewlet(e, t);
  }
  getPaneComposites() {
    return this.viewletRegistry.getPaneComposites().sort((e, t) => typeof e.order != "number" ? -1 : typeof t.order != "number" ? 1 : e.order - t.order);
  }
  getPaneComposite(e) {
    return this.getPaneComposites().filter((t) => t.id === e)[0];
  }
  doOpenViewlet(e, t) {
    if (!this.blockOpeningViewlet) {
      if (!this.layoutService.isVisible("workbench.parts.sidebar"))
        try {
          this.blockOpeningViewlet = !0, this.layoutService.setPartHidden(!1, "workbench.parts.sidebar");
        } finally {
          this.blockOpeningViewlet = !1;
        }
      return this.openComposite(e, t);
    }
  }
  getTitleAreaDropDownAnchorAlignment() {
    return this.layoutService.getSideBarPosition() === 0 ? 0 : 1;
  }
  onTitleAreaContextMenu(e) {
    const t = this.getActivePaneComposite();
    if (t) {
      const i = t ? t.getContextMenuActions() : [];
      i.length && this.contextMenuService.showContextMenu({
        getAnchor: () => e,
        getActions: () => i.slice(),
        getActionViewItem: (o) => this.actionViewItemProvider(o),
        actionRunner: t.getActionRunner(),
        skipTelemetry: !0
      });
    }
  }
  toJSON() {
    return {
      type: "workbench.parts.sidebar"
    };
  }
}, Co.activeViewletSettingsKey = "workbench.sidebar.activeviewletid", Co);
jr = y([
  l(0, We),
  l(1, ee),
  l(2, Ie),
  l(3, Pe),
  l(4, be),
  l(5, W),
  l(6, z),
  l(7, Me),
  l(8, F),
  l(9, ei)
], jr);
const _d = "viewsLog", mg = u("views log", "Views");
function Ed(c) {
  return on(c.windowLogsPath, "views.log");
}
P(class extends ye {
  constructor() {
    super({
      id: "_workbench.output.showViewsLog",
      title: { value: "Show Views Log", original: "Show Views Log" },
      category: Ce.Developer,
      f1: !0
    });
  }
  async run(c) {
    const e = c.get(Lc), t = c.get(Ip), i = c.get(Tt);
    e.setVisibility(Ed(i), !0), t.showChannel(_d);
  }
});
function bg(c) {
  return `${c}.hidden`;
}
let qr = class extends E {
  constructor(e, t, i, o, s) {
    super(), this.viewContainerName = t, this.storageService = i, this._onDidChangeStoredState = this._register(new w()), this.onDidChangeStoredState = this._onDidChangeStoredState.event, this.logger = o.createLogger(Ed(s), { id: _d, name: mg, hidden: !0 }), this.globalViewsStateStorageId = bg(e), this.workspaceViewsStateStorageId = e, this._register(this.storageService.onDidChangeValue((n) => this.onDidStorageChange(n))), this.state = this.initialize();
  }
  set(e, t) {
    this.state.set(e, t);
  }
  get(e) {
    return this.state.get(e);
  }
  updateState(e) {
    this.updateWorkspaceState(e), this.updateGlobalState(e);
  }
  updateWorkspaceState(e) {
    const t = this.getStoredWorkspaceState();
    for (const i of e) {
      const o = this.get(i.id);
      o && (t[i.id] = {
        collapsed: !!o.collapsed,
        isHidden: !o.visibleWorkspace,
        size: o.size,
        order: i.workspace && o ? o.order : void 0
      });
    }
    Object.keys(t).length > 0 ? this.storageService.store(this.workspaceViewsStateStorageId, JSON.stringify(t), 1, 1) : this.storageService.remove(this.workspaceViewsStateStorageId, 1);
  }
  updateGlobalState(e) {
    const t = this.getStoredGlobalState();
    for (const i of e) {
      const o = this.get(i.id);
      t.set(i.id, {
        id: i.id,
        isHidden: o && i.canToggleVisibility ? !o.visibleGlobal : !1,
        order: !i.workspace && o ? o.order : void 0
      });
    }
    this.setStoredGlobalState(t);
  }
  onDidStorageChange(e) {
    if (e.key === this.globalViewsStateStorageId && e.scope === 0 && this.globalViewsStatesValue !== this.getStoredGlobalViewsStatesValue()) {
      this._globalViewsStatesValue = void 0;
      const t = this.getStoredGlobalState(), i = this.getStoredWorkspaceState(), o = [];
      for (const [s, n] of t) {
        const r = this.get(s);
        if (r)
          r.visibleGlobal !== !n.isHidden && (n.isHidden || this.logger.info(`View visibility state changed: ${s} is now visible`, this.viewContainerName), o.push({ id: s, visible: !n.isHidden }));
        else {
          const a = i[s];
          this.set(s, {
            active: !1,
            visibleGlobal: !n.isHidden,
            visibleWorkspace: Yo(a == null ? void 0 : a.isHidden) ? void 0 : !(a != null && a.isHidden),
            collapsed: a == null ? void 0 : a.collapsed,
            order: a == null ? void 0 : a.order,
            size: a == null ? void 0 : a.size
          });
        }
      }
      if (o.length) {
        this._onDidChangeStoredState.fire(o);
        for (const s of o) {
          const n = this.get(s.id);
          n && (n.visibleGlobal = s.visible);
        }
      }
    }
  }
  initialize() {
    const e = /* @__PURE__ */ new Map(), t = this.getStoredWorkspaceState();
    for (const r of Object.keys(t)) {
      const a = t[r];
      e.set(r, {
        active: !1,
        visibleGlobal: void 0,
        visibleWorkspace: Yo(a.isHidden) ? void 0 : !a.isHidden,
        collapsed: a.collapsed,
        order: a.order,
        size: a.size
      });
    }
    const i = this.storageService.get(this.globalViewsStateStorageId, 1, "[]"), { state: o } = this.parseStoredGlobalState(i);
    if (o.size > 0) {
      for (const { id: r, isHidden: a } of o.values()) {
        const d = e.get(r);
        d ? Yo(d.visibleWorkspace) && (d.visibleWorkspace = !a) : e.set(r, {
          active: !1,
          collapsed: void 0,
          visibleGlobal: void 0,
          visibleWorkspace: !a
        });
      }
      this.storageService.remove(this.globalViewsStateStorageId, 1);
    }
    const { state: s, hasDuplicates: n } = this.parseStoredGlobalState(this.globalViewsStatesValue);
    n && this.setStoredGlobalState(s);
    for (const { id: r, isHidden: a, order: d } of s.values()) {
      const h = e.get(r);
      h ? (h.visibleGlobal = !a, Yo(d) || (h.order = d)) : e.set(r, {
        active: !1,
        visibleGlobal: !a,
        order: d,
        collapsed: void 0,
        visibleWorkspace: void 0
      });
    }
    return e;
  }
  getStoredWorkspaceState() {
    return JSON.parse(this.storageService.get(this.workspaceViewsStateStorageId, 1, "{}"));
  }
  getStoredGlobalState() {
    return this.parseStoredGlobalState(this.globalViewsStatesValue).state;
  }
  setStoredGlobalState(e) {
    this.globalViewsStatesValue = JSON.stringify([...e.values()]);
  }
  parseStoredGlobalState(e) {
    const t = JSON.parse(e);
    let i = !1;
    return { state: t.reduce((s, n) => (typeof n == "string" ? (i = i || s.has(n), s.set(n, { id: n, isHidden: !0 })) : (i = i || s.has(n.id), s.set(n.id, n)), s), /* @__PURE__ */ new Map()), hasDuplicates: i };
  }
  get globalViewsStatesValue() {
    return this._globalViewsStatesValue || (this._globalViewsStatesValue = this.getStoredGlobalViewsStatesValue()), this._globalViewsStatesValue;
  }
  set globalViewsStatesValue(e) {
    this.globalViewsStatesValue !== e && (this._globalViewsStatesValue = e, this.setStoredGlobalViewsStatesValue(e));
  }
  getStoredGlobalViewsStatesValue() {
    return this.storageService.get(this.globalViewsStateStorageId, 0, "[]");
  }
  setStoredGlobalViewsStatesValue(e) {
    this.storageService.store(this.globalViewsStateStorageId, e, 0, 0);
  }
};
qr = y([
  l(2, ee),
  l(3, Lc),
  l(4, Tt)
], qr);
let $r = class extends E {
  get title() {
    return this._title;
  }
  get icon() {
    return this._icon;
  }
  get keybindingId() {
    return this._keybindingId;
  }
  get allViewDescriptors() {
    return this.viewDescriptorItems.map((e) => e.viewDescriptor);
  }
  get activeViewDescriptors() {
    return this.viewDescriptorItems.filter((e) => e.state.active).map((e) => e.viewDescriptor);
  }
  get visibleViewDescriptors() {
    return this.viewDescriptorItems.filter((e) => this.isViewDescriptorVisible(e)).map((e) => e.viewDescriptor);
  }
  constructor(e, t, i, o, s) {
    super(), this.viewContainer = e, this.contextKeyService = i, this.contextKeys = new Jp(), this.viewDescriptorItems = [], this._onDidChangeContainerInfo = this._register(new w()), this.onDidChangeContainerInfo = this._onDidChangeContainerInfo.event, this._onDidChangeAllViewDescriptors = this._register(new w()), this.onDidChangeAllViewDescriptors = this._onDidChangeAllViewDescriptors.event, this._onDidChangeActiveViewDescriptors = this._register(new w()), this.onDidChangeActiveViewDescriptors = this._onDidChangeActiveViewDescriptors.event, this._onDidAddVisibleViewDescriptors = this._register(new w()), this.onDidAddVisibleViewDescriptors = this._onDidAddVisibleViewDescriptors.event, this._onDidRemoveVisibleViewDescriptors = this._register(new w()), this.onDidRemoveVisibleViewDescriptors = this._onDidRemoveVisibleViewDescriptors.event, this._onDidMoveVisibleViewDescriptors = this._register(new w()), this.onDidMoveVisibleViewDescriptors = this._onDidMoveVisibleViewDescriptors.event, this.logger = o.createLogger(Ed(s), { id: _d, name: mg, hidden: !0 }), this._register(_.filter(i.onDidChangeContext, (n) => n.affectsSome(this.contextKeys))(() => this.onDidChangeContext())), this.viewDescriptorsState = this._register(t.createInstance(qr, e.storageId || `${e.id}.state`, typeof e.title == "string" ? e.title : e.title.original)), this._register(this.viewDescriptorsState.onDidChangeStoredState((n) => this.updateVisibility(n))), this.updateContainerInfo();
  }
  updateContainerInfo() {
    var a, d, h, g, p, m;
    const e = this.viewContainer.alwaysUseContainerInfo || this.visibleViewDescriptors.length === 0 || this.visibleViewDescriptors.some(
      (C) => N.as(nt.ViewsRegistry).getViewContainer(C.id) === this.viewContainer
    ), t = e ? typeof this.viewContainer.title == "string" ? this.viewContainer.title : this.viewContainer.title.value : ((a = this.visibleViewDescriptors[0]) == null ? void 0 : a.containerTitle) || ((d = this.visibleViewDescriptors[0]) == null ? void 0 : d.name) || "";
    let i = !1;
    this._title !== t && (this._title = t, i = !0);
    const o = e ? this.viewContainer.icon : ((h = this.visibleViewDescriptors[0]) == null ? void 0 : h.containerIcon) || dh;
    let s = !1;
    this.isEqualIcon(o) || (this._icon = o, s = !0);
    const n = ((g = this.viewContainer.openCommandActionDescriptor) == null ? void 0 : g.id) ?? ((m = (p = this.activeViewDescriptors.find((C) => C.openCommandActionDescriptor)) == null ? void 0 : p.openCommandActionDescriptor) == null ? void 0 : m.id);
    let r = !1;
    this._keybindingId !== n && (this._keybindingId = n, r = !0), (i || s || r) && this._onDidChangeContainerInfo.fire({ title: i, icon: s, keybindingId: r });
  }
  isEqualIcon(e) {
    return A.isUri(e) ? A.isUri(this._icon) && Be(e, this._icon) : pe.isThemeIcon(e) ? pe.isThemeIcon(this._icon) && pe.isEqual(e, this._icon) : e === this._icon;
  }
  isVisible(e) {
    const t = this.viewDescriptorItems.find((i) => i.viewDescriptor.id === e);
    if (!t)
      throw new Error(`Unknown view ${e}`);
    return this.isViewDescriptorVisible(t);
  }
  setVisible(e, t) {
    this.updateVisibility([{ id: e, visible: t }]);
  }
  updateVisibility(e) {
    const t = ti(e.filter(({ visible: s }) => !s).map(({ id: s }) => this.findAndIgnoreIfNotFound(s))), i = [];
    for (const { viewDescriptorItem: s, visibleIndex: n } of t)
      this.updateViewDescriptorItemVisibility(s, !1) && i.push({ viewDescriptor: s.viewDescriptor, index: n });
    i.length && this.broadCastRemovedVisibleViewDescriptors(i);
    const o = [];
    for (const { id: s, visible: n } of e) {
      if (!n)
        continue;
      const r = this.findAndIgnoreIfNotFound(s);
      if (!r)
        continue;
      const { viewDescriptorItem: a, visibleIndex: d } = r;
      this.updateViewDescriptorItemVisibility(a, !0) && o.push({ index: d, viewDescriptor: a.viewDescriptor, size: a.state.size, collapsed: !!a.state.collapsed });
    }
    o.length && this.broadCastAddedVisibleViewDescriptors(o);
  }
  updateViewDescriptorItemVisibility(e, t) {
    return !e.viewDescriptor.canToggleVisibility || this.isViewDescriptorVisibleWhenActive(e) === t ? !1 : (e.viewDescriptor.workspace ? e.state.visibleWorkspace = t : (e.state.visibleGlobal = t, t && this.logger.info(`Showing view ${e.viewDescriptor.id} in the container ${this.viewContainer.id}`)), this.isViewDescriptorVisible(e) === t);
  }
  isCollapsed(e) {
    return !!this.find(e).viewDescriptorItem.state.collapsed;
  }
  setCollapsed(e, t) {
    const { viewDescriptorItem: i } = this.find(e);
    i.state.collapsed !== t && (i.state.collapsed = t), this.viewDescriptorsState.updateState(this.allViewDescriptors);
  }
  getSize(e) {
    return this.find(e).viewDescriptorItem.state.size;
  }
  setSizes(e) {
    for (const { id: t, size: i } of e) {
      const { viewDescriptorItem: o } = this.find(t);
      o.state.size !== i && (o.state.size = i);
    }
    this.viewDescriptorsState.updateState(this.allViewDescriptors);
  }
  move(e, t) {
    const i = this.viewDescriptorItems.findIndex((r) => r.viewDescriptor.id === e), o = this.viewDescriptorItems.findIndex((r) => r.viewDescriptor.id === t), s = this.viewDescriptorItems[i], n = this.viewDescriptorItems[o];
    Vp(this.viewDescriptorItems, i, o);
    for (let r = 0; r < this.viewDescriptorItems.length; r++)
      this.viewDescriptorItems[r].state.order = r;
    this.broadCastMovedViewDescriptors({ index: i, viewDescriptor: s.viewDescriptor }, { index: o, viewDescriptor: n.viewDescriptor });
  }
  add(e) {
    const t = [];
    for (const s of e) {
      const n = s.viewDescriptor;
      if (n.when)
        for (const a of n.when.keys())
          this.contextKeys.add(a);
      let r = this.viewDescriptorsState.get(n.id);
      if (r) {
        if (n.workspace)
          r.visibleWorkspace = tt(s.visible) ? tt(r.visibleWorkspace) ? !n.hideByDefault : r.visibleWorkspace : s.visible;
        else {
          const a = r.visibleGlobal;
          r.visibleGlobal = tt(s.visible) ? tt(r.visibleGlobal) ? !n.hideByDefault : r.visibleGlobal : s.visible, r.visibleGlobal && !a && this.logger.info(`Added view ${n.id} in the container ${this.viewContainer.id} and showing it.`, `${a}`, `${n.hideByDefault}`, `${s.visible}`);
        }
        r.collapsed = tt(s.collapsed) ? tt(r.collapsed) ? !!n.collapsed : r.collapsed : s.collapsed;
      } else
        r = {
          active: !1,
          visibleGlobal: tt(s.visible) ? !n.hideByDefault : s.visible,
          visibleWorkspace: tt(s.visible) ? !n.hideByDefault : s.visible,
          collapsed: tt(s.collapsed) ? !!n.collapsed : s.collapsed
        };
      this.viewDescriptorsState.set(n.id, r), r.active = this.contextKeyService.contextMatchesRules(n.when), t.push({ viewDescriptor: n, state: r });
    }
    this.viewDescriptorItems.push(...t), this.viewDescriptorItems.sort(this.compareViewDescriptors.bind(this)), this._onDidChangeAllViewDescriptors.fire({ added: t.map(({ viewDescriptor: s }) => s), removed: [] });
    const i = [];
    for (const s of t)
      s.state.active && i.push({ viewDescriptorItem: s, visible: this.isViewDescriptorVisible(s) });
    i.length && this._onDidChangeActiveViewDescriptors.fire({ added: i.map(({ viewDescriptorItem: s }) => s.viewDescriptor), removed: [] });
    const o = [];
    for (const { viewDescriptorItem: s, visible: n } of i)
      if (n && this.isViewDescriptorVisible(s)) {
        const { visibleIndex: r } = this.find(s.viewDescriptor.id);
        o.push({ index: r, viewDescriptor: s.viewDescriptor, size: s.state.size, collapsed: !!s.state.collapsed });
      }
    this.broadCastAddedVisibleViewDescriptors(o);
  }
  remove(e) {
    const t = [], i = [], o = [], s = [];
    for (const n of e) {
      if (n.when)
        for (const a of n.when.keys())
          this.contextKeys.delete(a);
      const r = this.viewDescriptorItems.findIndex((a) => a.viewDescriptor.id === n.id);
      if (r !== -1) {
        t.push(n);
        const a = this.viewDescriptorItems[r];
        if (a.state.active && o.push(a.viewDescriptor), this.isViewDescriptorVisible(a)) {
          const { visibleIndex: d } = this.find(a.viewDescriptor.id);
          s.push({ index: d, viewDescriptor: a.viewDescriptor });
        }
        i.push(a);
      }
    }
    i.forEach((n) => this.viewDescriptorItems.splice(this.viewDescriptorItems.indexOf(n), 1)), this.broadCastRemovedVisibleViewDescriptors(s), o.length && this._onDidChangeActiveViewDescriptors.fire({ added: [], removed: o }), t.length && this._onDidChangeAllViewDescriptors.fire({ added: [], removed: t });
  }
  onDidChangeContext() {
    const e = [], t = [];
    for (const s of this.viewDescriptorItems) {
      const n = s.state.active, r = this.contextKeyService.contextMatchesRules(s.viewDescriptor.when);
      n !== r && (r ? e.push({ item: s, visibleWhenActive: this.isViewDescriptorVisibleWhenActive(s) }) : t.push(s));
    }
    const i = [];
    for (const s of t)
      if (this.isViewDescriptorVisible(s)) {
        const { visibleIndex: n } = this.find(s.viewDescriptor.id);
        i.push({ index: n, viewDescriptor: s.viewDescriptor });
      }
    t.forEach((s) => s.state.active = !1), e.forEach(({ item: s }) => s.state.active = !0), this.broadCastRemovedVisibleViewDescriptors(i), (e.length || t.length) && this._onDidChangeActiveViewDescriptors.fire({ added: e.map(({ item: s }) => s.viewDescriptor), removed: t.map((s) => s.viewDescriptor) });
    const o = [];
    for (const { item: s, visibleWhenActive: n } of e)
      if (n && this.isViewDescriptorVisible(s)) {
        const { visibleIndex: r } = this.find(s.viewDescriptor.id);
        o.push({ index: r, viewDescriptor: s.viewDescriptor, size: s.state.size, collapsed: !!s.state.collapsed });
      }
    this.broadCastAddedVisibleViewDescriptors(o);
  }
  broadCastAddedVisibleViewDescriptors(e) {
    e.length && (this._onDidAddVisibleViewDescriptors.fire(e.sort((t, i) => t.index - i.index)), this.updateState(`Added views:${e.map((t) => t.viewDescriptor.id).join(",")} in ${this.viewContainer.id}`));
  }
  broadCastRemovedVisibleViewDescriptors(e) {
    e.length && (this._onDidRemoveVisibleViewDescriptors.fire(e.sort((t, i) => i.index - t.index)), this.updateState(`Removed views:${e.map((t) => t.viewDescriptor.id).join(",")} from ${this.viewContainer.id}`));
  }
  broadCastMovedViewDescriptors(e, t) {
    this._onDidMoveVisibleViewDescriptors.fire({ from: e, to: t }), this.updateState(`Moved view ${e.viewDescriptor.id} to ${t.viewDescriptor.id} in ${this.viewContainer.id}`);
  }
  updateState(e) {
    this.logger.info(e), this.viewDescriptorsState.updateState(this.allViewDescriptors), this.updateContainerInfo();
  }
  isViewDescriptorVisible(e) {
    return e.state.active ? this.isViewDescriptorVisibleWhenActive(e) : !1;
  }
  isViewDescriptorVisibleWhenActive(e) {
    return e.viewDescriptor.workspace ? !!e.state.visibleWorkspace : !!e.state.visibleGlobal;
  }
  find(e) {
    const t = this.findAndIgnoreIfNotFound(e);
    if (t)
      return t;
    throw new Error(`view descriptor ${e} not found`);
  }
  findAndIgnoreIfNotFound(e) {
    for (let t = 0, i = 0; t < this.viewDescriptorItems.length; t++) {
      const o = this.viewDescriptorItems[t];
      if (o.viewDescriptor.id === e)
        return { index: t, visibleIndex: i, viewDescriptorItem: o };
      this.isViewDescriptorVisible(o) && i++;
    }
  }
  compareViewDescriptors(e, t) {
    return e.viewDescriptor.id === t.viewDescriptor.id ? 0 : this.getViewOrder(e) - this.getViewOrder(t) || this.getGroupOrderResult(e.viewDescriptor, t.viewDescriptor);
  }
  getViewOrder(e) {
    const t = typeof e.state.order == "number" ? e.state.order : e.viewDescriptor.order;
    return typeof t == "number" ? t : Number.MAX_VALUE;
  }
  getGroupOrderResult(e, t) {
    return !e.group || !t.group || e.group === t.group ? 0 : e.group < t.group ? -1 : 1;
  }
};
$r = y([
  l(1, W),
  l(2, F),
  l(3, Lc),
  l(4, Tt)
], $r);
function Tl(c) {
  return `${c}.state`;
}
var ze;
let ea = (ze = class extends E {
  get viewContainers() {
    return this.viewContainersRegistry.all;
  }
  constructor(e, t, i, o, s) {
    super(), this.instantiationService = e, this.contextKeyService = t, this.storageService = i, this.extensionService = o, this.telemetryService = s, this._onDidChangeContainer = this._register(new w()), this.onDidChangeContainer = this._onDidChangeContainer.event, this._onDidChangeLocation = this._register(new w()), this.onDidChangeLocation = this._onDidChangeLocation.event, this._onDidChangeContainerLocation = this._register(new w()), this.onDidChangeContainerLocation = this._onDidChangeContainerLocation.event, this.viewContainerModels = this._register(new Hd()), this.viewsVisibilityActionDisposables = this._register(new Hd()), this._onDidChangeViewContainers = this._register(new w()), this.onDidChangeViewContainers = this._onDidChangeViewContainers.event, this.activeViewContextKeys = /* @__PURE__ */ new Map(), this.movableViewContextKeys = /* @__PURE__ */ new Map(), this.defaultViewLocationContextKeys = /* @__PURE__ */ new Map(), this.defaultViewContainerLocationContextKeys = /* @__PURE__ */ new Map(), this.viewContainersRegistry = N.as(nt.ViewContainersRegistry), this.viewsRegistry = N.as(nt.ViewsRegistry), this.migrateToViewsCustomizationsStorage(), this.viewContainersCustomLocations = new Map(Object.entries(this.viewCustomizations.viewContainerLocations)), this.viewDescriptorsCustomLocations = new Map(Object.entries(this.viewCustomizations.viewLocations)), this.viewContainerBadgeEnablementStates = new Map(Object.entries(this.viewCustomizations.viewContainerBadgeEnablementStates)), this.viewContainers.forEach((n) => this.onDidRegisterViewContainer(n)), this._register(this.viewsRegistry.onViewsRegistered((n) => this.onDidRegisterViews(n))), this._register(this.viewsRegistry.onViewsDeregistered(({ views: n, viewContainer: r }) => this.onDidDeregisterViews(n, r))), this._register(this.viewsRegistry.onDidChangeContainer(({ views: n, from: r, to: a }) => this.onDidChangeDefaultContainer(n, r, a))), this._register(this.viewContainersRegistry.onDidRegister(({ viewContainer: n }) => {
      this.onDidRegisterViewContainer(n), this._onDidChangeViewContainers.fire({ added: [{ container: n, location: this.getViewContainerLocation(n) }], removed: [] });
    })), this._register(this.viewContainersRegistry.onDidDeregister(({ viewContainer: n }) => {
      this.onDidDeregisterViewContainer(n), this._onDidChangeViewContainers.fire({ removed: [{ container: n, location: this.getViewContainerLocation(n) }], added: [] });
    })), this._register(this.storageService.onDidChangeValue((n) => {
      this.onDidStorageChange(n);
    })), this.extensionService.whenInstalledExtensionsRegistered().then(() => this.whenExtensionsRegistered());
  }
  migrateToViewsCustomizationsStorage() {
    if (this.storageService.get(ze.VIEWS_CUSTOMIZATIONS, 0))
      return;
    const e = this.storageService.get("views.cachedViewContainerLocations", 0), t = this.storageService.get("views.cachedViewPositions", 0);
    if (!e && !t)
      return;
    const i = e ? JSON.parse(e) : [], o = t ? JSON.parse(t) : [], s = {
      viewContainerLocations: i.reduce((n, [r, a]) => (n[r] = a, n), {}),
      viewLocations: o.reduce((n, [r, { containerId: a }]) => (n[r] = a, n), {}),
      viewContainerBadgeEnablementStates: {}
    };
    this.storageService.store(ze.VIEWS_CUSTOMIZATIONS, JSON.stringify(s), 0, 0), this.storageService.remove("views.cachedViewContainerLocations", 0), this.storageService.remove("views.cachedViewPositions", 0);
  }
  registerGroupedViews(e) {
    for (const [t, i] of e.entries()) {
      const o = this.viewContainersRegistry.get(t);
      if (!o || !this.viewContainerModels.has(o)) {
        if (this.isGeneratedContainerId(t)) {
          const n = this.viewContainersCustomLocations.get(t);
          n !== void 0 && this.registerGeneratedViewContainer(n, t);
        }
        continue;
      }
      const s = i.filter((n) => this.getViewContainerModel(o).allViewDescriptors.filter((r) => r.id === n.id).length === 0);
      this.addViews(o, s);
    }
  }
  deregisterGroupedViews(e) {
    for (const [t, i] of e.entries()) {
      const o = this.viewContainersRegistry.get(t);
      !o || !this.viewContainerModels.has(o) || this.removeViews(o, i);
    }
  }
  moveOrphanViewsToDefaultLocation() {
    for (const [e, t] of this.viewDescriptorsCustomLocations.entries()) {
      if (this.viewContainersRegistry.get(t))
        continue;
      const i = this.viewsRegistry.getViewContainer(e), o = this.getViewDescriptorById(e);
      i && o && this.addViews(i, [o]);
    }
  }
  whenExtensionsRegistered() {
    this.moveOrphanViewsToDefaultLocation();
    for (const e of [...this.viewContainersCustomLocations.keys()])
      this.cleanUpGeneratedViewContainer(e);
    this.saveViewCustomizations(), this.registerViewsVisibilityActions();
  }
  onDidRegisterViews(e) {
    this.contextKeyService.bufferChangeEvents(() => {
      e.forEach(({ views: t, viewContainer: i }) => {
        const o = this.regroupViews(i.id, t);
        this.registerGroupedViews(o), t.forEach((s) => this.getOrCreateMovableViewContextKey(s).set(!!s.canMoveView));
      });
    });
  }
  isGeneratedContainerId(e) {
    return e.startsWith(ze.COMMON_CONTAINER_ID_PREFIX);
  }
  onDidDeregisterViews(e, t) {
    const i = this.regroupViews(t.id, e);
    this.deregisterGroupedViews(i), this.contextKeyService.bufferChangeEvents(() => {
      e.forEach((o) => this.getOrCreateMovableViewContextKey(o).set(!1));
    });
  }
  regroupViews(e, t) {
    const i = /* @__PURE__ */ new Map();
    for (const o of t) {
      const s = this.viewDescriptorsCustomLocations.get(o.id) ?? e;
      let n = i.get(s);
      n || i.set(s, n = []), n.push(o);
    }
    return i;
  }
  getViewDescriptorById(e) {
    return this.viewsRegistry.getView(e);
  }
  getViewLocationById(e) {
    const t = this.getViewContainerByViewId(e);
    return t === null ? null : this.getViewContainerLocation(t);
  }
  getViewContainerByViewId(e) {
    const t = this.viewDescriptorsCustomLocations.get(e);
    return t ? this.viewContainersRegistry.get(t) ?? null : this.getDefaultContainerById(e);
  }
  getViewContainerLocation(e) {
    return this.viewContainersCustomLocations.get(e.id) ?? this.getDefaultViewContainerLocation(e);
  }
  getDefaultViewContainerLocation(e) {
    return this.viewContainersRegistry.getViewContainerLocation(e);
  }
  getDefaultContainerById(e) {
    return this.viewsRegistry.getViewContainer(e) ?? null;
  }
  getViewContainerModel(e) {
    return this.getOrRegisterViewContainerModel(e);
  }
  getViewContainerById(e) {
    return this.viewContainersRegistry.get(e) || null;
  }
  getViewContainersByLocation(e) {
    return this.viewContainers.filter((t) => this.getViewContainerLocation(t) === e);
  }
  getDefaultViewContainer(e) {
    return this.viewContainersRegistry.getDefaultViewContainer(e);
  }
  moveViewContainerToLocation(e, t, i) {
    this.moveViewContainerToLocationWithoutSaving(e, t, i), this.saveViewCustomizations();
  }
  getViewContainerBadgeEnablementState(e) {
    return this.viewContainerBadgeEnablementStates.get(e) ?? !0;
  }
  setViewContainerBadgeEnablementState(e, t) {
    this.viewContainerBadgeEnablementStates.set(e, t), this.saveViewCustomizations();
  }
  moveViewToLocation(e, t) {
    const i = this.registerGeneratedViewContainer(t);
    this.moveViewsToContainer([e], i);
  }
  moveViewsToContainer(e, t, i) {
    if (!e.length)
      return;
    const o = this.getViewContainerByViewId(e[0].id), s = t;
    o && s && o !== s && (this.moveViewsWithoutSaving(e, o, s, i), this.cleanUpGeneratedViewContainer(o.id), this.saveViewCustomizations(), this.reportMovedViews(e, o, s));
  }
  reset() {
    for (const e of this.viewContainers) {
      const t = this.getViewContainerModel(e);
      for (const s of t.allViewDescriptors) {
        const n = this.getDefaultContainerById(s.id), r = this.getViewContainerByViewId(s.id);
        r && n && r !== n && this.moveViewsWithoutSaving([s], r, n);
      }
      const i = this.getDefaultViewContainerLocation(e), o = this.getViewContainerLocation(e);
      i !== null && o !== i && this.moveViewContainerToLocationWithoutSaving(e, i), this.cleanUpGeneratedViewContainer(e.id);
    }
    this.viewContainersCustomLocations.clear(), this.viewDescriptorsCustomLocations.clear(), this.saveViewCustomizations();
  }
  isViewContainerRemovedPermanently(e) {
    return this.isGeneratedContainerId(e) && !this.viewContainersCustomLocations.has(e);
  }
  onDidChangeDefaultContainer(e, t, i) {
    const o = e.filter(
      (s) => !this.viewDescriptorsCustomLocations.has(s.id) || !this.viewContainers.includes(t) && this.viewDescriptorsCustomLocations.get(s.id) === t.id
    );
    o.length && this.moveViewsWithoutSaving(o, t, i);
  }
  reportMovedViews(e, t, i) {
    const o = (p) => p.id.startsWith(ze.COMMON_CONTAINER_ID_PREFIX) ? "custom" : p.extensionId ? "extension" : p.id, s = this.getViewContainerLocation(t), n = this.getViewContainerLocation(i), r = e.length, a = o(t), d = o(i), h = s === 1 ? "panel" : "sidebar", g = n === 1 ? "panel" : "sidebar";
    this.telemetryService.publicLog2("viewDescriptorService.moveViews", { viewCount: r, fromContainer: a, toContainer: d, fromLocation: h, toLocation: g });
  }
  moveViewsWithoutSaving(e, t, i, o = Lo.Expand) {
    this.removeViews(t, e), this.addViews(i, e, o);
    const s = this.getViewContainerLocation(t), n = this.getViewContainerLocation(i);
    s !== n && this._onDidChangeLocation.fire({ views: e, from: s, to: n }), this._onDidChangeContainer.fire({ views: e, from: t, to: i });
  }
  moveViewContainerToLocationWithoutSaving(e, t, i) {
    const o = this.getViewContainerLocation(e), s = t;
    if (o !== s) {
      const n = this.isGeneratedContainerId(e.id), r = s === this.getDefaultViewContainerLocation(e);
      n || !r ? this.viewContainersCustomLocations.set(e.id, s) : this.viewContainersCustomLocations.delete(e.id), this.getOrCreateDefaultViewContainerLocationContextKey(e).set(n || r), e.requestedIndex = i, this._onDidChangeContainerLocation.fire({ viewContainer: e, from: o, to: s });
      const a = this.getViewsByContainer(e);
      this._onDidChangeLocation.fire({ views: a, from: o, to: s });
    }
  }
  cleanUpGeneratedViewContainer(e) {
    var i;
    if (!this.isGeneratedContainerId(e))
      return;
    const t = this.getViewContainerById(e);
    t && ((i = this.getViewContainerModel(t)) != null && i.allViewDescriptors.length) || [...this.viewDescriptorsCustomLocations.values()].includes(e) || (t && this.viewContainersRegistry.deregisterViewContainer(t), this.viewContainersCustomLocations.delete(e), this.viewContainerBadgeEnablementStates.delete(e), this.storageService.remove(bg((t == null ? void 0 : t.storageId) || Tl(e)), 0));
  }
  registerGeneratedViewContainer(e, t) {
    const i = t || this.generateContainerId(e), o = this.viewContainersRegistry.registerViewContainer({
      id: i,
      ctorDescriptor: new T(Fc, [i, { mergeViewWithContainerWhenSingleView: !0 }]),
      title: i,
      icon: e === 0 ? dh : void 0,
      storageId: Tl(i),
      hideIfEmpty: !0
    }, e, { doNotRegisterOpenCommand: !0 });
    return this.viewContainersCustomLocations.get(o.id) !== e && this.viewContainersCustomLocations.set(o.id, e), this.getOrCreateDefaultViewContainerLocationContextKey(o).set(!0), o;
  }
  onDidStorageChange(e) {
    e.key === ze.VIEWS_CUSTOMIZATIONS && e.scope === 0 && JSON.stringify(this.viewCustomizations) !== this.getStoredViewCustomizationsValue() && this.onDidViewCustomizationsStorageChange();
  }
  onDidViewCustomizationsStorageChange() {
    this._viewCustomizations = void 0;
    const e = new Map(Object.entries(this.viewCustomizations.viewContainerLocations)), t = new Map(Object.entries(this.viewCustomizations.viewLocations)), i = [], o = [];
    for (const [s, n] of e.entries()) {
      const r = this.getViewContainerById(s);
      r ? n !== this.getViewContainerLocation(r) && i.push([r, n]) : this.isGeneratedContainerId(s) && this.registerGeneratedViewContainer(n, s);
    }
    for (const s of this.viewContainers)
      if (!e.has(s.id)) {
        const n = this.getViewContainerLocation(s), r = this.getDefaultViewContainerLocation(s);
        n !== r && i.push([s, r]);
      }
    for (const [s, n] of t.entries()) {
      const r = this.getViewDescriptorById(s);
      if (r) {
        const a = this.getViewContainerByViewId(s), d = this.viewContainersRegistry.get(n);
        a && d && d !== a && o.push({ views: [r], from: a, to: d });
      }
    }
    for (const s of this.viewContainers) {
      const n = this.getViewContainerModel(s);
      for (const r of n.allViewDescriptors)
        if (!t.has(r.id)) {
          const a = this.getViewContainerByViewId(r.id), d = this.getDefaultContainerById(r.id);
          a && d && a !== d && o.push({ views: [r], from: a, to: d });
        }
    }
    for (const [s, n] of i)
      this.moveViewContainerToLocationWithoutSaving(s, n);
    for (const { views: s, from: n, to: r } of o)
      this.moveViewsWithoutSaving(s, n, r, Lo.Default);
    this.viewContainersCustomLocations = e, this.viewDescriptorsCustomLocations = t;
  }
  generateContainerId(e) {
    return `${ze.COMMON_CONTAINER_ID_PREFIX}.${Pd(e)}.${An()}`;
  }
  saveViewCustomizations() {
    const e = { viewContainerLocations: {}, viewLocations: {}, viewContainerBadgeEnablementStates: {} };
    for (const [t, i] of this.viewContainersCustomLocations) {
      const o = this.getViewContainerById(t);
      o && !this.isGeneratedContainerId(t) && i === this.getDefaultViewContainerLocation(o) || (e.viewContainerLocations[t] = i);
    }
    for (const [t, i] of this.viewDescriptorsCustomLocations) {
      const o = this.getViewContainerById(i);
      if (o) {
        const s = this.getDefaultContainerById(t);
        if ((s == null ? void 0 : s.id) === o.id)
          continue;
      }
      e.viewLocations[t] = i;
    }
    for (const [t, i] of this.viewContainerBadgeEnablementStates)
      i === !1 && (e.viewContainerBadgeEnablementStates[t] = i);
    this.viewCustomizations = e;
  }
  get viewCustomizations() {
    return this._viewCustomizations || (this._viewCustomizations = JSON.parse(this.getStoredViewCustomizationsValue()), this._viewCustomizations.viewContainerLocations = this._viewCustomizations.viewContainerLocations ?? {}, this._viewCustomizations.viewLocations = this._viewCustomizations.viewLocations ?? {}, this._viewCustomizations.viewContainerBadgeEnablementStates = this._viewCustomizations.viewContainerBadgeEnablementStates ?? {}), this._viewCustomizations;
  }
  set viewCustomizations(e) {
    const t = JSON.stringify(e);
    JSON.stringify(this.viewCustomizations) !== t && (this._viewCustomizations = e, this.setStoredViewCustomizationsValue(t));
  }
  getStoredViewCustomizationsValue() {
    return this.storageService.get(ze.VIEWS_CUSTOMIZATIONS, 0, "{}");
  }
  setStoredViewCustomizationsValue(e) {
    this.storageService.store(ze.VIEWS_CUSTOMIZATIONS, e, 0, 0);
  }
  getViewsByContainer(e) {
    const t = this.viewsRegistry.getViews(e).filter((i) => (this.viewDescriptorsCustomLocations.get(i.id) ?? e.id) === e.id);
    for (const [i, o] of this.viewDescriptorsCustomLocations.entries()) {
      if (o !== e.id || this.viewsRegistry.getViewContainer(i) === e)
        continue;
      const s = this.getViewDescriptorById(i);
      s && t.push(s);
    }
    return t;
  }
  onDidRegisterViewContainer(e) {
    const t = this.isGeneratedContainerId(e.id) ? !0 : this.getViewContainerLocation(e) === this.getDefaultViewContainerLocation(e);
    this.getOrCreateDefaultViewContainerLocationContextKey(e).set(t), this.getOrRegisterViewContainerModel(e);
  }
  getOrRegisterViewContainerModel(e) {
    var i;
    let t = (i = this.viewContainerModels.get(e)) == null ? void 0 : i.viewContainerModel;
    if (!t) {
      const o = new Z();
      t = o.add(this.instantiationService.createInstance($r, e)), this.onDidChangeActiveViews({ added: t.activeViewDescriptors, removed: [] }), t.onDidChangeActiveViewDescriptors((n) => this.onDidChangeActiveViews(n), this, o), this.onDidChangeVisibleViews({ added: [...t.visibleViewDescriptors], removed: [] }), t.onDidAddVisibleViewDescriptors((n) => this.onDidChangeVisibleViews({ added: n.map(({ viewDescriptor: r }) => r), removed: [] }), this, o), t.onDidRemoveVisibleViewDescriptors((n) => this.onDidChangeVisibleViews({ added: [], removed: n.map(({ viewDescriptor: r }) => r) }), this, o), o.add(M(() => this.viewsVisibilityActionDisposables.deleteAndDispose(e))), o.add(this.registerResetViewContainerAction(e)), this.viewContainerModels.set(e, { viewContainerModel: t, disposables: o, dispose: () => o.dispose() }), this.onDidRegisterViews([{ views: this.viewsRegistry.getViews(e), viewContainer: e }]);
      const s = this.getViewsByContainer(e).filter((n) => this.getDefaultContainerById(n.id) !== e);
      s.length && (this.addViews(e, s), this.contextKeyService.bufferChangeEvents(() => {
        s.forEach((n) => this.getOrCreateMovableViewContextKey(n).set(!!n.canMoveView));
      }));
    }
    return t;
  }
  onDidDeregisterViewContainer(e) {
    this.viewContainerModels.deleteAndDispose(e);
  }
  onDidChangeActiveViews({ added: e, removed: t }) {
    this.contextKeyService.bufferChangeEvents(() => {
      e.forEach((i) => this.getOrCreateActiveViewContextKey(i).set(!0)), t.forEach((i) => this.getOrCreateActiveViewContextKey(i).set(!1));
    });
  }
  onDidChangeVisibleViews({ added: e, removed: t }) {
    this.contextKeyService.bufferChangeEvents(() => {
      e.forEach((i) => this.getOrCreateVisibleViewContextKey(i).set(!0)), t.forEach((i) => this.getOrCreateVisibleViewContextKey(i).set(!1));
    });
  }
  registerViewsVisibilityActions() {
    for (const [e, { viewContainerModel: t, disposables: i }] of this.viewContainerModels)
      this.viewsVisibilityActionDisposables.set(e, this.registerViewsVisibilityActionsForContainer(t)), i.add(_.any(t.onDidChangeActiveViewDescriptors, t.onDidAddVisibleViewDescriptors, t.onDidRemoveVisibleViewDescriptors, t.onDidMoveVisibleViewDescriptors)((o) => this.viewsVisibilityActionDisposables.set(e, this.registerViewsVisibilityActionsForContainer(t))));
  }
  registerViewsVisibilityActionsForContainer(e) {
    const t = new Z();
    return e.activeViewDescriptors.forEach((i, o) => {
      i.remoteAuthority || (t.add(P(class extends Md {
        constructor() {
          super({
            id: `${i.id}.toggleVisibility`,
            viewPaneContainerId: e.viewContainer.id,
            precondition: i.canToggleVisibility && (!e.isVisible(i.id) || e.visibleViewDescriptors.length > 1) ? f.true() : f.false(),
            toggled: f.has(`${i.id}.visible`),
            title: i.name,
            menu: [{
              id: Zp,
              group: "1_toggleViews",
              when: f.and(f.equals("viewContainer", e.viewContainer.id), f.equals(
                "viewContainerLocation",
                Pd(0)
              )),
              order: o
            }, {
              id: k.ViewContainerTitleContext,
              when: f.and(f.equals("viewContainer", e.viewContainer.id)),
              order: o,
              group: "1_toggleVisibility"
            }, {
              id: k.ViewTitleContext,
              when: f.and(e.visibleViewDescriptors.length > 1 ? f.or(...e.visibleViewDescriptors.map((s) => f.equals("view", s.id))) : f.false()),
              order: o,
              group: "2_toggleVisibility"
            }]
          });
        }
        async runInViewPaneContainer(s, n) {
          n.toggleViewVisibility(i.id);
        }
      })), t.add(P(class extends Md {
        constructor() {
          super({
            id: `${i.id}.removeView`,
            viewPaneContainerId: e.viewContainer.id,
            title: u("hideView", "Hide '{0}'", i.name),
            precondition: i.canToggleVisibility && (!e.isVisible(i.id) || e.visibleViewDescriptors.length > 1) ? f.true() : f.false(),
            menu: [{
              id: k.ViewTitleContext,
              when: f.and(f.equals("view", i.id), f.has(`${i.id}.visible`)),
              group: "1_hide",
              order: 1
            }]
          });
        }
        async runInViewPaneContainer(s, n) {
          n.toggleViewVisibility(i.id);
        }
      })));
    }), t;
  }
  registerResetViewContainerAction(e) {
    const t = this;
    return P(class extends ye {
      constructor() {
        super({
          id: `${e.id}.resetViewContainerLocation`,
          title: {
            original: "Reset Location",
            value: u("resetViewLocation", "Reset Location")
          },
          menu: [{
            id: k.ViewContainerTitleContext,
            when: f.or(f.and(f.equals("viewContainer", e.id), f.equals(`${e.id}.defaultViewContainerLocation`, !1)))
          }]
        });
      }
      run() {
        t.moveViewContainerToLocation(e, t.getDefaultViewContainerLocation(e));
      }
    });
  }
  addViews(e, t, i = Lo.Default) {
    this.contextKeyService.bufferChangeEvents(() => {
      t.forEach((o) => {
        const s = this.getDefaultContainerById(o.id) === e;
        this.getOrCreateDefaultViewLocationContextKey(o).set(s), s ? this.viewDescriptorsCustomLocations.delete(o.id) : this.viewDescriptorsCustomLocations.set(o.id, e.id);
      });
    }), this.getViewContainerModel(e).add(t.map((o) => ({
      viewDescriptor: o,
      collapsed: i === Lo.Default ? void 0 : !1,
      visible: i === Lo.Default ? void 0 : !0
    })));
  }
  removeViews(e, t) {
    this.contextKeyService.bufferChangeEvents(() => {
      t.forEach((i) => {
        this.viewDescriptorsCustomLocations.get(i.id) === e.id && this.viewDescriptorsCustomLocations.delete(i.id), this.getOrCreateDefaultViewLocationContextKey(i).set(!1);
      });
    }), this.getViewContainerModel(e).remove(t);
  }
  getOrCreateActiveViewContextKey(e) {
    const t = `${e.id}.active`;
    let i = this.activeViewContextKeys.get(t);
    return i || (i = new K(t, !1).bindTo(this.contextKeyService), this.activeViewContextKeys.set(t, i)), i;
  }
  getOrCreateVisibleViewContextKey(e) {
    const t = `${e.id}.visible`;
    let i = this.activeViewContextKeys.get(t);
    return i || (i = new K(t, !1).bindTo(this.contextKeyService), this.activeViewContextKeys.set(t, i)), i;
  }
  getOrCreateMovableViewContextKey(e) {
    const t = `${e.id}.canMove`;
    let i = this.movableViewContextKeys.get(t);
    return i || (i = new K(t, !1).bindTo(this.contextKeyService), this.movableViewContextKeys.set(t, i)), i;
  }
  getOrCreateDefaultViewLocationContextKey(e) {
    const t = `${e.id}.defaultViewLocation`;
    let i = this.defaultViewLocationContextKeys.get(t);
    return i || (i = new K(t, !1).bindTo(this.contextKeyService), this.defaultViewLocationContextKeys.set(t, i)), i;
  }
  getOrCreateDefaultViewContainerLocationContextKey(e) {
    const t = `${e.id}.defaultViewContainerLocation`;
    let i = this.defaultViewContainerLocationContextKeys.get(t);
    return i || (i = new K(t, !1).bindTo(this.contextKeyService), this.defaultViewContainerLocationContextKeys.set(t, i)), i;
  }
}, ze.VIEWS_CUSTOMIZATIONS = "views.customizations", ze.COMMON_CONTAINER_ID_PREFIX = "workbench.views.service", ze);
ea = y([
  l(0, W),
  l(1, F),
  l(2, ee),
  l(3, ei),
  l(4, Xe)
], ea);
const wi = "workbench.action.globalActivity", js = "workbench.action.accountsActivity";
let ta = class extends E {
  constructor(e, t, i) {
    super(), this.viewId = e, this.viewDescriptorService = t, this.activityService = i, this.activity = void 0, this.activityDisposable = E.None, this._register(_.filter(this.viewDescriptorService.onDidChangeContainer, (o) => o.views.some((s) => s.id === e))(() => this.update())), this._register(_.filter(this.viewDescriptorService.onDidChangeLocation, (o) => o.views.some((s) => s.id === e))(() => this.update()));
  }
  setActivity(e) {
    this.activity = e, this.update();
  }
  clearActivity() {
    this.activity = void 0, this.update();
  }
  update() {
    this.activityDisposable.dispose();
    const e = this.viewDescriptorService.getViewContainerByViewId(this.viewId);
    e && this.activity && (this.activityDisposable = this.activityService.showViewContainerActivity(e.id, this.activity));
  }
  dispose() {
    this.activityDisposable.dispose();
  }
};
ta = y([
  l(1, Me),
  l(2, Eo)
], ta);
let ia = class {
  constructor(e, t, i) {
    this.paneCompositeService = e, this.viewDescriptorService = t, this.instantiationService = i, this.viewActivities = /* @__PURE__ */ new Map();
  }
  showViewContainerActivity(e, { badge: t, clazz: i, priority: o }) {
    const s = this.viewDescriptorService.getViewContainerById(e);
    if (s) {
      const n = this.viewDescriptorService.getViewContainerLocation(s);
      if (n !== null)
        return this.paneCompositeService.showActivity(s.id, n, t, i, o);
    }
    return E.None;
  }
  showViewActivity(e, t) {
    let i = this.viewActivities.get(e);
    i ? i.id++ : (i = {
      id: 1,
      activity: this.instantiationService.createInstance(ta, e)
    }, this.viewActivities.set(e, i));
    const o = i.id;
    i.activity.setActivity(t);
    const s = i;
    return M(() => {
      s.id === o && (s.activity.dispose(), this.viewActivities.delete(e));
    });
  }
  showAccountsActivity({ badge: e, clazz: t, priority: i }) {
    return this.paneCompositeService.showActivity(js, 0, e, t, i);
  }
  showGlobalActivity({ badge: e, clazz: t, priority: i }) {
    return this.paneCompositeService.showActivity(wi, 0, e, t, i);
  }
};
ia = y([
  l(0, ii),
  l(1, Me),
  l(2, W)
], ia);
var Ww = '.monaco-workbench .part.activitybar{height:100%;width:48px}.monaco-workbench .activitybar.bordered:before{border-color:inherit;box-sizing:border-box;content:"";float:left;height:100%;position:absolute;width:0}.monaco-workbench .activitybar.left.bordered:before{border-right-style:solid;border-right-width:1px;right:0}.monaco-workbench .activitybar.right.bordered:before{border-left-style:solid;border-left-width:1px;left:0}.monaco-workbench .activitybar>.content{display:flex;flex-direction:column;height:100%;justify-content:space-between}.monaco-workbench .activitybar>.content .monaco-action-bar{background-color:inherit;text-align:left}.monaco-workbench .activitybar .action-item:focus{outline:0!important}.monaco-workbench .activitybar>.content>.composite-bar{margin-bottom:auto}.monaco-workbench .activitybar .menubar,.monaco-workbench .activitybar .menubar.compact .toolbar-toggle-more{height:35px;width:100%}';
oe(Ww, {});
var _w = '.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item{display:block;position:relative}.monaco-workbench .activitybar>.content .composite-bar>.monaco-action-bar .action-item:after,.monaco-workbench .activitybar>.content .composite-bar>.monaco-action-bar .action-item:before{background-color:transparent;content:"";display:none;height:2px;position:absolute;transition-delay:.1s;transition-duration:0ms;transition-property:background-color;width:48px}.monaco-workbench .activitybar>.content.dragged-over .composite-bar>.monaco-action-bar .action-item:after,.monaco-workbench .activitybar>.content.dragged-over .composite-bar>.monaco-action-bar .action-item:before{display:block}.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item:before{margin-top:-2px;top:1px}.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item:after{bottom:1px;margin-bottom:-2px}.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item:first-of-type:before{margin-top:-2px;top:2px}.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item:last-of-type:after{bottom:2px;margin-bottom:-2px}.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item.bottom:after,.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item.bottom:before,.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item.top:after,.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item.top:before{transition-delay:0s}.monaco-workbench .activitybar>.content.dragged-over-head>.composite-bar>.monaco-action-bar .action-item:first-of-type:before,.monaco-workbench .activitybar>.content.dragged-over-tail>.composite-bar>.monaco-action-bar .action-item:last-of-type:after,.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item.bottom+.action-item:before,.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item.top:before,.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item:last-of-type.bottom:after{background-color:var(--insert-border-color)}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-label{box-sizing:border-box;display:flex;height:48px;margin-right:0;overflow:hidden;position:relative;width:48px;z-index:1}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-label:not(.codicon){font-size:15px;line-height:40px;padding:0 0 0 48px}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-label.codicon{align-items:center;font-size:24px;justify-content:center}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item.active .action-label.codicon,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus .action-label.codicon,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:hover .action-label.codicon{color:var(--vscode-activityBar-foreground)!important}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item.active .action-label.uri-icon,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus .action-label.uri-icon,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:hover .action-label.uri-icon{background-color:var(--vscode-activityBar-foreground)!important}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item.checked .active-item-indicator:before,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus .active-item-indicator:before{border-left:2px solid;content:"";height:100%;position:absolute;top:0;width:0;z-index:1}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item.checked .active-item-indicator:before{height:100%;top:0}.monaco-workbench.hc-black .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item.checked:not(:focus) .active-item-indicator.action-item,.monaco-workbench.hc-light .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item.checked:not(:focus) .active-item-indicator{display:none}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item.clicked:focus:before{border-left:none!important}.monaco-workbench .activitybar.left>.content :not(.monaco-menu)>.monaco-action-bar .action-item .active-item-indicator:before{left:0}.monaco-workbench .activitybar.right>.content :not(.monaco-menu)>.monaco-action-bar .action-item .active-item-indicator:before{right:0}.monaco-workbench.hc-black .activitybar.left>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus:before,.monaco-workbench.hc-black .activitybar.right>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus:before,.monaco-workbench.hc-light .activitybar.left>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus:before,.monaco-workbench.hc-light .activitybar.right>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus:before{outline:none}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .active-item-indicator,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .badge,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .profile-badge{bottom:0;height:100%;left:0;margin:auto;overflow:hidden;position:absolute;top:0;width:100%}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .active-item-indicator,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .badge{z-index:2}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .profile-badge{z-index:1}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .active-item-indicator{pointer-events:none}.monaco-workbench.border .activitybar.right>.content :not(.monaco-menu)>.monaco-action-bar .active-item-indicator{left:-2px}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .badge .badge-content{border-radius:20px;font-size:9px;font-weight:600;height:16px;line-height:16px;min-width:8px;padding:0 4px;position:absolute;right:8px;text-align:center;top:24px}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .profile-badge .profile-badge-content{background-color:var(--vscode-profileBadge-background);border:2px solid var(--vscode-activityBar-background);border-radius:7px;color:var(--vscode-profileBadge-foreground);font-size:9px;font-weight:600;line-height:10px;padding:2px 3px;position:absolute;right:6px;top:24px}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:active .profile-badge-content,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus .profile-badge-content,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:hover .profile-badge-content{color:var(--vscode-activityBar-foreground)}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .badge .codicon.badge-content{font-size:12px;font-weight:unset;justify-content:center;padding:0}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .badge .codicon.badge-content:before{text-align:center;vertical-align:baseline}.monaco-workbench .activitybar.right>.content :not(.monaco-menu)>.monaco-action-bar .badge,.monaco-workbench .activitybar.right>.content :not(.monaco-menu)>.monaco-action-bar .profile-badge{left:auto;right:0}';
oe(_w, {});
var fo;
let ln = (fo = class extends Us {
  constructor(e, t, i, o, s) {
    super(e), this.paneCompositePart = t, this.layoutService = i, this.telemetryService = o, this.configurationService = s, this.lastRun = 0;
  }
  updateActivity(e) {
    this.activity = e;
  }
  async run(e) {
    if (e instanceof MouseEvent && e.button === 2)
      return;
    const t = Date.now();
    if (t > this.lastRun && t - this.lastRun < fo.preventDoubleClickDelay)
      return;
    this.lastRun = t;
    const i = this.layoutService.isVisible("workbench.parts.sidebar"), o = this.paneCompositePart.getActivePaneComposite(), s = this.configurationService.getValue("workbench.activityBar.iconClickBehavior"), n = e && "preserveFocus" in e ? !e.preserveFocus : !0;
    if (i && (o == null ? void 0 : o.getId()) === this.activity.id) {
      switch (s) {
        case "focus":
          this.logAction("refocus"), this.paneCompositePart.openPaneComposite(this.activity.id, n);
          break;
        case "toggle":
        default:
          this.logAction("hide"), this.layoutService.setPartHidden(!0, "workbench.parts.sidebar");
          break;
      }
      return;
    }
    return this.logAction("show"), await this.paneCompositePart.openPaneComposite(this.activity.id, n), this.activate();
  }
  logAction(e) {
    this.telemetryService.publicLog2("activityBarAction", { viewletId: this.activity.id, action: e });
  }
}, fo.preventDoubleClickDelay = 300, fo);
ln = y([
  l(2, Pe),
  l(3, Xe),
  l(4, x)
], ln);
let oa = class extends uw {
  constructor(e, t, i, o, s, n, r, a, d, h, g) {
    super(e, i, () => !0, o, s, d, g), this.contextMenuActionsProvider = t, this.menuService = n, this.contextMenuService = r, this.contextKeyService = a, this.environmentService = h;
  }
  render(e) {
    super.render(e), this._register(S(this.container, I.MOUSE_DOWN, async (t) => {
      U.stop(t, !0), (t == null ? void 0 : t.button) !== 2 && this.run();
    })), this._register(S(this.container, I.CONTEXT_MENU, async (t) => {
      const i = new Z(), o = await this.resolveContextMenuActions(i), s = new kt(t);
      this.contextMenuService.showContextMenu({
        getAnchor: () => s,
        getActions: () => o,
        onHide: () => i.dispose()
      });
    })), this._register(S(this.container, I.KEY_UP, (t) => {
      const i = new yt(t);
      (i.equals(3) || i.equals(10)) && (U.stop(t, !0), this.run());
    })), this._register(S(this.container, Ne.Tap, (t) => {
      U.stop(t, !0), this.run();
    }));
  }
  async resolveContextMenuActions(e) {
    return this.contextMenuActionsProvider();
  }
};
oa = y([
  l(3, z),
  l(4, Lt),
  l(5, lt),
  l(6, Ie),
  l(7, F),
  l(8, x),
  l(9, Tt),
  l(10, be)
], oa);
let hn = class extends oa {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m, C) {
    super(t, i, { draggable: !1, colors: s, icon: o, hasPopup: !0, hoverOptions: n }, r, a, d, h, g, p, m, C), this.menuId = e;
  }
  async run() {
    const e = new Z(), t = e.add(this.menuService.createMenu(this.menuId, this.contextKeyService)), i = await this.resolveMainMenuActions(t, e);
    this.contextMenuService.showContextMenu({
      getAnchor: () => this.container,
      anchorAlignment: this.configurationService.getValue("workbench.sideBar.location") === "left" ? 1 : 0,
      anchorAxisAlignment: 1,
      getActions: () => i,
      onHide: () => e.dispose(),
      menuActionOptions: { renderShortTitle: !0 }
    });
  }
  async resolveMainMenuActions(e, t) {
    const i = [];
    return ks(e, { renderShortTitle: !0 }, { primary: [], secondary: i }), i;
  }
};
hn = y([
  l(6, z),
  l(7, Lt),
  l(8, lt),
  l(9, Ie),
  l(10, F),
  l(11, x),
  l(12, Tt),
  l(13, be)
], hn);
var vo;
let Pi = (vo = class extends hn {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m, C, b, v, J, R) {
    super(k.AccountsContext, e, t, !0, i, o, s, n, a, r, d, m, g, b), this.authenticationService = h, this.productService = p, this.storageService = C, this.secretStorageService = v, this.credentialsService = J, this.logService = R, this.groupedAccounts = /* @__PURE__ */ new Map(), this.problematicProviders = /* @__PURE__ */ new Set(), this.initialized = !1, this.sessionFromEmbedder = Wp(this.credentialsService, this.secretStorageService, this.productService), this.registerListeners(), this.initialize();
  }
  registerListeners() {
    this._register(this.authenticationService.onDidRegisterAuthenticationProvider(async (e) => {
      await this.addAccountsFromProvider(e.id);
    })), this._register(this.authenticationService.onDidUnregisterAuthenticationProvider((e) => {
      this.groupedAccounts.delete(e.id), this.problematicProviders.delete(e.id);
    })), this._register(this.authenticationService.onDidChangeSessions(async (e) => {
      for (const t of [...e.event.changed, ...e.event.added])
        try {
          await this.addOrUpdateAccount(e.providerId, t.account);
        } catch (i) {
          this.logService.error(i);
        }
      for (const t of e.event.removed)
        this.removeAccount(e.providerId, t.account);
    }));
  }
  async initialize() {
    const e = this.authenticationService.getProviderIds(), t = await Promise.allSettled(e.map((i) => this.addAccountsFromProvider(i)));
    for (const i of t)
      i.status === "rejected" && this.logService.error(i.reason);
    this.initialized = !0;
  }
  async resolveMainMenuActions(e, t) {
    await super.resolveMainMenuActions(e, t);
    const i = this.authenticationService.getProviderIds(), o = e.getActions();
    let s = [];
    for (const n of i) {
      if (!this.initialized) {
        const d = t.add(new j("noAccountsAvailable", u("loading", "Loading..."), void 0, !1));
        s.push(d);
        break;
      }
      const r = this.authenticationService.getLabel(n), a = this.groupedAccounts.get(n);
      if (!a) {
        if (this.problematicProviders.has(n)) {
          const d = t.add(new j("providerUnavailable", u("authProviderUnavailable", "{0} is currently unavailable", r), void 0, !1));
          s.push(d);
          try {
            await this.addAccountsFromProvider(n);
          } catch (h) {
            this.logService.error(h);
          }
        }
        continue;
      }
      for (const d of a) {
        const g = [t.add(new j(`configureSessions${d.label}`, u("manageTrustedExtensions", "Manage Trusted Extensions"), void 0, !0, () => this.authenticationService.manageTrustedExtensionsForAccount(n, d.label)))];
        if (d.canSignOut) {
          const m = t.add(new j("signOut", u("signOut", "Sign Out"), void 0, !0, async () => {
            const b = (await this.authenticationService.getSessions(n)).filter((v) => v.account.id === d.id);
            return await this.authenticationService.removeAccountSessions(n, d.label, b);
          }));
          g.push(m);
        }
        const p = new ao(
          "activitybar.submenu",
          `${d.label} (${r})`,
          g
        );
        s.push(p);
      }
    }
    if (i.length && !s.length) {
      const n = t.add(new j("noAccountsAvailable", u("noAccounts", "You are not signed in to any accounts"), void 0, !1));
      s.push(n);
    }
    return s.length && o.length && s.push(new Qe()), o.forEach((n, r) => {
      const a = n[1];
      s = s.concat(a), r !== o.length - 1 && s.push(new Qe());
    }), s;
  }
  async resolveContextMenuActions(e) {
    const t = await super.resolveContextMenuActions(e);
    return t.unshift(we({ id: "hideAccounts", label: u("hideAccounts", "Hide Accounts"), run: () => this.storageService.store(vo.ACCOUNTS_VISIBILITY_PREFERENCE_KEY, !1, 0, 0) }), new Qe()), t;
  }
  async addOrUpdateAccount(e, t) {
    let i = this.groupedAccounts.get(e);
    if (i) {
      const n = i.find((r) => r.id === t.id);
      if (n) {
        n.label !== t.label && (n.label = t.label);
        return;
      }
    } else
      i = [], this.groupedAccounts.set(e, i);
    const o = await this.sessionFromEmbedder;
    let s = !!(o != null && o.canSignOut);
    s || (o != null && o.id ? s = !(await this.authenticationService.getSessions(e)).filter((r) => r.account.id === t.id).some((r) => r.id === o.id) : s = !0), i.push({ ...t, canSignOut: s });
  }
  removeAccount(e, t) {
    const i = this.groupedAccounts.get(e);
    if (!i)
      return;
    const o = i.findIndex((s) => s.id === t.id);
    o !== -1 && (i.splice(o, 1), i.length === 0 && this.groupedAccounts.delete(e));
  }
  async addAccountsFromProvider(e) {
    try {
      const t = await this.authenticationService.getSessions(e);
      this.problematicProviders.delete(e);
      for (const i of t)
        try {
          await this.addOrUpdateAccount(e, i.account);
        } catch (o) {
          this.logService.error(o);
        }
    } catch (t) {
      this.logService.error(t), this.problematicProviders.add(e);
    }
  }
}, vo.ACCOUNTS_VISIBILITY_PREFERENCE_KEY = "workbench.activity.showAccounts", vo);
Pi = y([
  l(4, z),
  l(5, Lt),
  l(6, Ie),
  l(7, lt),
  l(8, F),
  l(9, _p),
  l(10, Tt),
  l(11, lh),
  l(12, x),
  l(13, ee),
  l(14, be),
  l(15, Ep),
  l(16, Rp),
  l(17, rt)
], Pi);
let sa = class extends hn {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m) {
    super(k.GlobalActivity, e, t, !0, i, o, n, r, a, d, h, g, p, m), this.userDataProfileService = s, this._register(this.userDataProfileService.onDidChangeCurrentProfile(() => this.updateProfileBadge()));
  }
  render(e) {
    super.render(e), this.profileBadge = ae(e, Y(".profile-badge")), this.profileBadgeContent = ae(this.profileBadge, Y(".profile-badge-content")), this.updateProfileBadge();
  }
  updateProfileBadge() {
    !this.profileBadge || !this.profileBadgeContent || (Ut(this.profileBadgeContent), gi(this.profileBadge), !this.userDataProfileService.currentProfile.isDefault && (this.action.getBadge() || (this.profileBadgeContent.textContent = this.userDataProfileService.currentProfile.name.substring(0, 2).toUpperCase(), hi(this.profileBadge))));
  }
  updateBadge() {
    super.updateBadge(), this.updateProfileBadge();
  }
  computeTitle() {
    return this.userDataProfileService.currentProfile.isDefault ? super.computeTitle() : u(
      "manage",
      "Manage {0} (Profile)",
      this.userDataProfileService.currentProfile.name
    );
  }
};
sa = y([
  l(4, Gp),
  l(5, z),
  l(6, Lt),
  l(7, lt),
  l(8, Ie),
  l(9, F),
  l(10, x),
  l(11, Tt),
  l(12, be)
], sa);
class Ew extends ln {
}
class Ll extends Zd {
  constructor(e, t) {
    super({ id: e, name: e, classNames: void 0 }, t);
  }
  setActivity(e) {
    this.label = e.name;
  }
}
class Cg extends Wd {
  constructor(e, t) {
    super({ id: e, name: e, classNames: void 0 }, t);
  }
  setActivity(e) {
    this.label = e.name;
  }
}
class fg extends ye {
  constructor(e, t) {
    super(e), this.offset = t;
  }
  async run(e) {
    const t = e.get(ii), i = t.getVisiblePaneCompositeIds(0), o = t.getActivePaneComposite(0);
    if (!o)
      return;
    let s;
    for (let n = 0; n < i.length; n++)
      if (i[n] === o.getId()) {
        s = i[(n + i.length + this.offset) % i.length];
        break;
      }
    await t.openPaneComposite(s, 0, !0);
  }
}
P(class extends fg {
  constructor() {
    super({
      id: "workbench.action.previousSideBarView",
      title: { value: u("previousSideBarView", "Previous Primary Side Bar View"), original: "Previous Primary Side Bar View" },
      category: Ce.View,
      f1: !0
    }, -1);
  }
});
P(class extends fg {
  constructor() {
    super({
      id: "workbench.action.nextSideBarView",
      title: { value: u("nextSideBarView", "Next Primary Side Bar View"), original: "Next Primary Side Bar View" },
      category: Ce.View,
      f1: !0
    }, 1);
  }
});
P(class extends ye {
  constructor() {
    super({
      id: "workbench.action.focusActivityBar",
      title: { value: u("focusActivityBar", "Focus Activity Bar"), original: "Focus Activity Bar" },
      category: Ce.View,
      f1: !0
    });
  }
  async run(e) {
    const t = e.get(Pe);
    t.setPartHidden(!1, "workbench.parts.activitybar"), t.focusPart("workbench.parts.activitybar");
  }
});
Xc((c, e) => {
  const t = c.getColor(hh);
  t && e.addRule(`
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked .active-item-indicator:before {
				border-left-color: ${t};
			}
		`);
  const i = c.getColor(xp);
  i && e.addRule(`
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:focus::before {
				visibility: hidden;
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:focus .active-item-indicator:before {
				visibility: visible;
				border-left-color: ${i};
			}
		`);
  const o = c.getColor(uh);
  o && e.addRule(`
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked .active-item-indicator {
				z-index: 0;
				background-color: ${o};
			}
		`);
  const s = c.getColor(co);
  if (s)
    e.addRule(`
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item:before {
				content: "";
				position: absolute;
				top: 8px;
				left: 8px;
				height: 32px;
				width: 32px;
				z-index: 1;
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.profile-activity-item:before {
				top: -6px;
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.active:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.active:hover:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:hover:before {
				outline: 1px solid;
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item:hover:before {
				outline: 1px dashed;
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item:focus .active-item-indicator:before {
				border-left-color: ${s};
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.active:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.active:hover:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:hover:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item:hover:before {
				outline-color: ${s};
			}
		`);
  else {
    const n = c.getColor(Dp);
    n && e.addRule(`
				.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item:focus .active-item-indicator:before {
						border-left-color: ${n};
					}
				`);
  }
});
class vg {
  constructor(e, t, i, o, s) {
    this.viewDescriptorService = e, this.targetContainerLocation = t, this.openComposite = i, this.moveComposite = o, this.getItems = s;
  }
  drop(e, t, i, o) {
    const s = e.getData();
    if (s.type === "composite") {
      const n = this.viewDescriptorService.getViewContainerById(s.id);
      if (this.viewDescriptorService.getViewContainerLocation(n) === this.targetContainerLocation)
        t && this.moveComposite(s.id, t, o);
      else {
        if (this.viewDescriptorService.getViewContainerModel(n).allViewDescriptors.some((d) => !d.canMoveView))
          return;
        this.viewDescriptorService.moveViewContainerToLocation(n, this.targetContainerLocation, this.getTargetIndex(t, o));
      }
    }
    if (s.type === "view") {
      const n = this.viewDescriptorService.getViewDescriptorById(s.id);
      if (n && n.canMoveView) {
        this.viewDescriptorService.moveViewToLocation(n, this.targetContainerLocation);
        const r = this.viewDescriptorService.getViewContainerByViewId(n.id);
        t && this.moveComposite(r.id, t, o), this.openComposite(r.id, !0).then((a) => {
          a == null || a.openView(n.id, !0);
        });
      }
    }
  }
  onDragEnter(e, t, i) {
    return this.canDrop(e, t);
  }
  onDragOver(e, t, i) {
    return this.canDrop(e, t);
  }
  getTargetIndex(e, t) {
    if (!e)
      return;
    const i = this.getItems(), o = this.targetContainerLocation === 1 ? t == null ? void 0 : t.horizontallyBefore : t == null ? void 0 : t.verticallyBefore;
    return i.filter((s) => s.visible).findIndex((s) => s.id === e) + (o ? 0 : 1);
  }
  canDrop(e, t) {
    const i = e.getData();
    if (i.type === "composite") {
      const o = this.viewDescriptorService.getViewContainerById(i.id);
      return this.viewDescriptorService.getViewContainerLocation(o) === this.targetContainerLocation ? i.id !== t : !this.viewDescriptorService.getViewContainerModel(o).allViewDescriptors.some((r) => !r.canMoveView);
    } else {
      const o = this.viewDescriptorService.getViewDescriptorById(i.id);
      return !(!o || !o.canMoveView);
    }
  }
}
let un = class extends Bn {
  constructor(e, t, i, o, s) {
    super(), this.options = t, this.instantiationService = i, this.contextMenuService = o, this.viewDescriptorService = s, this._onDidChange = this._register(new w()), this.onDidChange = this._onDidChange.event, this.model = new Rw(e, t), this.visibleComposites = [], this.compositeSizeInBar = /* @__PURE__ */ new Map(), this.computeSizes(this.model.visibleItems);
  }
  getCompositeBarItems() {
    return [...this.model.items];
  }
  setCompositeBarItems(e) {
    this.model.setItems(e) && this.updateCompositeSwitcher();
  }
  getPinnedComposites() {
    return this.model.pinnedItems;
  }
  getVisibleComposites() {
    return this.model.visibleItems;
  }
  create(e) {
    const t = e.appendChild(Y(".composite-bar"));
    this.compositeSwitcherBar = this._register(new Ro(t, {
      actionViewItemProvider: (o) => {
        if (o instanceof Gl)
          return this.compositeOverflowActionViewItem;
        const s = this.model.findItem(o.id);
        return s && this.instantiationService.createInstance(gw, { draggable: !0, colors: this.options.colors, icon: this.options.icon, hoverOptions: this.options.activityHoverOptions }, o, s.pinnedAction, s.toggleBadgeAction, (n) => this.options.getContextMenuActionsForComposite(n), () => this.getContextMenuActions(), this.options.dndHandler, this);
      },
      orientation: this.options.orientation,
      ariaLabel: u("activityBarAriaLabel", "Active View Switcher"),
      ariaRole: "tablist",
      animated: !1,
      preventLoopNavigation: this.options.preventLoopNavigation,
      triggerKeys: { keyDown: !0 }
    })), this._register(S(e, I.CONTEXT_MENU, (o) => this.showContextMenu(o))), this._register(zt.addTarget(e)), this._register(S(e, Ne.Contextmenu, (o) => this.showContextMenu(o)));
    let i;
    return this._register(is.INSTANCE.registerTarget(e, {
      onDragOver: (o) => {
        const s = this.getVisibleComposites();
        if (!s.length || o.eventData.target && Nt(o.eventData.target, t)) {
          i = this.updateFromDragging(e, !1, !1, !0);
          return;
        }
        const n = this.insertAtFront(t, o.eventData), r = n ? s[0] : s[s.length - 1], a = this.options.dndHandler.onDragOver(o.dragAndDropData, r.id, o.eventData);
        gh(o.eventData.dataTransfer, "move", a), i = this.updateFromDragging(e, a, n, !0);
      },
      onDragLeave: (o) => {
        i = this.updateFromDragging(e, !1, !1, !1);
      },
      onDragEnd: (o) => {
        i = this.updateFromDragging(e, !1, !1, !1);
      },
      onDrop: (o) => {
        const s = this.getVisibleComposites();
        if (s.length) {
          const n = this.insertAtFront(t, o.eventData) ? s[0] : s[s.length - 1];
          this.options.dndHandler.drop(o.dragAndDropData, n.id, o.eventData, i);
        }
        i = this.updateFromDragging(e, !1, !1, !1);
      }
    })), t;
  }
  insertAtFront(e, t) {
    const i = e.getBoundingClientRect(), o = t.clientX, s = t.clientY;
    switch (this.options.orientation) {
      case 0:
        return o < i.left;
      case 1:
        return s < i.top;
    }
  }
  updateFromDragging(e, t, i, o) {
    if (e.classList.toggle("dragged-over", o), e.classList.toggle("dragged-over-head", t && i), e.classList.toggle("dragged-over-tail", t && !i), !!t)
      return { verticallyBefore: i, horizontallyBefore: i };
  }
  focus(e) {
    var t;
    (t = this.compositeSwitcherBar) == null || t.focus(e);
  }
  recomputeSizes() {
    this.computeSizes(this.model.visibleItems);
  }
  layout(e) {
    this.dimension = e, !(e.height === 0 || e.width === 0) && (this.compositeSizeInBar.size === 0 && this.computeSizes(this.model.visibleItems), this.updateCompositeSwitcher());
  }
  addComposite({ id: e, name: t, order: i, requestedIndex: o }) {
    this.model.add(e, t, i, o) && (this.computeSizes([this.model.findItem(e)]), this.updateCompositeSwitcher());
  }
  removeComposite(e) {
    this.isPinned(e) && this.unpin(e), this.model.remove(e) && this.updateCompositeSwitcher();
  }
  hideComposite(e) {
    this.model.hide(e) && (this.resetActiveComposite(e), this.updateCompositeSwitcher());
  }
  activateComposite(e) {
    const t = this.model.activeItem;
    this.model.activate(e) && (this.visibleComposites.indexOf(e) === -1 || this.model.activeItem && !this.model.activeItem.pinned || t && !t.pinned) && this.updateCompositeSwitcher();
  }
  deactivateComposite(e) {
    const t = this.model.activeItem;
    this.model.deactivate() && t && !t.pinned && this.updateCompositeSwitcher();
  }
  showActivity(e, t, i, o) {
    if (!t)
      throw Np("badge");
    typeof o != "number" && (o = 0);
    const s = { badge: t, clazz: i, priority: o };
    return this.model.addActivity(e, s), M(() => this.model.removeActivity(e, s));
  }
  async pin(e, t) {
    this.model.setPinned(e, !0) && (this.updateCompositeSwitcher(), t && (await this.options.openComposite(e), this.activateComposite(e)));
  }
  unpin(e) {
    this.model.setPinned(e, !1) && (this.updateCompositeSwitcher(), this.resetActiveComposite(e));
  }
  areBadgesEnabled(e) {
    return this.viewDescriptorService.getViewContainerBadgeEnablementState(e);
  }
  toggleBadgeEnablement(e) {
    this.viewDescriptorService.setViewContainerBadgeEnablementState(e, !this.areBadgesEnabled(e)), this.updateCompositeSwitcher();
    const t = this.model.findItem(e);
    t && t.activityAction.setBadge(t.activityAction.getBadge(), t.activityAction.getClass());
  }
  resetActiveComposite(e) {
    const t = this.options.getDefaultCompositeId();
    !this.model.activeItem || this.model.activeItem.id !== e || (this.deactivateComposite(e), t && t !== e && this.isPinned(t) ? this.options.openComposite(t, !0) : this.options.openComposite(this.visibleComposites.filter((i) => i !== e)[0]));
  }
  isPinned(e) {
    const t = this.model.findItem(e);
    return t == null ? void 0 : t.pinned;
  }
  move(e, t, i) {
    if (i !== void 0) {
      const o = this.model.items.findIndex((n) => n.id === e);
      let s = this.model.items.findIndex((n) => n.id === t);
      o >= 0 && s >= 0 && (!i && o > s && s++, i && o < s && s--, s < this.model.items.length && s >= 0 && s !== o && this.model.move(this.model.items[o].id, this.model.items[s].id) && setTimeout(() => this.updateCompositeSwitcher(), 0));
    } else
      this.model.move(e, t) && setTimeout(() => this.updateCompositeSwitcher(), 0);
  }
  getAction(e) {
    const t = this.model.findItem(e);
    return t == null ? void 0 : t.activityAction;
  }
  computeSizes(e) {
    const t = this.options.compositeSize;
    if (t)
      e.forEach((i) => this.compositeSizeInBar.set(i.id, t));
    else {
      const i = this.compositeSwitcherBar;
      if (i && this.dimension && this.dimension.height !== 0 && this.dimension.width !== 0) {
        const o = i.viewItems.length;
        i.push(e.map((s) => s.activityAction)), e.forEach((s, n) => this.compositeSizeInBar.set(s.id, this.options.orientation === 1 ? i.getHeight(o + n) : i.getWidth(o + n))), e.forEach(() => i.pull(i.viewItems.length - 1));
      }
    }
  }
  updateCompositeSwitcher() {
    var a, d;
    const e = this.compositeSwitcherBar;
    if (!e || !this.dimension)
      return;
    let t = this.model.visibleItems.filter((h) => h.pinned || this.model.activeItem && this.model.activeItem.id === h.id).map((h) => h.id), i = t.length;
    const o = t.length;
    let s = 0;
    const n = this.options.orientation === 1 ? this.dimension.height : this.dimension.width;
    for (let h = 0; h < t.length; h++) {
      const g = this.compositeSizeInBar.get(t[h]);
      if (s + g > n) {
        i = h;
        break;
      }
      s += g;
    }
    for (o > i && (t = t.slice(0, i)), this.model.activeItem && t.every((h) => !!this.model.activeItem && h !== this.model.activeItem.id) && (s += this.compositeSizeInBar.get(this.model.activeItem.id), t.push(this.model.activeItem.id)); s > n && t.length; ) {
      const h = t.length > 1 ? t.splice(t.length - 2, 1)[0] : t.pop();
      s -= this.compositeSizeInBar.get(h);
    }
    for (o > t.length && (s += this.options.overflowActionSize); s > n && t.length; ) {
      const h = t.length > 1 && t[t.length - 1] === ((a = this.model.activeItem) == null ? void 0 : a.id) ? t.splice(t.length - 2, 1)[0] : t.pop();
      s -= this.compositeSizeInBar.get(h);
    }
    o === t.length && this.compositeOverflowAction && (e.pull(e.length() - 1), this.compositeOverflowAction.dispose(), this.compositeOverflowAction = void 0, (d = this.compositeOverflowActionViewItem) == null || d.dispose(), this.compositeOverflowActionViewItem = void 0);
    const r = [];
    this.visibleComposites.forEach((h, g) => {
      t.includes(h) || r.push(g);
    }), r.reverse().forEach((h) => {
      const g = e.viewItems[h];
      e.pull(h), g.dispose(), this.visibleComposites.splice(h, 1);
    }), t.forEach((h, g) => {
      const p = this.visibleComposites.indexOf(h);
      if (g !== p) {
        if (p !== -1) {
          const m = e.viewItems[p];
          e.pull(p), m.dispose(), this.visibleComposites.splice(p, 1);
        }
        e.push(this.model.findItem(h).activityAction, { label: !0, icon: this.options.icon, index: g }), this.visibleComposites.splice(g, 0, h);
      }
    }), o > t.length && !this.compositeOverflowAction && (this.compositeOverflowAction = this.instantiationService.createInstance(Gl, () => {
      var h;
      (h = this.compositeOverflowActionViewItem) == null || h.showMenu();
    }), this.compositeOverflowActionViewItem = this.instantiationService.createInstance(pw, this.compositeOverflowAction, () => this.getOverflowingComposites(), () => this.model.activeItem ? this.model.activeItem.id : void 0, (h) => {
      var p;
      const g = this.model.findItem(h);
      return (p = g == null ? void 0 : g.activity[0]) == null ? void 0 : p.badge;
    }, this.options.getOnCompositeClickAction, this.options.colors, this.options.activityHoverOptions), e.push(this.compositeOverflowAction, { label: !1, icon: !0 })), this._onDidChange.fire();
  }
  getOverflowingComposites() {
    let e = this.model.visibleItems.filter((t) => t.pinned).map((t) => t.id);
    return this.model.activeItem && !this.model.activeItem.pinned && e.push(this.model.activeItem.id), e = e.filter((t) => !this.visibleComposites.includes(t)), this.model.visibleItems.filter((t) => e.includes(t.id)).map(
      (t) => {
        var i;
        return { id: t.id, name: ((i = this.getAction(t.id)) == null ? void 0 : i.label) || t.name };
      }
    );
  }
  showContextMenu(e) {
    U.stop(e, !0);
    const t = new kt(e);
    this.contextMenuService.showContextMenu({
      getAnchor: () => t,
      getActions: () => this.getContextMenuActions(e)
    });
  }
  getContextMenuActions(e) {
    return this.model.visibleItems.map(({ id: i, name: o, activityAction: s }) => we({
      id: i,
      label: this.getAction(i).label || o || i,
      checked: this.isPinned(i),
      enabled: s.enabled,
      run: () => {
        this.isPinned(i) ? this.unpin(i) : this.pin(i, !0);
      }
    }));
  }
};
un = y([
  l(2, W),
  l(3, Ie),
  l(4, Me)
], un);
class Rw {
  get items() {
    return this._items;
  }
  constructor(e, t) {
    this._items = [], this.options = t, this.setItems(e);
  }
  setItems(e) {
    const t = [];
    let i = !1;
    if (!this.items || this.items.length === 0)
      this._items = e.map(
        (o) => this.createCompositeBarItem(o.id, o.name, o.order, o.pinned, o.visible)
      ), i = !0;
    else {
      const o = this.items;
      for (let s = 0; s < e.length; s++) {
        const n = e[s], r = o.filter(({ id: a }) => a === n.id)[0];
        r ? r.pinned !== n.pinned || s !== o.indexOf(r) ? (r.pinned = n.pinned, t.push(r), i = !0) : t.push(r) : (t.push(this.createCompositeBarItem(n.id, n.name, n.order, n.pinned, n.visible)), i = !0);
      }
      this._items = t;
    }
    return i;
  }
  get visibleItems() {
    return this.items.filter((e) => e.visible);
  }
  get pinnedItems() {
    return this.items.filter((e) => e.visible && e.pinned);
  }
  createCompositeBarItem(e, t, i, o, s) {
    const n = this.options;
    return {
      id: e,
      name: t,
      pinned: o,
      order: i,
      visible: s,
      activity: [],
      get activityAction() {
        return n.getActivityAction(e);
      },
      get pinnedAction() {
        return n.getCompositePinnedAction(e);
      },
      get toggleBadgeAction() {
        return n.getCompositeBadgeAction(e);
      }
    };
  }
  add(e, t, i, o) {
    const s = this.findItem(e);
    if (s) {
      let n = !1;
      return s.name = t, tt(i) || (n = s.order !== i, s.order = i), s.visible || (s.visible = !0, n = !0), n;
    } else {
      const n = this.createCompositeBarItem(e, t, i, !0, !0);
      if (tt(o))
        if (tt(i))
          this.items.push(n);
        else {
          let r = 0;
          for (; r < this.items.length && typeof this.items[r].order == "number" && this.items[r].order < i; )
            r++;
          this.items.splice(r, 0, n);
        }
      else {
        let r = 0, a = o;
        for (; a > 0 && r < this.items.length; )
          this.items[r++].visible && a--;
        this.items.splice(r, 0, n);
      }
      return !0;
    }
  }
  remove(e) {
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].id === e)
        return this.items.splice(t, 1), !0;
    return !1;
  }
  hide(e) {
    for (const t of this.items)
      if (t.id === e)
        return t.visible ? (t.visible = !1, !0) : !1;
    return !1;
  }
  move(e, t) {
    const i = this.findIndex(e), o = this.findIndex(t);
    if (i === -1 || o === -1)
      return !1;
    const s = this.items.splice(i, 1)[0];
    return this.items.splice(o, 0, s), s.pinned = !0, !0;
  }
  setPinned(e, t) {
    for (const i of this.items)
      if (i.id === e)
        return i.pinned !== t ? (i.pinned = t, !0) : !1;
    return !1;
  }
  addActivity(e, t) {
    const i = this.findItem(e);
    if (i) {
      const o = i.activity;
      for (let s = 0; s <= o.length; s++)
        if (s === o.length) {
          o.push(t);
          break;
        } else if (o[s].priority <= t.priority) {
          o.splice(s, 0, t);
          break;
        }
      return this.updateActivity(e), !0;
    }
    return !1;
  }
  removeActivity(e, t) {
    const i = this.findItem(e);
    if (i) {
      const o = i.activity.indexOf(t);
      if (o !== -1)
        return i.activity.splice(o, 1), this.updateActivity(e), !0;
    }
    return !1;
  }
  updateActivity(e) {
    const t = this.findItem(e);
    if (t)
      if (t.activity.length) {
        const [{ badge: i, clazz: o }] = t.activity;
        t.activityAction.setBadge(i, o);
      } else
        t.activityAction.setBadge(void 0);
  }
  activate(e) {
    if (!this.activeItem || this.activeItem.id !== e) {
      this.activeItem && this.deactivate();
      for (const t of this.items)
        if (t.id === e)
          return this.activeItem = t, this.activeItem.activityAction.activate(), !0;
    }
    return !1;
  }
  deactivate() {
    return this.activeItem ? (this.activeItem.activityAction.deactivate(), this.activeItem = void 0, !0) : !1;
  }
  findItem(e) {
    return this.items.filter((t) => t.id === e)[0];
  }
  findIndex(e) {
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].id === e)
        return t;
    return -1;
  }
}
var Gw = ".monaco-workbench .menubar .toolbar-toggle-more,.monaco-workbench .menubar>.menubar-menu-button{color:var(--vscode-titleBar-activeForeground)}.monaco-workbench .activitybar .menubar.compact .toolbar-toggle-more,.monaco-workbench .activitybar .menubar.compact>.menubar-menu-button{color:var(--vscode-activityBar-inactiveForeground)}.monaco-workbench .activitybar .menubar.compact:not(:focus-within)>.menubar-menu-button:hover,.monaco-workbench .activitybar .menubar.compact:not(:focus-within)>.menubar-menu-button:hover .toolbar-toggle-more,.monaco-workbench .activitybar .menubar.compact>.menubar-menu-button.open,.monaco-workbench .activitybar .menubar.compact>.menubar-menu-button.open .toolbar-toggle-more,.monaco-workbench .activitybar .menubar.compact>.menubar-menu-button:focus,.monaco-workbench .activitybar .menubar.compact>.menubar-menu-button:focus .toolbar-toggle-more{color:var(--vscode-activityBar-foreground)}.monaco-workbench .menubar.inactive:not(.compact)>.menubar-menu-button,.monaco-workbench .menubar.inactive:not(.compact)>.menubar-menu-button .toolbar-toggle-more{color:var(--vscode-titleBar-inactiveForeground)}.monaco-workbench .menubar:not(.compact)>.menubar-menu-button.open,.monaco-workbench .menubar:not(.compact)>.menubar-menu-button.open .toolbar-toggle-more,.monaco-workbench .menubar:not(.compact)>.menubar-menu-button:focus,.monaco-workbench .menubar:not(.compact)>.menubar-menu-button:focus .toolbar-toggle-more,.monaco-workbench .menubar:not(:focus-within):not(.compact)>.menubar-menu-button:hover,.monaco-workbench .menubar:not(:focus-within):not(.compact)>.menubar-menu-button:hover .toolbar-toggle-more{color:var(--vscode-menubar-selectionForeground)}.monaco-workbench .menubar:not(.compact)>.menubar-menu-button.open .menubar-menu-title,.monaco-workbench .menubar:not(.compact)>.menubar-menu-button:focus .menubar-menu-title,.monaco-workbench .menubar:not(:focus-within):not(.compact)>.menubar-menu-button:hover .menubar-menu-title{background-color:var(--vscode-menubar-selectionBackground)}.monaco-workbench .menubar>.menubar-menu-button:hover .menubar-menu-title{outline:dashed 1px var(--vscode-menubar-selectionBorder)}.monaco-workbench .menubar>.menubar-menu-button.open .menubar-menu-title,.monaco-workbench .menubar>.menubar-menu-button:focus .menubar-menu-title{outline:solid 1px var(--vscode-menubar-selectionBorder)}.monaco-workbench .menubar>.menubar-menu-button.open .menubar-menu-title,.monaco-workbench .menubar>.menubar-menu-button:focus .menubar-menu-title,.monaco-workbench .menubar>.menubar-menu-button:hover .menubar-menu-title{outline-color:var(--vscode-menubar-selectionBorder);outline-offset:-1px}";
oe(Gw, {});
var xw = '.menubar{box-sizing:border-box;display:flex;flex-shrink:1;height:100%;overflow:hidden}.menubar.overflow-menu-only{width:38px}.fullscreen .menubar:not(.compact){margin:0;padding:4px 5px}.menubar>.menubar-menu-button{-webkit-app-region:no-drag;zoom:1;align-items:center;box-sizing:border-box;cursor:default;display:flex;outline:0!important;white-space:nowrap}.monaco-workbench .menubar:not(.compact)>.menubar-menu-button:focus .menubar-menu-title{outline-color:var(--vscode-focusBorder);outline-offset:-1px;outline-style:solid;outline-width:1px}.menubar.compact{flex-shrink:0;overflow:visible}.menubar.compact>.menubar-menu-button{height:100%;padding:0;width:100%}.menubar-menu-title{border-radius:5px;padding:0 8px}.menubar .menubar-menu-items-holder{left:0;opacity:1;position:fixed;z-index:2000}.menubar.compact .menubar-menu-items-holder{position:fixed}.menubar .menubar-menu-items-holder.monaco-menu-container{border:none;outline:0}.menubar .menubar-menu-items-holder.monaco-menu-container :focus{outline:0}.menubar .toolbar-toggle-more{align-items:center;display:flex;height:22px;justify-content:center;padding:0 8px;vertical-align:sub;width:22px}.menubar.compact .toolbar-toggle-more{align-items:center;cursor:pointer;display:flex;justify-content:center;left:0;position:relative;top:0;width:100%}.menubar.compact .toolbar-toggle-more:before,.menubar:not(.compact) .menubar-menu-button:first-child .toolbar-toggle-more:before{content:"\\eb94"!important}.menubar.compact>.menubar-menu-button.open .menubar-menu-title,.menubar.compact>.menubar-menu-button:focus .menubar-menu-title,.menubar.compact>.menubar-menu-button:hover .menubar-menu-title{outline-offset:-8px!important;outline-width:1px!important}';
oe(xw, {});
const Ki = Y;
var fe;
(function(c) {
  c[c.HIDDEN = 0] = "HIDDEN", c[c.VISIBLE = 1] = "VISIBLE", c[c.FOCUSED = 2] = "FOCUSED", c[c.OPEN = 3] = "OPEN";
})(fe || (fe = {}));
const ue = class ue extends E {
  constructor(e, t, i) {
    super(), this.container = e, this.options = t, this.menuStyle = i, this._mnemonicsInUse = !1, this.openedViaKeyboard = !1, this.awaitingAltRelease = !1, this.ignoreNextMouseUp = !1, this.updatePending = !1, this.numMenusShown = 0, this.overflowLayoutScheduled = void 0, this.container.setAttribute("role", "menubar"), this.isCompact && this.container.classList.add("compact"), this.menus = [], this.mnemonics = /* @__PURE__ */ new Map(), this._focusState = fe.VISIBLE, this._onVisibilityChange = this._register(new w()), this._onFocusStateChange = this._register(new w()), this.createOverflowMenu(), this.menuUpdater = this._register(new Ss(() => this.update(), 200)), this.actionRunner = this.options.actionRunner ?? this._register(new Tn()), this._register(this.actionRunner.onWillRun(() => {
      this.setUnfocusedState();
    })), this._register(Qp.getInstance().event(this.onModifierKeyToggled, this)), this._register(S(this.container, I.KEY_DOWN, (o) => {
      const s = new yt(o);
      let n = !0;
      const r = o.key ? o.key.toLocaleLowerCase() : "", a = Ze && !this.isCompact;
      if (s.equals(15) || a && s.equals(1026))
        this.focusPrevious();
      else if (s.equals(17) || a && s.equals(2))
        this.focusNext();
      else if (s.equals(9) && this.isFocused && !this.isOpen)
        this.setUnfocusedState();
      else if (!this.isOpen && !s.ctrlKey && this.options.enableMnemonics && this.mnemonicsInUse && this.mnemonics.has(r)) {
        const d = this.mnemonics.get(r);
        this.onMenuTriggered(d, !1);
      } else
        n = !1;
      !this.isCompact && (s.equals(1026) || s.equals(2)) && s.preventDefault(), n && (s.preventDefault(), s.stopPropagation());
    })), this._register(S(window, I.MOUSE_DOWN, () => {
      this.isFocused && this.setUnfocusedState();
    })), this._register(S(this.container, I.FOCUS_IN, (o) => {
      const s = o;
      s.relatedTarget && (this.container.contains(s.relatedTarget) || (this.focusToReturn = s.relatedTarget));
    })), this._register(S(this.container, I.FOCUS_OUT, (o) => {
      const s = o;
      s.relatedTarget ? s.relatedTarget && !this.container.contains(s.relatedTarget) && (this.focusToReturn = void 0, this.setUnfocusedState()) : this.setUnfocusedState();
    })), this._register(S(window, I.KEY_DOWN, (o) => {
      if (!this.options.enableMnemonics || !o.altKey || o.ctrlKey || o.defaultPrevented)
        return;
      const s = o.key.toLocaleLowerCase();
      if (!this.mnemonics.has(s))
        return;
      this.mnemonicsInUse = !0, this.updateMnemonicVisibility(!0);
      const n = this.mnemonics.get(s);
      this.onMenuTriggered(n, !1);
    })), this.setUnfocusedState();
  }
  push(e) {
    Xp(e).forEach((i) => {
      const o = this.menus.length, s = zd(i.label), n = Ud.exec(i.label);
      if (n) {
        const r = n[1] ? n[1] : n[3];
        this.registerMnemonic(this.menus.length, r);
      }
      if (this.isCompact)
        this.menus.push(i);
      else {
        const r = Ki("div.menubar-menu-button", { role: "menuitem", tabindex: -1, "aria-label": s, "aria-haspopup": !0 }), a = Ki("div.menubar-menu-title", { role: "none", "aria-hidden": !0 });
        r.appendChild(a), this.container.insertBefore(r, this.overflowMenu.buttonElement), this.updateLabels(a, r, i.label), this._register(S(r, I.KEY_UP, (d) => {
          const h = new yt(d);
          let g = !0;
          (h.equals(18) || h.equals(3)) && !this.isOpen ? (this.focusedMenu = { index: o }, this.openedViaKeyboard = !0, this.focusState = fe.OPEN) : g = !1, g && (h.preventDefault(), h.stopPropagation());
        })), this._register(zt.addTarget(r)), this._register(S(r, Ne.Tap, (d) => {
          this.isOpen && this.focusedMenu && this.focusedMenu.holder && Nt(d.initialTarget, this.focusedMenu.holder) || (this.ignoreNextMouseUp = !1, this.onMenuTriggered(o, !0), d.preventDefault(), d.stopPropagation());
        })), this._register(S(r, I.MOUSE_DOWN, (d) => {
          if (!new kt(d).leftButton) {
            d.preventDefault();
            return;
          }
          this.isOpen ? this.ignoreNextMouseUp = !1 : (this.ignoreNextMouseUp = !0, this.onMenuTriggered(o, !0)), d.preventDefault(), d.stopPropagation();
        })), this._register(S(r, I.MOUSE_UP, (d) => {
          d.defaultPrevented || (this.ignoreNextMouseUp ? this.ignoreNextMouseUp = !1 : this.isFocused && this.onMenuTriggered(o, !0));
        })), this._register(S(r, I.MOUSE_ENTER, () => {
          this.isOpen && !this.isCurrentMenu(o) ? (r.focus(), this.cleanupCustomMenu(), this.showCustomMenu(o, !1)) : this.isFocused && !this.isOpen && (this.focusedMenu = { index: o }, r.focus());
        })), this.menus.push({
          label: i.label,
          actions: i.actions,
          buttonElement: r,
          titleElement: a
        });
      }
    });
  }
  createOverflowMenu() {
    const e = this.isCompact ? u("mAppMenu", "Application Menu") : u("mMore", "More"), t = Ki("div.menubar-menu-button", { role: "menuitem", tabindex: this.isCompact ? 0 : -1, "aria-label": e, "aria-haspopup": !0 }), i = Ki("div.menubar-menu-title.toolbar-toggle-more" + pe.asCSSSelector(he.menuBarMore), { role: "none", "aria-hidden": !0 });
    t.appendChild(i), this.container.appendChild(t), t.style.visibility = "hidden", this._register(S(t, I.KEY_UP, (o) => {
      const s = new yt(o);
      let n = !0;
      const r = [3];
      this.isCompact ? (r.push(10), this.options.compactMode === ki.Right ? r.push(17) : this.options.compactMode === ki.Left && r.push(15)) : r.push(18), r.some((a) => s.equals(a)) && !this.isOpen ? (this.focusedMenu = { index: ue.OVERFLOW_INDEX }, this.openedViaKeyboard = !0, this.focusState = fe.OPEN) : n = !1, n && (s.preventDefault(), s.stopPropagation());
    })), this._register(zt.addTarget(t)), this._register(S(t, Ne.Tap, (o) => {
      this.isOpen && this.focusedMenu && this.focusedMenu.holder && Nt(o.initialTarget, this.focusedMenu.holder) || (this.ignoreNextMouseUp = !1, this.onMenuTriggered(ue.OVERFLOW_INDEX, !0), o.preventDefault(), o.stopPropagation());
    })), this._register(S(t, I.MOUSE_DOWN, (o) => {
      if (!new kt(o).leftButton) {
        o.preventDefault();
        return;
      }
      this.isOpen ? this.ignoreNextMouseUp = !1 : (this.ignoreNextMouseUp = !0, this.onMenuTriggered(ue.OVERFLOW_INDEX, !0)), o.preventDefault(), o.stopPropagation();
    })), this._register(S(t, I.MOUSE_UP, (o) => {
      o.defaultPrevented || (this.ignoreNextMouseUp ? this.ignoreNextMouseUp = !1 : this.isFocused && this.onMenuTriggered(ue.OVERFLOW_INDEX, !0));
    })), this._register(S(t, I.MOUSE_ENTER, () => {
      this.isOpen && !this.isCurrentMenu(ue.OVERFLOW_INDEX) ? (this.overflowMenu.buttonElement.focus(), this.cleanupCustomMenu(), this.showCustomMenu(ue.OVERFLOW_INDEX, !1)) : this.isFocused && !this.isOpen && (this.focusedMenu = { index: ue.OVERFLOW_INDEX }, t.focus());
    })), this.overflowMenu = {
      buttonElement: t,
      titleElement: i,
      label: "More",
      actions: []
    };
  }
  updateMenu(e) {
    const t = this.menus.filter((i) => i.label === e.label);
    t && t.length && (t[0].actions = e.actions);
  }
  dispose() {
    super.dispose(), this.menus.forEach((e) => {
      var t, i;
      (t = e.titleElement) == null || t.remove(), (i = e.buttonElement) == null || i.remove();
    }), this.overflowMenu.titleElement.remove(), this.overflowMenu.buttonElement.remove(), le(this.overflowLayoutScheduled), this.overflowLayoutScheduled = void 0;
  }
  blur() {
    this.setUnfocusedState();
  }
  getWidth() {
    if (!this.isCompact && this.menus) {
      const e = this.menus[0].buttonElement.getBoundingClientRect().left;
      return (this.hasOverflow ? this.overflowMenu.buttonElement.getBoundingClientRect().right : this.menus[this.menus.length - 1].buttonElement.getBoundingClientRect().right) - e;
    }
    return 0;
  }
  getHeight() {
    return this.container.clientHeight;
  }
  toggleFocus() {
    !this.isFocused && this.options.visibility !== "hidden" ? (this.mnemonicsInUse = !0, this.focusedMenu = { index: this.numMenusShown > 0 ? 0 : ue.OVERFLOW_INDEX }, this.focusState = fe.FOCUSED) : this.isOpen || this.setUnfocusedState();
  }
  updateOverflowAction() {
    var r, a;
    if (!this.menus || !this.menus.length)
      return;
    const e = "overflow-menu-only";
    this.container.classList.toggle(e, !1);
    const t = this.container.offsetWidth;
    let i = 0, o = this.isCompact;
    const s = this.numMenusShown;
    this.numMenusShown = 0;
    const n = this.menus.filter((d) => d.buttonElement !== void 0 && d.titleElement !== void 0);
    for (const d of n) {
      if (!o) {
        const h = d.buttonElement.offsetWidth;
        i + h > t ? o = !0 : (i += h, this.numMenusShown++, this.numMenusShown > s && (d.buttonElement.style.visibility = "visible"));
      }
      o && (d.buttonElement.style.visibility = "hidden");
    }
    if (this.numMenusShown - 1 <= n.length / 2) {
      for (const d of n)
        d.buttonElement.style.visibility = "hidden";
      o = !0, this.numMenusShown = 0, i = 0;
    }
    if (this.isCompact) {
      this.overflowMenu.actions = [];
      for (let h = this.numMenusShown; h < this.menus.length; h++)
        this.overflowMenu.actions.push(new ao(
          `menubar.submenu.${this.menus[h].label}`,
          this.menus[h].label,
          this.menus[h].actions || []
        ));
      const d = (a = (r = this.options).getCompactMenuActions) == null ? void 0 : a.call(r);
      d && d.length && (this.overflowMenu.actions.push(new Qe()), this.overflowMenu.actions.push(...d)), this.overflowMenu.buttonElement.style.visibility = "visible";
    } else if (o) {
      for (; i + this.overflowMenu.buttonElement.offsetWidth > t && this.numMenusShown > 0; ) {
        this.numMenusShown--;
        const d = n[this.numMenusShown].buttonElement.offsetWidth;
        n[this.numMenusShown].buttonElement.style.visibility = "hidden", i -= d;
      }
      this.overflowMenu.actions = [];
      for (let d = this.numMenusShown; d < n.length; d++)
        this.overflowMenu.actions.push(new ao(
          `menubar.submenu.${n[d].label}`,
          n[d].label,
          n[d].actions || []
        ));
      this.overflowMenu.buttonElement.nextElementSibling !== n[this.numMenusShown].buttonElement && (this.overflowMenu.buttonElement.remove(), this.container.insertBefore(this.overflowMenu.buttonElement, n[this.numMenusShown].buttonElement)), this.overflowMenu.buttonElement.style.visibility = "visible";
    } else
      this.overflowMenu.buttonElement.remove(), this.container.appendChild(this.overflowMenu.buttonElement), this.overflowMenu.buttonElement.style.visibility = "hidden";
    this.container.classList.toggle(e, this.numMenusShown === 0);
  }
  updateLabels(e, t, i) {
    const o = zd(i);
    if (this.options.enableMnemonics) {
      const n = Ap(i);
      nr.lastIndex = 0;
      let r = nr.exec(n);
      for (; r && r[1]; )
        r = nr.exec(n);
      const a = (d) => d.replace(/&amp;&amp;/g, "&amp;");
      r ? (e.innerText = "", e.append(Bp(a(n.substr(0, r.index)), " "), Ki("mnemonic", { "aria-hidden": "true" }, r[3]), Tp(a(n.substr(r.index + r[0].length)), " "))) : e.innerText = a(n).trim();
    } else
      e.innerText = o.replace(/&&/g, "&");
    const s = Ud.exec(i);
    if (s) {
      const n = s[1] ? s[1] : s[3];
      this.options.enableMnemonics ? t.setAttribute("aria-keyshortcuts", "Alt+" + n.toLocaleLowerCase()) : t.removeAttribute("aria-keyshortcuts");
    }
  }
  update(e) {
    if (e && (this.options = e), this.isFocused) {
      this.updatePending = !0;
      return;
    }
    this.menus.forEach((t) => {
      !t.buttonElement || !t.titleElement || this.updateLabels(t.titleElement, t.buttonElement, t.label);
    }), this.overflowLayoutScheduled || (this.overflowLayoutScheduled = Zr(() => {
      this.updateOverflowAction(), this.overflowLayoutScheduled = void 0;
    })), this.setUnfocusedState();
  }
  registerMnemonic(e, t) {
    this.mnemonics.set(t.toLocaleLowerCase(), e);
  }
  hideMenubar() {
    this.container.style.display !== "none" && (this.container.style.display = "none", this._onVisibilityChange.fire(!1));
  }
  showMenubar() {
    this.container.style.display !== "flex" && (this.container.style.display = "flex", this._onVisibilityChange.fire(!0), this.updateOverflowAction());
  }
  get focusState() {
    return this._focusState;
  }
  set focusState(e) {
    var s, n;
    if (this._focusState >= fe.FOCUSED && e < fe.FOCUSED && this.updatePending && (this.menuUpdater.schedule(), this.updatePending = !1), e === this._focusState)
      return;
    const t = this.isVisible, i = this.isOpen, o = this.isFocused;
    switch (this._focusState = e, e) {
      case fe.HIDDEN:
        t && this.hideMenubar(), i && this.cleanupCustomMenu(), o && (this.focusedMenu = void 0, this.focusToReturn && (this.focusToReturn.focus(), this.focusToReturn = void 0));
        break;
      case fe.VISIBLE:
        t || this.showMenubar(), i && this.cleanupCustomMenu(), o && (this.focusedMenu && (this.focusedMenu.index === ue.OVERFLOW_INDEX ? this.overflowMenu.buttonElement.blur() : (s = this.menus[this.focusedMenu.index].buttonElement) == null || s.blur()), this.focusedMenu = void 0, this.focusToReturn && (this.focusToReturn.focus(), this.focusToReturn = void 0));
        break;
      case fe.FOCUSED:
        t || this.showMenubar(), i && this.cleanupCustomMenu(), this.focusedMenu && (this.focusedMenu.index === ue.OVERFLOW_INDEX ? this.overflowMenu.buttonElement.focus() : (n = this.menus[this.focusedMenu.index].buttonElement) == null || n.focus());
        break;
      case fe.OPEN:
        t || this.showMenubar(), this.focusedMenu && this.showCustomMenu(this.focusedMenu.index, this.openedViaKeyboard);
        break;
    }
    this._focusState = e, this._onFocusStateChange.fire(this.focusState >= fe.FOCUSED);
  }
  get isVisible() {
    return this.focusState >= fe.VISIBLE;
  }
  get isFocused() {
    return this.focusState >= fe.FOCUSED;
  }
  get isOpen() {
    return this.focusState >= fe.OPEN;
  }
  get hasOverflow() {
    return this.isCompact || this.numMenusShown < this.menus.length;
  }
  get isCompact() {
    return this.options.compactMode !== void 0;
  }
  setUnfocusedState() {
    this.options.visibility === "toggle" || this.options.visibility === "hidden" ? this.focusState = fe.HIDDEN : this.options.visibility === "classic" && ph() ? this.focusState = fe.HIDDEN : this.focusState = fe.VISIBLE, this.ignoreNextMouseUp = !1, this.mnemonicsInUse = !1, this.updateMnemonicVisibility(!1);
  }
  focusPrevious() {
    var t;
    if (!this.focusedMenu || this.numMenusShown === 0)
      return;
    let e = (this.focusedMenu.index - 1 + this.numMenusShown) % this.numMenusShown;
    this.focusedMenu.index === ue.OVERFLOW_INDEX ? e = this.numMenusShown - 1 : this.focusedMenu.index === 0 && this.hasOverflow && (e = ue.OVERFLOW_INDEX), e !== this.focusedMenu.index && (this.isOpen ? (this.cleanupCustomMenu(), this.showCustomMenu(e)) : this.isFocused && (this.focusedMenu.index = e, e === ue.OVERFLOW_INDEX ? this.overflowMenu.buttonElement.focus() : (t = this.menus[e].buttonElement) == null || t.focus()));
  }
  focusNext() {
    var t;
    if (!this.focusedMenu || this.numMenusShown === 0)
      return;
    let e = (this.focusedMenu.index + 1) % this.numMenusShown;
    this.focusedMenu.index === ue.OVERFLOW_INDEX ? e = 0 : this.focusedMenu.index === this.numMenusShown - 1 && (e = ue.OVERFLOW_INDEX), e !== this.focusedMenu.index && (this.isOpen ? (this.cleanupCustomMenu(), this.showCustomMenu(e)) : this.isFocused && (this.focusedMenu.index = e, e === ue.OVERFLOW_INDEX ? this.overflowMenu.buttonElement.focus() : (t = this.menus[e].buttonElement) == null || t.focus()));
  }
  updateMnemonicVisibility(e) {
    this.menus && this.menus.forEach((t) => {
      if (t.titleElement && t.titleElement.children.length) {
        const i = t.titleElement.children.item(0);
        i && (i.style.textDecoration = this.options.alwaysOnMnemonics || e ? "underline" : "");
      }
    });
  }
  get mnemonicsInUse() {
    return this._mnemonicsInUse;
  }
  set mnemonicsInUse(e) {
    this._mnemonicsInUse = e;
  }
  get shouldAltKeyFocus() {
    return Ze ? !1 : !this.options.disableAltFocus || this.options.visibility === "toggle";
  }
  get onVisibilityChange() {
    return this._onVisibilityChange.event;
  }
  get onFocusStateChange() {
    return this._onFocusStateChange.event;
  }
  onMenuTriggered(e, t) {
    this.isOpen ? this.isCurrentMenu(e) ? this.setUnfocusedState() : (this.cleanupCustomMenu(), this.showCustomMenu(e, this.openedViaKeyboard)) : (this.focusedMenu = { index: e }, this.openedViaKeyboard = !t, this.focusState = fe.OPEN);
  }
  onModifierKeyToggled(e) {
    const t = !e.altKey && !e.ctrlKey && !e.shiftKey && !e.metaKey;
    this.options.visibility !== "hidden" && (e.event && this.shouldAltKeyFocus && Lp.toEnum(e.event.code) === 159 && e.event.preventDefault(), this.isFocused && e.lastKeyPressed === "alt" && e.altKey && (this.setUnfocusedState(), this.mnemonicsInUse = !1, this.awaitingAltRelease = !0), t && e.lastKeyPressed === "alt" && e.lastKeyReleased === "alt" && (this.awaitingAltRelease || (!this.isFocused && this.shouldAltKeyFocus ? (this.mnemonicsInUse = !0, this.focusedMenu = { index: this.numMenusShown > 0 ? 0 : ue.OVERFLOW_INDEX }, this.focusState = fe.FOCUSED) : this.isOpen || this.setUnfocusedState())), !e.altKey && e.lastKeyReleased === "alt" && (this.awaitingAltRelease = !1), this.options.enableMnemonics && this.menus && !this.isOpen && this.updateMnemonicVisibility(!this.awaitingAltRelease && e.altKey || this.mnemonicsInUse));
  }
  isCurrentMenu(e) {
    return this.focusedMenu ? this.focusedMenu.index === e : !1;
  }
  cleanupCustomMenu() {
    var e, t, i;
    this.focusedMenu && (this.focusedMenu.index === ue.OVERFLOW_INDEX ? this.overflowMenu.buttonElement.focus() : (e = this.menus[this.focusedMenu.index].buttonElement) == null || e.focus(), this.focusedMenu.holder && ((t = this.focusedMenu.holder.parentElement) == null || t.classList.remove("open"), this.focusedMenu.holder.remove()), (i = this.focusedMenu.widget) == null || i.dispose(), this.focusedMenu = { index: this.focusedMenu.index });
  }
  showCustomMenu(e, t = !0) {
    const i = e >= this.numMenusShown ? ue.OVERFLOW_INDEX : e, o = i === ue.OVERFLOW_INDEX ? this.overflowMenu : this.menus[i];
    if (!o.actions || !o.buttonElement || !o.titleElement)
      return;
    const s = Ki("div.menubar-menu-items-holder", { title: "" });
    o.buttonElement.classList.add("open");
    const n = o.titleElement.getBoundingClientRect(), r = mh(o.titleElement);
    this.options.compactMode === ki.Right ? (s.style.top = `${n.top}px`, s.style.left = `${n.left + this.container.clientWidth}px`) : this.options.compactMode === ki.Left ? (s.style.top = `${n.top}px`, s.style.right = `${this.container.clientWidth}px`, s.style.left = "auto") : (s.style.top = `${n.bottom * r}px`, s.style.left = `${n.left * r}px`), o.buttonElement.appendChild(s);
    const a = {
      getKeyBinding: this.options.getKeybinding,
      actionRunner: this.actionRunner,
      enableMnemonics: this.options.alwaysOnMnemonics || this.mnemonicsInUse && this.options.enableMnemonics,
      ariaLabel: ui(o.buttonElement.getAttribute("aria-label")),
      expandDirection: this.isCompact ? this.options.compactMode : ki.Right,
      useEventAsContext: !0
    }, d = this._register(new Fp(s, o.actions, a, this.menuStyle));
    this._register(d.onDidCancel(() => {
      this.focusState = fe.FOCUSED;
    })), i !== e ? d.trigger(e - this.numMenusShown) : d.focus(t), this.focusedMenu = {
      index: i,
      holder: s,
      widget: d
    };
  }
};
ue.OVERFLOW_INDEX = -1;
let na = ue;
function Fl(c) {
  return c && c.hasOwnProperty("folderUri");
}
function Dw(c) {
  return c && c.hasOwnProperty("workspace");
}
const wg = "inRecentFilesPicker";
class Nw extends ye {
  constructor(e) {
    super(e), this.removeFromRecentlyOpened = {
      iconClass: pe.asClassName(he.removeClose),
      tooltip: u("remove", "Remove from Recently Opened")
    }, this.dirtyRecentlyOpenedFolder = {
      iconClass: "dirty-workspace " + pe.asClassName(he.closeDirty),
      tooltip: u("dirtyRecentlyOpenedFolder", "Folder With Unsaved Files"),
      alwaysVisible: !0
    }, this.dirtyRecentlyOpenedWorkspace = {
      ...this.dirtyRecentlyOpenedFolder,
      tooltip: u("dirtyRecentlyOpenedWorkspace", "Workspace With Unsaved Files")
    };
  }
  async run(e) {
    const t = e.get(Kc), i = e.get(Is), o = e.get(at), s = e.get(Ft), n = e.get(be), r = e.get(Ch), a = e.get(fh), d = e.get(Ai), h = e.get(Yc), g = await t.getRecentlyOpened(), p = await t.getDirtyWorkspaces();
    let m = !1;
    const C = new Et(), b = new Et();
    for (const X of p)
      Fl(X) ? C.set(X.folderUri, !0) : (b.set(X.workspace.configPath, X.workspace), m = !0);
    const v = new Et(), J = new Et();
    for (const X of g.workspaces)
      Hs(X) ? v.set(X.folderUri, !0) : (J.set(X.workspace.configPath, X.workspace), m = !0);
    const R = [];
    for (const X of g.workspaces) {
      const To = Hs(X) ? C.has(X.folderUri) : b.has(X.workspace.configPath);
      R.push(this.toQuickPick(r, a, s, X, To));
    }
    for (const X of p)
      Fl(X) && !v.has(X.folderUri) ? R.push(this.toQuickPick(r, a, s, X, !0)) : Dw(X) && !J.has(X.workspace.configPath) && R.push(this.toQuickPick(r, a, s, X, !0));
    const O = g.files.map(
      (X) => this.toQuickPick(r, a, s, X, !1)
    ), Je = g.workspaces[0], Jt = Je && o.isCurrentWorkspace(Wr(Je) ? Je.workspace : Je.folderUri);
    let Q;
    const se = { type: "separator", label: m ? u("workspacesAndFolders", "folders & workspaces") : u("folders", "folders") }, ne = { type: "separator", label: u("files", "files") }, pt = [se, ...R, ne, ...O], ni = await i.pick(pt, {
      contextKey: wg,
      activeItem: [...R, ...O][Jt ? 1 : 0],
      placeHolder: Ze ? u(
        "openRecentPlaceholderMac",
        "Select to open (hold Cmd-key to force new window or Option-key for same window)"
      ) : u(
        "openRecentPlaceholder",
        "Select to open (hold Ctrl-key to force new window or Alt-key for same window)"
      ),
      matchOnDescription: !0,
      onKeyMods: (X) => Q = X,
      quickNavigate: this.isQuickNavigate() ? { keybindings: n.lookupKeybindings(this.desc.id) } : void 0,
      hideInput: this.isQuickNavigate(),
      onDidTriggerItemButton: async (X) => {
        if (X.button === this.removeFromRecentlyOpened)
          await t.removeRecentlyOpened([X.item.resource]), X.removeItem();
        else if (X.button === this.dirtyRecentlyOpenedFolder || X.button === this.dirtyRecentlyOpenedWorkspace) {
          const To = X.button === this.dirtyRecentlyOpenedWorkspace, { confirmed: pp } = await h.confirm({
            title: To ? u("dirtyWorkspace", "Workspace with Unsaved Files") : u("dirtyFolder", "Folder with Unsaved Files"),
            message: To ? u(
              "dirtyWorkspaceConfirm",
              "Do you want to open the workspace to review the unsaved files?"
            ) : u(
              "dirtyFolderConfirm",
              "Do you want to open the folder to review the unsaved files?"
            ),
            detail: To ? u(
              "dirtyWorkspaceConfirmDetail",
              "Workspaces with unsaved files cannot be removed until all unsaved files have been saved or reverted."
            ) : u(
              "dirtyFolderConfirmDetail",
              "Folders with unsaved files cannot be removed until all unsaved files have been saved or reverted."
            )
          });
          pp && (d.openWindow([X.item.openable], {
            remoteAuthority: X.item.remoteAuthority || null
          }), i.cancel());
        }
      }
    });
    if (ni)
      return d.openWindow([ni.openable], {
        forceNewWindow: Q == null ? void 0 : Q.ctrlCmd,
        forceReuseWindow: Q == null ? void 0 : Q.alt,
        remoteAuthority: ni.remoteAuthority || null
      });
  }
  toQuickPick(e, t, i, o, s) {
    let n, r, a, d, h = !1;
    Hs(o) ? (d = o.folderUri, r = rr(e, t, d, Ae.FOLDER), n = { folderUri: d }, a = o.label || i.getWorkspaceLabel(d, { verbose: 2 })) : Wr(o) ? (d = o.workspace.configPath, r = rr(e, t, d, Ae.ROOT_FOLDER), n = { workspaceUri: d }, a = o.label || i.getWorkspaceLabel(o.workspace, { verbose: 2 }), h = !0) : (d = o.fileUri, r = rr(e, t, d, Ae.FILE), n = { fileUri: d }, a = o.label || i.getUriLabel(d));
    const { name: g, parentPath: p } = Op(a);
    return {
      iconClasses: r,
      label: g,
      ariaLabel: s ? h ? u(
        "recentDirtyWorkspaceAriaLabel",
        "{0}, workspace with unsaved changes",
        g
      ) : u("recentDirtyFolderAriaLabel", "{0}, folder with unsaved changes", g) : g,
      description: p,
      buttons: s ? [h ? this.dirtyRecentlyOpenedWorkspace : this.dirtyRecentlyOpenedFolder] : [this.removeFromRecentlyOpened],
      openable: n,
      resource: d,
      remoteAuthority: o.remoteAuthority
    };
  }
}
const En = class En extends Nw {
  constructor() {
    super({
      id: En.ID,
      title: {
        value: u("openRecent", "Open Recent..."),
        mnemonicTitle: u({ key: "miMore", comment: ["&& denotes a mnemonic"] }, "&&More..."),
        original: "Open Recent..."
      },
      category: Ce.File,
      f1: !0,
      keybinding: {
        weight: 200,
        primary: 2096,
        mac: { primary: 304 }
      },
      menu: {
        id: k.MenubarRecentMenu,
        group: "y_more",
        order: 1
      }
    });
  }
  isQuickNavigate() {
    return !1;
  }
};
En.ID = "workbench.action.openRecent";
let ra = En;
const Rn = class Rn extends ye {
  constructor() {
    super({
      id: Rn.ID,
      title: { value: u("reloadWindow", "Reload Window"), original: "Reload Window" },
      category: Ce.Developer,
      f1: !0,
      keybinding: {
        weight: 200 + 50,
        when: Kp,
        primary: 2096
      }
    });
  }
  run(e) {
    return e.get(Ai).reload();
  }
};
Rn.ID = "workbench.action.reloadWindow";
let Xl = Rn;
const yg = f.and(Yp, f.has(wg)), Kl = "workbench.action.quickOpenNavigateNextInRecentFilesPicker";
V.registerCommandAndKeybindingRule({
  id: Kl,
  weight: 200 + 50,
  handler: bh(Kl, !0),
  when: yg,
  primary: 2096,
  mac: { primary: 304 }
});
const Yl = "workbench.action.quickOpenNavigatePreviousInRecentFilesPicker";
V.registerCommandAndKeybindingRule({
  id: Yl,
  weight: 200 + 50,
  handler: bh(Yl, !1),
  when: yg,
  primary: 3120,
  mac: { primary: 1328 }
});
Te.registerCommand("workbench.action.toggleConfirmBeforeClose", (c) => {
  const e = c.get(x), t = e.inspect("window.confirmBeforeClose").userValue;
  return e.updateValue("window.confirmBeforeClose", t === "never" ? "keyboardOnly" : "never");
});
G.appendMenuItem(k.MenubarMainMenu, {
  submenu: k.MenubarFileMenu,
  title: {
    value: "File",
    original: "File",
    mnemonicTitle: u({ key: "mFile", comment: ["&& denotes a mnemonic"] }, "&&File")
  },
  order: 1
});
G.appendMenuItem(k.MenubarMainMenu, {
  submenu: k.MenubarEditMenu,
  title: {
    value: "Edit",
    original: "Edit",
    mnemonicTitle: u({ key: "mEdit", comment: ["&& denotes a mnemonic"] }, "&&Edit")
  },
  order: 2
});
G.appendMenuItem(k.MenubarMainMenu, {
  submenu: k.MenubarSelectionMenu,
  title: {
    value: "Selection",
    original: "Selection",
    mnemonicTitle: u({ key: "mSelection", comment: ["&& denotes a mnemonic"] }, "&&Selection")
  },
  order: 3
});
G.appendMenuItem(k.MenubarMainMenu, {
  submenu: k.MenubarViewMenu,
  title: {
    value: "View",
    original: "View",
    mnemonicTitle: u({ key: "mView", comment: ["&& denotes a mnemonic"] }, "&&View")
  },
  order: 4
});
G.appendMenuItem(k.MenubarMainMenu, {
  submenu: k.MenubarGoMenu,
  title: {
    value: "Go",
    original: "Go",
    mnemonicTitle: u({ key: "mGoto", comment: ["&& denotes a mnemonic"] }, "&&Go")
  },
  order: 5
});
G.appendMenuItem(k.MenubarMainMenu, {
  submenu: k.MenubarTerminalMenu,
  title: {
    value: "Terminal",
    original: "Terminal",
    mnemonicTitle: u({ key: "mTerminal", comment: ["&& denotes a mnemonic"] }, "&&Terminal")
  },
  order: 7
});
G.appendMenuItem(k.MenubarMainMenu, {
  submenu: k.MenubarHelpMenu,
  title: {
    value: "Help",
    original: "Help",
    mnemonicTitle: u({ key: "mHelp", comment: ["&& denotes a mnemonic"] }, "&&Help")
  },
  order: 8
});
G.appendMenuItem(k.MenubarMainMenu, {
  submenu: k.MenubarPreferencesMenu,
  title: {
    value: "Preferences",
    original: "Preferences",
    mnemonicTitle: u({ key: "mPreferences", comment: ["&& denotes a mnemonic"] }, "Preferences")
  },
  when: Hp,
  order: 9
});
const ts = class ts extends E {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m, C) {
    super(), this.menuService = e, this.workspacesService = t, this.contextKeyService = i, this.keybindingService = o, this.configurationService = s, this.labelService = n, this.updateService = r, this.storageService = a, this.notificationService = d, this.preferencesService = h, this.environmentService = g, this.accessibilityService = p, this.hostService = m, this.commandService = C, this.keys = [
      "window.menuBarVisibility",
      "window.enableMenuBarMnemonics",
      "window.customMenuBarAltFocus",
      "workbench.sideBar.location",
      "window.nativeTabs"
    ], this.menus = {}, this.topLevelTitles = {}, this.recentlyOpened = { files: [], workspaces: [] }, this.mainMenu = this._register(this.menuService.createMenu(k.MenubarMainMenu, this.contextKeyService)), this.mainMenuDisposables = this._register(new Z()), this.setupMainMenu(), this.menuUpdater = this._register(new Ss(() => this.doUpdateMenubar(!1), 200)), this.notifyUserOfCustomMenubarAccessibility();
  }
  registerListeners() {
    this._register(this.hostService.onDidChangeFocus((e) => this.onDidChangeWindowFocus(e))), this._register(this.configurationService.onDidChangeConfiguration((e) => this.onConfigurationUpdated(e))), this.updateService.onStateChange(() => this.onUpdateStateChange()), this._register(this.workspacesService.onDidChangeRecentlyOpened(() => {
      this.onDidChangeRecentlyOpened();
    })), this._register(this.keybindingService.onDidUpdateKeybindings(() => this.updateMenubar())), this._register(this.labelService.onDidChangeFormatters(() => {
      this.onDidChangeRecentlyOpened();
    })), this._register(this.mainMenu.onDidChange(() => {
      this.setupMainMenu(), this.doUpdateMenubar(!0);
    }));
  }
  setupMainMenu() {
    this.mainMenuDisposables.clear(), this.menus = {}, this.topLevelTitles = {};
    const [, e] = this.mainMenu.getActions()[0];
    for (const t of e)
      t instanceof _r && typeof t.item.title != "string" && (this.menus[t.item.title.original] = this.mainMenuDisposables.add(this.menuService.createMenu(t.item.submenu, this.contextKeyService, { emitEventsForSubmenuChanges: !0 })), this.topLevelTitles[t.item.title.original] = t.item.title.mnemonicTitle ?? t.item.title.value);
  }
  updateMenubar() {
    this.menuUpdater.schedule();
  }
  calculateActionLabel(e) {
    return e.label;
  }
  onUpdateStateChange() {
    this.updateMenubar();
  }
  onUpdateKeybindings() {
    this.updateMenubar();
  }
  getOpenRecentActions() {
    if (!this.recentlyOpened)
      return [];
    const { workspaces: e, files: t } = this.recentlyOpened, i = [];
    if (e.length > 0) {
      for (let o = 0; o < ts.MAX_MENU_RECENT_ENTRIES && o < e.length; o++)
        i.push(this.createOpenRecentMenuAction(e[o]));
      i.push(new Qe());
    }
    if (t.length > 0) {
      for (let o = 0; o < ts.MAX_MENU_RECENT_ENTRIES && o < t.length; o++)
        i.push(this.createOpenRecentMenuAction(t[o]));
      i.push(new Qe());
    }
    return i;
  }
  onDidChangeWindowFocus(e) {
    e && this.onDidChangeRecentlyOpened();
  }
  onConfigurationUpdated(e) {
    this.keys.some((t) => e.affectsConfiguration(t)) && this.updateMenubar(), e.affectsConfiguration("editor.accessibilitySupport") && this.notifyUserOfCustomMenubarAccessibility(), e.affectsConfiguration("window.menuBarVisibility") && this.onDidChangeRecentlyOpened();
  }
  get menubarHidden() {
    return Ze && Oc ? !1 : qo(this.configurationService) === "hidden";
  }
  onDidChangeRecentlyOpened() {
    this.menubarHidden || this.workspacesService.getRecentlyOpened().then((e) => {
      this.recentlyOpened = e, this.updateMenubar();
    });
  }
  createOpenRecentMenuAction(e) {
    let t, i, o, s;
    const n = e.remoteAuthority;
    Hs(e) ? (i = e.folderUri, t = e.label || this.labelService.getWorkspaceLabel(i, { verbose: 2 }), o = "openRecentFolder", s = { folderUri: i }) : Wr(e) ? (i = e.workspace.configPath, t = e.label || this.labelService.getWorkspaceLabel(e.workspace, { verbose: 2 }), o = "openRecentWorkspace", s = { workspaceUri: i }) : (i = e.fileUri, t = e.label || this.labelService.getUriLabel(i), o = "openRecentFile", s = { fileUri: i });
    const r = new j(o, Pp(t), void 0, void 0, (a) => {
      const d = a, h = a && (!Ze && (d.ctrlKey || d.shiftKey) || Ze && (d.metaKey || d.altKey));
      return this.hostService.openWindow([s], {
        forceNewWindow: !!h,
        remoteAuthority: n || null
      });
    });
    return Object.assign(r, { uri: i, remoteAuthority: n });
  }
  notifyUserOfCustomMenubarAccessibility() {
    if (ot || Ze)
      return;
    const e = this.storageService.getBoolean("menubar/accessibleMenubarNotified", -1, !1), t = kw(this.configurationService) === "custom";
    if (e || t || !this.accessibilityService.isScreenReaderOptimized())
      return;
    const i = u(
      "menubar.customTitlebarAccessibilityNotification",
      "Accessibility support is enabled for you. For the most accessible experience, we recommend the custom title bar style."
    );
    this.notificationService.prompt(xi.Info, i, [
      {
        label: u("goToSetting", "Open Settings"),
        run: () => this.preferencesService.openUserSettings({ query: "window.titleBarStyle" })
      }
    ]), this.storageService.store("menubar/accessibleMenubarNotified", !0, -1, 0);
  }
};
ts.MAX_MENU_RECENT_ENTRIES = 10;
let aa = ts, ca = class extends aa {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m, C, b, v) {
    super(e, t, i, o, s, n, r, a, d, h, g, p, b, v), this.layoutService = m, this.telemetryService = C, this.alwaysOnMnemonics = !1, this.focusInsideMenubar = !1, this.pendingFirstTimeUpdate = !1, this.visible = !0, this.webNavigationMenu = this._register(this.menuService.createMenu(k.MenubarHomeMenu, this.contextKeyService)), this.reinstallDisposables = this._register(new Z()), this._onVisibilityChange = this._register(new w()), this._onFocusStateChange = this._register(new w()), this.actionRunner = this._register(new Tn()), this.actionRunner.onDidRun((J) => {
      this.telemetryService.publicLog2("workbenchActionExecuted", { id: J.action.id, from: "menu" });
    }), this.workspacesService.getRecentlyOpened().then((J) => {
      this.recentlyOpened = J;
    }), this.registerListeners(), this.registerActions();
  }
  doUpdateMenubar(e) {
    this.focusInsideMenubar || this.setupCustomMenubar(e), e && (this.pendingFirstTimeUpdate = !0);
  }
  registerActions() {
    const e = this;
    ot && this._register(P(class extends ye {
      constructor() {
        super({
          id: "workbench.actions.menubar.focus",
          title: { value: u("focusMenu", "Focus Application Menu"), original: "Focus Application Menu" },
          keybinding: {
            primary: 68,
            weight: 200,
            when: Ho
          },
          f1: !0
        });
      }
      async run() {
        var t;
        (t = e.menubar) == null || t.toggleFocus();
      }
    }));
  }
  getUpdateAction() {
    switch (this.updateService.state.type) {
      case "idle":
        return new j("update.check", u(
          { key: "checkForUpdates", comment: ["&& denotes a mnemonic"] },
          "Check for &&Updates..."
        ), void 0, !0, () => this.updateService.checkForUpdates(!0));
      case "checking for updates":
        return new j("update.checking", u("checkingForUpdates", "Checking for Updates..."), void 0, !1);
      case "available for download":
        return new j("update.downloadNow", u(
          { key: "download now", comment: ["&& denotes a mnemonic"] },
          "D&&ownload Update"
        ), void 0, !0, () => this.updateService.downloadUpdate());
      case "downloading":
        return new j("update.downloading", u("DownloadingUpdate", "Downloading Update..."), void 0, !1);
      case "downloaded":
        return new j("update.install", u(
          { key: "installUpdate...", comment: ["&& denotes a mnemonic"] },
          "Install &&Update..."
        ), void 0, !0, () => this.updateService.applyUpdate());
      case "updating":
        return new j("update.updating", u("installingUpdate", "Installing Update..."), void 0, !1);
      case "ready":
        return new j("update.restart", u(
          { key: "restartToUpdate", comment: ["&& denotes a mnemonic"] },
          "Restart to &&Update"
        ), void 0, !0, () => this.updateService.quitAndInstall());
      default:
        return null;
    }
  }
  get currentMenubarVisibility() {
    return qo(this.configurationService);
  }
  get currentDisableMenuBarAltFocus() {
    const e = this.configurationService.getValue("window.customMenuBarAltFocus");
    let t = !1;
    return typeof e == "boolean" && (t = !e), t;
  }
  insertActionsBefore(e, t) {
    switch (e.id) {
      case ra.ID:
        t.push(...this.getOpenRecentActions());
        break;
      case "workbench.action.showAboutDialog":
        if (!Ze && !ot) {
          const i = this.getUpdateAction();
          i && (i.label = ri(i.label), t.push(i), t.push(new Qe()));
        }
        break;
    }
  }
  get currentEnableMenuBarMnemonics() {
    let e = this.configurationService.getValue("window.enableMenuBarMnemonics");
    return typeof e != "boolean" && (e = !0), e && (!ot || ph());
  }
  get currentCompactMenuMode() {
    return this.currentMenubarVisibility !== "compact" ? void 0 : this.configurationService.getValue("workbench.sideBar.location") === "right" ? ki.Left : ki.Right;
  }
  onDidVisibilityChange(e) {
    this.visible = e, this.onDidChangeRecentlyOpened(), this._onVisibilityChange.fire(e);
  }
  toActionsArray(e) {
    const t = [];
    return sn(e, { shouldForwardArgs: !0 }, t), t;
  }
  setupCustomMenubar(e) {
    var i;
    if (!this.container)
      return;
    e ? (this.menubar && this.reinstallDisposables.clear(), this.menubar = this.reinstallDisposables.add(new na(this.container, this.getMenuBarOptions(), zp)), this.accessibilityService.alwaysUnderlineAccessKeys().then((o) => {
      var s;
      this.alwaysOnMnemonics = o, (s = this.menubar) == null || s.update(this.getMenuBarOptions());
    }), this.reinstallDisposables.add(this.menubar.onFocusStateChange((o) => {
      this._onFocusStateChange.fire(o), o || (this.pendingFirstTimeUpdate ? (this.setupCustomMenubar(!0), this.pendingFirstTimeUpdate = !1) : this.updateMenubar(), this.focusInsideMenubar = !1);
    })), this.reinstallDisposables.add(this.menubar.onVisibilityChange((o) => this.onDidVisibilityChange(o))), this.reinstallDisposables.add(S(this.container, I.FOCUS_IN, () => {
      this.focusInsideMenubar = !0;
    })), this.reinstallDisposables.add(S(this.container, I.FOCUS_OUT, () => {
      this.focusInsideMenubar = !1;
    })), this.menubar.isVisible && this.onDidVisibilityChange(!0)) : (i = this.menubar) == null || i.update(this.getMenuBarOptions());
    const t = (o, s, n) => {
      s.splice(0);
      for (const r of o)
        if (this.insertActionsBefore(r, s), r instanceof Qe)
          s.push(r);
        else if (r instanceof _r || r instanceof jd) {
          let a = typeof r.item.title == "string" ? r.item.title : r.item.title.mnemonicTitle ?? r.item.title.value;
          if (r instanceof _r) {
            const d = [];
            t(r.actions, d, n), d.length > 0 && s.push(new ao(r.id, ri(a), d));
          } else {
            qp(r.item.toggled) && (a = r.item.toggled.mnemonicTitle ?? r.item.toggled.title ?? a);
            const d = new j(
              r.id,
              ri(a),
              r.class,
              r.enabled,
              () => this.commandService.executeCommand(r.id)
            );
            d.tooltip = r.tooltip, d.checked = r.checked, s.push(d);
          }
        }
      if (n === "File" && this.currentCompactMenuMode === void 0) {
        const r = this.getWebNavigationActions();
        r.length && s.push(...r);
      }
    };
    for (const o of Object.keys(this.topLevelTitles)) {
      const s = this.menus[o];
      e && s && (this.reinstallDisposables.add(s.onDidChange(() => {
        var r;
        if (!this.focusInsideMenubar) {
          const a = [];
          t(this.toActionsArray(s), a, o), (r = this.menubar) == null || r.updateMenu({ actions: a, label: ri(this.topLevelTitles[o]) });
        }
      })), s === this.menus.File && this.reinstallDisposables.add(this.webNavigationMenu.onDidChange(() => {
        var r;
        if (!this.focusInsideMenubar) {
          const a = [];
          t(this.toActionsArray(s), a, o), (r = this.menubar) == null || r.updateMenu({ actions: a, label: ri(this.topLevelTitles[o]) });
        }
      })));
      const n = [];
      s && t(this.toActionsArray(s), n, o), this.menubar && (e ? this.menubar.push({ actions: n, label: ri(this.topLevelTitles[o]) }) : this.menubar.updateMenu({ actions: n, label: ri(this.topLevelTitles[o]) }));
    }
  }
  getWebNavigationActions() {
    if (!ot)
      return [];
    const e = [];
    for (const t of this.webNavigationMenu.getActions()) {
      const [, i] = t;
      for (const o of i)
        if (o instanceof jd) {
          const s = typeof o.item.title == "string" ? o.item.title : o.item.title.mnemonicTitle ?? o.item.title.value;
          e.push(new j(
            o.id,
            ri(s),
            o.class,
            o.enabled,
            async (n) => {
              this.commandService.executeCommand(o.id, n);
            }
          ));
        }
      e.push(new Qe());
    }
    return e.length && e.pop(), e;
  }
  getMenuBarOptions() {
    return {
      enableMnemonics: this.currentEnableMenuBarMnemonics,
      disableAltFocus: this.currentDisableMenuBarAltFocus,
      visibility: this.currentMenubarVisibility,
      actionRunner: this.actionRunner,
      getKeybinding: (e) => this.keybindingService.lookupKeybinding(e.id),
      alwaysOnMnemonics: this.alwaysOnMnemonics,
      compactMode: this.currentCompactMenuMode,
      getCompactMenuActions: () => ot ? this.getWebNavigationActions() : []
    };
  }
  onDidChangeWindowFocus(e) {
    var t;
    this.visible && (super.onDidChangeWindowFocus(e), this.container && (e ? this.container.classList.remove("inactive") : (this.container.classList.add("inactive"), (t = this.menubar) == null || t.blur())));
  }
  onUpdateStateChange() {
    this.visible && super.onUpdateStateChange();
  }
  onDidChangeRecentlyOpened() {
    this.visible && super.onDidChangeRecentlyOpened();
  }
  onUpdateKeybindings() {
    this.visible && super.onUpdateKeybindings();
  }
  registerListeners() {
    super.registerListeners(), this._register(S(window, I.RESIZE, () => {
      this.menubar && !(Up && jp.pointerEvents) && this.menubar.blur();
    })), ot && (this._register(this.layoutService.onDidChangeFullscreen((e) => this.updateMenubar())), this._register(this.webNavigationMenu.onDidChange(() => this.updateMenubar())));
  }
  get onVisibilityChange() {
    return this._onVisibilityChange.event;
  }
  get onFocusStateChange() {
    return this._onFocusStateChange.event;
  }
  getMenubarItemsDimensions() {
    return this.menubar ? new H(this.menubar.getWidth(), this.menubar.getHeight()) : new H(0, 0);
  }
  create(e) {
    return this.container = e, this.container && this.doUpdateMenubar(!0), this.container;
  }
  layout(e) {
    var t;
    (t = this.menubar) == null || t.update(this.getMenuBarOptions());
  }
  toggleFocus() {
    var e;
    (e = this.menubar) == null || e.toggleFocus();
  }
};
ca = y([
  l(0, lt),
  l(1, Kc),
  l(2, F),
  l(3, be),
  l(4, x),
  l(5, Ft),
  l(6, Mp),
  l(7, ee),
  l(8, We),
  l(9, Hc),
  l(10, Tt),
  l(11, Pc),
  l(12, Pe),
  l(13, Xe),
  l(14, Ai),
  l(15, Bi)
], ca);
var de;
let da = (de = class extends er {
  constructor(e, t, i, o, s, n, r, a, d, h) {
    super("workbench.parts.activitybar", { hasTitle: !1 }, o, s, i), this.paneCompositePart = e, this.instantiationService = t, this.storageService = s, this.extensionService = n, this.viewDescriptorService = r, this.contextKeyService = a, this.configurationService = d, this.environmentService = h, this.minimumWidth = 48, this.maximumWidth = 48, this.minimumHeight = 0, this.maximumHeight = Number.POSITIVE_INFINITY, this.globalActivity = [], this.accountsActivity = [], this.compositeActions = /* @__PURE__ */ new Map(), this.viewContainerDisposables = /* @__PURE__ */ new Map(), this.keyboardNavigationDisposables = this._register(new Z()), this.location = 0, this.hasExtensionsRegistered = !1, this.enabledViewContainersContextKeys = /* @__PURE__ */ new Map(), this._cachedViewContainers = void 0;
    for (const g of this.cachedViewContainers)
      g.visible = !this.shouldBeHidden(g.id, g);
    this.compositeBar = this.createCompositeBar(), this.onDidRegisterViewContainers(this.getViewContainers()), this.registerListeners();
  }
  createCompositeBar() {
    const e = this.cachedViewContainers.map((t) => ({
      id: t.id,
      name: t.name,
      visible: t.visible,
      order: t.order,
      pinned: t.pinned
    }));
    return this._register(this.instantiationService.createInstance(un, e, {
      icon: !0,
      orientation: 1,
      activityHoverOptions: this.getActivityHoverOptions(),
      preventLoopNavigation: !0,
      openComposite: async (t, i) => await this.paneCompositePart.openPaneComposite(t, !i) ?? null,
      getActivityAction: (t) => this.getCompositeActions(t).activityAction,
      getCompositePinnedAction: (t) => this.getCompositeActions(t).pinnedAction,
      getCompositeBadgeAction: (t) => this.getCompositeActions(t).badgeAction,
      getOnCompositeClickAction: (t) => we({ id: t, label: "", run: async () => {
        var i;
        return ((i = this.paneCompositePart.getActivePaneComposite()) == null ? void 0 : i.getId()) === t ? this.paneCompositePart.hideActivePaneComposite() : this.paneCompositePart.openPaneComposite(t);
      } }),
      fillExtraContextMenuActions: (t, i) => {
        const o = qo(this.configurationService);
        (o === "compact" || o === "hidden" || o === "toggle") && t.unshift(we({ id: "toggleMenuVisibility", label: u("menu", "Menu"), checked: o === "compact", run: () => this.configurationService.updateValue("window.menuBarVisibility", o === "compact" ? "toggle" : "compact") }), new Qe()), o === "compact" && this.menuBarContainer && (i != null && i.target) && Nt(i.target, this.menuBarContainer) && t.unshift(we({ id: "hideCompactMenu", label: u("hideMenu", "Hide Menu"), run: () => this.configurationService.updateValue("window.menuBarVisibility", "toggle") }), new Qe()), t.push(new Qe()), t.push(we({ id: "toggleAccountsVisibility", label: u("accounts", "Accounts"), checked: this.accountsVisibilityPreference, run: () => this.accountsVisibilityPreference = !this.accountsVisibilityPreference })), t.push(new Qe()), t.push(we({ id: jo.ID, label: jo.getLabel(this.layoutService), run: () => this.instantiationService.invokeFunction((s) => new jo().run(s)) })), t.push(we({ id: xl.ID, label: u("hideActivitBar", "Hide Activity Bar"), run: () => this.instantiationService.invokeFunction((s) => new xl().run(s)) }));
      },
      getContextMenuActionsForComposite: (t) => this.getContextMenuActionsForComposite(t),
      getDefaultCompositeId: () => {
        var t;
        return (t = this.viewDescriptorService.getDefaultViewContainer(this.location)) == null ? void 0 : t.id;
      },
      hidePart: () => this.layoutService.setPartHidden(!0, "workbench.parts.sidebar"),
      dndHandler: new vg(
        this.viewDescriptorService,
        0,
        async (t, i) => await this.paneCompositePart.openPaneComposite(t, i) ?? null,
        (t, i, o) => this.compositeBar.move(t, i, o == null ? void 0 : o.verticallyBefore),
        () => this.compositeBar.getCompositeBarItems()
      ),
      compositeSize: 52,
      colors: (t) => this.getActivitybarItemColors(t),
      overflowActionSize: de.ACTION_HEIGHT
    }));
  }
  getActivityHoverOptions() {
    return {
      position: () => this.layoutService.getSideBarPosition() === 0 ? 1 : 0
    };
  }
  getContextMenuActionsForComposite(e) {
    const t = [], i = this.viewDescriptorService.getViewContainerById(e), o = this.viewDescriptorService.getDefaultViewContainerLocation(i);
    if (o !== this.viewDescriptorService.getViewContainerLocation(i))
      t.push(we({ id: "resetLocationAction", label: u("resetLocation", "Reset Location"), run: () => this.viewDescriptorService.moveViewContainerToLocation(i, o) }));
    else {
      const s = this.viewDescriptorService.getViewContainerModel(i);
      if (s.allViewDescriptors.length === 1) {
        const n = s.allViewDescriptors[0], r = this.viewDescriptorService.getDefaultContainerById(n.id);
        r !== i && t.push(we({ id: "resetLocationAction", label: u("resetLocation", "Reset Location"), run: () => this.viewDescriptorService.moveViewsToContainer([n], r) }));
      }
    }
    return t;
  }
  registerListeners() {
    this._register(this.viewDescriptorService.onDidChangeViewContainers(({ added: t, removed: i }) => this.onDidChangeViewContainers(t, i))), this._register(this.viewDescriptorService.onDidChangeContainerLocation(({ viewContainer: t, from: i, to: o }) => this.onDidChangeViewContainerLocation(t, i, o))), this.paneCompositePart.onDidPaneCompositeOpen((t) => this.onDidChangeViewContainerVisibility(t.getId(), !0)), this.paneCompositePart.onDidPaneCompositeClose((t) => this.onDidChangeViewContainerVisibility(t.getId(), !1));
    const e = this._register(new Z());
    this._register(this.extensionService.onDidRegisterExtensions(() => {
      e.clear(), this.onDidRegisterExtensions(), this.compositeBar.onDidChange(() => this.saveCachedViewContainers(), this, e), this.storageService.onDidChangeValue((t) => this.onDidStorageValueChange(t), this, e);
    })), this._register(this.configurationService.onDidChangeConfiguration((t) => {
      t.affectsConfiguration("window.menuBarVisibility") && (qo(this.configurationService) === "compact" ? this.installMenubar() : this.uninstallMenubar());
    }));
  }
  onDidChangeViewContainers(e, t) {
    t.filter(({ location: i }) => i === 0).forEach(({ container: i }) => this.onDidDeregisterViewContainer(i)), this.onDidRegisterViewContainers(e.filter(({ location: i }) => i === 0).map(({ container: i }) => i));
  }
  onDidChangeViewContainerLocation(e, t, i) {
    t === this.location && this.onDidDeregisterViewContainer(e), i === this.location && this.onDidRegisterViewContainers([e]);
  }
  onDidChangeViewContainerVisibility(e, t) {
    t ? this.onDidViewContainerVisible(e) : this.compositeBar.deactivateComposite(e);
  }
  onDidRegisterExtensions() {
    this.hasExtensionsRegistered = !0;
    for (const { id: e } of this.cachedViewContainers) {
      const t = this.getViewContainer(e);
      t ? this.showOrHideViewContainer(t) : this.viewDescriptorService.isViewContainerRemovedPermanently(e) ? this.removeComposite(e) : this.hideComposite(e);
    }
    this.saveCachedViewContainers();
  }
  onDidViewContainerVisible(e) {
    const t = this.getViewContainer(e);
    t && (this.addComposite(t), this.compositeBar.activateComposite(t.id), this.shouldBeHidden(t) && this.viewDescriptorService.getViewContainerModel(t).activeViewDescriptors.length === 0 && this.hideComposite(t.id));
  }
  showActivity(e, t, i, o) {
    return this.getViewContainer(e) ? this.compositeBar.showActivity(e, t, i, o) : e === wi ? this.showGlobalActivity(wi, t, i, o) : e === js ? this.showGlobalActivity(js, t, i, o) : E.None;
  }
  showGlobalActivity(e, t, i, o) {
    typeof o != "number" && (o = 0);
    const s = { badge: t, clazz: i, priority: o }, n = e === wi ? this.globalActivity : this.accountsActivity;
    for (let r = 0; r <= n.length; r++)
      if (r === n.length) {
        n.push(s);
        break;
      } else if (n[r].priority <= o) {
        n.splice(r, 0, s);
        break;
      }
    return this.updateGlobalActivity(e), M(() => this.removeGlobalActivity(e, s));
  }
  removeGlobalActivity(e, t) {
    const i = e === wi ? this.globalActivity : this.accountsActivity, o = i.indexOf(t);
    o !== -1 && (i.splice(o, 1), this.updateGlobalActivity(e));
  }
  updateGlobalActivity(e) {
    const t = e === wi ? this.globalActivityAction : this.accountsActivityAction;
    if (!t)
      return;
    const i = e === wi ? this.globalActivity : this.accountsActivity;
    if (i.length) {
      const [{ badge: o, clazz: s, priority: n }] = i;
      if (o instanceof to && i.length > 1) {
        const r = this.getCumulativeNumberBadge(i, n);
        t.setBadge(r);
      } else
        t.setBadge(o, s);
    } else
      t.setBadge(void 0);
  }
  getCumulativeNumberBadge(e, t) {
    const i = e.filter((n) => n.badge instanceof to && n.priority === t), o = i.reduce((n, r) => n + r.badge.number, 0), s = () => i.reduce((n, r, a) => (n = n + r.badge.getDescription(), a < i.length - 1 && (n = `${n}
`), n), "");
    return new to(o, s);
  }
  uninstallMenubar() {
    this.menuBar && (this.menuBar.dispose(), this.menuBar = void 0), this.menuBarContainer && (this.menuBarContainer.remove(), this.menuBarContainer = void 0, this.registerKeyboardNavigationListeners());
  }
  installMenubar() {
    if (this.menuBar)
      return;
    this.menuBarContainer = document.createElement("div"), this.menuBarContainer.classList.add("menubar"), L(this.content).prepend(this.menuBarContainer), this.menuBar = this._register(this.instantiationService.createInstance(ca)), this.menuBar.create(this.menuBarContainer), this.registerKeyboardNavigationListeners();
  }
  createContentArea(e) {
    return this.element = e, this.content = document.createElement("div"), this.content.classList.add("content"), e.appendChild(this.content), qo(this.configurationService) === "compact" && this.installMenubar(), this.compositeBarContainer = this.compositeBar.create(this.content), this.globalActivitiesContainer = document.createElement("div"), this.content.appendChild(this.globalActivitiesContainer), this.registerKeyboardNavigationListeners(), this.content;
  }
  registerKeyboardNavigationListeners() {
    this.keyboardNavigationDisposables.clear(), this.menuBarContainer && this.keyboardNavigationDisposables.add(S(this.menuBarContainer, I.KEY_DOWN, (e) => {
      var i;
      const t = new yt(e);
      (t.equals(18) || t.equals(17)) && ((i = this.compositeBar) == null || i.focus());
    })), this.compositeBarContainer && this.keyboardNavigationDisposables.add(S(this.compositeBarContainer, I.KEY_DOWN, (e) => {
      var i, o;
      const t = new yt(e);
      t.equals(18) || t.equals(17) ? (i = this.globalActivityActionBar) == null || i.focus(!0) : (t.equals(16) || t.equals(15)) && ((o = this.menuBar) == null || o.toggleFocus());
    })), this.globalActivitiesContainer && this.keyboardNavigationDisposables.add(S(this.globalActivitiesContainer, I.KEY_DOWN, (e) => {
      var i;
      const t = new yt(e);
      (t.equals(16) || t.equals(15)) && ((i = this.compositeBar) == null || i.focus(this.getVisiblePaneCompositeIds().length - 1));
    }));
  }
  createGlobalActivityActionBar(e) {
    this.globalActivityActionBar = this._register(new Ro(e, {
      actionViewItemProvider: (t) => {
        if (t.id === "workbench.actions.manage")
          return this.instantiationService.createInstance(sa, t, () => this.compositeBar.getContextMenuActions(), (i) => this.getActivitybarItemColors(i), this.getActivityHoverOptions());
        if (t.id === "workbench.actions.accounts")
          return this.instantiationService.createInstance(Pi, t, () => this.compositeBar.getContextMenuActions(), (i) => this.getActivitybarItemColors(i), this.getActivityHoverOptions());
        throw new Error(`No view item for action '${t.id}'`);
      },
      orientation: 1,
      ariaLabel: u("manage", "Manage"),
      animated: !1,
      preventLoopNavigation: !0
    })), this.globalActivityAction = this._register(new Us({
      id: "workbench.actions.manage",
      name: u("manage", "Manage"),
      classNames: pe.asClassNameArray(de.GEAR_ICON)
    })), this.accountsVisibilityPreference && (this.accountsActivityAction = this._register(new Us({
      id: "workbench.actions.accounts",
      name: u("accounts", "Accounts"),
      classNames: pe.asClassNameArray(de.ACCOUNTS_ICON)
    })), this.globalActivityActionBar.push(this.accountsActivityAction, { index: de.ACCOUNTS_ACTION_INDEX })), this.globalActivityActionBar.push(this.globalActivityAction);
  }
  toggleAccountsActivity() {
    !!this.accountsActivityAction !== this.accountsVisibilityPreference && (this.globalActivityActionBar && (this.accountsActivityAction ? (this.globalActivityActionBar.pull(de.ACCOUNTS_ACTION_INDEX), this.accountsActivityAction = void 0) : (this.accountsActivityAction = this._register(new Us({
      id: "workbench.actions.accounts",
      name: u("accounts", "Accounts"),
      classNames: pe.asClassNameArray(he.account)
    })), this.globalActivityActionBar.push(this.accountsActivityAction, { index: de.ACCOUNTS_ACTION_INDEX }))), this.updateGlobalActivity(js));
  }
  getCompositeActions(e) {
    let t = this.compositeActions.get(e);
    if (!t) {
      const i = this.getViewContainer(e);
      if (i) {
        const o = this.viewDescriptorService.getViewContainerModel(i);
        t = {
          activityAction: this.instantiationService.createInstance(ln, this.toActivity(o), this.paneCompositePart),
          pinnedAction: new Zd(this.toActivity(o), this.compositeBar),
          badgeAction: new Wd(this.toActivity(o), this.compositeBar)
        };
      } else {
        const o = this.cachedViewContainers.filter((s) => s.id === e)[0];
        t = {
          activityAction: this.instantiationService.createInstance(Ew, de.toActivity(e, e, o == null ? void 0 : o.icon, void 0), this.paneCompositePart),
          pinnedAction: new Ll(e, this.compositeBar),
          badgeAction: new Cg(e, this.compositeBar)
        };
      }
      this.compositeActions.set(e, t);
    }
    return t;
  }
  onDidRegisterViewContainers(e) {
    for (const t of e) {
      this.addComposite(t), this.cachedViewContainers.filter(({ id: r }) => r === t.id)[0] || this.compositeBar.pin(t.id);
      const o = this.paneCompositePart.getActivePaneComposite();
      (o == null ? void 0 : o.getId()) === t.id && this.compositeBar.activateComposite(t.id);
      const s = this.viewDescriptorService.getViewContainerModel(t);
      this.updateActivity(t, s), this.showOrHideViewContainer(t);
      const n = new Z();
      n.add(s.onDidChangeContainerInfo(() => this.updateActivity(t, s))), n.add(s.onDidChangeActiveViewDescriptors(() => this.showOrHideViewContainer(t))), this.viewContainerDisposables.set(t.id, n);
    }
  }
  onDidDeregisterViewContainer(e) {
    const t = this.viewContainerDisposables.get(e.id);
    t == null || t.dispose(), this.viewContainerDisposables.delete(e.id), this.removeComposite(e.id);
  }
  updateActivity(e, t) {
    const i = this.toActivity(t), { activityAction: o, pinnedAction: s } = this.getCompositeActions(e.id);
    o.updateActivity(i), s instanceof Ll && s.setActivity(i), this.saveCachedViewContainers();
  }
  toActivity(e) {
    return de.toActivity(e.viewContainer.id, e.title, e.icon, e.keybindingId);
  }
  static toActivity(e, t, i, o) {
    let s, n;
    if (A.isUri(i)) {
      n = i;
      const r = Mc(i), a = new vh();
      a.update(r);
      const d = `activity-${e.replace(/\./g, "-")}-${a.digest()}`, h = `.monaco-workbench .activitybar .monaco-action-bar .action-label.${d}`;
      s = [d, "uri-icon"], wh(h, `
				mask: ${r} no-repeat 50% 50%;
				mask-size: 24px;
				-webkit-mask: ${r} no-repeat 50% 50%;
				-webkit-mask-size: 24px;
			`);
    } else
      pe.isThemeIcon(i) && (s = pe.asClassNameArray(i));
    return { id: e, name: t, classNames: s, iconUrl: n, keybindingId: o };
  }
  showOrHideViewContainer(e) {
    let t = this.enabledViewContainersContextKeys.get(e.id);
    t || (t = this.contextKeyService.createKey(yh(e.id), !1), this.enabledViewContainersContextKeys.set(e.id, t)), this.shouldBeHidden(e) ? (t.set(!1), this.hideComposite(e.id)) : (t.set(!0), this.addComposite(e));
  }
  shouldBeHidden(e, t) {
    var s;
    const i = os(e) ? this.getViewContainer(e) : e, o = os(e) ? e : e.id;
    if (i)
      if (i.hideIfEmpty) {
        if (this.viewDescriptorService.getViewContainerModel(i).activeViewDescriptors.length > 0)
          return !1;
      } else
        return !1;
    if (!this.hasExtensionsRegistered && !(this.environmentService.remoteAuthority && Oc)) {
      if (t = t || this.cachedViewContainers.find(({ id: n }) => n === o), !i && (t != null && t.isBuiltin) && (t != null && t.visible))
        return !1;
      if ((s = t == null ? void 0 : t.views) != null && s.length)
        return t.views.every(({ when: n }) => !!n && !this.contextKeyService.contextMatchesRules(f.deserialize(n)));
    }
    return !0;
  }
  addComposite(e) {
    this.compositeBar.addComposite({ id: e.id, name: typeof e.title == "string" ? e.title : e.title.value, order: e.order, requestedIndex: e.requestedIndex });
  }
  hideComposite(e) {
    this.compositeBar.hideComposite(e);
    const t = this.compositeActions.get(e);
    t && (t.activityAction.dispose(), t.pinnedAction.dispose(), this.compositeActions.delete(e));
  }
  removeComposite(e) {
    this.compositeBar.removeComposite(e);
    const t = this.compositeActions.get(e);
    t && (t.activityAction.dispose(), t.pinnedAction.dispose(), this.compositeActions.delete(e));
  }
  getPinnedPaneCompositeIds() {
    const e = this.compositeBar.getPinnedComposites().map((t) => t.id);
    return this.getViewContainers().filter((t) => this.compositeBar.isPinned(t.id)).sort((t, i) => e.indexOf(t.id) - e.indexOf(i.id)).map((t) => t.id);
  }
  getVisiblePaneCompositeIds() {
    return this.compositeBar.getVisibleComposites().filter((e) => {
      var t;
      return ((t = this.paneCompositePart.getActivePaneComposite()) == null ? void 0 : t.getId()) === e.id || this.compositeBar.isPinned(e.id);
    }).map((e) => e.id);
  }
  focus() {
    this.compositeBar.focus();
  }
  updateStyles() {
    super.updateStyles();
    const e = L(this.getContainer()), t = this.getColor($p) || "";
    e.style.backgroundColor = t;
    const i = this.getColor(em) || this.getColor(Oe) || "";
    e.classList.toggle("bordered", !!i), e.style.borderColor = i || "";
  }
  getActivitybarItemColors(e) {
    return {
      activeForegroundColor: e.getColor(tm),
      inactiveForegroundColor: e.getColor(im),
      activeBorderColor: e.getColor(hh),
      activeBackground: e.getColor(uh),
      badgeBackground: e.getColor(om),
      badgeForeground: e.getColor(sm),
      dragAndDropBorder: e.getColor(nm),
      activeBackgroundColor: void 0,
      inactiveBackgroundColor: void 0,
      activeBorderBottomColor: void 0
    };
  }
  layout(e, t) {
    if (!this.layoutService.isVisible("workbench.parts.activitybar"))
      return;
    let o = super.layoutContents(e, t).contentSize.height;
    this.menuBarContainer && (o -= this.menuBarContainer.clientHeight), this.globalActivityActionBar && (o -= this.globalActivityActionBar.viewItems.length * de.ACTION_HEIGHT), this.compositeBar.layout(new H(e, o));
  }
  getViewContainer(e) {
    const t = this.viewDescriptorService.getViewContainerById(e);
    return t && this.viewDescriptorService.getViewContainerLocation(t) === this.location ? t : void 0;
  }
  getViewContainers() {
    return this.viewDescriptorService.getViewContainersByLocation(this.location);
  }
  onDidStorageValueChange(e) {
    if (e.key === de.PINNED_VIEW_CONTAINERS && e.scope === 0 && this.pinnedViewContainersValue !== this.getStoredPinnedViewContainersValue()) {
      this._pinnedViewContainersValue = void 0, this._cachedViewContainers = void 0;
      const t = [], i = this.compositeBar.getCompositeBarItems();
      for (const o of this.cachedViewContainers)
        t.push({
          id: o.id,
          name: o.name,
          order: o.order,
          pinned: o.pinned,
          visible: !!i.find(({ id: s }) => s === o.id)
        });
      for (let o = 0; o < i.length; o++)
        if (!t.some(({ id: s }) => s === i[o].id)) {
          const s = this.viewDescriptorService.getViewContainerById(i[o].id);
          t.splice(o, 0, {
            ...i[o],
            pinned: !0,
            visible: !0,
            order: s == null ? void 0 : s.order
          });
        }
      this.compositeBar.setCompositeBarItems(t);
    }
    e.key === Pi.ACCOUNTS_VISIBILITY_PREFERENCE_KEY && e.scope === 0 && this.toggleAccountsActivity();
  }
  saveCachedViewContainers() {
    const e = [], t = this.compositeBar.getCompositeBarItems();
    for (const i of t) {
      const o = this.getViewContainer(i.id);
      if (o) {
        const s = this.viewDescriptorService.getViewContainerModel(o), n = [];
        for (const { when: r } of s.allViewDescriptors)
          n.push({ when: r ? r.serialize() : void 0 });
        e.push({
          id: i.id,
          name: s.title,
          icon: A.isUri(s.icon) && this.environmentService.remoteAuthority ? void 0 : s.icon,
          views: n,
          pinned: i.pinned,
          order: i.order,
          visible: i.visible,
          isBuiltin: !o.extensionId
        });
      } else
        e.push({ id: i.id, pinned: i.pinned, order: i.order, visible: !1, isBuiltin: !1 });
    }
    this.storeCachedViewContainersState(e);
  }
  get cachedViewContainers() {
    if (this._cachedViewContainers === void 0) {
      this._cachedViewContainers = this.getPinnedViewContainers();
      for (const e of this.getPlaceholderViewContainers()) {
        const t = this._cachedViewContainers.filter((i) => i.id === e.id)[0];
        t && (t.name = e.name, t.icon = e.themeIcon ? e.themeIcon : e.iconUrl ? A.revive(e.iconUrl) : void 0, A.isUri(t.icon) && this.environmentService.remoteAuthority && (t.icon = void 0), t.views = e.views, t.isBuiltin = e.isBuiltin);
      }
    }
    return this._cachedViewContainers;
  }
  storeCachedViewContainersState(e) {
    this.setPinnedViewContainers(e.map(({ id: t, pinned: i, visible: o, order: s }) => ({
      id: t,
      pinned: i,
      visible: o,
      order: s
    }))), this.setPlaceholderViewContainers(e.map(({ id: t, icon: i, name: o, views: s, isBuiltin: n }) => ({
      id: t,
      iconUrl: A.isUri(i) ? i : void 0,
      themeIcon: pe.isThemeIcon(i) ? i : void 0,
      name: o,
      isBuiltin: n,
      views: s
    })));
  }
  getPinnedViewContainers() {
    return JSON.parse(this.pinnedViewContainersValue);
  }
  setPinnedViewContainers(e) {
    this.pinnedViewContainersValue = JSON.stringify(e);
  }
  get pinnedViewContainersValue() {
    return this._pinnedViewContainersValue || (this._pinnedViewContainersValue = this.getStoredPinnedViewContainersValue()), this._pinnedViewContainersValue;
  }
  set pinnedViewContainersValue(e) {
    this.pinnedViewContainersValue !== e && (this._pinnedViewContainersValue = e, this.setStoredPinnedViewContainersValue(e));
  }
  getStoredPinnedViewContainersValue() {
    return this.storageService.get(de.PINNED_VIEW_CONTAINERS, 0, "[]");
  }
  setStoredPinnedViewContainersValue(e) {
    this.storageService.store(de.PINNED_VIEW_CONTAINERS, e, 0, 0);
  }
  getPlaceholderViewContainers() {
    return JSON.parse(this.placeholderViewContainersValue);
  }
  setPlaceholderViewContainers(e) {
    this.placeholderViewContainersValue = JSON.stringify(e);
  }
  get placeholderViewContainersValue() {
    return this._placeholderViewContainersValue || (this._placeholderViewContainersValue = this.getStoredPlaceholderViewContainersValue()), this._placeholderViewContainersValue;
  }
  set placeholderViewContainersValue(e) {
    this.placeholderViewContainersValue !== e && (this._placeholderViewContainersValue = e, this.setStoredPlaceholderViewContainersValue(e));
  }
  getStoredPlaceholderViewContainersValue() {
    return this.storageService.get(de.PLACEHOLDER_VIEW_CONTAINERS, 0, "[]");
  }
  setStoredPlaceholderViewContainersValue(e) {
    this.storageService.store(de.PLACEHOLDER_VIEW_CONTAINERS, e, 0, 1);
  }
  get accountsVisibilityPreference() {
    return this.storageService.getBoolean(Pi.ACCOUNTS_VISIBILITY_PREFERENCE_KEY, 0, !0);
  }
  set accountsVisibilityPreference(e) {
    this.storageService.store(Pi.ACCOUNTS_VISIBILITY_PREFERENCE_KEY, e, 0, 0);
  }
  toJSON() {
    return {
      type: "workbench.parts.activitybar"
    };
  }
}, de.PINNED_VIEW_CONTAINERS = "workbench.activity.pinnedViewlets2", de.PLACEHOLDER_VIEW_CONTAINERS = "workbench.activity.placeholderViewlets", de.ACTION_HEIGHT = 48, de.ACCOUNTS_ACTION_INDEX = 0, de.GEAR_ICON = lo("settings-view-bar-icon", he.settingsGear, u("settingsViewBarIcon", "Settings icon in the view bar.")), de.ACCOUNTS_ICON = lo("accounts-view-bar-icon", he.account, u("accountsViewBarIcon", "Accounts icon in the view bar.")), de);
da = y([
  l(1, W),
  l(2, Pe),
  l(3, z),
  l(4, ee),
  l(5, ei),
  l(6, Me),
  l(7, F),
  l(8, x),
  l(9, Tt)
], da);
var Qw = ".monaco-workbench.noauxiliarybar .part.auxiliarybar{display:none!important;visibility:hidden!important}.monaco-workbench .part.auxiliarybar>.content .monaco-editor,.monaco-workbench .part.auxiliarybar>.content .monaco-editor .margin,.monaco-workbench .part.auxiliarybar>.content .monaco-editor .monaco-editor-background{background-color:var(--vscode-sideBar-background)}.monaco-workbench .part.auxiliarybar>.title>.panel-switcher-container>.monaco-action-bar .action-item:focus .action-label,.monaco-workbench .part.auxiliarybar>.title>.panel-switcher-container>.monaco-action-bar .action-item:hover .action-label{color:var(--vscode-sideBarTitle-foreground)!important}.monaco-workbench .part.auxiliarybar>.title>.panel-switcher-container>.monaco-action-bar .action-item.checked .action-label,.monaco-workbench .part.auxiliarybar>.title>.panel-switcher-container>.monaco-action-bar .action-item:hover .action-label{outline:var(--vscode-contrastActiveBorder,unset) solid 1px!important}.monaco-workbench .part.auxiliarybar>.title>.panel-switcher-container>.monaco-action-bar .action-item:not(.checked):hover .action-label{outline:var(--vscode-contrastActiveBorder,unset) dashed 1px!important}";
oe(Qw, {});
var Aw = '.monaco-workbench .part.basepanel>.composite.title>.title-actions .monaco-action-bar .actions-container{justify-content:flex-end}.monaco-workbench .part.basepanel>.composite.title>.global-actions .monaco-action-bar .action-item,.monaco-workbench .part.basepanel>.composite.title>.title-actions .monaco-action-bar .action-item{margin-right:4px}.monaco-workbench .part.basepanel>.composite.title>.title-actions .monaco-action-bar .action-item .action-label{outline-offset:-2px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container.composite-bar>.monaco-action-bar .action-label.codicon-more{align-items:center;color:inherit!important;display:flex;justify-content:center;margin-left:0;margin-right:0}.monaco-workbench .part.basepanel .empty-panel-message-area{display:none;height:100%;width:100%}.monaco-workbench .part.basepanel .empty-panel-message-area.visible{align-content:center;align-items:center;display:flex;justify-content:center}.monaco-workbench .part.basepanel .empty-panel-message-area .empty-panel-message{margin:12px;text-align:center}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar{height:35px;line-height:27px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item{display:flex;font-size:11px;padding:2px 10px;text-transform:uppercase}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.icon{padding-left:2px;padding-right:2px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.icon .action-label:not(.codicon){height:16px;width:16px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:after,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:before{background-color:var(--insert-border-color);content:"";display:none;height:24px;opacity:0;position:absolute;transition-delay:.1s;transition-duration:0ms;transition-property:opacity;width:2px}.monaco-workbench .part.basepanel>.composite.title.dragged-over>.panel-switcher-container>.monaco-action-bar .action-item:after,.monaco-workbench .part.basepanel>.composite.title.dragged-over>.panel-switcher-container>.monaco-action-bar .action-item:before{display:block}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:before{left:1px;margin-left:-2px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:after{margin-right:-2px;right:1px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:first-of-type:before{left:2px;margin-left:-2px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:last-of-type:after{margin-right:-2px;right:2px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.left:after,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.left:before,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.right:after,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.right:before{transition-delay:0s}.monaco-workbench .part.basepanel>.composite.title.dragged-over-head>.panel-switcher-container>.monaco-action-bar .action-item:first-of-type:before,.monaco-workbench .part.basepanel>.composite.title.dragged-over-tail>.panel-switcher-container>.monaco-action-bar .action-item:last-of-type:after,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.left:before,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.right+.action-item:before,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:last-of-type.right:after{opacity:1}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item .action-label{border-radius:0;margin-right:0;padding:2px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.icon .action-label.codicon,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:not(.icon) .action-label{background:none!important}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.checked .action-label{margin-right:0}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .badge{align-items:center;display:flex;margin-left:8px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.icon .badge{margin-left:0}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .badge .badge-content{border-radius:11px;box-sizing:border-box;display:inline-block;font-size:11px;font-weight:400;height:18px;line-height:11px;min-width:18px;padding:3px 5px;position:relative;text-align:center}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item .active-item-indicator{bottom:0;height:100%;left:10px;overflow:hidden;pointer-events:none;position:absolute;top:-4px;width:calc(100% - 20px);z-index:1}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.icon .active-item-indicator{left:2px;top:1px;width:calc(100% - 4px)}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.checked .active-item-indicator:before,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:focus .active-item-indicator:before{border-top-style:solid;border-top-width:1px;bottom:0;content:"";height:0;position:absolute;width:100%;z-index:1}.monaco-workbench .part.basepanel>.title>.panel-switcher-container>.monaco-action-bar .action-item.clicked:not(.checked):focus .active-item-indicator:before{border-top-color:transparent!important}.monaco-workbench .part.basepanel.right .global-actions .codicon-panel-maximize:before,.monaco-workbench .part.basepanel.right .global-actions .codicon-panel-restore:before,.monaco-workbench .part.basepanel.right .title-actions .codicon-split-horizontal:before{display:inline-block;transform:rotate(-90deg)}.monaco-workbench .part.basepanel.left .global-actions .codicon-panel-maximize:before,.monaco-workbench .part.basepanel.left .global-actions .codicon-panel-restore:before,.monaco-workbench .part.basepanel.left .title-actions .codicon-split-horizontal:before{display:inline-block;transform:rotate(90deg)}';
oe(Aw, {});
var Ri;
let gn = (Ri = class extends pg {
  get preferredHeight() {
    return this.layoutService.dimension.height * 0.4;
  }
  get preferredWidth() {
    const e = this.getActivePaneComposite();
    if (!e)
      return;
    const t = e.getOptimalWidth();
    if (typeof t == "number")
      return Math.max(t, 300);
  }
  get onDidPaneCompositeOpen() {
    return _.map(this.onDidCompositeOpen.event, (e) => e.composite);
  }
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m, C, b, v, J, R, O, Je) {
    var Jt;
    super(e, t, i, o, s, n, r, N.as(b), p, ((Jt = a.getDefaultViewContainer(J)) == null ? void 0 : Jt.id) || "", "panel", "panel", void 0, g, Je), this.viewDescriptorService = a, this.contextKeyService = d, this.extensionService = h, this.partId = g, this.pinnedPanelsKey = m, this.placeholdeViewContainersKey = C, this.backgroundColor = v, this.viewContainerLocation = J, this.activePanelContextKey = R, this.panelFocusContextKey = O, this.panelOptions = Je, this.minimumWidth = 300, this.maximumWidth = Number.POSITIVE_INFINITY, this.minimumHeight = 77, this.maximumHeight = Number.POSITIVE_INFINITY, this.snap = !0, this.onDidPaneCompositeClose = this.onDidCompositeClose.event, this.compositeActions = /* @__PURE__ */ new Map(), this.panelDisposables = /* @__PURE__ */ new Map(), this.blockOpeningPanel = !1, this.extensionsRegistered = !1, this.enabledViewContainersContextKeys = /* @__PURE__ */ new Map(), this.panelRegistry = N.as(b), this.dndHandler = new vg(
      this.viewDescriptorService,
      this.viewContainerLocation,
      (Q, se) => this.openPaneComposite(Q, se).then((ne) => ne || null),
      (Q, se, ne) => this.compositeBar.move(Q, se, ne == null ? void 0 : ne.horizontallyBefore),
      () => this.compositeBar.getCompositeBarItems()
    ), this.compositeBar = this._register(this.instantiationService.createInstance(un, this.getCachedPanels(), {
      icon: !!this.panelOptions.useIcons,
      orientation: 0,
      activityHoverOptions: this.getActivityHoverOptions(),
      openComposite: (Q, se) => this.openPaneComposite(Q, !se).then((ne) => ne || null),
      getActivityAction: (Q) => this.getCompositeActions(Q).activityAction,
      getCompositePinnedAction: (Q) => this.getCompositeActions(Q).pinnedAction,
      getCompositeBadgeAction: (Q) => this.getCompositeActions(Q).badgeAction,
      getOnCompositeClickAction: (Q) => this.instantiationService.createInstance(Dl, L(this.getPaneComposite(Q)), this.viewContainerLocation),
      fillExtraContextMenuActions: (Q) => this.fillExtraContextMenuActions(Q),
      getContextMenuActionsForComposite: (Q) => this.getContextMenuActionsForComposite(Q),
      getDefaultCompositeId: () => {
        var Q;
        return (Q = a.getDefaultViewContainer(this.viewContainerLocation)) == null ? void 0 : Q.id;
      },
      hidePart: () => this.layoutService.setPartHidden(!0, this.partId),
      dndHandler: this.dndHandler,
      compositeSize: 0,
      overflowActionSize: 44,
      colors: (Q) => ({
        activeBackgroundColor: Q.getColor(this.backgroundColor),
        inactiveBackgroundColor: Q.getColor(this.backgroundColor),
        activeBorderBottomColor: Q.getColor(rm),
        activeForegroundColor: Q.getColor(am),
        inactiveForegroundColor: Q.getColor(cm),
        badgeBackground: Q.getColor(dm),
        badgeForeground: Q.getColor(lm),
        dragAndDropBorder: Q.getColor(hm)
      })
    })), this.registerListeners(), this.onDidRegisterPanels([...this.getPaneComposites()]), this.globalActions = this._register(this.instantiationService.createInstance(um, g === "workbench.parts.panel" ? k.PanelTitle : k.AuxiliaryBarTitle, void 0, void 0)), this._register(this.globalActions.onDidChange(() => this.updateGlobalToolbarActions()));
  }
  getContextMenuActionsForComposite(e) {
    const t = [], i = this.viewDescriptorService.getViewContainerById(e), o = this.viewDescriptorService.getDefaultViewContainerLocation(i);
    if (o !== this.viewDescriptorService.getViewContainerLocation(i))
      t.push(we({ id: "resetLocationAction", label: u("resetLocation", "Reset Location"), run: () => this.viewDescriptorService.moveViewContainerToLocation(i, o) }));
    else {
      const s = this.viewDescriptorService.getViewContainerModel(i);
      if (s.allViewDescriptors.length === 1) {
        const n = s.allViewDescriptors[0], r = this.viewDescriptorService.getDefaultContainerById(n.id);
        r !== i && t.push(we({ id: "resetLocationAction", label: u("resetLocation", "Reset Location"), run: () => this.viewDescriptorService.moveViewsToContainer([n], r) }));
      }
    }
    return t;
  }
  onDidRegisterPanels(e) {
    const t = this.getCachedPanels();
    for (const i of e) {
      const o = t.filter(({ id: r }) => r === i.id)[0], s = this.getActivePaneComposite(), n = (s == null ? void 0 : s.getId()) === i.id || this.extensionsRegistered && this.compositeBar.getVisibleComposites().length === 0;
      if (n || !this.shouldBeHidden(i.id, o)) {
        const r = {
          id: i.id,
          name: i.name,
          order: i.order,
          requestedIndex: i.requestedIndex
        };
        this.compositeBar.addComposite(r), o || this.compositeBar.pin(i.id), n && (this.compositeBar.activateComposite(i.id), !s && this.element && this.layoutService.isVisible(this.partId) && this.doOpenPanel(i.id));
      }
    }
    for (const i of e) {
      const o = this.getViewContainer(i.id), s = this.viewDescriptorService.getViewContainerModel(o);
      this.updateActivity(o, s), this.showOrHideViewContainer(o, s);
      const n = new Z();
      n.add(s.onDidChangeActiveViewDescriptors(() => this.showOrHideViewContainer(o, s))), n.add(s.onDidChangeContainerInfo(() => this.updateActivity(o, s))), this.panelDisposables.set(i.id, n);
    }
  }
  async onDidDeregisterPanel(e) {
    var o, s;
    const t = this.panelDisposables.get(e);
    t == null || t.dispose(), this.panelDisposables.delete(e);
    const i = this.viewDescriptorService.getViewContainersByLocation(this.viewContainerLocation).filter((n) => this.viewDescriptorService.getViewContainerModel(n).activeViewDescriptors.length > 0);
    if (i.length) {
      if (((o = this.getActivePaneComposite()) == null ? void 0 : o.getId()) === e) {
        const n = (s = this.viewDescriptorService.getDefaultViewContainer(this.viewContainerLocation)) == null ? void 0 : s.id, r = i.filter((a) => a.id === n)[0] || i[0];
        await this.openPaneComposite(r.id);
      }
    } else
      this.layoutService.setPartHidden(!0, this.partId);
    this.removeComposite(e);
  }
  updateActivity(e, t) {
    var r;
    const i = (r = this.getPlaceholderViewContainers().filter((a) => a.id === e.id)[0]) == null ? void 0 : r.name, o = {
      id: e.id,
      name: this.extensionsRegistered || i === void 0 ? t.title : i,
      keybindingId: t.keybindingId
    }, { activityAction: s, pinnedAction: n } = this.getCompositeActions(e.id);
    s.setActivity(this.toActivity(t)), n instanceof Nl && n.setActivity(o), this.compositeBar.recomputeSizes(), this.layoutCompositeBar(), this.extensionsRegistered && this.saveCachedPanels();
  }
  toActivity(e) {
    return Ri.toActivity(e.viewContainer.id, e.title, this.panelOptions.useIcons ? e.icon : void 0, e.keybindingId);
  }
  static toActivity(e, t, i, o) {
    let s, n;
    if (A.isUri(i)) {
      n = i;
      const r = Mc(i), a = new vh();
      a.update(r);
      const d = `activity-${e.replace(/\./g, "-")}-${a.digest()}`;
      s = [d, "uri-icon"];
      const h = `.monaco-workbench .basepanel .monaco-action-bar .action-label.${d}`;
      wh(h, `
				mask: ${r} no-repeat 50% 50%;
				mask-size: 16px;
				-webkit-mask: ${r} no-repeat 50% 50%;
				-webkit-mask-size: 16px;
				mask-origin: padding;
				-webkit-mask-origin: padding;
			`);
    } else
      pe.isThemeIcon(i) && (s = pe.asClassNameArray(i));
    return { id: e, name: t, classNames: s, iconUrl: n, keybindingId: o };
  }
  showOrHideViewContainer(e, t) {
    let i = this.enabledViewContainersContextKeys.get(e.id);
    if (i || (i = this.contextKeyService.createKey(yh(e.id), !1), this.enabledViewContainersContextKeys.set(e.id, i)), t.activeViewDescriptors.length) {
      if (i.set(!0), this.compositeBar.addComposite({ id: e.id, name: typeof e.title == "string" ? e.title : e.title.value, order: e.order, requestedIndex: e.requestedIndex }), this.layoutService.isRestored() && this.layoutService.isVisible(this.partId)) {
        const o = this.getActiveComposite();
        (o === void 0 || o.getId() === e.id) && this.compositeBar.activateComposite(e.id);
      }
      this.layoutCompositeBar(), this.layoutEmptyMessage();
    } else
      e.hideIfEmpty && (i.set(!1), this.hideComposite(e.id));
  }
  shouldBeHidden(e, t) {
    const i = this.getViewContainer(e);
    return !i || !i.hideIfEmpty ? !1 : t != null && t.views && t.views.length ? t.views.every(({ when: o }) => !!o && !this.contextKeyService.contextMatchesRules(f.deserialize(o))) : !1;
  }
  registerListeners() {
    this._register(this.registry.onDidRegister((t) => this.onDidRegisterPanels([t]))), this._register(this.registry.onDidDeregister((t) => this.onDidDeregisterPanel(t.id))), this._register(this.onDidPaneCompositeOpen((t) => this.onPanelOpen(t))), this._register(this.onDidPaneCompositeClose(this.onPanelClose, this));
    const e = this._register(new Z());
    this._register(this.extensionService.onDidRegisterExtensions(() => {
      e.clear(), this.onDidRegisterExtensions(), this.compositeBar.onDidChange(() => this.saveCachedPanels(), this, e), this.storageService.onDidChangeValue((t) => this.onDidStorageValueChange(t), this, e);
    }));
  }
  onDidRegisterExtensions() {
    this.extensionsRegistered = !0;
    const e = this.getPaneComposites();
    for (const { id: t } of this.getCachedPanels())
      e.every((i) => i.id !== t) && (this.viewDescriptorService.isViewContainerRemovedPermanently(t) ? this.removeComposite(t) : this.hideComposite(t));
    this.saveCachedPanels();
  }
  hideComposite(e) {
    this.compositeBar.hideComposite(e);
    const t = this.compositeActions.get(e);
    t && (t.activityAction.dispose(), t.pinnedAction.dispose(), this.compositeActions.delete(e));
  }
  onPanelOpen(e) {
    this.activePanelContextKey.set(e.getId());
    const t = this.panelRegistry.getPaneComposite(e.getId());
    t && this.compositeBar.addComposite(t), this.compositeBar.activateComposite(e.getId());
    const i = this.panelRegistry.getPaneComposite(e.getId());
    if (i) {
      const o = this.getViewContainer(i.id);
      o != null && o.hideIfEmpty && this.viewDescriptorService.getViewContainerModel(o).activeViewDescriptors.length === 0 && this.hideComposite(i.id);
    }
    this.layoutCompositeBar(), this.layoutEmptyMessage();
  }
  onPanelClose(e) {
    const t = e.getId();
    this.activePanelContextKey.get() === t && this.activePanelContextKey.reset(), this.compositeBar.deactivateComposite(e.getId()), this.layoutEmptyMessage();
  }
  create(e) {
    this.element = e, super.create(e), this.createEmptyPanelMessage();
    const t = this._register(pi(e));
    this._register(t.onDidFocus(() => this.panelFocusContextKey.set(!0))), this._register(t.onDidBlur(() => this.panelFocusContextKey.set(!1)));
  }
  createEmptyPanelMessage() {
    const e = this.getContentArea();
    this.emptyPanelMessageElement = document.createElement("div"), this.emptyPanelMessageElement.classList.add("empty-panel-message-area");
    const t = document.createElement("div");
    t.classList.add("empty-panel-message"), t.innerText = u("panel.emptyMessage", "Drag a view here to display."), this.emptyPanelMessageElement.appendChild(t), e.appendChild(this.emptyPanelMessageElement), this._register(is.INSTANCE.registerTarget(this.emptyPanelMessageElement, {
      onDragOver: (i) => {
        U.stop(i.eventData, !0);
        const o = this.dndHandler.onDragEnter(i.dragAndDropData, void 0, i.eventData);
        gh(i.eventData.dataTransfer, "move", o);
      },
      onDragEnter: (i) => {
        var s;
        U.stop(i.eventData, !0);
        const o = this.dndHandler.onDragEnter(i.dragAndDropData, void 0, i.eventData);
        this.emptyPanelMessageElement.style.backgroundColor = o && ((s = this.theme.getColor(Ln)) == null ? void 0 : s.toString()) || "";
      },
      onDragLeave: (i) => {
        U.stop(i.eventData, !0), this.emptyPanelMessageElement.style.backgroundColor = "";
      },
      onDragEnd: (i) => {
        U.stop(i.eventData, !0), this.emptyPanelMessageElement.style.backgroundColor = "";
      },
      onDrop: (i) => {
        U.stop(i.eventData, !0), this.emptyPanelMessageElement.style.backgroundColor = "", this.dndHandler.drop(i.dragAndDropData, void 0, i.eventData);
      }
    }));
  }
  createTitleArea(e) {
    const t = super.createTitleArea(e), i = t.appendChild(Y(".global-actions"));
    return this.globalToolBar = this._register(new gm(i, this.contextMenuService, {
      actionViewItemProvider: (o) => this.actionViewItemProvider(o),
      orientation: 0,
      getKeyBinding: (o) => this.keybindingService.lookupKeybinding(o.id),
      anchorAlignmentProvider: () => this.getTitleAreaDropDownAnchorAlignment(),
      toggleMenuTitle: u("moreActions", "More Actions...")
    })), this.updateGlobalToolbarActions(), t;
  }
  updateStyles() {
    super.updateStyles();
    const e = L(this.getContainer());
    e.style.backgroundColor = this.getColor(this.backgroundColor) || "";
    const t = this.getColor(Oe) || "";
    e.style.borderLeftColor = t, e.style.borderRightColor = t;
    const i = this.getTitleArea();
    i && (i.style.borderTopColor = this.getColor(Oe) || "");
  }
  doOpenPanel(e, t) {
    if (!this.blockOpeningPanel) {
      if (!this.layoutService.isVisible(this.partId))
        try {
          this.blockOpeningPanel = !0, this.layoutService.setPartHidden(!1, this.partId);
        } finally {
          this.blockOpeningPanel = !1;
        }
      return this.openComposite(e, t);
    }
  }
  async openPaneComposite(e, t) {
    if (typeof e == "string" && this.getPaneComposite(e))
      return this.doOpenPanel(e, t);
    if (await this.extensionService.whenInstalledExtensionsRegistered(), typeof e == "string" && this.getPaneComposite(e))
      return this.doOpenPanel(e, t);
  }
  showActivity(e, t, i) {
    return this.compositeBar.showActivity(e, t, i);
  }
  getPaneComposite(e) {
    return this.panelRegistry.getPaneComposite(e);
  }
  getPaneComposites() {
    return this.panelRegistry.getPaneComposites().sort((e, t) => typeof e.order != "number" ? 1 : typeof t.order != "number" ? -1 : e.order - t.order);
  }
  getPinnedPaneCompositeIds() {
    const e = this.compositeBar.getPinnedComposites().map((t) => t.id);
    return this.getPaneComposites().filter((t) => e.includes(t.id)).sort((t, i) => e.indexOf(t.id) - e.indexOf(i.id)).map((t) => t.id);
  }
  getVisiblePaneCompositeIds() {
    return this.compositeBar.getVisibleComposites().filter((e) => {
      var t;
      return ((t = this.getActivePaneComposite()) == null ? void 0 : t.getId()) === e.id || this.compositeBar.isPinned(e.id);
    }).map((e) => e.id);
  }
  getActivePaneComposite() {
    return this.getActiveComposite();
  }
  getLastActivePaneCompositeId() {
    return this.getLastActiveCompositeId();
  }
  hideActivePaneComposite() {
    this.layoutService.isVisible(this.partId) && this.layoutService.setPartHidden(!0, this.partId), this.hideActiveComposite();
  }
  createTitleLabel(e) {
    return this.compositeBar.create(e).classList.add("panel-switcher-container"), {
      updateTitle: (i, o, s) => {
        const n = this.compositeBar.getAction(i);
        n && (n.label = o);
      },
      updateStyles: () => {
      }
    };
  }
  onTitleAreaUpdate(e) {
    super.onTitleAreaUpdate(e), this.layoutCompositeBar();
  }
  layout(e, t, i, o) {
    this.layoutService.isVisible(this.partId) && (this.contentDimension = new H(e, t), super.layout(this.contentDimension.width, this.contentDimension.height, i, o), this.layoutCompositeBar(), this.layoutEmptyMessage());
  }
  layoutCompositeBar() {
    if (this.contentDimension && this.dimension) {
      let e = this.contentDimension.width - 40;
      this.toolBar && (e = Math.max(Ri.MIN_COMPOSITE_BAR_WIDTH, e - this.getToolbarWidth())), this.compositeBar.layout(new H(e, this.dimension.height));
    }
  }
  layoutEmptyMessage() {
    var e;
    (e = this.emptyPanelMessageElement) == null || e.classList.toggle("visible", this.compositeBar.getVisibleComposites().length === 0);
  }
  getViewContainer(e) {
    const t = this.viewDescriptorService.getViewContainerById(e);
    return t && this.viewDescriptorService.getViewContainerLocation(t) === this.viewContainerLocation ? t : void 0;
  }
  updateGlobalToolbarActions() {
    var i;
    const e = this.globalActions.getPrimaryActions(), t = this.globalActions.getSecondaryActions();
    (i = this.globalToolBar) == null || i.setActions(ro(e), ro(t));
  }
  getCompositeActions(e) {
    let t = this.compositeActions.get(e);
    if (!t) {
      const i = this.getViewContainer(e);
      if (i) {
        const o = this.viewDescriptorService.getViewContainerModel(i);
        t = {
          activityAction: this.instantiationService.createInstance(Dl, this.toActivity(o), this.viewContainerLocation),
          pinnedAction: new Zd(this.toActivity(o), this.compositeBar),
          badgeAction: new Wd(this.toActivity(o), this.compositeBar)
        };
      } else
        t = {
          activityAction: this.instantiationService.createInstance(mw, e, this.viewContainerLocation),
          pinnedAction: new Nl(e, this.compositeBar),
          badgeAction: new Cg(e, this.compositeBar)
        };
      this.compositeActions.set(e, t);
    }
    return t;
  }
  removeComposite(e) {
    if (super.removeComposite(e)) {
      this.compositeBar.removeComposite(e);
      const t = this.compositeActions.get(e);
      return t && (t.activityAction.dispose(), t.pinnedAction.dispose(), this.compositeActions.delete(e)), !0;
    }
    return !1;
  }
  getToolbarWidth() {
    var t;
    return !this.getActivePaneComposite() || !this.toolBar ? 0 : this.toolBar.getItemsWidth() + (((t = this.globalToolBar) == null ? void 0 : t.getItemsWidth()) ?? 0);
  }
  onDidStorageValueChange(e) {
    if (e.key === this.pinnedPanelsKey && e.scope === 0 && this.cachedPanelsValue !== this.getStoredCachedPanelsValue()) {
      this._cachedPanelsValue = void 0;
      const t = [], i = this.compositeBar.getCompositeBarItems(), o = this.getCachedPanels();
      for (const s of o)
        t.push({
          id: s.id,
          name: s.name,
          order: s.order,
          pinned: s.pinned,
          visible: !!i.find(({ id: n }) => n === s.id)
        });
      for (let s = 0; s < i.length; s++)
        t.some(({ id: n }) => n === i[s].id) || t.splice(s, 0, i[s]);
      this.compositeBar.setCompositeBarItems(t);
    }
  }
  saveCachedPanels() {
    const e = [], t = [], i = this.compositeBar.getCompositeBarItems();
    for (const o of i) {
      const s = this.getViewContainer(o.id);
      if (s) {
        const n = this.viewDescriptorService.getViewContainerModel(s);
        e.push({ id: o.id, name: n.title, pinned: o.pinned, order: o.order, visible: o.visible }), t.push({ id: o.id, name: this.getCompositeActions(o.id).activityAction.label });
      } else
        e.push({ id: o.id, name: o.name, pinned: o.pinned, order: o.order, visible: o.visible });
    }
    this.cachedPanelsValue = JSON.stringify(e), this.setPlaceholderViewContainers(t);
  }
  getCachedPanels() {
    const e = this.getPaneComposites(), i = JSON.parse(this.cachedPanelsValue).map((o) => {
      const s = typeof o == "string" ? { id: o, pinned: !0, order: void 0, visible: !0 } : o, n = e.some((r) => r.id === s.id);
      return s.visible = n ? tt(s.visible) ? !0 : s.visible : !1, s;
    });
    for (const o of this.getPlaceholderViewContainers()) {
      const s = i.filter((n) => n.id === o.id)[0];
      s && (s.name = o.name);
    }
    return i;
  }
  get cachedPanelsValue() {
    return this._cachedPanelsValue || (this._cachedPanelsValue = this.getStoredCachedPanelsValue()), this._cachedPanelsValue;
  }
  set cachedPanelsValue(e) {
    this.cachedPanelsValue !== e && (this._cachedPanelsValue = e, this.setStoredCachedViewletsValue(e));
  }
  getStoredCachedPanelsValue() {
    return this.storageService.get(this.pinnedPanelsKey, 0, "[]");
  }
  setStoredCachedViewletsValue(e) {
    this.storageService.store(this.pinnedPanelsKey, e, 0, 0);
  }
  getPlaceholderViewContainers() {
    return JSON.parse(this.placeholderViewContainersValue);
  }
  setPlaceholderViewContainers(e) {
    this.placeholderViewContainersValue = JSON.stringify(e);
  }
  get placeholderViewContainersValue() {
    return this._placeholderViewContainersValue || (this._placeholderViewContainersValue = this.getStoredPlaceholderViewContainersValue()), this._placeholderViewContainersValue;
  }
  set placeholderViewContainersValue(e) {
    this.placeholderViewContainersValue !== e && (this._placeholderViewContainersValue = e, this.setStoredPlaceholderViewContainersValue(e));
  }
  getStoredPlaceholderViewContainersValue() {
    return this.storageService.get(this.placeholdeViewContainersKey, 1, "[]");
  }
  setStoredPlaceholderViewContainersValue(e) {
    this.storageService.store(this.placeholdeViewContainersKey, e, 1, 1);
  }
}, Ri.MIN_COMPOSITE_BAR_WIDTH = 50, Ri);
gn = y([
  l(0, We),
  l(1, ee),
  l(2, Ie),
  l(3, Pe),
  l(4, be),
  l(5, W),
  l(6, z),
  l(7, Me),
  l(8, F),
  l(9, ei)
], gn);
var wo;
let la = (wo = class extends gn {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m) {
    super(e, t, o, s, n, r, a, d, h, g, "workbench.parts.panel", wo.activePanelSettingsKey, "workbench.panel.pinnedPanels", "workbench.panel.placeholderPanels", cs.Panels, Er, 1, pm.bindTo(h), mm.bindTo(h), {
      useIcons: !1,
      hasTitle: !0
    }), this.commandService = p, this.menuService = m;
  }
  updateStyles() {
    super.updateStyles();
    const e = L(this.getContainer()), t = this.getColor(qd) || this.getColor(Oe) || "";
    e.style.borderLeftColor = t, e.style.borderRightColor = t;
    const i = this.getTitleArea();
    i && (i.style.borderTopColor = this.getColor(qd) || this.getColor(Oe) || "");
  }
  getActivityHoverOptions() {
    return {
      position: () => this.layoutService.getPanelPosition() === 2 && !this.layoutService.isPanelMaximized() ? 3 : 2
    };
  }
  fillExtraContextMenuActions(e) {
    const t = this.menuService.createMenu(k.PanelPositionMenu, this.contextKeyService), i = this.menuService.createMenu(k.PanelAlignmentMenu, this.contextKeyService), o = [], s = [];
    sn(t, { shouldForwardArgs: !0 }, { primary: [], secondary: o }), sn(i, { shouldForwardArgs: !0 }, { primary: [], secondary: s }), i.dispose(), t.dispose(), e.push(new Qe(), new ao("workbench.action.panel.position", u("panel position", "Panel Position"), o), new ao("workbench.action.panel.align", u("align panel", "Align Panel"), s), we({ id: Ql.ID, label: u("hidePanel", "Hide Panel"), run: () => this.commandService.executeCommand(Ql.ID) }));
  }
  layout(e, t, i, o) {
    let s;
    this.layoutService.getPanelPosition() === 1 ? s = new H(e - 1, t) : s = new H(e, t), super.layout(s.width, s.height, i, o);
  }
  toJSON() {
    return {
      type: "workbench.parts.panel"
    };
  }
}, wo.activePanelSettingsKey = "workbench.panelpart.activepanelid", wo);
la = y([
  l(0, We),
  l(1, ee),
  l(2, Xe),
  l(3, Ie),
  l(4, Pe),
  l(5, be),
  l(6, W),
  l(7, z),
  l(8, Me),
  l(9, F),
  l(10, ei),
  l(11, Bi),
  l(12, lt)
], la);
var Zt;
let ha = (Zt = class extends gn {
  constructor(e, t, i, o, s, n, r, a, d, h, g) {
    super(e, t, i, o, s, n, r, a, d, h, "workbench.parts.auxiliarybar", Zt.activePanelSettingsKey, Zt.pinnedPanelsKey, Zt.placeholdeViewContainersKey, cs.Auxiliary, tn, 2, bm.bindTo(d), Cm.bindTo(d), {
      useIcons: !0,
      hasTitle: !0,
      borderWidth: () => this.getColor(en) || this.getColor(Oe) ? 1 : 0
    }), this.commandService = g, this.minimumWidth = 170, this.maximumWidth = Number.POSITIVE_INFINITY, this.minimumHeight = 0, this.maximumHeight = Number.POSITIVE_INFINITY, this.priority = 1;
  }
  updateStyles() {
    super.updateStyles();
    const e = L(this.getContainer()), t = this.getColor(en) || this.getColor(Oe), i = this.layoutService.getSideBarPosition() === 1;
    e.style.color = this.getColor(ch) || "", e.style.borderLeftColor = t ?? "", e.style.borderRightColor = t ?? "", e.style.borderLeftStyle = t && !i ? "solid" : "none", e.style.borderRightStyle = t && i ? "solid" : "none", e.style.borderLeftWidth = t && !i ? "1px" : "0px", e.style.borderRightWidth = t && i ? "1px" : "0px";
  }
  getActivityHoverOptions() {
    return {
      position: () => 2
    };
  }
  fillExtraContextMenuActions(e) {
    const t = this.layoutService.getSideBarPosition() === 0;
    e.push(new Qe(), we({ id: jo.ID, label: t ? u("move second side bar left", "Move Secondary Side Bar Left") : u("move second side bar right", "Move Secondary Side Bar Right"), run: () => this.commandService.executeCommand(jo.ID) }), we({ id: Al.ID, label: u("hide second side bar", "Hide Secondary Side Bar"), run: () => this.commandService.executeCommand(Al.ID) }));
  }
  toJSON() {
    return {
      type: "workbench.parts.auxiliarybar"
    };
  }
}, Zt.activePanelSettingsKey = "workbench.auxiliarybar.activepanelid", Zt.pinnedPanelsKey = "workbench.auxiliarybar.pinnedPanels", Zt.placeholdeViewContainersKey = "workbench.auxiliarybar.placeholderPanels", Zt);
ha = y([
  l(0, We),
  l(1, ee),
  l(2, Ie),
  l(3, Pe),
  l(4, be),
  l(5, W),
  l(6, z),
  l(7, Me),
  l(8, F),
  l(9, ei),
  l(10, Bi)
], ha);
let ua = class extends E {
  constructor(e) {
    super(), this.paneCompositeParts = /* @__PURE__ */ new Map(), this.paneCompositeSelectorParts = /* @__PURE__ */ new Map();
    const t = e.createInstance(la), i = e.createInstance(jr), o = e.createInstance(ha), s = e.createInstance(da, i);
    this.paneCompositeParts.set(1, t), this.paneCompositeParts.set(0, i), this.paneCompositeParts.set(2, o), this.paneCompositeSelectorParts.set(1, t), this.paneCompositeSelectorParts.set(0, s), this.paneCompositeSelectorParts.set(2, o);
    const n = this._register(new Z());
    this.onDidPaneCompositeOpen = _.any(...$d.map((r) => _.map(
      this.paneCompositeParts.get(r).onDidPaneCompositeOpen,
      (a) => ({ composite: a, viewContainerLocation: r }),
      n
    ))), this.onDidPaneCompositeClose = _.any(...$d.map((r) => _.map(
      this.paneCompositeParts.get(r).onDidPaneCompositeClose,
      (a) => ({ composite: a, viewContainerLocation: r }),
      n
    )));
  }
  openPaneComposite(e, t, i) {
    return this.getPartByLocation(t).openPaneComposite(e, i);
  }
  getActivePaneComposite(e) {
    return this.getPartByLocation(e).getActivePaneComposite();
  }
  getPaneComposite(e, t) {
    return this.getPartByLocation(t).getPaneComposite(e);
  }
  getPaneComposites(e) {
    return this.getPartByLocation(e).getPaneComposites();
  }
  getPinnedPaneCompositeIds(e) {
    return this.getSelectorPartByLocation(e).getPinnedPaneCompositeIds();
  }
  getVisiblePaneCompositeIds(e) {
    return this.getSelectorPartByLocation(e).getVisiblePaneCompositeIds();
  }
  getProgressIndicator(e, t) {
    return this.getPartByLocation(t).getProgressIndicator(e);
  }
  hideActivePaneComposite(e) {
    this.getPartByLocation(e).hideActivePaneComposite();
  }
  getLastActivePaneCompositeId(e) {
    return this.getPartByLocation(e).getLastActivePaneCompositeId();
  }
  showActivity(e, t, i, o, s) {
    return this.getSelectorPartByLocation(t).showActivity(e, i, o, s);
  }
  getPartByLocation(e) {
    return L(this.paneCompositeParts.get(e));
  }
  getSelectorPartByLocation(e) {
    return L(this.paneCompositeSelectorParts.get(e));
  }
};
ua = y([
  l(0, W)
], ua);
var Bw = '.monaco-workbench .workbench-hover{background:var(--vscode-editorHoverWidget-background);border:1px solid var(--vscode-editorHoverWidget-border);border-radius:3px;box-shadow:0 2px 8px var(--vscode-widget-shadow);color:var(--vscode-editorHoverWidget-foreground);font-size:13px;line-height:19px;max-width:700px;overflow:hidden;position:relative;z-index:40}.monaco-workbench .workbench-hover hr{border-bottom:none}.monaco-workbench .workbench-hover:not(.skip-fade-in){animation:fadein .1s linear}.monaco-workbench .workbench-hover.compact{font-size:12px}.monaco-workbench .workbench-hover.compact .hover-contents{padding:2px 8px}.monaco-workbench .workbench-hover-container.locked .workbench-hover{outline:1px solid var(--vscode-editorHoverWidget-border)}.monaco-workbench .workbench-hover-container.locked .workbench-hover:focus,.monaco-workbench .workbench-hover-lock:focus{outline:1px solid var(--vscode-focusBorder)}.monaco-workbench .workbench-hover-container.locked .workbench-hover-lock:hover{background:var(--vscode-toolbar-hoverBackground)}.monaco-workbench .workbench-hover-pointer{pointer-events:none;position:absolute;z-index:41}.monaco-workbench .workbench-hover-pointer:after{background-color:var(--vscode-editorHoverWidget-background);border-bottom:1px solid var(--vscode-editorHoverWidget-border);border-right:1px solid var(--vscode-editorHoverWidget-border);content:"";height:5px;position:absolute;width:5px}.monaco-workbench .locked .workbench-hover-pointer:after{border-bottom-width:2px;border-right-width:2px;height:4px;width:4px}.monaco-workbench .workbench-hover-pointer.left{left:-3px}.monaco-workbench .workbench-hover-pointer.right{right:3px}.monaco-workbench .workbench-hover-pointer.top{top:-3px}.monaco-workbench .workbench-hover-pointer.bottom{bottom:3px}.monaco-workbench .workbench-hover-pointer.left:after{transform:rotate(135deg)}.monaco-workbench .workbench-hover-pointer.right:after{transform:rotate(315deg)}.monaco-workbench .workbench-hover-pointer.top:after{transform:rotate(225deg)}.monaco-workbench .workbench-hover-pointer.bottom:after{transform:rotate(45deg)}.monaco-workbench .workbench-hover a{color:var(--vscode-textLink-foreground)}.monaco-workbench .workbench-hover a:focus{outline:1px solid;outline-color:var(--vscode-focusBorder);outline-offset:-1px;text-decoration:underline}.monaco-workbench .workbench-hover a:active,.monaco-workbench .workbench-hover a:hover{color:var(--vscode-textLink-activeForeground)}.monaco-workbench .workbench-hover code{background:var(--vscode-textCodeBlock-background)}.monaco-workbench .workbench-hover .hover-row .actions{background:var(--vscode-editorHoverWidget-statusBarBackground)}.monaco-workbench .workbench-hover.right-aligned{left:1px}.monaco-workbench .workbench-hover.right-aligned .hover-row.status-bar .actions{flex-direction:row-reverse}.monaco-workbench .workbench-hover.right-aligned .hover-row.status-bar .actions .action-container{margin-left:16px;margin-right:0}';
oe(Bw, {});
const Vt = Y;
let ga = class extends Bn {
  get isDisposed() {
    return this._isDisposed;
  }
  get isMouseIn() {
    return this._lockMouseTracker.isMouseIn;
  }
  get domNode() {
    return this._hover.containerDomNode;
  }
  get onDispose() {
    return this._onDispose.event;
  }
  get onRequestLayout() {
    return this._onRequestLayout.event;
  }
  get anchor() {
    return this._hoverPosition === 2 ? 0 : 1;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(e) {
    this._isLocked !== e && (this._isLocked = e, this._hoverContainer.classList.toggle("locked", this._isLocked));
  }
  constructor(e, t, i, o, s) {
    super(), this._keybindingService = t, this._configurationService = i, this._openerService = o, this._instantiationService = s, this._messageListeners = new Z(), this._isDisposed = !1, this._forcePosition = !1, this._x = 0, this._y = 0, this._isLocked = !1, this._enableFocusTraps = !1, this._addedFocusTrap = !1, this._onDispose = this._register(new w()), this._onRequestLayout = this._register(new w()), this._linkHandler = e.linkHandler || ((g) => fm(this._openerService, g, _i(e.content) ? e.content.isTrusted : void 0)), this._target = "targetElements" in e.target ? e.target : new Tw(e.target), this._hoverPointer = e.showPointer ? Vt("div.workbench-hover-pointer") : void 0, this._hover = this._register(new vm()), this._hover.containerDomNode.classList.add("workbench-hover", "fadeIn"), e.compact && this._hover.containerDomNode.classList.add("workbench-hover", "compact"), e.skipFadeInAnimation && this._hover.containerDomNode.classList.add("skip-fade-in"), e.additionalClasses && this._hover.containerDomNode.classList.add(...e.additionalClasses), e.forcePosition && (this._forcePosition = !0), e.trapFocus && (this._enableFocusTraps = !0), this._hoverPosition = e.hoverPosition ?? 3, this.onmousedown(this._hover.containerDomNode, (g) => g.stopPropagation()), this.onkeydown(this._hover.containerDomNode, (g) => {
      g.equals(9) && this.dispose();
    }), this._register(S(window, "blur", () => this.dispose()));
    const n = Vt("div.hover-row.markdown-hover"), r = Vt("div.hover-contents");
    if (typeof e.content == "string")
      r.textContent = e.content, r.style.whiteSpace = "pre-wrap";
    else if (e.content instanceof HTMLElement)
      r.appendChild(e.content), r.classList.add("html-hover-contents");
    else {
      const g = e.content, p = this._instantiationService.createInstance(kh, { codeBlockFontFamily: this._configurationService.getValue("editor").fontFamily || Ps.fontFamily }), { element: m } = p.render(g, {
        actionHandler: {
          callback: (C) => this._linkHandler(C),
          disposables: this._messageListeners
        },
        asyncRenderCallback: () => {
          r.classList.add("code-hover-contents"), this.layout(), this._onRequestLayout.fire();
        }
      });
      r.appendChild(m);
    }
    if (n.appendChild(r), this._hover.contentsDomNode.appendChild(n), e.actions && e.actions.length > 0) {
      const g = Vt("div.hover-row.status-bar"), p = Vt("div.actions");
      e.actions.forEach((m) => {
        const C = this._keybindingService.lookupKeybinding(m.commandId), b = C ? C.getLabel() : null;
        wm.render(p, {
          label: m.label,
          commandId: m.commandId,
          run: (v) => {
            m.run(v), this.dispose();
          },
          iconClass: m.iconClass
        }, b);
      }), g.appendChild(p), this._hover.containerDomNode.appendChild(g);
    }
    this._hoverContainer = Vt("div.workbench-hover-container"), this._hoverPointer && this._hoverContainer.appendChild(this._hoverPointer), this._hoverContainer.appendChild(this._hover.containerDomNode);
    let a;
    if (e.actions && e.actions.length > 0 ? a = !1 : e.hideOnHover === void 0 ? a = typeof e.content == "string" || _i(e.content) && !e.content.value.includes("](") && !e.content.value.includes("</a>") : a = e.hideOnHover, a && e.showHoverHint) {
      const g = Vt("div.hover-row.status-bar"), p = Vt("div.info");
      p.textContent = u("hoverhint", "Hold {0} key to mouse over", Ze ? "Option" : "Alt"), g.appendChild(p), this._hover.containerDomNode.appendChild(g);
    }
    const d = [...this._target.targetElements];
    a || d.push(this._hoverContainer);
    const h = this._register(new Ol(d));
    if (this._register(h.onMouseOut(() => {
      this._isLocked || this.dispose();
    })), a) {
      const g = [...this._target.targetElements, this._hoverContainer];
      this._lockMouseTracker = this._register(new Ol(g)), this._register(this._lockMouseTracker.onMouseOut(() => {
        this._isLocked || this.dispose();
      }));
    } else
      this._lockMouseTracker = h;
  }
  addFocusTrap() {
    if (!this._enableFocusTraps || this._addedFocusTrap)
      return;
    this._addedFocusTrap = !0;
    const e = this._hover.containerDomNode, t = this.findLastFocusableChild(this._hover.containerDomNode);
    if (t) {
      const i = Sh(this._hoverContainer, Vt("div")), o = ae(this._hoverContainer, Vt("div"));
      i.tabIndex = 0, o.tabIndex = 0, this._register(S(o, "focus", (s) => {
        e.focus(), s.preventDefault();
      })), this._register(S(i, "focus", (s) => {
        t.focus(), s.preventDefault();
      }));
    }
  }
  findLastFocusableChild(e) {
    if (e.hasChildNodes())
      for (let t = 0; t < e.childNodes.length; t++) {
        const i = e.childNodes.item(e.childNodes.length - t - 1);
        if (i.nodeType === i.ELEMENT_NODE) {
          const s = i;
          if (typeof s.tabIndex == "number" && s.tabIndex >= 0)
            return s;
        }
        const o = this.findLastFocusableChild(i);
        if (o)
          return o;
      }
  }
  render(e) {
    e.appendChild(this._hoverContainer), this.layout(), this.addFocusTrap();
  }
  layout() {
    this._hover.containerDomNode.classList.remove("right-aligned"), this._hover.contentsDomNode.style.maxHeight = "";
    const e = (h) => {
      const g = mh(h), p = h.getBoundingClientRect();
      return {
        top: p.top * g,
        bottom: p.bottom * g,
        right: p.right * g,
        left: p.left * g
      };
    }, t = this._target.targetElements.map((h) => e(h)), i = Math.min(...t.map((h) => h.top)), o = Math.max(...t.map((h) => h.right)), s = Math.max(...t.map((h) => h.bottom)), n = Math.min(...t.map((h) => h.left)), r = o - n, a = s - i, d = {
      top: i,
      right: o,
      bottom: s,
      left: n,
      width: r,
      height: a,
      center: {
        x: n + r / 2,
        y: i + a / 2
      }
    };
    if (this.adjustHorizontalHoverPosition(d), this.adjustVerticalHoverPosition(d), this.adjustHoverMaxHeight(d), this._hoverContainer.style.padding = "", this._hoverContainer.style.margin = "", this._hoverPointer) {
      switch (this._hoverPosition) {
        case 1:
          d.left += 3, d.right += 3, this._hoverContainer.style.paddingLeft = "3px", this._hoverContainer.style.marginLeft = "-3px";
          break;
        case 0:
          d.left -= 3, d.right -= 3, this._hoverContainer.style.paddingRight = "3px", this._hoverContainer.style.marginRight = "-3px";
          break;
        case 2:
          d.top += 3, d.bottom += 3, this._hoverContainer.style.paddingTop = "3px", this._hoverContainer.style.marginTop = "-3px";
          break;
        case 3:
          d.top -= 3, d.bottom -= 3, this._hoverContainer.style.paddingBottom = "3px", this._hoverContainer.style.marginBottom = "-3px";
          break;
      }
      d.center.x = d.left + r / 2, d.center.y = d.top + a / 2;
    }
    this.computeXCordinate(d), this.computeYCordinate(d), this._hoverPointer && (this._hoverPointer.classList.remove("top"), this._hoverPointer.classList.remove("left"), this._hoverPointer.classList.remove("right"), this._hoverPointer.classList.remove("bottom"), this.setHoverPointerPosition(d)), this._hover.onContentsChanged();
  }
  computeXCordinate(e) {
    const t = this._hover.containerDomNode.clientWidth + 2;
    this._target.x !== void 0 ? this._x = this._target.x : this._hoverPosition === 1 ? this._x = e.right : this._hoverPosition === 0 ? this._x = e.left - t : (this._hoverPointer ? this._x = e.center.x - this._hover.containerDomNode.clientWidth / 2 : this._x = e.left, this._x + t >= document.documentElement.clientWidth && (this._hover.containerDomNode.classList.add("right-aligned"), this._x = Math.max(document.documentElement.clientWidth - t - 2, document.documentElement.clientLeft))), this._x < document.documentElement.clientLeft && (this._x = e.left + 2);
  }
  computeYCordinate(e) {
    this._target.y !== void 0 ? this._y = this._target.y : this._hoverPosition === 3 ? this._y = e.top : this._hoverPosition === 2 ? this._y = e.bottom - 2 : this._hoverPointer ? this._y = e.center.y + this._hover.containerDomNode.clientHeight / 2 : this._y = e.bottom, this._y > window.innerHeight && (this._y = e.bottom);
  }
  adjustHorizontalHoverPosition(e) {
    if (this._target.x === void 0) {
      if (this._forcePosition) {
        const t = (this._hoverPointer ? 3 : 0) + 2;
        this._hoverPosition === 1 ? this._hover.containerDomNode.style.maxWidth = `${document.documentElement.clientWidth - e.right - t}px` : this._hoverPosition === 0 && (this._hover.containerDomNode.style.maxWidth = `${e.left - t}px`);
        return;
      }
      this._hoverPosition === 1 ? document.documentElement.clientWidth - e.right < this._hover.containerDomNode.clientWidth && (e.left >= this._hover.containerDomNode.clientWidth ? this._hoverPosition = 0 : this._hoverPosition = 2) : this._hoverPosition === 0 && (e.left < this._hover.containerDomNode.clientWidth && (document.documentElement.clientWidth - e.right >= this._hover.containerDomNode.clientWidth ? this._hoverPosition = 1 : this._hoverPosition = 2), e.left - this._hover.containerDomNode.clientWidth <= document.documentElement.clientLeft && (this._hoverPosition = 1));
    }
  }
  adjustVerticalHoverPosition(e) {
    this._target.y !== void 0 || this._forcePosition || (this._hoverPosition === 3 ? e.top - this._hover.containerDomNode.clientHeight < 0 && (this._hoverPosition = 2) : this._hoverPosition === 2 && e.bottom + this._hover.containerDomNode.clientHeight > window.innerHeight && (this._hoverPosition = 3));
  }
  adjustHoverMaxHeight(e) {
    let t = window.innerHeight / 2;
    if (this._forcePosition) {
      const i = (this._hoverPointer ? 3 : 0) + 2;
      this._hoverPosition === 3 ? t = Math.min(t, e.top - i) : this._hoverPosition === 2 && (t = Math.min(t, window.innerHeight - e.bottom - i));
    }
    if (this._hover.containerDomNode.style.maxHeight = `${t}px`, this._hover.contentsDomNode.clientHeight < this._hover.contentsDomNode.scrollHeight) {
      const i = `${this._hover.scrollbar.options.verticalScrollbarSize}px`;
      this._hover.contentsDomNode.style.paddingRight !== i && (this._hover.contentsDomNode.style.paddingRight = i);
    }
  }
  setHoverPointerPosition(e) {
    if (this._hoverPointer)
      switch (this._hoverPosition) {
        case 0:
        case 1: {
          this._hoverPointer.classList.add(this._hoverPosition === 0 ? "right" : "left");
          const t = this._hover.containerDomNode.clientHeight;
          t > e.height ? this._hoverPointer.style.top = `${e.center.y - (this._y - t) - 3}px` : this._hoverPointer.style.top = `${Math.round(t / 2) - 3}px`;
          break;
        }
        case 3:
        case 2: {
          this._hoverPointer.classList.add(this._hoverPosition === 3 ? "bottom" : "top");
          const t = this._hover.containerDomNode.clientWidth;
          let i = Math.round(t / 2) - 3;
          const o = this._x + i;
          (o < e.left || o > e.right) && (i = e.center.x - this._x - 3), this._hoverPointer.style.left = `${i}px`;
          break;
        }
      }
  }
  focus() {
    this._hover.containerDomNode.focus();
  }
  hide() {
    this.dispose();
  }
  dispose() {
    this._isDisposed || (this._onDispose.fire(), this._hoverContainer.remove(), this._messageListeners.dispose(), this._target.dispose(), super.dispose()), this._isDisposed = !0;
  }
};
ga = y([
  l(1, be),
  l(2, x),
  l(3, Ti),
  l(4, W)
], ga);
class Ol extends Bn {
  get onMouseOut() {
    return this._onMouseOut.event;
  }
  get isMouseIn() {
    return this._isMouseIn;
  }
  constructor(e) {
    super(), this._elements = e, this._isMouseIn = !0, this._onMouseOut = this._register(new w()), this._elements.forEach((t) => this.onmouseover(t, () => this._onTargetMouseOver())), this._elements.forEach((t) => this.onmouseleave(t, () => this._onTargetMouseLeave()));
  }
  _onTargetMouseOver() {
    this._isMouseIn = !0, this._clearEvaluateMouseStateTimeout();
  }
  _onTargetMouseLeave() {
    this._isMouseIn = !1, this._evaluateMouseState();
  }
  _evaluateMouseState() {
    this._clearEvaluateMouseStateTimeout(), this._mouseTimeout = window.setTimeout(() => this._fireIfMouseOutside(), 0);
  }
  _clearEvaluateMouseStateTimeout() {
    this._mouseTimeout && (clearTimeout(this._mouseTimeout), this._mouseTimeout = void 0);
  }
  _fireIfMouseOutside() {
    this._isMouseIn || this._onMouseOut.fire();
  }
}
class Tw {
  constructor(e) {
    this._element = e, this.targetElements = [this._element];
  }
  dispose() {
  }
}
let pa = class {
  constructor(e, t, i, o, s) {
    this._instantiationService = e, this._contextViewService = t, this._keybindingService = o, this._accessibilityService = s, i.onDidShowContextMenu(() => this.hideHover());
  }
  showHover(e, t, i) {
    if (Hl(this._currentHoverOptions) === Hl(e))
      return;
    this._currentHoverOptions = e, this._lastHoverOptions = e;
    const o = e.trapFocus || this._accessibilityService.isScreenReaderOptimized();
    i || (o && document.activeElement ? this._lastFocusedElementBeforeOpen = document.activeElement : this._lastFocusedElementBeforeOpen = void 0);
    const s = new Z(), n = this._instantiationService.createInstance(ga, e);
    n.onDispose(() => {
      var d;
      (d = this._lastFocusedElementBeforeOpen) == null || d.focus(), this._currentHoverOptions === e && (this._currentHoverOptions = void 0), s.dispose();
    });
    const r = this._contextViewService;
    if (r.showContextView(new Lw(n, t), e.container), n.onRequestLayout(() => r.layout()), "targetElements" in e.target)
      for (const d of e.target.targetElements)
        s.add(S(d, I.CLICK, () => this.hideHover()));
    else
      s.add(S(e.target, I.CLICK, () => this.hideHover()));
    const a = document.activeElement;
    if (a && (s.add(S(a, I.KEY_DOWN, (d) => this._keyDown(d, n, !!e.hideOnKeyDown))), s.add(S(document, I.KEY_DOWN, (d) => this._keyDown(d, n, !!e.hideOnKeyDown))), s.add(S(a, I.KEY_UP, (d) => this._keyUp(d, n))), s.add(S(document, I.KEY_UP, (d) => this._keyUp(d, n)))), "IntersectionObserver" in window) {
      const d = new IntersectionObserver((g) => this._intersectionChange(g, n), { threshold: 0 }), h = "targetElements" in e.target ? e.target.targetElements[0] : e.target;
      d.observe(h), s.add(M(() => d.disconnect()));
    }
    return this._currentHover = n, n;
  }
  hideHover() {
    var e;
    (e = this._currentHover) != null && e.isLocked || !this._currentHoverOptions || (this._currentHover = void 0, this._currentHoverOptions = void 0, this._contextViewService.hideContextView());
  }
  _intersectionChange(e, t) {
    e[e.length - 1].isIntersecting || t.dispose();
  }
  showAndFocusLastHover() {
    this._lastHoverOptions && this.showHover(this._lastHoverOptions, !0, !0);
  }
  _keyDown(e, t, i) {
    var n, r;
    if (e.key === "Alt") {
      t.isLocked = !0;
      return;
    }
    const o = new yt(e);
    this._keybindingService.resolveKeyboardEvent(o).getSingleModifierDispatchChords().some((a) => !!a) || this._keybindingService.softDispatch(o, o.target).kind !== 0 || i && (!((n = this._currentHoverOptions) != null && n.trapFocus) || e.key !== "Tab") && (this.hideHover(), (r = this._lastFocusedElementBeforeOpen) == null || r.focus());
  }
  _keyUp(e, t) {
    var i;
    e.key === "Alt" && (t.isLocked = !1, t.isMouseIn || (this.hideHover(), (i = this._lastFocusedElementBeforeOpen) == null || i.focus()));
  }
};
pa = y([
  l(0, W),
  l(1, Fn),
  l(2, Ie),
  l(3, be),
  l(4, Pc)
], pa);
function Hl(c) {
  if (c !== void 0)
    return (c == null ? void 0 : c.id) ?? c;
}
class Lw {
  get anchorPosition() {
    return this._hover.anchor;
  }
  constructor(e, t = !1) {
    this._hover = e, this._focus = t;
  }
  render(e) {
    return this._hover.render(e), this._focus && this._hover.focus(), this._hover;
  }
  getAnchor() {
    return {
      x: this._hover.x,
      y: this._hover.y
    };
  }
  layout() {
    this._hover.layout();
  }
}
Xc((c, e) => {
  const t = c.getColor(ym);
  t && (e.addRule(`.monaco-workbench .workbench-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${t.transparent(0.5)}; }`), e.addRule(`.monaco-workbench .workbench-hover hr { border-top: 1px solid ${t.transparent(0.5)}; }`));
});
const ds = new km();
var yo;
let ma = (yo = class {
  constructor(e, t, i, o, s, n, r, a, d, h) {
    this.fileService = e, this.configurationService = t, this.contextService = i, this.clipboardService = o, this.editorService = s, this.uriIdentityService = n, this.bulkEditService = r, this.progressService = a, this.filesConfigurationService = h, this.disposables = new Z(), this.fileChangeEvents = [], this.config = this.configurationService.getValue("explorer"), this.model = new Sm(
      this.contextService,
      this.uriIdentityService,
      this.fileService,
      this.configurationService,
      this.filesConfigurationService
    ), this.disposables.add(this.model), this.disposables.add(this.fileService.onDidRunOperation((g) => this.onDidRunOperation(g))), this.onFileChangesScheduler = new Ss(async () => {
      const g = this.fileChangeEvents;
      this.fileChangeEvents = [];
      const p = [2];
      this.config.sortOrder === "modified" && p.push(0);
      let m = !1;
      this.roots.forEach((C) => {
        this.view && !m && (m = kg(C, this.view, g, p));
      }), g.forEach((C) => {
        if (!m)
          for (const b of C.rawAdded) {
            const v = this.model.findClosest(Vi(b));
            if (v && !v.getChild(Le(b))) {
              m = !0;
              break;
            }
          }
      }), m && await this.refresh(!1);
    }, yo.EXPLORER_FILE_CHANGES_REACT_DELAY), this.disposables.add(this.fileService.onDidFilesChange((g) => {
      this.fileChangeEvents.push(g), !this.editable && (this.onFileChangesScheduler.isScheduled() || this.onFileChangesScheduler.schedule());
    })), this.disposables.add(this.configurationService.onDidChangeConfiguration((g) => this.onConfigurationUpdated(g))), this.disposables.add(_.any(this.fileService.onDidChangeFileSystemProviderRegistrations, this.fileService.onDidChangeFileSystemProviderCapabilities)(async (g) => {
      let p = !1;
      this.model.roots.forEach((m) => {
        m.resource.scheme === g.scheme && (p = !0, m.forgetChildren());
      }), p && this.view && await this.view.setTreeInput();
    })), this.disposables.add(this.model.onDidChangeRoots(() => {
      var g;
      (g = this.view) == null || g.setTreeInput();
    })), this.disposables.add(d.onDidChangeFocus((g) => {
      g && this.refresh(!1);
    })), this.revealExcludeMatcher = new Ih(
      (g) => Fw(t.getValue({ resource: g })),
      (g) => g.affectsConfiguration("explorer.autoRevealExclude"),
      i,
      t
    ), this.disposables.add(this.revealExcludeMatcher);
  }
  get roots() {
    return this.model.roots;
  }
  get sortOrderConfiguration() {
    return {
      sortOrder: this.config.sortOrder,
      lexicographicOptions: this.config.sortOrderLexicographicOptions
    };
  }
  registerView(e) {
    this.view = e;
  }
  getContext(e, t = !1) {
    if (!this.view)
      return [];
    const i = new Set(this.view.getContext(e));
    return i.forEach((o) => {
      var s;
      try {
        if (e && !t && ((s = this.view) != null && s.isItemCollapsed(o)) && o.nestedChildren)
          for (const n of o.nestedChildren)
            i.add(n);
      } catch {
        return;
      }
    }), [...i];
  }
  async applyBulkEdit(e, t) {
    const i = new $e(), o = this.progressService.withProgress({
      location: t.progressLocation || 10,
      title: t.progressLabel,
      cancellable: e.length > 1,
      delay: 500
    }, async (s) => {
      await this.bulkEditService.apply(e, {
        undoRedoSource: ds,
        label: t.undoLabel,
        code: "undoredo.explorerOperation",
        progress: s,
        token: i.token,
        confirmBeforeUndo: t.confirmBeforeUndo
      });
    }, () => i.cancel());
    await this.progressService.withProgress({ location: 1, delay: 500 }, () => o), i.dispose();
  }
  hasViewFocus() {
    return !!this.view && this.view.hasFocus();
  }
  findClosest(e) {
    return this.model.findClosest(e);
  }
  findClosestRoot(e) {
    const t = this.model.roots.filter((i) => this.uriIdentityService.extUri.isEqualOrParent(e, i.resource)).sort((i, o) => o.resource.path.length - i.resource.path.length);
    return t.length ? t[0] : null;
  }
  async setEditable(e, t) {
    if (!this.view)
      return;
    t ? this.editable = { stat: e, data: t } : this.editable = void 0;
    const i = this.isEditable(e);
    await this.view.setEditable(e, i), !this.editable && this.fileChangeEvents.length && !this.onFileChangesScheduler.isScheduled() && this.onFileChangesScheduler.schedule();
  }
  async setToCopy(e, t) {
    var o;
    const i = this.cutItems;
    this.cutItems = t ? e : void 0, await this.clipboardService.writeResources(e.map((s) => s.resource)), (o = this.view) == null || o.itemsCopied(e, t, i);
  }
  isCut(e) {
    return !!this.cutItems && this.cutItems.some((t) => this.uriIdentityService.extUri.isEqual(t.resource, e.resource));
  }
  getEditable() {
    return this.editable;
  }
  getEditableData(e) {
    return this.editable && this.editable.stat === e ? this.editable.data : void 0;
  }
  isEditable(e) {
    return !!this.editable && (this.editable.stat === e || !e);
  }
  async select(e, t) {
    if (!this.view)
      return;
    const i = t === "force", o = this.findClosest(e);
    if (o)
      return this.shouldAutoRevealItem(o, i) ? (await this.view.selectResource(o.resource, t), Promise.resolve(void 0)) : void 0;
    const s = { resolveTo: [e], resolveMetadata: this.config.sortOrder === "modified" }, n = this.findClosestRoot(e);
    if (n)
      try {
        const r = await this.fileService.resolve(n.resource, s), a = Fo.create(this.fileService, this.configurationService, this.filesConfigurationService, r, void 0, s.resolveTo);
        Fo.mergeLocalWithDisk(a, n);
        const d = n.find(e);
        if (await this.view.refresh(!0, n), d && !this.shouldAutoRevealItem(d, i))
          return;
        await this.view.selectResource(d ? d.resource : void 0, t);
      } catch (r) {
        n.error = r, await this.view.refresh(!1, n);
      }
  }
  async refresh(e = !0) {
    var t;
    if (this.model.roots.forEach((i) => i.forgetChildren()), this.view) {
      await this.view.refresh(!0);
      const i = (t = this.editorService.activeEditor) == null ? void 0 : t.resource, o = this.configurationService.getValue().explorer.autoReveal;
      e && i && o && this.select(i, o);
    }
  }
  async onDidRunOperation(e) {
    const t = this.config.fileNesting.enabled;
    if (e.isOperation(0) || e.isOperation(3)) {
      const i = e.target, o = Vi(i.resource), s = this.model.findAll(o);
      s.length && await Promise.all(s.map(async (n) => {
        var d;
        const r = this.config.sortOrder === "modified";
        if (!n.isDirectoryResolved) {
          const h = await this.fileService.resolve(n.resource, { resolveMetadata: r });
          if (h) {
            const g = Fo.create(this.fileService, this.configurationService, this.filesConfigurationService, h, n.parent);
            Fo.mergeLocalWithDisk(g, n);
          }
        }
        const a = Fo.create(this.fileService, this.configurationService, this.filesConfigurationService, i, n.parent);
        n.removeChild(a), n.addChild(a), await ((d = this.view) == null ? void 0 : d.refresh(t, n));
      }));
    } else if (e.isOperation(2)) {
      const i = e.resource, o = e.target, s = Vi(i), n = Vi(o.resource), r = this.model.findAll(i);
      if (r.every((d) => !d.nestedParent) && this.uriIdentityService.extUri.isEqual(s, n))
        await Promise.all(r.map(async (d) => {
          var h;
          d.rename(o), await ((h = this.view) == null ? void 0 : h.refresh(t, d.parent));
        }));
      else {
        const d = this.model.findAll(n);
        d.length && r.length && await Promise.all(r.map(async (h, g) => {
          var C, b, v;
          const p = h.parent, m = h.nestedParent;
          h.move(d[g]), m && await ((C = this.view) == null ? void 0 : C.refresh(!1, m)), await ((b = this.view) == null ? void 0 : b.refresh(!1, p)), await ((v = this.view) == null ? void 0 : v.refresh(t, d[g]));
        }));
      }
    } else if (e.isOperation(1)) {
      const i = this.model.findAll(e.resource);
      await Promise.all(i.map(async (o) => {
        var s, n;
        if (o.parent) {
          const r = o.parent;
          r.removeChild(o);
          const a = o.nestedParent;
          a && (a.removeChild(o), await ((s = this.view) == null ? void 0 : s.refresh(!1, a))), await ((n = this.view) == null ? void 0 : n.refresh(t, r));
        }
      }));
    }
  }
  shouldAutoRevealItem(e, t) {
    if (e === void 0 || t)
      return !0;
    if (this.revealExcludeMatcher.matches(e.resource, (s) => !!(e.parent && e.parent.getChild(s))))
      return !1;
    const i = e.root;
    let o = e.parent;
    for (; o !== i; ) {
      if (o === void 0)
        return !0;
      if (this.revealExcludeMatcher.matches(o.resource))
        return !1;
      o = o.parent;
    }
    return !0;
  }
  async onConfigurationUpdated(e) {
    var n, r;
    if (!e.affectsConfiguration("explorer"))
      return;
    let t = !1;
    e.affectsConfiguration("explorer.fileNesting") && (t = !0);
    const i = this.configurationService.getValue(), o = ((n = i == null ? void 0 : i.explorer) == null ? void 0 : n.sortOrder) || "default";
    this.config.sortOrder !== o && (t = this.config.sortOrder !== void 0);
    const s = ((r = i == null ? void 0 : i.explorer) == null ? void 0 : r.sortOrderLexicographicOptions) || "default";
    this.config.sortOrderLexicographicOptions !== s && (t = t || this.config.sortOrderLexicographicOptions !== void 0), this.config = i.explorer, t && await this.refresh();
  }
  dispose() {
    this.disposables.dispose();
  }
}, yo.EXPLORER_FILE_CHANGES_REACT_DELAY = 500, yo);
ma = y([
  l(0, _e),
  l(1, x),
  l(2, at),
  l(3, Xn),
  l(4, D),
  l(5, Li),
  l(6, Jh),
  l(7, Kn),
  l(8, Ai),
  l(9, Js)
], ma);
function kg(c, e, t, i) {
  for (const [o, s] of c.children)
    if (e.isItemVisible(s) && (t.some((n) => n.contains(s.resource, ...i)) || s.isDirectory && s.isDirectoryResolved && kg(s, e, t, i)))
      return !0;
  return !1;
}
function Fw(c) {
  const e = c && c.explorer && c.explorer.autoRevealExclude;
  return e || {};
}
var Xw = ".monaco-grid-view{overflow:hidden;position:relative}.monaco-grid-branch-node,.monaco-grid-view{height:100%;width:100%}";
oe(Xw, {});
const Kw = {
  separatorBorder: mi.transparent
};
function xt(c) {
  return c === 0 ? 1 : 0;
}
class Yw {
  constructor(e) {
    this.isLayoutEnabled = e;
  }
}
function Ow(c, e) {
  return e === 1 ? { left: c.start, right: c.end, top: c.orthogonalStart, bottom: c.orthogonalEnd } : { top: c.start, bottom: c.end, left: c.orthogonalStart, right: c.orthogonalEnd };
}
function Hw(c, e) {
  return e === 1 ? { start: c.left, end: c.right, orthogonalStart: c.top, orthogonalEnd: c.bottom } : { start: c.top, end: c.bottom, orthogonalStart: c.left, orthogonalEnd: c.right };
}
function mt(c, e) {
  if (Math.abs(c) > e)
    throw new Error("Invalid index");
  return Im(c, e + 1);
}
class re {
  get size() {
    return this._size;
  }
  get orthogonalSize() {
    return this._orthogonalSize;
  }
  get absoluteOffset() {
    return this._absoluteOffset;
  }
  get absoluteOrthogonalOffset() {
    return this._absoluteOrthogonalOffset;
  }
  get styles() {
    return this._styles;
  }
  get width() {
    return this.orientation === 1 ? this.size : this.orthogonalSize;
  }
  get height() {
    return this.orientation === 1 ? this.orthogonalSize : this.size;
  }
  get top() {
    return this.orientation === 1 ? this._absoluteOffset : this._absoluteOrthogonalOffset;
  }
  get left() {
    return this.orientation === 1 ? this._absoluteOrthogonalOffset : this._absoluteOffset;
  }
  get minimumSize() {
    return this.children.length === 0 ? 0 : Math.max(...this.children.map((e) => e.minimumOrthogonalSize));
  }
  get maximumSize() {
    return Math.min(...this.children.map((e) => e.maximumOrthogonalSize));
  }
  get priority() {
    if (this.children.length === 0)
      return 0;
    const e = this.children.map(
      (t) => typeof t.priority > "u" ? 0 : t.priority
    );
    return e.some((t) => t === 2) ? 2 : e.some((t) => t === 1) ? 1 : 0;
  }
  get proportionalLayout() {
    return this.children.length === 0 ? !0 : this.children.every((e) => e.proportionalLayout);
  }
  get minimumOrthogonalSize() {
    return this.splitview.minimumSize;
  }
  get maximumOrthogonalSize() {
    return this.splitview.maximumSize;
  }
  get minimumWidth() {
    return this.orientation === 1 ? this.minimumOrthogonalSize : this.minimumSize;
  }
  get minimumHeight() {
    return this.orientation === 1 ? this.minimumSize : this.minimumOrthogonalSize;
  }
  get maximumWidth() {
    return this.orientation === 1 ? this.maximumOrthogonalSize : this.maximumSize;
  }
  get maximumHeight() {
    return this.orientation === 1 ? this.maximumSize : this.maximumOrthogonalSize;
  }
  get boundarySashes() {
    return this._boundarySashes;
  }
  set boundarySashes(e) {
    if (!(this._boundarySashes.start === e.start && this._boundarySashes.end === e.end && this._boundarySashes.orthogonalStart === e.orthogonalStart && this._boundarySashes.orthogonalEnd === e.orthogonalEnd)) {
      this._boundarySashes = e, this.splitview.orthogonalStartSash = e.orthogonalStart, this.splitview.orthogonalEndSash = e.orthogonalEnd;
      for (let t = 0; t < this.children.length; t++) {
        const i = this.children[t], o = t === 0, s = t === this.children.length - 1;
        i.boundarySashes = {
          start: e.orthogonalStart,
          end: e.orthogonalEnd,
          orthogonalStart: o ? e.start : i.boundarySashes.orthogonalStart,
          orthogonalEnd: s ? e.end : i.boundarySashes.orthogonalEnd
        };
      }
    }
  }
  get edgeSnapping() {
    return this._edgeSnapping;
  }
  set edgeSnapping(e) {
    if (this._edgeSnapping !== e) {
      this._edgeSnapping = e;
      for (const t of this.children)
        t instanceof re && (t.edgeSnapping = e);
      this.updateSplitviewEdgeSnappingEnablement();
    }
  }
  constructor(e, t, i, o, s = 0, n = 0, r = !1, a) {
    if (this.orientation = e, this.layoutController = t, this.splitviewProportionalLayout = o, this.children = [], this._absoluteOffset = 0, this._absoluteOrthogonalOffset = 0, this.absoluteOrthogonalSize = 0, this._onDidChange = new w(), this.onDidChange = this._onDidChange.event, this._onDidScroll = new w(), this.onDidScrollDisposable = E.None, this.onDidScroll = this._onDidScroll.event, this.childrenChangeDisposable = E.None, this._onDidSashReset = new w(), this.onDidSashReset = this._onDidSashReset.event, this.splitviewSashResetDisposable = E.None, this.childrenSashResetDisposable = E.None, this._boundarySashes = {}, this._edgeSnapping = !1, this._styles = i, this._size = s, this._orthogonalSize = n, this.element = Y(".monaco-grid-branch-node"), !a)
      this.splitview = new ss(
        this.element,
        { orientation: e, styles: i, proportionalLayout: o }
      ), this.splitview.layout(s, { orthogonalSize: n, absoluteOffset: 0, absoluteOrthogonalOffset: 0, absoluteSize: s, absoluteOrthogonalSize: n });
    else {
      const h = {
        views: a.map((p) => ({
          view: p.node,
          size: p.node.size,
          visible: p.node instanceof Ee && p.visible !== void 0 ? p.visible : !0
        })),
        size: this.orthogonalSize
      }, g = { proportionalLayout: o, orientation: e, styles: i };
      this.children = a.map((p) => p.node), this.splitview = new ss(this.element, { ...g, descriptor: h }), this.children.forEach((p, m) => {
        const C = m === 0, b = m === this.children.length;
        p.boundarySashes = {
          start: this.boundarySashes.orthogonalStart,
          end: this.boundarySashes.orthogonalEnd,
          orthogonalStart: C ? this.boundarySashes.start : this.splitview.sashes[m - 1],
          orthogonalEnd: b ? this.boundarySashes.end : this.splitview.sashes[m]
        };
      });
    }
    const d = _.map(this.splitview.onDidSashReset, (h) => [h]);
    this.splitviewSashResetDisposable = d(this._onDidSashReset.fire, this._onDidSashReset), this.updateChildrenEvents();
  }
  style(e) {
    this._styles = e, this.splitview.style(e);
    for (const t of this.children)
      t instanceof re && t.style(e);
  }
  layout(e, t, i) {
    if (this.layoutController.isLayoutEnabled) {
      if (typeof i > "u")
        throw new Error("Invalid state");
      this._size = i.orthogonalSize, this._orthogonalSize = e, this._absoluteOffset = i.absoluteOffset + t, this._absoluteOrthogonalOffset = i.absoluteOrthogonalOffset, this.absoluteOrthogonalSize = i.absoluteOrthogonalSize, this.splitview.layout(i.orthogonalSize, {
        orthogonalSize: e,
        absoluteOffset: this._absoluteOrthogonalOffset,
        absoluteOrthogonalOffset: this._absoluteOffset,
        absoluteSize: i.absoluteOrthogonalSize,
        absoluteOrthogonalSize: i.absoluteSize
      }), this.updateSplitviewEdgeSnappingEnablement();
    }
  }
  setVisible(e) {
    for (const t of this.children)
      t.setVisible(e);
  }
  addChild(e, t, i, o) {
    i = mt(i, this.children.length), this.splitview.addView(e, t, i, o), this.children.splice(i, 0, e), this.updateBoundarySashes(), this.onDidChildrenChange();
  }
  removeChild(e, t) {
    e = mt(e, this.children.length), this.splitview.removeView(e, t), this.children.splice(e, 1), this.updateBoundarySashes(), this.onDidChildrenChange();
  }
  moveChild(e, t) {
    e = mt(e, this.children.length), t = mt(t, this.children.length), e !== t && (e < t && (t -= 1), this.splitview.moveView(e, t), this.children.splice(t, 0, this.children.splice(e, 1)[0]), this.updateBoundarySashes(), this.onDidChildrenChange());
  }
  swapChildren(e, t) {
    e = mt(e, this.children.length), t = mt(t, this.children.length), e !== t && (this.splitview.swapViews(e, t), [this.children[e].boundarySashes, this.children[t].boundarySashes] = [this.children[e].boundarySashes, this.children[t].boundarySashes], [this.children[e], this.children[t]] = [this.children[t], this.children[e]], this.onDidChildrenChange());
  }
  resizeChild(e, t) {
    e = mt(e, this.children.length), this.splitview.resizeView(e, t);
  }
  isChildSizeMaximized(e) {
    return this.splitview.isViewSizeMaximized(e);
  }
  distributeViewSizes(e = !1) {
    if (this.splitview.distributeViewSizes(), e)
      for (const t of this.children)
        t instanceof re && t.distributeViewSizes(!0);
  }
  getChildSize(e) {
    return e = mt(e, this.children.length), this.splitview.getViewSize(e);
  }
  isChildVisible(e) {
    return e = mt(e, this.children.length), this.splitview.isViewVisible(e);
  }
  setChildVisible(e, t) {
    e = mt(e, this.children.length), this.splitview.isViewVisible(e) !== t && this.splitview.setViewVisible(e, t);
  }
  getChildCachedVisibleSize(e) {
    return e = mt(e, this.children.length), this.splitview.getViewCachedVisibleSize(e);
  }
  updateBoundarySashes() {
    for (let e = 0; e < this.children.length; e++)
      this.children[e].boundarySashes = {
        start: this.boundarySashes.orthogonalStart,
        end: this.boundarySashes.orthogonalEnd,
        orthogonalStart: e === 0 ? this.boundarySashes.start : this.splitview.sashes[e - 1],
        orthogonalEnd: e === this.children.length - 1 ? this.boundarySashes.end : this.splitview.sashes[e]
      };
  }
  onDidChildrenChange() {
    this.updateChildrenEvents(), this._onDidChange.fire(void 0);
  }
  updateChildrenEvents() {
    const e = _.map(_.any(...this.children.map((o) => o.onDidChange)), () => {
    });
    this.childrenChangeDisposable.dispose(), this.childrenChangeDisposable = e(this._onDidChange.fire, this._onDidChange);
    const t = _.any(...this.children.map((o, s) => _.map(o.onDidSashReset, (n) => [s, ...n])));
    this.childrenSashResetDisposable.dispose(), this.childrenSashResetDisposable = t(this._onDidSashReset.fire, this._onDidSashReset);
    const i = _.any(_.signal(this.splitview.onDidScroll), ...this.children.map((o) => o.onDidScroll));
    this.onDidScrollDisposable.dispose(), this.onDidScrollDisposable = i(this._onDidScroll.fire, this._onDidScroll);
  }
  trySet2x2(e) {
    if (this.children.length !== 2 || e.children.length !== 2)
      return E.None;
    if (this.getChildSize(0) !== e.getChildSize(0))
      return E.None;
    const [t, i] = this.children, [o, s] = e.children;
    if (!(t instanceof Ee) || !(i instanceof Ee))
      return E.None;
    if (!(o instanceof Ee) || !(s instanceof Ee))
      return E.None;
    this.orientation === 0 ? (i.linkedWidthNode = o.linkedHeightNode = t, t.linkedWidthNode = s.linkedHeightNode = i, s.linkedWidthNode = t.linkedHeightNode = o, o.linkedWidthNode = i.linkedHeightNode = s) : (o.linkedWidthNode = i.linkedHeightNode = t, s.linkedWidthNode = t.linkedHeightNode = i, t.linkedWidthNode = s.linkedHeightNode = o, i.linkedWidthNode = o.linkedHeightNode = s);
    const n = this.splitview.sashes[0], r = e.splitview.sashes[0];
    return n.linkedSash = r, r.linkedSash = n, this._onDidChange.fire(void 0), e._onDidChange.fire(void 0), M(() => {
      n.linkedSash = r.linkedSash = void 0, t.linkedHeightNode = t.linkedWidthNode = void 0, i.linkedHeightNode = i.linkedWidthNode = void 0, o.linkedHeightNode = o.linkedWidthNode = void 0, s.linkedHeightNode = s.linkedWidthNode = void 0;
    });
  }
  updateSplitviewEdgeSnappingEnablement() {
    this.splitview.startSnappingEnabled = this._edgeSnapping || this._absoluteOrthogonalOffset > 0, this.splitview.endSnappingEnabled = this._edgeSnapping || this._absoluteOrthogonalOffset + this._size < this.absoluteOrthogonalSize;
  }
  dispose() {
    for (const e of this.children)
      e.dispose();
    this._onDidChange.dispose(), this._onDidSashReset.dispose(), this.splitviewSashResetDisposable.dispose(), this.childrenSashResetDisposable.dispose(), this.childrenChangeDisposable.dispose(), this.splitview.dispose();
  }
}
function Pw(c) {
  const [e, t] = _.split(c.onDidChange, Yo);
  return _.any(t, _.map(_.latch(_.map(
    e,
    (i) => [c.minimumWidth, c.maximumWidth, c.minimumHeight, c.maximumHeight]
  ), bi), (i) => {
  }));
}
class Ee {
  get size() {
    return this._size;
  }
  get orthogonalSize() {
    return this._orthogonalSize;
  }
  get linkedWidthNode() {
    return this._linkedWidthNode;
  }
  set linkedWidthNode(e) {
    this._onDidLinkedWidthNodeChange.input = e ? e._onDidViewChange : _.None, this._linkedWidthNode = e, this._onDidSetLinkedNode.fire(void 0);
  }
  get linkedHeightNode() {
    return this._linkedHeightNode;
  }
  set linkedHeightNode(e) {
    this._onDidLinkedHeightNodeChange.input = e ? e._onDidViewChange : _.None, this._linkedHeightNode = e, this._onDidSetLinkedNode.fire(void 0);
  }
  constructor(e, t, i, o, s = 0) {
    this.view = e, this.orientation = t, this.layoutController = i, this._size = 0, this.absoluteOffset = 0, this.absoluteOrthogonalOffset = 0, this.onDidScroll = _.None, this.onDidSashReset = _.None, this._onDidLinkedWidthNodeChange = new Ht(), this._linkedWidthNode = void 0, this._onDidLinkedHeightNodeChange = new Ht(), this._linkedHeightNode = void 0, this._onDidSetLinkedNode = new w(), this.disposables = new Z(), this._boundarySashes = {}, this.cachedWidth = 0, this.cachedHeight = 0, this.cachedTop = 0, this.cachedLeft = 0, this._orthogonalSize = o, this._size = s;
    const n = Pw(e);
    this._onDidViewChange = _.map(
      n,
      (r) => r && (this.orientation === 0 ? r.width : r.height),
      this.disposables
    ), this.onDidChange = _.any(this._onDidViewChange, this._onDidSetLinkedNode.event, this._onDidLinkedWidthNodeChange.event, this._onDidLinkedHeightNodeChange.event);
  }
  get width() {
    return this.orientation === 1 ? this.orthogonalSize : this.size;
  }
  get height() {
    return this.orientation === 1 ? this.size : this.orthogonalSize;
  }
  get top() {
    return this.orientation === 1 ? this.absoluteOffset : this.absoluteOrthogonalOffset;
  }
  get left() {
    return this.orientation === 1 ? this.absoluteOrthogonalOffset : this.absoluteOffset;
  }
  get element() {
    return this.view.element;
  }
  get minimumWidth() {
    return this.linkedWidthNode ? Math.max(this.linkedWidthNode.view.minimumWidth, this.view.minimumWidth) : this.view.minimumWidth;
  }
  get maximumWidth() {
    return this.linkedWidthNode ? Math.min(this.linkedWidthNode.view.maximumWidth, this.view.maximumWidth) : this.view.maximumWidth;
  }
  get minimumHeight() {
    return this.linkedHeightNode ? Math.max(this.linkedHeightNode.view.minimumHeight, this.view.minimumHeight) : this.view.minimumHeight;
  }
  get maximumHeight() {
    return this.linkedHeightNode ? Math.min(this.linkedHeightNode.view.maximumHeight, this.view.maximumHeight) : this.view.maximumHeight;
  }
  get minimumSize() {
    return this.orientation === 1 ? this.minimumHeight : this.minimumWidth;
  }
  get maximumSize() {
    return this.orientation === 1 ? this.maximumHeight : this.maximumWidth;
  }
  get priority() {
    return this.view.priority;
  }
  get proportionalLayout() {
    return this.view.proportionalLayout ?? !0;
  }
  get snap() {
    return this.view.snap;
  }
  get minimumOrthogonalSize() {
    return this.orientation === 1 ? this.minimumWidth : this.minimumHeight;
  }
  get maximumOrthogonalSize() {
    return this.orientation === 1 ? this.maximumWidth : this.maximumHeight;
  }
  get boundarySashes() {
    return this._boundarySashes;
  }
  set boundarySashes(e) {
    var t, i;
    this._boundarySashes = e, (i = (t = this.view).setBoundarySashes) == null || i.call(t, Ow(e, this.orientation));
  }
  layout(e, t, i) {
    if (this.layoutController.isLayoutEnabled) {
      if (typeof i > "u")
        throw new Error("Invalid state");
      this._size = e, this._orthogonalSize = i.orthogonalSize, this.absoluteOffset = i.absoluteOffset + t, this.absoluteOrthogonalOffset = i.absoluteOrthogonalOffset, this._layout(this.width, this.height, this.top, this.left);
    }
  }
  _layout(e, t, i, o) {
    this.cachedWidth === e && this.cachedHeight === t && this.cachedTop === i && this.cachedLeft === o || (this.cachedWidth = e, this.cachedHeight = t, this.cachedTop = i, this.cachedLeft = o, this.view.layout(e, t, i, o));
  }
  setVisible(e) {
    var t, i;
    (i = (t = this.view).setVisible) == null || i.call(t, e);
  }
  dispose() {
    this.disposables.dispose();
  }
}
function Sg(c, e, t) {
  if (c instanceof re) {
    const i = new re(
      xt(c.orientation),
      c.layoutController,
      c.styles,
      c.splitviewProportionalLayout,
      e,
      t,
      c.edgeSnapping
    );
    let o = 0;
    for (let s = c.children.length - 1; s >= 0; s--) {
      const n = c.children[s], r = n instanceof re ? n.orthogonalSize : n.size;
      let a = c.size === 0 ? 0 : Math.round(e * r / c.size);
      o += a, s === 0 && (a += e - o), i.addChild(Sg(n, t, a), a, 0, !0);
    }
    return i;
  } else
    return new Ee(
      c.view,
      xt(c.orientation),
      c.layoutController,
      t
    );
}
class so {
  get root() {
    return this._root;
  }
  set root(e) {
    const t = this._root;
    t && (this.element.removeChild(t.element), t.dispose()), this._root = e, this.element.appendChild(e.element), this.onDidSashResetRelay.input = e.onDidSashReset, this._onDidChange.input = _.map(e.onDidChange, () => {
    }), this._onDidScroll.input = e.onDidScroll;
  }
  get width() {
    return this.root.width;
  }
  get height() {
    return this.root.height;
  }
  get minimumWidth() {
    return this.root.minimumWidth;
  }
  get minimumHeight() {
    return this.root.minimumHeight;
  }
  get maximumWidth() {
    return this.root.maximumHeight;
  }
  get maximumHeight() {
    return this.root.maximumHeight;
  }
  get orientation() {
    return this._root.orientation;
  }
  get boundarySashes() {
    return this._boundarySashes;
  }
  set orientation(e) {
    if (this._root.orientation === e)
      return;
    const { size: t, orthogonalSize: i, absoluteOffset: o, absoluteOrthogonalOffset: s } = this._root;
    this.root = Sg(this._root, i, t), this.root.layout(t, 0, { orthogonalSize: i, absoluteOffset: s, absoluteOrthogonalOffset: o, absoluteSize: t, absoluteOrthogonalSize: i }), this.boundarySashes = this.boundarySashes;
  }
  set boundarySashes(e) {
    this._boundarySashes = e, this.root.boundarySashes = Hw(e, this.orientation);
  }
  set edgeSnapping(e) {
    this.root.edgeSnapping = e;
  }
  constructor(e = {}) {
    this.onDidSashResetRelay = new Ht(), this._onDidScroll = new Ht(), this._onDidChange = new Ht(), this._boundarySashes = {}, this.disposable2x2 = E.None, this.onDidSashReset = this.onDidSashResetRelay.event, this.onDidScroll = this._onDidScroll.event, this.onDidChange = this._onDidChange.event, this.element = Y(".monaco-grid-view"), this.styles = e.styles || Kw, this.proportionalLayout = typeof e.proportionalLayout < "u" ? !!e.proportionalLayout : !0, this.layoutController = new Yw(!1), this.root = new re(
      0,
      this.layoutController,
      this.styles,
      this.proportionalLayout
    );
  }
  style(e) {
    this.styles = e, this.root.style(e);
  }
  layout(e, t, i = 0, o = 0) {
    this.layoutController.isLayoutEnabled = !0;
    const [s, n, r, a] = this.root.orientation === 1 ? [t, e, i, o] : [e, t, o, i];
    this.root.layout(s, 0, { orthogonalSize: n, absoluteOffset: r, absoluteOrthogonalOffset: a, absoluteSize: s, absoluteOrthogonalSize: n });
  }
  addView(e, t, i) {
    this.disposable2x2.dispose(), this.disposable2x2 = E.None;
    const [o, s] = ve(i), [n, r] = this.getNode(o);
    if (r instanceof re) {
      const a = new Ee(
        e,
        xt(r.orientation),
        this.layoutController,
        r.orthogonalSize
      );
      r.addChild(a, t, s);
    } else {
      const [, a] = ve(n), [, d] = ve(o);
      let h = 0;
      const g = a.getChildCachedVisibleSize(d);
      typeof g == "number" && (h = st.Invisible(g)), a.removeChild(d);
      const p = new re(
        r.orientation,
        r.layoutController,
        this.styles,
        this.proportionalLayout,
        r.size,
        r.orthogonalSize,
        a.edgeSnapping
      );
      a.addChild(p, r.size, d);
      const m = new Ee(r.view, a.orientation, this.layoutController, r.size);
      p.addChild(m, h, 0), typeof t != "number" && t.type === "split" && (t = st.Split(0));
      const C = new Ee(e, a.orientation, this.layoutController, r.size);
      p.addChild(C, t, s);
    }
    this.trySet2x2();
  }
  removeView(e, t) {
    this.disposable2x2.dispose(), this.disposable2x2 = E.None;
    const [i, o] = ve(e), [s, n] = this.getNode(i);
    if (!(n instanceof re))
      throw new Error("Invalid location");
    const r = n.children[o];
    if (!(r instanceof Ee))
      throw new Error("Invalid location");
    if (n.removeChild(o, t), n.children.length === 0)
      throw new Error("Invalid grid state");
    if (n.children.length > 1)
      return this.trySet2x2(), r.view;
    if (s.length === 0) {
      const m = n.children[0];
      return m instanceof Ee || (n.removeChild(0), this.root = m, this.boundarySashes = this.boundarySashes, this.trySet2x2()), r.view;
    }
    const [, a] = ve(s), [, d] = ve(i), h = n.children[0], g = n.isChildVisible(0);
    n.removeChild(0);
    const p = a.children.map((m, C) => a.getChildSize(C));
    if (a.removeChild(d, t), h instanceof re) {
      p.splice(d, 1, ...h.children.map((m) => m.size));
      for (let m = 0; m < h.children.length; m++) {
        const C = h.children[m];
        a.addChild(C, C.size, d + m);
      }
    } else {
      const m = new Ee(
        h.view,
        xt(h.orientation),
        this.layoutController,
        h.size
      ), C = g ? h.orthogonalSize : st.Invisible(h.orthogonalSize);
      a.addChild(m, C, d);
    }
    for (let m = 0; m < p.length; m++)
      a.resizeChild(m, p[m]);
    return this.trySet2x2(), r.view;
  }
  moveView(e, t, i) {
    const [, o] = this.getNode(e);
    if (!(o instanceof re))
      throw new Error("Invalid location");
    o.moveChild(t, i), this.trySet2x2();
  }
  swapViews(e, t) {
    const [i, o] = ve(e), [, s] = this.getNode(i);
    if (!(s instanceof re))
      throw new Error("Invalid from location");
    const n = s.getChildSize(o), r = s.children[o];
    if (!(r instanceof Ee))
      throw new Error("Invalid from location");
    const [a, d] = ve(t), [, h] = this.getNode(a);
    if (!(h instanceof re))
      throw new Error("Invalid to location");
    const g = h.getChildSize(d), p = h.children[d];
    if (!(p instanceof Ee))
      throw new Error("Invalid to location");
    s === h ? s.swapChildren(o, d) : (s.removeChild(o), h.removeChild(d), s.addChild(p, n, o), h.addChild(r, g, d)), this.trySet2x2();
  }
  resizeView(e, t) {
    const [i, o] = ve(e), [s, n] = this.getNode(i);
    if (!(n instanceof re))
      throw new Error("Invalid location");
    if (!t.width && !t.height)
      return;
    const [r, a] = n.orientation === 1 ? [t.width, t.height] : [t.height, t.width];
    if (typeof a == "number" && s.length > 0) {
      const [, d] = ve(s), [, h] = ve(i);
      d.resizeChild(h, a);
    }
    typeof r == "number" && n.resizeChild(o, r), this.trySet2x2();
  }
  getViewSize(e) {
    if (!e)
      return { width: this.root.width, height: this.root.height };
    const [, t] = this.getNode(e);
    return { width: t.width, height: t.height };
  }
  getViewCachedVisibleSize(e) {
    const [t, i] = ve(e), [, o] = this.getNode(t);
    if (!(o instanceof re))
      throw new Error("Invalid location");
    return o.getChildCachedVisibleSize(i);
  }
  maximizeViewSize(e) {
    const [t, i] = this.getNode(e);
    if (!(i instanceof Ee))
      throw new Error("Invalid location");
    for (let o = 0; o < t.length; o++)
      t[o].resizeChild(e[o], Number.POSITIVE_INFINITY);
  }
  isViewSizeMaximized(e) {
    const [t, i] = this.getNode(e);
    if (!(i instanceof Ee))
      throw new Error("Invalid location");
    for (let o = 0; o < t.length; o++)
      if (!t[o].isChildSizeMaximized(e[o]))
        return !1;
    return !0;
  }
  distributeViewSizes(e) {
    if (!e) {
      this.root.distributeViewSizes(!0);
      return;
    }
    const [, t] = this.getNode(e);
    if (!(t instanceof re))
      throw new Error("Invalid location");
    t.distributeViewSizes(), this.trySet2x2();
  }
  isViewVisible(e) {
    const [t, i] = ve(e), [, o] = this.getNode(t);
    if (!(o instanceof re))
      throw new Error("Invalid from location");
    return o.isChildVisible(i);
  }
  setViewVisible(e, t) {
    const [i, o] = ve(e), [, s] = this.getNode(i);
    if (!(s instanceof re))
      throw new Error("Invalid from location");
    s.setChildVisible(o, t);
  }
  getView(e) {
    const t = e ? this.getNode(e)[1] : this._root;
    return this._getViews(t, this.orientation);
  }
  static deserialize(e, t, i = {}) {
    var r;
    if (typeof e.orientation != "number")
      throw new Error("Invalid JSON: 'orientation' property must be a number.");
    if (typeof e.width != "number")
      throw new Error("Invalid JSON: 'width' property must be a number.");
    if (typeof e.height != "number")
      throw new Error("Invalid JSON: 'height' property must be a number.");
    if (((r = e.root) == null ? void 0 : r.type) !== "branch")
      throw new Error("Invalid JSON: 'root' property must have 'type' value of branch.");
    const o = e.orientation, s = e.height, n = new so(i);
    return n._deserialize(e.root, o, t, s), n;
  }
  _deserialize(e, t, i, o) {
    this.root = this._deserializeNode(e, t, i, o);
  }
  _deserializeNode(e, t, i, o) {
    let s;
    if (e.type === "branch") {
      const r = e.data.map((a) => ({
        node: this._deserializeNode(a, xt(t), i, e.size),
        visible: a.visible
      }));
      s = new re(
        t,
        this.layoutController,
        this.styles,
        this.proportionalLayout,
        e.size,
        o,
        void 0,
        r
      );
    } else
      s = new Ee(
        i.fromJSON(e.data),
        t,
        this.layoutController,
        o,
        e.size
      );
    return s;
  }
  _getViews(e, t, i) {
    const o = { top: e.top, left: e.left, width: e.width, height: e.height };
    if (e instanceof Ee)
      return { view: e.view, box: o, cachedVisibleSize: i };
    const s = [];
    for (let n = 0; n < e.children.length; n++) {
      const r = e.children[n], a = e.getChildCachedVisibleSize(n);
      s.push(this._getViews(r, xt(t), a));
    }
    return { children: s, box: o };
  }
  getNode(e, t = this.root, i = []) {
    if (e.length === 0)
      return [i, t];
    if (!(t instanceof re))
      throw new Error("Invalid location");
    const [o, ...s] = e;
    if (o < 0 || o >= t.children.length)
      throw new Error("Invalid location");
    const n = t.children[o];
    return i.push(t), this.getNode(s, n, i);
  }
  trySet2x2() {
    if (this.disposable2x2.dispose(), this.disposable2x2 = E.None, this.root.children.length !== 2)
      return;
    const [e, t] = this.root.children;
    !(e instanceof re) || !(t instanceof re) || (this.disposable2x2 = e.trySet2x2(t));
  }
  getViewMap(e, t) {
    t || (t = this.root), t instanceof re ? t.children.forEach((i) => this.getViewMap(e, i)) : e.set(t.view, t.element);
  }
  dispose() {
    this.onDidSashResetRelay.dispose(), this.root.dispose(), this.element && this.element.parentElement && this.element.parentElement.removeChild(this.element);
  }
}
function Mw(c) {
  switch (c) {
    case 0:
      return 1;
    case 1:
      return 0;
    case 2:
      return 3;
    case 3:
      return 2;
  }
}
function Ei(c) {
  return !!c.children;
}
function Ig(c, e) {
  if (e.length === 0)
    return c;
  if (!Ei(c))
    throw new Error("Invalid location");
  const [t, ...i] = e;
  return Ig(c.children[t], i);
}
function zw(c, e) {
  return !(c.start >= e.end || e.start >= c.end);
}
function Jg(c, e) {
  const t = Rd(e), i = e === 0 ? c.top : e === 3 ? c.left + c.width : e === 1 ? c.top + c.height : c.left, o = {
    start: t === 1 ? c.top : c.left,
    end: t === 1 ? c.top + c.height : c.left + c.width
  };
  return { offset: i, range: o };
}
function Uw(c, e, t) {
  const i = [];
  function o(s, n, r) {
    if (Ei(s))
      for (const a of s.children)
        o(a, n, r);
    else {
      const { offset: a, range: d } = Jg(s.box, n);
      a === r.offset && zw(d, r.range) && i.push(s);
    }
  }
  return o(c, e, t), i;
}
function ba(c, e) {
  return e.length % 2 === 0 ? xt(c) : c;
}
function Rd(c) {
  return c === 0 || c === 1 ? 0 : 1;
}
function Pl(c, e, t) {
  const i = ba(c, e), o = Rd(t);
  if (i === o) {
    let [s, n] = ve(e);
    return (t === 3 || t === 1) && (n += 1), [...s, n];
  } else {
    const s = t === 3 || t === 1 ? 1 : 0;
    return [...e, s];
  }
}
function jw(c) {
  const e = c.parentElement;
  if (!e)
    throw new Error("Invalid grid element");
  let t = e.firstElementChild, i = 0;
  for (; t !== c && t !== e.lastElementChild && t; )
    t = t.nextElementSibling, i++;
  return i;
}
function Vg(c) {
  const e = c.parentElement;
  if (!e)
    throw new Error("Invalid grid element");
  if (/\bmonaco-grid-view\b/.test(e.className))
    return [];
  const t = jw(e), i = e.parentElement.parentElement.parentElement.parentElement;
  return [...Vg(i), t];
}
var no;
(function(c) {
  c.Distribute = { type: "distribute" }, c.Split = { type: "split" }, c.Auto = { type: "auto" };
  function e(t) {
    return { type: "invisible", cachedVisibleSize: t };
  }
  c.Invisible = e;
})(no || (no = {}));
class qw extends E {
  get orientation() {
    return this.gridview.orientation;
  }
  set orientation(e) {
    this.gridview.orientation = e;
  }
  get width() {
    return this.gridview.width;
  }
  get height() {
    return this.gridview.height;
  }
  get minimumWidth() {
    return this.gridview.minimumWidth;
  }
  get minimumHeight() {
    return this.gridview.minimumHeight;
  }
  get maximumWidth() {
    return this.gridview.maximumWidth;
  }
  get maximumHeight() {
    return this.gridview.maximumHeight;
  }
  get boundarySashes() {
    return this.gridview.boundarySashes;
  }
  set boundarySashes(e) {
    this.gridview.boundarySashes = e;
  }
  set edgeSnapping(e) {
    this.gridview.edgeSnapping = e;
  }
  get element() {
    return this.gridview.element;
  }
  constructor(e, t = {}) {
    super(), this.views = /* @__PURE__ */ new Map(), this.didLayout = !1, e instanceof so ? (this.gridview = e, this.gridview.getViewMap(this.views)) : this.gridview = new so(t), this._register(this.gridview), this._register(this.gridview.onDidSashReset(this.onDidSashReset, this)), e instanceof so || this._addView(e, 0, [0]), this.onDidChange = this.gridview.onDidChange, this.onDidScroll = this.gridview.onDidScroll;
  }
  style(e) {
    this.gridview.style(e);
  }
  layout(e, t, i = 0, o = 0) {
    this.gridview.layout(e, t, i, o), this.didLayout = !0;
  }
  addView(e, t, i, o) {
    if (this.views.has(e))
      throw new Error("Can't add same view twice");
    const s = Rd(o);
    this.views.size === 1 && this.orientation !== s && (this.orientation = s);
    const n = this.getViewLocation(i), r = Pl(this.gridview.orientation, n, o);
    let a;
    if (typeof t == "number")
      a = t;
    else if (t.type === "split") {
      const [, d] = ve(n);
      a = st.Split(d);
    } else if (t.type === "distribute")
      a = st.Distribute;
    else if (t.type === "auto") {
      const [, d] = ve(n);
      a = st.Auto(d);
    } else
      a = t;
    this._addView(e, a, r);
  }
  addViewAt(e, t, i) {
    if (this.views.has(e))
      throw new Error("Can't add same view twice");
    let o;
    typeof t == "number" ? o = t : t.type === "distribute" ? o = st.Distribute : o = t, this._addView(e, o, i);
  }
  _addView(e, t, i) {
    this.views.set(e, e.element), this.gridview.addView(e, t, i);
  }
  removeView(e, t) {
    if (this.views.size === 1)
      throw new Error("Can't remove last view");
    const i = this.getViewLocation(e);
    let o;
    if ((t == null ? void 0 : t.type) === "distribute")
      o = st.Distribute;
    else if ((t == null ? void 0 : t.type) === "auto") {
      const s = i[i.length - 1];
      o = st.Auto(s === 0 ? 1 : s - 1);
    }
    this.gridview.removeView(i, o), this.views.delete(e);
  }
  moveView(e, t, i, o) {
    const s = this.getViewLocation(e), [n, r] = ve(s), a = this.getViewLocation(i), d = Pl(this.gridview.orientation, a, o), [h, g] = ve(d);
    bi(n, h) ? this.gridview.moveView(n, r, g) : (this.removeView(e, typeof t == "number" ? void 0 : t), this.addView(e, t, i, o));
  }
  moveViewTo(e, t) {
    const i = this.getViewLocation(e), [o, s] = ve(i), [n, r] = ve(t);
    if (bi(o, n))
      this.gridview.moveView(o, s, r);
    else {
      const a = this.getViewSize(e), d = ba(this.gridview.orientation, i), h = this.getViewCachedVisibleSize(e), g = typeof h > "u" ? d === 1 ? a.width : a.height : no.Invisible(h);
      this.removeView(e), this.addViewAt(e, g, t);
    }
  }
  swapViews(e, t) {
    const i = this.getViewLocation(e), o = this.getViewLocation(t);
    return this.gridview.swapViews(i, o);
  }
  resizeView(e, t) {
    const i = this.getViewLocation(e);
    return this.gridview.resizeView(i, t);
  }
  isViewSizeMaximized(e) {
    const t = this.getViewLocation(e);
    return this.gridview.isViewSizeMaximized(t);
  }
  getViewSize(e) {
    if (!e)
      return this.gridview.getViewSize();
    const t = this.getViewLocation(e);
    return this.gridview.getViewSize(t);
  }
  getViewCachedVisibleSize(e) {
    const t = this.getViewLocation(e);
    return this.gridview.getViewCachedVisibleSize(t);
  }
  maximizeViewSize(e) {
    const t = this.getViewLocation(e);
    this.gridview.maximizeViewSize(t);
  }
  distributeViewSizes() {
    this.gridview.distributeViewSizes();
  }
  isViewVisible(e) {
    const t = this.getViewLocation(e);
    return this.gridview.isViewVisible(t);
  }
  setViewVisible(e, t) {
    const i = this.getViewLocation(e);
    this.gridview.setViewVisible(i, t);
  }
  getViews() {
    return this.gridview.getView();
  }
  getNeighborViews(e, t, i = !1) {
    if (!this.didLayout)
      throw new Error("Can't call getNeighborViews before first layout");
    const o = this.getViewLocation(e), s = this.getViews(), n = Ig(s, o);
    let r = Jg(n.box, t);
    return i && (t === 0 && n.box.top === 0 ? r = { offset: s.box.top + s.box.height, range: r.range } : t === 3 && n.box.left + n.box.width === s.box.width ? r = { offset: 0, range: r.range } : t === 1 && n.box.top + n.box.height === s.box.height ? r = { offset: 0, range: r.range } : t === 2 && n.box.left === 0 && (r = { offset: s.box.left + s.box.width, range: r.range })), Uw(s, Mw(t), r).map((a) => a.view);
  }
  getViewLocation(e) {
    const t = this.views.get(e);
    if (!t)
      throw new Error("View not found");
    return Vg(t);
  }
  onDidSashReset(e) {
    const t = (s) => {
      const n = this.gridview.getView(s);
      if (Ei(n))
        return !1;
      const r = ba(this.orientation, s), a = r === 1 ? n.view.preferredWidth : n.view.preferredHeight;
      if (typeof a != "number")
        return !1;
      const d = r === 1 ? { width: Math.round(a) } : { height: Math.round(a) };
      return this.gridview.resizeView(s, d), !0;
    };
    if (t(e))
      return;
    const [i, o] = ve(e);
    t([...i, o + 1]) || this.gridview.distributeViewSizes(i);
  }
}
class Wi extends qw {
  constructor() {
    super(...arguments), this.initialLayoutContext = !0;
  }
  static serializeNode(e, t) {
    const i = t === 0 ? e.box.width : e.box.height;
    return Ei(e) ? { type: "branch", data: e.children.map((o) => Wi.serializeNode(o, xt(t))), size: i } : typeof e.cachedVisibleSize == "number" ? { type: "leaf", data: e.view.toJSON(), size: e.cachedVisibleSize, visible: !1 } : { type: "leaf", data: e.view.toJSON(), size: i };
  }
  static deserialize(e, t, i = {}) {
    if (typeof e.orientation != "number")
      throw new Error("Invalid JSON: 'orientation' property must be a number.");
    if (typeof e.width != "number")
      throw new Error("Invalid JSON: 'width' property must be a number.");
    if (typeof e.height != "number")
      throw new Error("Invalid JSON: 'height' property must be a number.");
    const o = so.deserialize(e, t, i);
    return new Wi(o, i);
  }
  static from(e, t = {}) {
    return Wi.deserialize(Rg(e), { fromJSON: (i) => i }, t);
  }
  serialize() {
    return {
      root: Wi.serializeNode(this.getViews(), this.orientation),
      orientation: this.orientation,
      width: this.width,
      height: this.height
    };
  }
  layout(e, t, i = 0, o = 0) {
    super.layout(e, t, i, o), this.initialLayoutContext && (this.initialLayoutContext = !1, this.gridview.trySet2x2());
  }
}
function Zg(c) {
  return !!c.groups;
}
function Wg(c, e) {
  if (!e && c.groups && c.groups.length <= 1 && (c.groups = void 0), !Zg(c))
    return;
  let t = 0, i = 0;
  for (const r of c.groups)
    Wg(r, !1), r.size && (t += r.size, i++);
  const o = i > 0 ? t : 1, s = c.groups.length - i, n = o / s;
  for (const r of c.groups)
    r.size || (r.size = n);
}
function _g(c) {
  return Zg(c) ? { type: "branch", data: c.groups.map((e) => _g(e)), size: c.size } : { type: "leaf", data: c.data, size: c.size };
}
function Eg(c, e) {
  if (c.type === "branch") {
    const t = c.data.map((i) => Eg(i, xt(e)));
    if (e === 0) {
      const i = c.size || (t.length === 0 ? void 0 : Math.max(...t.map((s) => s.width || 0))), o = t.length === 0 ? void 0 : t.reduce((s, n) => s + (n.height || 0), 0);
      return { width: i, height: o };
    } else {
      const i = t.length === 0 ? void 0 : t.reduce((s, n) => s + (n.width || 0), 0), o = c.size || (t.length === 0 ? void 0 : Math.max(...t.map((s) => s.height || 0)));
      return { width: i, height: o };
    }
  } else {
    const t = e === 0 ? c.size : void 0, i = e === 0 ? void 0 : c.size;
    return { width: t, height: i };
  }
}
function Rg(c) {
  Wg(c, !0);
  const e = _g(c), { width: t, height: i } = Eg(e, c.orientation);
  return {
    root: e,
    orientation: c.orientation,
    width: t || 1,
    height: i || 1
  };
}
var $w = '.monaco-workbench .part.editor>.content .editor-group-container{height:100%}.monaco-workbench .part.editor>.content .editor-group-container.empty{opacity:.5}.monaco-workbench .part.editor>.content .editor-group-container.empty.active,.monaco-workbench .part.editor>.content .editor-group-container.empty.dragged-over{opacity:1}.monaco-workbench .part.editor>.content:not(.empty) .editor-group-container.empty.active:focus{outline:1px solid var(--vscode-editorGroup-focusedEmptyBorder);outline-offset:-2px}.monaco-workbench .part.editor>.content.empty .editor-group-container.empty.active:focus{outline:none}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark{align-items:center;display:flex;flex-direction:column;height:100%;justify-content:center;margin:auto;max-width:290px}.monaco-workbench .part.editor>.content .editor-group-container:not(.empty)>.editor-group-watermark{display:none}.monaco-workbench .part.editor>.content:not(.empty) .editor-group-container.empty>.editor-group-watermark{height:calc(100% - 70px);max-width:200px}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.letterpress{aspect-ratio:1/1;background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjYwIDI2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWw6c3BhY2U9InByZXNlcnZlIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEuNDE0MjEiPjxnIG9wYWNpdHk9Ii4xIj48cGF0aCBkPSJNMjU5Ljk5NiAyNDIuMDAySC0uMDAzVjE4aDI2MHYyMjRaTTUuOTk3IDI0LjAwNnYyMTEuOTkxaDI0OFYyNC4wMDZoLTI0OFoiLz48cGF0aCBkPSJNNzcgMjJoMTh2MjE2SDc3ek0xMTIgNDJoNzB2MThoLTcwek0xMTIgMTgyaDcwdjE4aC03MHpNMTI5LjQ5OCA3N2g4OHYxOGgtODh6TTEyOS40OTggMTEyaDg4djE4aC04OHpNMTI5LjQ5OCAxNDdoODh2MThoLTg4eiIvPjwvZz48L3N2Zz4=");background-position-x:center;background-repeat:no-repeat;background-size:contain;max-height:100%;width:100%}.monaco-workbench.vs-dark .part.editor>.content .editor-group-container .editor-group-watermark>.letterpress{background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjYwIDI2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWw6c3BhY2U9InByZXNlcnZlIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEuNDE0MjEiPjxnIG9wYWNpdHk9Ii4zIj48cGF0aCBkPSJNMjU5Ljk5NiAyNDIuMDAySC0uMDAzVjE4aDI2MHYyMjRaTTUuOTk3IDI0LjAwNnYyMTEuOTkxaDI0OFYyNC4wMDZoLTI0OFoiLz48cGF0aCBkPSJNNzcgMjJoMTh2MjE2SDc3ek0xMTIgNDJoNzB2MThoLTcwek0xMTIgMTgyaDcwdjE4aC03MHpNMTI5LjQ5OCA3N2g4OHYxOGgtODh6TTEyOS40OTggMTEyaDg4djE4aC04OHpNMTI5LjQ5OCAxNDdoODh2MThoLTg4eiIvPjwvZz48L3N2Zz4=")}.monaco-workbench.hc-light .part.editor>.content .editor-group-container .editor-group-watermark>.letterpress{background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjYwIDI2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWw6c3BhY2U9InByZXNlcnZlIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEuNDE0MjEiPjxnIGZpbGw9IiNkOWQ5ZDkiPjxwYXRoIGQ9Ik0yNTkuOTk2IDI0Mi4wMDJILS4wMDNWMThoMjYwdjIyNFpNNS45OTcgMjQuMDA2djIxMS45OTFoMjQ4VjI0LjAwNmgtMjQ4WiIvPjxwYXRoIGQ9Ik03NyAyMmgxOHYyMTZINzd6TTExMiA0Mmg3MHYxOGgtNzB6TTExMiAxODJoNzB2MThoLTcwek0xMjkuNDk4IDc3aDg4djE4aC04OHpNMTI5LjQ5OCAxMTJoODh2MThoLTg4ek0xMjkuNDk4IDE0N2g4OHYxOGgtODh6Ii8+PC9nPjwvc3ZnPg==")}.monaco-workbench.hc-black .part.editor>.content .editor-group-container .editor-group-watermark>.letterpress{background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjYwIDI2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWw6c3BhY2U9InByZXNlcnZlIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEuNDE0MjEiPjxnIGZpbGw9IiMzQzNDM0MiPjxwYXRoIGQ9Ik0yNTkuOTk2IDI0Mi4wMDJILS4wMDNWMThoMjYwdjIyNFpNNS45OTcgMjQuMDA2djIxMS45OTFoMjQ4VjI0LjAwNmgtMjQ4WiIvPjxwYXRoIGQ9Ik03NyAyMmgxOHYyMTZINzd6TTExMiA0Mmg3MHYxOGgtNzB6TTExMiAxODJoNzB2MThoLTcwek0xMjkuNDk4IDc3aDg4djE4aC04OHpNMTI5LjQ5OCAxMTJoODh2MThoLTg4ek0xMjkuNDk4IDE0N2g4OHYxOGgtODh6Ii8+PC9nPjwvc3ZnPg==")}.monaco-workbench .part.editor>.content .editor-group-container.max-height-478px>.editor-group-watermark>.shortcuts,.monaco-workbench .part.editor>.content:not(.empty) .editor-group-container>.editor-group-watermark>.shortcuts{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts>.watermark-box{border-collapse:separate;border-spacing:11px 17px;display:inline-table}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts dl{cursor:default;display:table-row;opacity:.8}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts dt{letter-spacing:.04em;text-align:right}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts dd{text-align:left}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts dd,.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts dt{display:table-cell;vertical-align:middle}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts dl,.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts dt{color:rgba(0,0,0,.68)}.monaco-workbench.vs-dark .part.editor>.content .editor-group-container .editor-group-watermark>.shortcuts dl,.monaco-workbench.vs-dark .part.editor>.content .editor-group-container .editor-group-watermark>.shortcuts dt{color:hsla(0,0%,100%,.6)}.monaco-workbench.hc-black .part.editor>.content .editor-group-container .editor-group-watermark>.shortcuts dt,.monaco-workbench.hc-light .part.editor>.content .editor-group-container .editor-group-watermark>.shortcuts dt{color:var(--vscode-editor-foreground)}.monaco-workbench.hc-black .part.editor>.content .editor-group-container .editor-group-watermark>.shortcuts dl,.monaco-workbench.hc-light .part.editor>.content .editor-group-container .editor-group-watermark>.shortcuts dl{color:var(--vscode-editor-foreground);opacity:1}.monaco-workbench .part.editor>.content .editor-group-container>.title{box-sizing:border-box;overflow:hidden;position:relative}.monaco-workbench .part.editor>.content .editor-group-container>.title:not(.tabs){display:flex;flex-wrap:nowrap}.monaco-workbench .part.editor>.content .editor-group-container>.title.title-border-bottom:after{background-color:var(--title-border-bottom-color);bottom:0;content:"";height:1px;left:0;pointer-events:none;position:absolute;width:100%;z-index:9}.monaco-workbench .part.editor>.content .editor-group-container.empty>.title{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-container-toolbar{display:none;height:35px}.monaco-workbench .part.editor>.content:not(.empty) .editor-group-container.empty>.editor-group-container-toolbar{display:block}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-container-toolbar .actions-container{justify-content:flex-end}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-container-toolbar .action-item{margin-right:4px}.monaco-workbench .part.editor>.content .editor-group-container.empty>.editor-container{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.editor-container>.editor-instance{height:100%}.monaco-workbench .part.editor>.content .grid-view-container{height:100%;width:100%}';
oe($w, {});
var ey = '.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container{display:flex;position:relative}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container.tabs-border-bottom:after{background-color:var(--tabs-border-bottom-color);bottom:0;content:"";height:1px;left:0;pointer-events:none;position:absolute;width:100%;z-index:9}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container>.monaco-scrollable-element{flex:1}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container>.monaco-scrollable-element .scrollbar{cursor:default;z-index:11}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container{display:flex;height:35px;scrollbar-width:none}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container.scroll{overflow:scroll!important}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container.wrapping .tabs-container{flex-wrap:wrap;height:auto}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container::-webkit-scrollbar{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab{box-sizing:border-box;cursor:pointer;display:flex;height:35px;padding-left:10px;position:relative;white-space:nowrap}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container.wrapping .tabs-container>.tab:last-child{margin-right:var(--last-tab-margin-right)}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container.wrapping .tabs-container>.tab.last-in-row:not(:last-child){border-right:0!important}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.has-icon.tab-actions-off:not(.sticky-compact),.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.has-icon.tab-actions-right,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.has-icon.tab-actions-off:not(.sticky-compact),.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.has-icon.tab-actions-right{padding-left:5px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fit{flex-shrink:0;min-width:fit-content;width:120px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed{flex:1 0 0;max-width:var(--tab-sizing-current-width,var(--tab-sizing-fixed-max-width,160px));min-width:var(--tab-sizing-current-width,var(--tab-sizing-fixed-min-width,50px))}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.last-in-row{min-width:calc(var(--tab-sizing-current-width, var(--tab-sizing-fixed-min-width, 50px)) - 1px)}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container.wrapping .tabs-container>.tab.sizing-fit.last-in-row:not(:last-child){flex-grow:1}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink{flex-basis:0;flex-grow:1;max-width:fit-content;min-width:80px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fit.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fit.sticky-shrink,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.sticky-shrink,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.sticky-shrink{flex-basis:0;flex-grow:0;position:sticky;z-index:8}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fit.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.sticky-compact{max-width:38px;min-width:38px;width:38px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fit.sticky-shrink,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.sticky-shrink,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.sticky-shrink{max-width:80px;min-width:80px;width:80px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container.disable-sticky-tabs>.tab.sizing-fit.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container.disable-sticky-tabs>.tab.sizing-fit.sticky-shrink,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container.disable-sticky-tabs>.tab.sizing-fixed.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container.disable-sticky-tabs>.tab.sizing-fixed.sticky-shrink,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container.disable-sticky-tabs>.tab.sizing-shrink.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container.disable-sticky-tabs>.tab.sizing-shrink.sticky-shrink{position:static}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.tab-actions-left:after,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.tab-actions-off:after,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.tab-actions-left:after,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.tab-actions-off:after{content:"";display:flex;flex:0;width:5px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.tab-actions-left,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.tab-actions-left{min-width:80px;padding-right:5px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dragged{transform:translateZ(0)}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dragged-over div{pointer-events:none}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-left{flex-direction:row-reverse;padding-left:0;padding-right:10px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab>.tab-border-bottom-container,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab>.tab-border-top-container{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.active.tab-border-bottom>.tab-border-bottom-container,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.active.tab-border-top>.tab-border-top-container,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dirty-border-top>.tab-border-top-container{display:block;left:0;pointer-events:none;position:absolute;width:100%}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.active.tab-border-top>.tab-border-top-container{background-color:var(--tab-border-top-color);height:1px;top:0;z-index:6}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.active.tab-border-bottom>.tab-border-bottom-container{background-color:var(--tab-border-bottom-color);bottom:0;height:1px;z-index:10}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dirty-border-top>.tab-border-top-container{background-color:var(--tab-dirty-border-top-color);height:2px;top:0;z-index:6}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab .tab-label{line-height:35px;margin-bottom:auto;margin-top:auto}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed .tab-label,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink .tab-label{position:relative}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed>.tab-label>.monaco-icon-label-container:after,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink>.tab-label>.monaco-icon-label-container:after{bottom:1px;content:"";height:calc(100% - 2px);opacity:1;padding:0;position:absolute;right:0;top:1px;width:5px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed:focus>.tab-label>.monaco-icon-label-container:after,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink:focus>.tab-label>.monaco-icon-label-container:after{opacity:0}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed>.tab-label.tab-label-has-badge:after,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink>.tab-label.tab-label-has-badge:after{padding-right:5px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sticky-compact:not(.has-icon) .monaco-icon-label{text-align:center}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fit .monaco-icon-label,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fit .monaco-icon-label>.monaco-icon-label-container{overflow:visible}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed>.monaco-icon-label>.monaco-icon-label-container,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink>.monaco-icon-label>.monaco-icon-label-container{flex:none;text-overflow:clip}.monaco-workbench.hc-black .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed>.monaco-icon-label>.monaco-icon-label-container,.monaco-workbench.hc-black .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink>.monaco-icon-label>.monaco-icon-label-container,.monaco-workbench.hc-light .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed>.monaco-icon-label>.monaco-icon-label-container,.monaco-workbench.hc-light .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink>.monaco-icon-label>.monaco-icon-label-container{text-overflow:ellipsis}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab>.tab-actions{margin-bottom:auto;margin-top:auto;width:28px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab>.tab-actions>.monaco-action-bar{width:28px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-right.sizing-fixed>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-right.sizing-shrink>.tab-actions{flex:0;overflow:hidden}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dirty.tab-actions-right.sizing-fixed>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dirty.tab-actions-right.sizing-shrink>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sticky.tab-actions-right.sizing-fixed>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sticky.tab-actions-right.sizing-shrink>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-right.sizing-fixed:hover>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-right.sizing-fixed>.tab-actions:focus-within,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-right.sizing-shrink:hover>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-right.sizing-shrink>.tab-actions:focus-within{overflow:visible}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-off.sticky-compact>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-off:not(.dirty):not(.sticky)>.tab-actions{display:none}.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab.active:hover>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab.active>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab.dirty>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab.sticky>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab:hover>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab>.tab-actions .action-label:focus{opacity:1}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab>.tab-actions .actions-container{justify-content:center}.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab>.tab-actions .action-label.codicon{color:inherit;font-size:16px;height:16px;padding:2px;width:16px}.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab.sticky.dirty>.tab-actions .action-label:not(:hover):before,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sticky.dirty>.tab-actions .action-label:not(:hover):before{content:"\\ebb2"}.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab.dirty>.tab-actions .action-label:not(:hover):before,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dirty>.tab-actions .action-label:not(:hover):before{content:"\\ea71"}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.active:hover>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.active>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dirty>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sticky>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab:hover>.tab-actions .action-label{opacity:.5}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab>.tab-actions .action-label{opacity:0}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-off{padding-right:10px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.tab-actions-off:not(.sticky-compact),.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.tab-actions-off:not(.sticky-compact){padding-right:5px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-off.dirty-border-top>.tab-actions{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-off.dirty:not(.dirty-border-top):not(.sticky-compact),.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-off.sticky:not(.sticky-compact){padding-right:0}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-off>.tab-actions{pointer-events:none}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control{cursor:default;flex:1 100%;height:22px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control .monaco-icon-label{height:22px;line-height:22px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control .monaco-icon-label:before{height:22px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control .outline-element-icon{height:22px;line-height:22px;padding-right:3px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item{max-width:80%}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item:before{align-items:center;display:flex;height:22px;justify-content:center;width:16px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item:last-child{padding-right:8px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item:last-child .codicon:last-child{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.title .editor-actions{cursor:default;flex:initial;height:35px;padding:0 8px 0 4px}.monaco-workbench .part.editor>.content .editor-group-container>.title .editor-actions .action-item{margin-right:4px}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container.wrapping .editor-actions{bottom:0;position:absolute;right:0}';
oe(ey, {});
var ty = ".monaco-workbench .part.editor>.content .editor-group-container>.title{cursor:pointer}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab .tab-label,.monaco-workbench .part.editor>.content .editor-group-container>.title .title-label{flex:1;white-space:nowrap}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab .tab-label a,.monaco-workbench .part.editor>.content .editor-group-container>.title .title-label a{font-size:13px}.monaco-workbench .part.editor>.content .editor-group-container>.title .monaco-icon-label:before,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab .monaco-icon-label:before,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab .tab-label a,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab .tab-label span,.monaco-workbench .part.editor>.content .editor-group-container>.title .title-label a,.monaco-workbench .part.editor>.content .editor-group-container>.title .title-label h2{cursor:pointer}.monaco-workbench .part.editor>.content .editor-group-container>.title .monaco-icon-label:before{height:35px}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .monaco-icon-label:after,.monaco-workbench .part.editor>.content .editor-group-container>.title.tabs .monaco-icon-label:after{margin-right:0}.monaco-editor-group-drag-image{border-radius:10px;display:inline-block;font-size:12px;padding:1px 7px;position:absolute}";
oe(ty, {});
class Gd {
  dispose() {
  }
}
class iy {
  constructor(e, t, i, o) {
    this._disposables = new Z(), this._onDidSelectItem = new w(), this._onDidFocusItem = new w(), this._onDidChangeFocus = new w(), this.onDidSelectItem = this._onDidSelectItem.event, this.onDidFocusItem = this._onDidFocusItem.event, this.onDidChangeFocus = this._onDidChangeFocus.event, this._items = new Array(), this._nodes = new Array(), this._freeNodes = new Array(), this._enabled = !0, this._focusedItemIdx = -1, this._selectedItemIdx = -1, this._domNode = document.createElement("div"), this._domNode.className = "monaco-breadcrumbs", this._domNode.tabIndex = 0, this._domNode.setAttribute("role", "list"), this._scrollable = new Jm(this._domNode, {
      vertical: 2,
      horizontal: 1,
      horizontalScrollbarSize: t,
      useShadows: !1,
      scrollYToX: !0
    }), this._separatorIcon = i, this._disposables.add(this._scrollable), this._disposables.add(Vm(this._domNode, "click", (r) => this._onClick(r))), e.appendChild(this._scrollable.getDomNode());
    const s = Vh(this._domNode);
    this._style(s, o);
    const n = pi(this._domNode);
    this._disposables.add(n), this._disposables.add(n.onDidBlur((r) => this._onDidChangeFocus.fire(!1))), this._disposables.add(n.onDidFocus((r) => this._onDidChangeFocus.fire(!0)));
  }
  setHorizontalScrollbarSize(e) {
    this._scrollable.updateOptions({
      horizontalScrollbarSize: e
    });
  }
  dispose() {
    var e;
    this._disposables.dispose(), (e = this._pendingLayout) === null || e === void 0 || e.dispose(), this._onDidSelectItem.dispose(), this._onDidFocusItem.dispose(), this._onDidChangeFocus.dispose(), this._domNode.remove(), this._nodes.length = 0, this._freeNodes.length = 0;
  }
  layout(e) {
    var t;
    e && H.equals(e, this._dimension) || ((t = this._pendingLayout) === null || t === void 0 || t.dispose(), e ? this._pendingLayout = this._updateDimensions(e) : this._pendingLayout = this._updateScrollbar());
  }
  _updateDimensions(e) {
    const t = new Z();
    return t.add(Zm(() => {
      this._dimension = e, this._domNode.style.width = `${e.width}px`, this._domNode.style.height = `${e.height}px`, t.add(this._updateScrollbar());
    })), t;
  }
  _updateScrollbar() {
    return el(() => {
      el(() => {
        this._scrollable.setRevealOnScroll(!1), this._scrollable.scanDomNode(), this._scrollable.setRevealOnScroll(!0);
      });
    });
  }
  _style(e, t) {
    let i = "";
    t.breadcrumbsBackground && (i += `.monaco-breadcrumbs { background-color: ${t.breadcrumbsBackground}}`), t.breadcrumbsForeground && (i += `.monaco-breadcrumbs .monaco-breadcrumb-item { color: ${t.breadcrumbsForeground}}
`), t.breadcrumbsFocusForeground && (i += `.monaco-breadcrumbs .monaco-breadcrumb-item.focused { color: ${t.breadcrumbsFocusForeground}}
`), t.breadcrumbsFocusAndSelectionForeground && (i += `.monaco-breadcrumbs .monaco-breadcrumb-item.focused.selected { color: ${t.breadcrumbsFocusAndSelectionForeground}}
`), t.breadcrumbsHoverForeground && (i += `.monaco-breadcrumbs:not(.disabled	) .monaco-breadcrumb-item:hover:not(.focused):not(.selected) { color: ${t.breadcrumbsHoverForeground}}
`), e.innerText = i;
  }
  setEnabled(e) {
    this._enabled = e, this._domNode.classList.toggle("disabled", !this._enabled);
  }
  domFocus() {
    const e = this._focusedItemIdx >= 0 ? this._focusedItemIdx : this._items.length - 1;
    e >= 0 && e < this._items.length ? this._focus(e, void 0) : this._domNode.focus();
  }
  isDOMFocused() {
    let e = document.activeElement;
    for (; e; ) {
      if (this._domNode === e)
        return !0;
      e = e.parentElement;
    }
    return !1;
  }
  getFocused() {
    return this._items[this._focusedItemIdx];
  }
  setFocused(e, t) {
    this._focus(this._items.indexOf(e), t);
  }
  focusPrev(e) {
    this._focusedItemIdx > 0 && this._focus(this._focusedItemIdx - 1, e);
  }
  focusNext(e) {
    this._focusedItemIdx + 1 < this._nodes.length && this._focus(this._focusedItemIdx + 1, e);
  }
  _focus(e, t) {
    this._focusedItemIdx = -1;
    for (let i = 0; i < this._nodes.length; i++) {
      const o = this._nodes[i];
      i !== e ? o.classList.remove("focused") : (this._focusedItemIdx = i, o.classList.add("focused"), o.focus());
    }
    this._reveal(this._focusedItemIdx, !0), this._onDidFocusItem.fire({ type: "focus", item: this._items[this._focusedItemIdx], node: this._nodes[this._focusedItemIdx], payload: t });
  }
  reveal(e) {
    const t = this._items.indexOf(e);
    t >= 0 && this._reveal(t, !1);
  }
  revealLast() {
    this._reveal(this._items.length - 1, !1);
  }
  _reveal(e, t) {
    if (e < 0 || e >= this._nodes.length)
      return;
    const i = this._nodes[e];
    if (!i)
      return;
    const { width: o } = this._scrollable.getScrollDimensions(), { scrollLeft: s } = this._scrollable.getScrollPosition();
    (!t || i.offsetLeft > s + o || i.offsetLeft < s) && (this._scrollable.setRevealOnScroll(!1), this._scrollable.setScrollPosition({ scrollLeft: i.offsetLeft }), this._scrollable.setRevealOnScroll(!0));
  }
  getSelection() {
    return this._items[this._selectedItemIdx];
  }
  setSelection(e, t) {
    this._select(this._items.indexOf(e), t);
  }
  _select(e, t) {
    this._selectedItemIdx = -1;
    for (let i = 0; i < this._nodes.length; i++) {
      const o = this._nodes[i];
      i !== e ? o.classList.remove("selected") : (this._selectedItemIdx = i, o.classList.add("selected"));
    }
    this._onDidSelectItem.fire({ type: "select", item: this._items[this._selectedItemIdx], node: this._nodes[this._selectedItemIdx], payload: t });
  }
  getItems() {
    return this._items;
  }
  setItems(e) {
    let t, i = [];
    try {
      t = Wm(this._items, e, (o, s) => o.equals(s)), i = this._items.splice(t, this._items.length - t, ...e.slice(t)), this._render(t), le(i), this._focus(-1, void 0);
    } catch (o) {
      const s = new Error(`BreadcrumbsItem#setItems: newItems: ${e.length}, prefix: ${t}, removed: ${i.length}`);
      throw s.name = o.name, s.stack = o.stack, s;
    }
  }
  _render(e) {
    let t = !1;
    for (; e < this._items.length && e < this._nodes.length; e++) {
      const i = this._items[e], o = this._nodes[e];
      this._renderItem(i, o), t = !0;
    }
    for (; e < this._nodes.length; ) {
      const i = this._nodes.pop();
      i && (this._freeNodes.push(i), i.remove(), t = !0);
    }
    for (; e < this._items.length; e++) {
      const i = this._items[e], o = this._freeNodes.length > 0 ? this._freeNodes.pop() : document.createElement("div");
      o && (this._renderItem(i, o), this._domNode.appendChild(o), this._nodes.push(o), t = !0);
    }
    t && this.layout(void 0);
  }
  _renderItem(e, t) {
    Ut(t), t.className = "";
    try {
      e.render(t);
    } catch (o) {
      t.innerText = "<<RENDER ERROR>>", console.error(o);
    }
    t.tabIndex = -1, t.setAttribute("role", "listitem"), t.classList.add("monaco-breadcrumb-item");
    const i = Y(pe.asCSSSelector(this._separatorIcon));
    t.appendChild(i);
  }
  _onClick(e) {
    if (this._enabled)
      for (let t = e.target; t; t = t.parentElement) {
        const i = this._nodes.indexOf(t);
        if (i >= 0) {
          this._focus(i, e), this._select(i, e);
          break;
        }
      }
  }
}
var oy = ".monaco-workbench .part.editor>.content .editor-group-container .breadcrumbs-control.hidden{display:none}.monaco-workbench .part.editor>.content .editor-group-container .breadcrumbs-control .monaco-breadcrumb-item.focused .hint-more,.monaco-workbench .part.editor>.content .editor-group-container .breadcrumbs-control .monaco-breadcrumb-item.focused .monaco-icon-label,.monaco-workbench .part.editor>.content .editor-group-container .breadcrumbs-control .monaco-breadcrumb-item.selected .hint-more,.monaco-workbench .part.editor>.content .editor-group-container .breadcrumbs-control .monaco-breadcrumb-item.selected .monaco-icon-label{text-decoration-line:underline}.monaco-workbench .monaco-breadcrumb-item.shows-symbol-icon .codicon[class*=codicon-symbol-]{padding-right:6px}.monaco-workbench .monaco-breadcrumbs-picker .arrow{border-style:solid;position:absolute;width:0}.monaco-workbench .monaco-breadcrumbs-picker .picker-item{flex:1;line-height:22px}.monaco-workbench .monaco-breadcrumbs-picker .highlighting-tree{display:flex;flex-direction:column;height:100%;overflow:hidden}.monaco-workbench .monaco-breadcrumbs-picker .highlighting-tree>.input{box-sizing:border-box;height:36px;padding:5px 9px;position:relative}.monaco-workbench .monaco-breadcrumbs-picker .highlighting-tree>.tree{height:calc(100% - 36px)}.monaco-workbench .monaco-breadcrumbs-picker .highlighting-tree.inactive>.input{display:none}.monaco-workbench .monaco-breadcrumbs-picker .highlighting-tree.inactive>.tree{height:100%}.monaco-workbench .monaco-breadcrumbs-picker .highlighting-tree .monaco-highlighted-label .highlight{font-weight:700}";
oe(oy, {});
class pn {
  constructor(e, t) {
    this.uri = e, this.kind = t;
  }
}
class Ca {
  constructor(e, t) {
    this.element = e, this.outline = t;
  }
}
let fa = class {
  constructor(e, t, i, o, s) {
    this.resource = e, this._workspaceService = o, this._outlineService = s, this._disposables = new Z(), this._currentOutline = new Re(), this._outlineDisposables = new Z(), this._onDidUpdate = new w(), this.onDidUpdate = this._onDidUpdate.event, this._cfgFilePath = Dt.FilePath.bindTo(i), this._cfgSymbolPath = Dt.SymbolPath.bindTo(i), this._disposables.add(this._cfgFilePath.onDidChange((n) => this._onDidUpdate.fire(this))), this._disposables.add(this._cfgSymbolPath.onDidChange((n) => this._onDidUpdate.fire(this))), this._workspaceService.onDidChangeWorkspaceFolders(this._onDidChangeWorkspaceFolders, this, this._disposables), this._fileInfo = this._initFilePathInfo(e), t && (this._bindToEditor(t), this._disposables.add(s.onDidChange(() => this._bindToEditor(t))), this._disposables.add(t.onDidChangeControl(() => this._bindToEditor(t)))), this._onDidUpdate.fire(this);
  }
  dispose() {
    this._disposables.dispose(), this._cfgFilePath.dispose(), this._cfgSymbolPath.dispose(), this._currentOutline.dispose(), this._outlineDisposables.dispose(), this._onDidUpdate.dispose();
  }
  isRelative() {
    return !!this._fileInfo.folder;
  }
  getElements() {
    let e = [];
    if (this._cfgFilePath.getValue() === "on" ? e = e.concat(this._fileInfo.path) : this._cfgFilePath.getValue() === "last" && this._fileInfo.path.length > 0 && (e = e.concat(this._fileInfo.path.slice(-1))), this._cfgSymbolPath.getValue() === "off" || !this._currentOutline.value)
      return e;
    const t = this._currentOutline.value.config.breadcrumbsDataSource.getBreadcrumbElements();
    for (let i = this._cfgSymbolPath.getValue() === "last" && t.length > 0 ? t.length - 1 : 0; i < t.length; i++)
      e.push(new Ca(t[i], this._currentOutline.value));
    return t.length === 0 && !this._currentOutline.value.isEmpty && e.push(new Ca(this._currentOutline.value, this._currentOutline.value)), e;
  }
  _initFilePathInfo(e) {
    if (_m(e, q.untitled, q.data))
      return {
        folder: void 0,
        path: []
      };
    const t = {
      folder: ui(this._workspaceService.getWorkspaceFolder(e)),
      path: []
    };
    let i = e;
    for (; i && i.path !== "/" && !(t.folder && Be(t.folder.uri, i)); ) {
      t.path.unshift(new pn(i, t.path.length === 0 ? Ae.FILE : Ae.FOLDER));
      const o = i.path.length;
      if (i = Vi(i), i.path.length === o)
        break;
    }
    return t.folder && this._workspaceService.getWorkbenchState() === 3 && t.path.unshift(new pn(t.folder.uri, Ae.ROOT_FOLDER)), t;
  }
  _onDidChangeWorkspaceFolders() {
    this._fileInfo = this._initFilePathInfo(this.resource), this._onDidUpdate.fire(this);
  }
  _bindToEditor(e) {
    const t = new $e();
    this._currentOutline.clear(), this._outlineDisposables.clear(), this._outlineDisposables.add(M(() => t.dispose(!0))), this._outlineService.createOutline(e, 2, t.token).then((i) => {
      t.token.isCancellationRequested && (i == null || i.dispose(), i = void 0), this._currentOutline.value = i, this._onDidUpdate.fire(this), i && this._outlineDisposables.add(i.onDidChange(() => this._onDidUpdate.fire(this)));
    }).catch((i) => {
      this._onDidUpdate.fire(this), ho(i);
    });
  }
};
fa = y([
  l(2, x),
  l(3, at),
  l(4, Yn)
], fa);
let mn = class {
  constructor(e, t, i, o, s) {
    this.resource = t, this._instantiationService = i, this._themeService = o, this._configurationService = s, this._disposables = new Z(), this._fakeEvent = new UIEvent("fakeEvent"), this._onWillPickElement = new w(), this.onWillPickElement = this._onWillPickElement.event, this._previewDispoables = new Re(), this._domNode = document.createElement("div"), this._domNode.className = "monaco-breadcrumbs-picker show-file-icons", e.appendChild(this._domNode);
  }
  dispose() {
    this._disposables.dispose(), this._previewDispoables.dispose(), this._onWillPickElement.dispose(), this._domNode.remove(), setTimeout(() => this._tree.dispose(), 0);
  }
  async show(e, t, i, o, s) {
    const r = this._themeService.getColorTheme().getColor(Zh);
    this._arrow = document.createElement("div"), this._arrow.className = "arrow", this._arrow.style.borderColor = `transparent transparent ${r ? r.toString() : ""}`, this._domNode.appendChild(this._arrow), this._treeContainer = document.createElement("div"), this._treeContainer.style.background = r ? r.toString() : "", this._treeContainer.style.paddingTop = "2px", this._treeContainer.style.borderRadius = "3px", this._treeContainer.style.boxShadow = `0 0 8px 2px ${this._themeService.getColorTheme().getColor(Em)}`, this._treeContainer.style.border = `1px solid ${this._themeService.getColorTheme().getColor(Rm)}`, this._domNode.appendChild(this._treeContainer), this._layoutInfo = { maxHeight: t, width: i, arrowSize: o, arrowOffset: s, inputHeight: 0 }, this._tree = this._createTree(this._treeContainer, e), this._disposables.add(this._tree.onDidOpen(async (a) => {
      const { element: d, editorOptions: h, sideBySide: g } = a;
      await this._revealElement(d, { ...h, preserveFocus: !1 }, g);
    })), this._disposables.add(this._tree.onDidChangeFocus((a) => {
      this._previewDispoables.value = this._previewElement(a.elements[0]);
    })), this._disposables.add(this._tree.onDidChangeContentHeight(() => {
      this._layout();
    })), this._domNode.focus();
    try {
      await this._setInput(e), this._layout();
    } catch (a) {
      ho(a);
    }
  }
  _layout() {
    const e = 2 * this._layoutInfo.arrowSize, t = Math.min(this._layoutInfo.maxHeight - e, this._tree.contentHeight), i = t + e;
    this._domNode.style.height = `${i}px`, this._domNode.style.width = `${this._layoutInfo.width}px`, this._arrow.style.top = `-${2 * this._layoutInfo.arrowSize}px`, this._arrow.style.borderWidth = `${this._layoutInfo.arrowSize}px`, this._arrow.style.marginLeft = `${this._layoutInfo.arrowOffset}px`, this._treeContainer.style.height = `${t}px`, this._treeContainer.style.width = `${this._layoutInfo.width}px`, this._tree.layout(t, this._layoutInfo.width);
  }
  restoreViewState() {
  }
};
mn = y([
  l(2, W),
  l(3, z),
  l(4, x)
], mn);
class sy {
  getHeight(e) {
    return 22;
  }
  getTemplateId(e) {
    return "FileStat";
  }
}
class ny {
  getId(e) {
    return A.isUri(e) ? e.toString() : Rr(e) ? e.id : jt(e) ? e.uri.toString() : e.resource.toString();
  }
}
let va = class {
  constructor(e) {
    this._fileService = e;
  }
  hasChildren(e) {
    return A.isUri(e) || Rr(e) || jt(e) || e.isDirectory;
  }
  async getChildren(e) {
    if (Rr(e))
      return e.folders;
    let t;
    return jt(e) ? t = e.uri : A.isUri(e) ? t = e : t = e.resource, (await this._fileService.resolve(t)).children ?? [];
  }
};
va = y([
  l(0, _e)
], va);
let wa = class {
  constructor(e, t) {
    this._labels = e, this._configService = t, this.templateId = "FileStat";
  }
  renderTemplate(e) {
    return this._labels.create(e, { supportHighlights: !0 });
  }
  renderElement(e, t, i) {
    const o = this._configService.getValue("explorer.decorations"), { element: s } = e;
    let n, r;
    jt(s) ? (n = s.uri, r = Ae.ROOT_FOLDER) : (n = s.resource, r = s.isDirectory ? Ae.FOLDER : Ae.FILE), i.setFile(n, {
      fileKind: r,
      hidePath: !0,
      fileDecorations: o,
      matches: Di(e.filterData),
      extraClasses: ["picker-item"]
    });
  }
  disposeTemplate(e) {
    e.dispose();
  }
};
wa = y([
  l(1, x)
], wa);
class ry {
  getKeyboardNavigationLabel(e) {
    return e.name;
  }
}
class ay {
  getWidgetAriaLabel() {
    return u("breadcrumbs", "Breadcrumbs");
  }
  getAriaLabel(e) {
    return e.name;
  }
}
let ya = class {
  constructor(e, t) {
    this._workspaceService = e, this._cachedExpressions = /* @__PURE__ */ new Map(), this._disposables = new Z();
    const i = Dt.FileExcludes.bindTo(t), o = () => {
      e.getWorkspace().folders.forEach((s) => {
        const n = i.getValue({ resource: s.uri });
        if (!n)
          return;
        const r = {};
        for (const a in n) {
          if (typeof n[a] != "boolean")
            continue;
          const d = a.indexOf("**/") !== 0 ? Wh.join(s.uri.path, a) : a;
          r[d] = n[a];
        }
        this._cachedExpressions.set(s.uri.toString(), xm(r));
      });
    };
    o(), this._disposables.add(i), this._disposables.add(i.onDidChange(o)), this._disposables.add(e.onDidChangeWorkspaceFolders(o));
  }
  dispose() {
    this._disposables.dispose();
  }
  filter(e, t) {
    if (jt(e))
      return !0;
    const i = this._workspaceService.getWorkspaceFolder(e.resource);
    return !i || !this._cachedExpressions.has(i.uri.toString()) ? !0 : !this._cachedExpressions.get(i.uri.toString())(Gm(i.uri.path, e.resource.path), Le(e.resource));
  }
};
ya = y([
  l(0, at),
  l(1, x)
], ya);
class cy {
  compare(e, t) {
    return jt(e) && jt(t) ? e.index - t.index : e.isDirectory === t.isDirectory ? Dm(e.name, t.name) : e.isDirectory ? -1 : 1;
  }
}
let ka = class extends mn {
  constructor(e, t, i, o, s, n, r) {
    super(e, t, i, o, s), this._workspaceService = n, this._editorService = r;
  }
  _createTree(e) {
    this._treeContainer.classList.add("file-icon-themable-tree"), this._treeContainer.classList.add("show-file-icons");
    const t = (o) => {
      this._treeContainer.classList.toggle("align-icons-and-twisties", o.hasFileIcons && !o.hasFolderIcons), this._treeContainer.classList.toggle("hide-arrows", o.hidesExplorerArrows === !0);
    };
    this._disposables.add(this._themeService.onDidFileIconThemeChange(t)), t(this._themeService.getFileIconTheme());
    const i = this._instantiationService.createInstance(On, zc);
    return this._disposables.add(i), this._instantiationService.createInstance(Vs, "BreadcrumbsFilePicker", e, new sy(), [this._instantiationService.createInstance(wa, i)], this._instantiationService.createInstance(va), {
      multipleSelectionSupport: !1,
      sorter: new cy(),
      filter: this._instantiationService.createInstance(ya),
      identityProvider: new ny(),
      keyboardNavigationLabelProvider: new ry(),
      accessibilityProvider: this._instantiationService.createInstance(ay),
      showNotFoundMessage: !1,
      overrideStyles: {
        listBackground: Zh
      }
    });
  }
  async _setInput(e) {
    const { uri: t, kind: i } = e;
    let o;
    i === Ae.ROOT_FOLDER ? o = this._workspaceService.getWorkspace() : o = Vi(t);
    const s = this._tree;
    await s.setInput(o);
    let n;
    for (const { element: r } of s.getNode().children)
      if (jt(r) && Be(r.uri, t)) {
        n = r;
        break;
      } else if (Be(r.resource, t)) {
        n = r;
        break;
      }
    n && (s.reveal(n, 0.5), s.setFocus([n], this._fakeEvent)), s.domFocus();
  }
  _previewElement(e) {
    return E.None;
  }
  async _revealElement(e, t, i) {
    return !jt(e) && e.isFile ? (this._onWillPickElement.fire(), await this._editorService.openEditor({ resource: e.resource, options: t }, i ? uo : void 0), !0) : !1;
  }
};
ka = y([
  l(2, W),
  l(3, z),
  l(4, x),
  l(5, at),
  l(6, D)
], ka);
let Sa = class {
  constructor(e, t, i) {
    this.comparator = e, this._order = i.getValue(t, "breadcrumbs.symbolSortOrder");
  }
  compare(e, t) {
    return this._order === "name" ? this.comparator.compareByName(e, t) : this._order === "type" ? this.comparator.compareByType(e, t) : this.comparator.compareByPosition(e, t);
  }
};
Sa = y([
  l(2, Go)
], Sa);
class dy extends mn {
  _createTree(e, t) {
    const { config: i } = t.outline;
    return this._instantiationService.createInstance(Uc, "BreadcrumbsOutlinePicker", e, i.delegate, i.renderers, i.treeDataSource, {
      ...i.options,
      sorter: this._instantiationService.createInstance(Sa, i.comparator, void 0),
      collapseByDefault: !0,
      expandOnlyOnTwistieClick: !0,
      multipleSelectionSupport: !1,
      showNotFoundMessage: !1
    });
  }
  _setInput(e) {
    const t = e.outline.captureViewState();
    this.restoreViewState = () => {
      t.dispose();
    };
    const i = this._tree;
    return i.setInput(e.outline), e.element !== e.outline && (i.reveal(e.element, 0.5), i.setFocus([e.element], this._fakeEvent)), i.domFocus(), Promise.resolve();
  }
  _previewElement(e) {
    return this._tree.getInput().preview(e);
  }
  async _revealElement(e, t, i) {
    return this._onWillPickElement.fire(), await this._tree.getInput().reveal(e, t, i), !0;
  }
}
class bn extends Gd {
  constructor(e, t, i) {
    super(), this.model = e, this.element = t, this.options = i, this._disposables = new Z();
  }
  dispose() {
    this._disposables.dispose();
  }
  equals(e) {
    return e instanceof bn ? this.element.element === e.element.element && this.options.showFileIcons === e.options.showFileIcons && this.options.showSymbolIcons === e.options.showSymbolIcons : !1;
  }
  render(e) {
    const { element: t, outline: i } = this.element;
    if (t === i) {
      const r = Y("span", void 0, "");
      e.appendChild(r);
      return;
    }
    const o = i.config.delegate.getTemplateId(t), s = i.config.renderers.find((r) => r.templateId === o);
    if (!s) {
      e.innerText = "<<NO RENDERER>>";
      return;
    }
    const n = s.renderTemplate(e);
    s.renderElement({
      element: t,
      children: [],
      depth: 0,
      visibleChildrenCount: 0,
      visibleChildIndex: 0,
      collapsible: !1,
      collapsed: !1,
      visible: !0,
      filterData: void 0
    }, 0, n, void 0), this._disposables.add(M(() => {
      s.disposeTemplate(n);
    }));
  }
}
class Cn extends Gd {
  constructor(e, t, i, o) {
    super(), this.model = e, this.element = t, this.options = i, this._labels = o, this._disposables = new Z();
  }
  dispose() {
    this._disposables.dispose();
  }
  equals(e) {
    return e instanceof Cn ? Bm.isEqual(this.element.uri, e.element.uri) && this.options.showFileIcons === e.options.showFileIcons && this.options.showSymbolIcons === e.options.showSymbolIcons : !1;
  }
  render(e) {
    const t = this._labels.create(e);
    t.setFile(this.element.uri, {
      hidePath: !0,
      hideIcon: this.element.kind === Ae.FOLDER || !this.options.showFileIcons,
      fileKind: this.element.kind,
      fileDecorations: { colors: this.options.showDecorationColors, badges: !1 }
    }), e.classList.add(Ae[this.element.kind].toLowerCase()), this._disposables.add(t);
  }
}
const ly = lo("breadcrumb-separator", he.chevronRight, u("separatorIcon", "Icon for the separator in the breadcrumbs."));
var Se;
let $ = (Se = class {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p) {
    this._options = t, this._editorGroup = i, this._contextKeyService = o, this._contextViewService = s, this._instantiationService = n, this._quickInputService = r, this._fileService = a, this._editorService = d, this._labelService = h, this._disposables = new Z(), this._breadcrumbsDisposables = new Z(), this._model = new Re(), this._breadcrumbsPickerShowing = !1, this.domNode = document.createElement("div"), this.domNode.classList.add("breadcrumbs-control"), ae(e, this.domNode), this._cfUseQuickPick = Dt.UseQuickPick.bindTo(g), this._cfShowIcons = Dt.Icons.bindTo(g), this._cfTitleScrollbarSizing = Dt.TitleScrollbarSizing.bindTo(g), this._labels = this._instantiationService.createInstance(On, zc);
    const m = this._cfTitleScrollbarSizing.getValue() ?? "default", C = t.widgetStyles ?? _h;
    this._widget = new iy(
      this.domNode,
      Se.SCROLLBAR_SIZES[m],
      ly,
      C
    ), this._widget.onDidSelectItem(this._onSelectEvent, this, this._disposables), this._widget.onDidFocusItem(this._onFocusEvent, this, this._disposables), this._widget.onDidChangeFocus(this._updateCkBreadcrumbsActive, this, this._disposables), this._ckBreadcrumbsPossible = Se.CK_BreadcrumbsPossible.bindTo(this._contextKeyService), this._ckBreadcrumbsVisible = Se.CK_BreadcrumbsVisible.bindTo(this._contextKeyService), this._ckBreadcrumbsActive = Se.CK_BreadcrumbsActive.bindTo(this._contextKeyService), this._disposables.add(p.register(this._editorGroup.id, this._widget)), this.hide();
  }
  dispose() {
    this._disposables.dispose(), this._breadcrumbsDisposables.dispose(), this._ckBreadcrumbsPossible.reset(), this._ckBreadcrumbsVisible.reset(), this._ckBreadcrumbsActive.reset(), this._cfUseQuickPick.dispose(), this._cfShowIcons.dispose(), this._widget.dispose(), this._labels.dispose(), this.domNode.remove();
  }
  get model() {
    return this._model.value;
  }
  layout(e) {
    this._widget.layout(e);
  }
  isHidden() {
    return this.domNode.classList.contains("hidden");
  }
  hide() {
    this._breadcrumbsDisposables.clear(), this._ckBreadcrumbsVisible.set(!1), this.domNode.classList.toggle("hidden", !0);
  }
  revealLast() {
    this._widget.revealLast();
  }
  update() {
    this._breadcrumbsDisposables.clear();
    const e = me.getCanonicalUri(this._editorGroup.activeEditor, { supportSideBySide: ie.PRIMARY }), t = this.isHidden();
    if (!e || !this._fileService.hasProvider(e))
      return this._ckBreadcrumbsPossible.set(!1), t ? !1 : (this.hide(), !0);
    const i = me.getOriginalUri(this._editorGroup.activeEditor, { supportSideBySide: ie.PRIMARY });
    this.domNode.classList.toggle("hidden", !1), this._ckBreadcrumbsVisible.set(!0), this._ckBreadcrumbsPossible.set(!0);
    const o = this._instantiationService.createInstance(fa, i ?? e, this._editorGroup.activeEditorPane);
    this._model.value = o, this.domNode.classList.toggle("backslash-path", this._labelService.getSeparator(e.scheme, e.authority) === "\\");
    const s = () => {
      this.domNode.classList.toggle("relative-path", o.isRelative());
      const h = this._cfShowIcons.getValue(), g = {
        ...this._options,
        showFileIcons: this._options.showFileIcons && h,
        showSymbolIcons: this._options.showSymbolIcons && h
      }, p = o.getElements().map((m) => m instanceof pn ? new Cn(o, m, g, this._labels) : new bn(o, m, g));
      p.length === 0 ? (this._widget.setEnabled(!1), this._widget.setItems([new class extends Gd {
        render(m) {
          m.innerText = u("empty", "no elements");
        }
        equals(m) {
          return m === this;
        }
      }()])) : (this._widget.setEnabled(!0), this._widget.setItems(p), this._widget.reveal(p[p.length - 1]));
    }, n = o.onDidUpdate(s), r = this._cfShowIcons.onDidChange(s);
    s(), this._breadcrumbsDisposables.clear(), this._breadcrumbsDisposables.add(n), this._breadcrumbsDisposables.add(M(() => this._model.clear())), this._breadcrumbsDisposables.add(r), this._breadcrumbsDisposables.add(M(() => this._widget.setItems([])));
    const a = () => {
      const h = this._cfTitleScrollbarSizing.getValue() ?? "default";
      this._widget.setHorizontalScrollbarSize(Se.SCROLLBAR_SIZES[h]);
    };
    a();
    const d = this._cfTitleScrollbarSizing.onDidChange(a);
    return this._breadcrumbsDisposables.add(d), this._breadcrumbsDisposables.add({
      dispose: () => {
        this._breadcrumbsPickerShowing && this._contextViewService.hideContextView({ source: this });
      }
    }), t !== this.isHidden();
  }
  _onFocusEvent(e) {
    e.item && this._breadcrumbsPickerShowing && (this._breadcrumbsPickerIgnoreOnceItem = void 0, this._widget.setSelection(e.item));
  }
  _onSelectEvent(e) {
    if (!e.item)
      return;
    if (e.item === this._breadcrumbsPickerIgnoreOnceItem) {
      this._breadcrumbsPickerIgnoreOnceItem = void 0, this._widget.setFocused(void 0), this._widget.setSelection(void 0);
      return;
    }
    const { element: t } = e.item;
    this._editorGroup.focus();
    const i = this._getEditorGroup(e.payload);
    if (i !== void 0) {
      this._widget.setFocused(void 0), this._widget.setSelection(void 0), this._revealInEditor(e, t, i);
      return;
    }
    if (this._cfUseQuickPick.getValue()) {
      this._widget.setFocused(void 0), this._widget.setSelection(void 0), this._quickInputService.quickAccess.show(t instanceof Ca ? "@" : "");
      return;
    }
    let o, s;
    this._contextViewService.showContextView({
      render: (n) => {
        e.item instanceof Cn ? o = this._instantiationService.createInstance(ka, n, e.item.model.resource) : e.item instanceof bn && (o = this._instantiationService.createInstance(dy, n, e.item.model.resource));
        const r = o.onWillPickElement(() => this._contextViewService.hideContextView({ source: this, didPick: !0 })), a = Nm.onDidChange(() => this._contextViewService.hideContextView({ source: this })), d = pi(n), h = d.onDidBlur(() => {
          this._breadcrumbsPickerIgnoreOnceItem = this._widget.isDOMFocused() ? e.item : void 0, this._contextViewService.hideContextView({ source: this });
        });
        return this._breadcrumbsPickerShowing = !0, this._updateCkBreadcrumbsActive(), Gr(o, r, a, d, h);
      },
      getAnchor: () => {
        if (!s) {
          const n = window.innerWidth - 8;
          let r = Math.min(window.innerHeight * 0.7, 300);
          const a = Math.min(n, Math.max(240, n / 4.17)), d = 8;
          let h;
          const g = Qm(e.node.firstChild), p = g.top + g.height + d;
          p + r >= window.innerHeight && (r = window.innerHeight - p - 30);
          let m = g.left;
          if (m + a >= n && (m = n - a), e.payload instanceof kt) {
            const C = a - 2 * d;
            h = e.payload.posx - m, h > C && (m = Math.min(n - a, m + h - C), h = C);
          } else
            h = g.left + g.width * 0.3 - m;
          o.show(t, r, a, d, Math.max(0, h)), s = { x: m, y: p };
        }
        return s;
      },
      onHide: (n) => {
        n != null && n.didPick || o.restoreViewState(), this._breadcrumbsPickerShowing = !1, this._updateCkBreadcrumbsActive(), (n == null ? void 0 : n.source) === this && (this._widget.setFocused(void 0), this._widget.setSelection(void 0)), o.dispose();
      }
    });
  }
  _updateCkBreadcrumbsActive() {
    const e = this._widget.isDOMFocused() || this._breadcrumbsPickerShowing;
    this._ckBreadcrumbsActive.set(e);
  }
  async _revealInEditor(e, t, i, o = !1) {
    if (t instanceof pn)
      if (t.kind === Ae.FILE)
        await this._editorService.openEditor({ resource: t.uri, options: { pinned: o } }, i);
      else {
        const s = this._widget.getItems(), n = s.indexOf(e.item);
        this._widget.setFocused(s[n + 1]), this._widget.setSelection(s[n + 1], Se.Payload_Pick);
      }
    else
      t.outline.reveal(t, { pinned: o }, i === uo);
  }
  _getEditorGroup(e) {
    return e === Se.Payload_RevealAside ? uo : e === Se.Payload_Reveal ? Am : void 0;
  }
}, Se.HEIGHT = 22, Se.SCROLLBAR_SIZES = {
  default: 3,
  large: 8
}, Se.Payload_Reveal = {}, Se.Payload_RevealAside = {}, Se.Payload_Pick = {}, Se.CK_BreadcrumbsPossible = new K("breadcrumbsPossible", !1, u("breadcrumbsPossible", "Whether the editor can show breadcrumbs")), Se.CK_BreadcrumbsVisible = new K("breadcrumbsVisible", !1, u("breadcrumbsVisible", "Whether breadcrumbs are currently visible")), Se.CK_BreadcrumbsActive = new K("breadcrumbsActive", !1, u("breadcrumbsActive", "Whether breadcrumbs have focus")), Se);
$ = y([
  l(3, F),
  l(4, Fn),
  l(5, W),
  l(6, Is),
  l(7, _e),
  l(8, D),
  l(9, Ft),
  l(10, x),
  l(11, Xt)
], $);
P(class extends ye {
  constructor() {
    super({
      id: "breadcrumbs.toggle",
      title: {
        value: u("cmd.toggle", "Toggle Breadcrumbs"),
        mnemonicTitle: u(
          { key: "miBreadcrumbs", comment: ["&& denotes a mnemonic"] },
          "Toggle &&Breadcrumbs"
        ),
        original: "Toggle Breadcrumbs"
      },
      category: Ce.View,
      toggled: {
        condition: f.equals("config.breadcrumbs.enabled", !0),
        title: u("cmd.toggle2", "Breadcrumbs"),
        mnemonicTitle: u(
          { key: "miBreadcrumbs2", comment: ["&& denotes a mnemonic"] },
          "&&Breadcrumbs"
        )
      },
      menu: [
        { id: k.CommandPalette },
        { id: k.MenubarAppearanceMenu, group: "4_editor", order: 2 },
        { id: k.NotebookToolbar, group: "notebookLayout", order: 2 },
        { id: k.StickyScrollContext }
      ]
    });
  }
  run(e) {
    const t = e.get(x), i = Dt.IsEnabled.bindTo(t).getValue();
    Dt.IsEnabled.bindTo(t).updateValue(!i);
  }
});
function xd(c, e) {
  const t = c.get(ce), o = c.get(Xt).getWidget(t.activeGroup.id);
  if (o) {
    const s = Eh(o.getItems());
    o.setFocused(s), e && o.setSelection(s, $.Payload_Pick);
  }
}
P(class extends ye {
  constructor() {
    super({
      id: "breadcrumbs.focusAndSelect",
      title: {
        value: u("cmd.focusAndSelect", "Focus and Select Breadcrumbs"),
        original: "Focus and Select Breadcrumbs"
      },
      precondition: $.CK_BreadcrumbsVisible,
      keybinding: {
        weight: 200,
        primary: 3161,
        when: $.CK_BreadcrumbsPossible
      },
      f1: !0
    });
  }
  run(e, ...t) {
    xd(e, !0);
  }
});
P(class extends ye {
  constructor() {
    super({
      id: "breadcrumbs.focus",
      title: {
        value: u("cmd.focus", "Focus Breadcrumbs"),
        original: "Focus Breadcrumbs"
      },
      precondition: $.CK_BreadcrumbsVisible,
      keybinding: {
        weight: 200,
        primary: 3157,
        when: $.CK_BreadcrumbsPossible
      },
      f1: !0
    });
  }
  run(e, ...t) {
    xd(e, !1);
  }
});
V.registerCommandAndKeybindingRule({
  id: "breadcrumbs.toggleToOn",
  weight: 200,
  primary: 3161,
  when: f.not("config.breadcrumbs.enabled"),
  handler: async (c) => {
    const e = c.get(W), t = c.get(x), i = Dt.IsEnabled.bindTo(t);
    return i.getValue() || (await i.updateValue(!0), await jc(50)), e.invokeFunction(xd, !0);
  }
});
V.registerCommandAndKeybindingRule({
  id: "breadcrumbs.focusNext",
  weight: 200,
  primary: 17,
  secondary: [2065],
  mac: {
    primary: 17,
    secondary: [529]
  },
  when: f.and(
    $.CK_BreadcrumbsVisible,
    $.CK_BreadcrumbsActive
  ),
  handler(c) {
    const e = c.get(ce), i = c.get(Xt).getWidget(e.activeGroup.id);
    i && i.focusNext();
  }
});
V.registerCommandAndKeybindingRule({
  id: "breadcrumbs.focusPrevious",
  weight: 200,
  primary: 15,
  secondary: [2063],
  mac: {
    primary: 15,
    secondary: [527]
  },
  when: f.and(
    $.CK_BreadcrumbsVisible,
    $.CK_BreadcrumbsActive
  ),
  handler(c) {
    const e = c.get(ce), i = c.get(Xt).getWidget(e.activeGroup.id);
    i && i.focusPrev();
  }
});
V.registerCommandAndKeybindingRule({
  id: "breadcrumbs.focusNextWithPicker",
  weight: 200 + 1,
  primary: 2065,
  mac: {
    primary: 529
  },
  when: f.and(
    $.CK_BreadcrumbsVisible,
    $.CK_BreadcrumbsActive,
    te
  ),
  handler(c) {
    const e = c.get(ce), i = c.get(Xt).getWidget(e.activeGroup.id);
    i && i.focusNext();
  }
});
V.registerCommandAndKeybindingRule({
  id: "breadcrumbs.focusPreviousWithPicker",
  weight: 200 + 1,
  primary: 2063,
  mac: {
    primary: 527
  },
  when: f.and(
    $.CK_BreadcrumbsVisible,
    $.CK_BreadcrumbsActive,
    te
  ),
  handler(c) {
    const e = c.get(ce), i = c.get(Xt).getWidget(e.activeGroup.id);
    i && i.focusPrev();
  }
});
V.registerCommandAndKeybindingRule({
  id: "breadcrumbs.selectFocused",
  weight: 200,
  primary: 3,
  secondary: [18],
  when: f.and(
    $.CK_BreadcrumbsVisible,
    $.CK_BreadcrumbsActive
  ),
  handler(c) {
    const e = c.get(ce), i = c.get(Xt).getWidget(e.activeGroup.id);
    i && i.setSelection(i.getFocused(), $.Payload_Pick);
  }
});
V.registerCommandAndKeybindingRule({
  id: "breadcrumbs.revealFocused",
  weight: 200,
  primary: 10,
  secondary: [2051],
  when: f.and(
    $.CK_BreadcrumbsVisible,
    $.CK_BreadcrumbsActive
  ),
  handler(c) {
    const e = c.get(ce), i = c.get(Xt).getWidget(e.activeGroup.id);
    i && i.setSelection(i.getFocused(), $.Payload_Reveal);
  }
});
V.registerCommandAndKeybindingRule({
  id: "breadcrumbs.selectEditor",
  weight: 200 + 1,
  primary: 9,
  when: f.and(
    $.CK_BreadcrumbsVisible,
    $.CK_BreadcrumbsActive
  ),
  handler(c) {
    var o;
    const e = c.get(ce), i = c.get(Xt).getWidget(e.activeGroup.id);
    i && (i.setFocused(void 0), i.setSelection(void 0), (o = e.activeGroup.activeEditorPane) == null || o.focus());
  }
});
V.registerCommandAndKeybindingRule({
  id: "breadcrumbs.revealFocusedFromTreeAside",
  weight: 200,
  primary: 2051,
  when: f.and(
    $.CK_BreadcrumbsVisible,
    $.CK_BreadcrumbsActive,
    te
  ),
  handler(c) {
    const e = c.get(D), i = c.get(B).lastFocusedList;
    if (!(i instanceof Uc) && !(i instanceof Vs))
      return;
    const o = i.getFocus()[0];
    if (A.isUri(o == null ? void 0 : o.resource))
      return e.openEditor({
        resource: o.resource,
        options: { pinned: !0 }
      }, uo);
    const s = i.getInput();
    if (s && typeof s.outlineKind == "string")
      return s.reveal(o, {
        pinned: !0,
        preserveFocus: !1
      }, !0);
  }
});
class Gg extends Tn {
  constructor(e) {
    super(), this.context = e;
  }
  run(e, t) {
    let i = this.context;
    return t != null && t.preserveFocus && (i = {
      ...this.context,
      preserveFocus: !0
    }), super.run(e, i);
  }
}
let fn = class extends Hn {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m, C) {
    super(g), this.accessor = t, this.group = i, this.contextMenuService = o, this.instantiationService = s, this.contextKeyService = n, this.keybindingService = r, this.notificationService = a, this.menuService = d, this.quickInputService = h, this.configurationService = p, this.fileService = m, this.editorResolverService = C, this.editorTransfer = Pt.getInstance(), this.groupTransfer = Pt.getInstance(), this.treeItemsTransfer = Pt.getInstance(), this.breadcrumbsControl = void 0, this.editorToolBarMenuDisposables = this._register(new Z()), this.resourceContext = this._register(s.createInstance(ke)), this.editorPinnedContext = Rh.bindTo(n), this.editorIsFirstContext = Gh.bindTo(n), this.editorIsLastContext = xh.bindTo(n), this.editorStickyContext = Dh.bindTo(n), this.editorAvailableEditorIds = Nh.bindTo(this.contextKeyService), this.editorCanSplitInGroupContext = Tm.bindTo(n), this.sideBySideEditorContext = Lm.bindTo(n), this.groupLockedContext = Qh.bindTo(n), this.renderDropdownAsChildElement = !1, this.create(e);
  }
  createBreadcrumbsControl(e, t) {
    const i = this._register(Dt.IsEnabled.bindTo(this.configurationService));
    this._register(i.onDidChange(() => {
      const o = i.getValue();
      !o && this.breadcrumbsControl ? (this.breadcrumbsControl.dispose(), this.breadcrumbsControl = void 0, this.handleBreadcrumbsEnablementChange()) : o && !this.breadcrumbsControl && (this.breadcrumbsControl = this.instantiationService.createInstance($, e, t, this.group), this.breadcrumbsControl.update(), this.handleBreadcrumbsEnablementChange());
    })), i.getValue() && (this.breadcrumbsControl = this.instantiationService.createInstance($, e, t, this.group)), this._register(this.fileService.onDidChangeFileSystemProviderRegistrations((o) => {
      var s, n;
      (s = this.breadcrumbsControl) != null && s.model && this.breadcrumbsControl.model.resource.scheme !== o.scheme || (n = this.breadcrumbsControl) != null && n.update() && this.handleBreadcrumbsEnablementChange();
    }));
  }
  createEditorActionsToolBar(e) {
    const t = { groupId: this.group.id };
    this.editorActionsToolbar = this._register(this.instantiationService.createInstance(ah, e, {
      actionViewItemProvider: (i) => this.actionViewItemProvider(i),
      orientation: 0,
      ariaLabel: u("ariaLabelEditorActions", "Editor actions"),
      getKeyBinding: (i) => this.getKeybinding(i),
      actionRunner: this._register(new Gg(t)),
      anchorAlignmentProvider: () => 1,
      renderDropdownAsChildElement: this.renderDropdownAsChildElement,
      telemetrySource: "editorPart",
      resetMenu: k.EditorTitle,
      maxNumberOfItems: 9
    })), this.editorActionsToolbar.context = t, this._register(this.editorActionsToolbar.actionRunner.onDidRun((i) => {
      i.error && !Qi(i.error) && this.notificationService.error(i.error);
    }));
  }
  actionViewItemProvider(e) {
    const t = this.group.activeEditorPane;
    if (t instanceof xr) {
      const i = t.getActionViewItem(e);
      if (i)
        return i;
    }
    return Ac(this.instantiationService, e, { menuAsChild: this.renderDropdownAsChildElement });
  }
  updateEditorActionsToolbar() {
    const { primary: e, secondary: t } = this.prepareEditorActions(this.getEditorActions());
    L(this.editorActionsToolbar).setActions(ro(e), ro(t));
  }
  getEditorActions() {
    const e = [], t = [];
    if (this.editorToolBarMenuDisposables.clear(), this.contextKeyService.bufferChangeEvents(() => {
      const o = this.group.activeEditor;
      this.resourceContext.set(tl(me.getOriginalUri(o, { supportSideBySide: ie.PRIMARY }))), this.editorPinnedContext.set(o ? this.group.isPinned(o) : !1), this.editorIsFirstContext.set(o ? this.group.isFirst(o) : !1), this.editorIsLastContext.set(o ? this.group.isLast(o) : !1), this.editorStickyContext.set(o ? this.group.isSticky(o) : !1), il(this.editorAvailableEditorIds, o, this.editorResolverService), this.editorCanSplitInGroupContext.set(o ? o.hasCapability(32) : !1), this.sideBySideEditorContext.set((o == null ? void 0 : o.typeId) === li.ID), this.groupLockedContext.set(this.group.isLocked);
    }), this.group.activeEditorPane instanceof xr) {
      const o = this.getEditorPaneAwareContextKeyService(), s = this.menuService.createMenu(k.EditorTitle, o, { emitEventsForSubmenuChanges: !0, eventDebounceDelay: 0 });
      this.editorToolBarMenuDisposables.add(s), this.editorToolBarMenuDisposables.add(s.onDidChange(() => {
        this.updateEditorActionsToolbar();
      }));
      const n = (r, a) => a === "navigation" && r.actions.length <= 1;
      ks(s, { arg: this.resourceContext.get(), shouldForwardArgs: !0 }, { primary: e, secondary: t }, "navigation", n);
    }
    return { primary: e, secondary: t };
  }
  getEditorPaneAwareContextKeyService() {
    var e;
    return ((e = this.group.activeEditorPane) == null ? void 0 : e.scopedContextKeyService) ?? this.contextKeyService;
  }
  clearEditorActionsToolbar() {
    var e;
    (e = this.editorActionsToolbar) == null || e.setActions([], []);
  }
  enableGroupDragging(e) {
    this._register(S(e, I.DRAG_START, (t) => {
      var o;
      if (t.target !== e)
        return;
      this.groupTransfer.setData([new Ye(this.group.id)], Ye.prototype), t.dataTransfer && (t.dataTransfer.effectAllowed = "copyMove");
      let i = !1;
      if (this.accessor.partOptions.showTabs ? i = this.doFillResourceDataTransfers(this.group.getEditors(1), t) : this.group.activeEditor && (i = this.doFillResourceDataTransfers([this.group.activeEditor], t)), !i && Dr && ((o = t.dataTransfer) == null || o.setData(io.TEXT, String(this.group.label))), this.group.activeEditor) {
        let s = this.group.activeEditor.getName();
        this.accessor.partOptions.showTabs && this.group.count > 1 && (s = u("draggedEditorGroup", "{0} (+{1})", s, this.group.count - 1)), Fm(t, s, "monaco-editor-group-drag-image", this.getColor(Km), this.getColor(Xm));
      }
    })), this._register(S(e, I.DRAG_END, () => {
      this.groupTransfer.clearData(Ye.prototype);
    }));
  }
  doFillResourceDataTransfers(e, t) {
    return e.length ? (this.instantiationService.invokeFunction(Ah, e.map((i) => ({ editor: i, groupId: this.group.id })), t), !0) : !1;
  }
  onContextMenu(e, t, i) {
    const o = this.resourceContext.get();
    this.resourceContext.set(tl(me.getOriginalUri(e, { supportSideBySide: ie.PRIMARY })));
    const s = !!this.editorPinnedContext.get();
    this.editorPinnedContext.set(this.group.isPinned(e));
    const n = !!this.editorIsFirstContext.get();
    this.editorIsFirstContext.set(this.group.isFirst(e));
    const r = !!this.editorIsLastContext.get();
    this.editorIsLastContext.set(this.group.isLast(e));
    const a = !!this.editorStickyContext.get();
    this.editorStickyContext.set(this.group.isSticky(e));
    const d = !!this.groupLockedContext.get();
    this.groupLockedContext.set(this.group.isLocked);
    const h = !!this.editorCanSplitInGroupContext.get();
    this.editorCanSplitInGroupContext.set(e.hasCapability(32));
    const g = !!this.sideBySideEditorContext.get();
    this.sideBySideEditorContext.set(e.typeId === li.ID);
    const p = this.editorAvailableEditorIds.get() ?? "";
    il(this.editorAvailableEditorIds, e, this.editorResolverService);
    let m = i;
    t instanceof MouseEvent && (m = new kt(t)), this.contextMenuService.showContextMenu({
      getAnchor: () => m,
      menuId: k.EditorTitleContext,
      menuActionOptions: { shouldForwardArgs: !0, arg: this.resourceContext.get() },
      contextKeyService: this.contextKeyService,
      getActionsContext: () => ({ groupId: this.group.id, editorIndex: this.group.getIndexOfEditor(e) }),
      getKeyBinding: (C) => this.getKeybinding(C),
      onHide: () => {
        this.resourceContext.set(o || null), this.editorPinnedContext.set(s), this.editorIsFirstContext.set(n), this.editorIsLastContext.set(r), this.editorStickyContext.set(a), this.groupLockedContext.set(d), this.editorCanSplitInGroupContext.set(h), this.sideBySideEditorContext.set(g), this.editorAvailableEditorIds.set(p), this.accessor.activeGroup.focus();
      }
    });
  }
  getKeybinding(e) {
    return this.keybindingService.lookupKeybinding(e.id, this.getEditorPaneAwareContextKeyService());
  }
  getKeybindingLabel(e) {
    const t = this.getKeybinding(e);
    return t ? ui(t.getLabel()) : void 0;
  }
  dispose() {
    le(this.breadcrumbsControl), this.breadcrumbsControl = void 0, super.dispose();
  }
};
fn = y([
  l(3, Ie),
  l(4, W),
  l(5, F),
  l(6, be),
  l(7, We),
  l(8, lt),
  l(9, Is),
  l(10, z),
  l(11, x),
  l(12, _e),
  l(13, Zs)
], fn);
var ge;
let Ia = (ge = class extends fn {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m, C, b, v, J, R) {
    super(e, t, i, o, s, n, r, a, d, h, g, p, m, R), this.editorService = C, this.pathService = b, this.editorGroupService = v, this.treeViewsDragAndDropService = J, this.closeEditorAction = this._register(this.instantiationService.createInstance(ar, ar.ID, ar.LABEL)), this.unpinEditorAction = this._register(this.instantiationService.createInstance(cr, cr.ID, cr.LABEL)), this.tabResourceLabels = this._register(this.instantiationService.createInstance(On, zc)), this.tabLabels = [], this.tabActionBars = [], this.tabDisposables = [], this.dimensions = {
      container: H.None,
      available: H.None
    }, this.layoutScheduler = this._register(new Re()), this.path = Qt ? Ym : Wh, this.lastMouseWheelEventTime = 0, this.isMouseOverTabs = !1, this.updateEditorLabelScheduler = this._register(new Ss(() => this.doUpdateEditorLabels(), 0)), (async () => this.path = await this.pathService.path)(), this._register(this.tabResourceLabels.onDidChangeDecorations(() => this.doHandleDecorationsChange()));
  }
  create(e) {
    this.titleContainer = e, this.tabsAndActionsContainer = document.createElement("div"), this.tabsAndActionsContainer.classList.add("tabs-and-actions-container"), this.titleContainer.appendChild(this.tabsAndActionsContainer), this.tabsContainer = document.createElement("div"), this.tabsContainer.setAttribute("role", "tablist"), this.tabsContainer.draggable = !0, this.tabsContainer.classList.add("tabs-container"), this._register(zt.addTarget(this.tabsContainer)), this.tabSizingFixedDisposables = this._register(new Z()), this.updateTabSizing(!1), this.tabsScrollbar = this._register(this.createTabsScrollbar(this.tabsContainer)), this.tabsAndActionsContainer.appendChild(this.tabsScrollbar.getDomNode()), this.registerTabsContainerListeners(this.tabsContainer, this.tabsScrollbar), this.editorToolbarContainer = document.createElement("div"), this.editorToolbarContainer.classList.add("editor-actions"), this.tabsAndActionsContainer.appendChild(this.editorToolbarContainer), this.createEditorActionsToolBar(this.editorToolbarContainer);
    const t = document.createElement("div");
    t.classList.add("tabs-breadcrumbs"), this.titleContainer.appendChild(t), this.createBreadcrumbsControl(t, { showFileIcons: !0, showSymbolIcons: !0, showDecorationColors: !1, showPlaceholder: !0 });
  }
  createTabsScrollbar(e) {
    const t = new Om(e, {
      horizontal: 1,
      horizontalScrollbarSize: this.getTabsScrollbarSizing(),
      vertical: 2,
      scrollYToX: !0,
      useShadows: !1
    });
    return t.onScroll((i) => {
      i.scrollLeftChanged && (e.scrollLeft = i.scrollLeft);
    }), t;
  }
  updateTabsScrollbarSizing() {
    var e;
    (e = this.tabsScrollbar) == null || e.updateOptions({
      horizontalScrollbarSize: this.getTabsScrollbarSizing()
    });
  }
  updateTabSizing(e) {
    const [t, i] = Yi(this.tabsContainer, this.tabSizingFixedDisposables);
    i.clear();
    const o = this.accessor.partOptions;
    o.tabSizing === "fixed" ? (t.style.setProperty("--tab-sizing-fixed-min-width", `${o.tabSizingFixedMinWidth}px`), t.style.setProperty("--tab-sizing-fixed-max-width", `${o.tabSizingFixedMaxWidth}px`), i.add(S(t, I.MOUSE_ENTER, () => {
      this.isMouseOverTabs = !0;
    })), i.add(S(t, I.MOUSE_LEAVE, () => {
      this.isMouseOverTabs = !1, this.updateTabsFixedWidth(!1);
    }))) : e && (t.style.removeProperty("--tab-sizing-fixed-min-width"), t.style.removeProperty("--tab-sizing-fixed-max-width"), this.updateTabsFixedWidth(!1));
  }
  updateTabsFixedWidth(e) {
    this.forEachTab((t, i, o) => {
      if (e) {
        const { width: s } = o.getBoundingClientRect();
        o.style.setProperty("--tab-sizing-current-width", `${s}px`);
      } else
        o.style.removeProperty("--tab-sizing-current-width");
    });
  }
  getTabsScrollbarSizing() {
    return this.accessor.partOptions.titleScrollbarSizing !== "large" ? ge.SCROLLBAR_SIZES.default : ge.SCROLLBAR_SIZES.large;
  }
  registerTabsContainerListeners(e, t) {
    this.enableGroupDragging(e), this._register(S(e, I.SCROLL, () => {
      e.classList.contains("scroll") && t.setScrollPosition({
        scrollLeft: e.scrollLeft
      });
    }));
    for (const o of [Ne.Tap, I.DBLCLICK])
      this._register(S(e, o, (s) => {
        if (o === I.DBLCLICK) {
          if (s.target !== e)
            return;
        } else if (s.tapCount !== 2 || s.initialTarget !== e)
          return;
        U.stop(s), this.editorService.openEditor({
          resource: void 0,
          options: {
            pinned: !0,
            index: this.group.count,
            override: Ke.id
          }
        }, this.group.id);
      }));
    this._register(S(e, I.MOUSE_DOWN, (o) => {
      o.button === 1 && o.preventDefault();
    })), this._register(new Nr(e, {
      onDragEnter: (o) => {
        if (e.classList.add("scroll"), o.target !== e) {
          this.updateDropFeedback(e, !1);
          return;
        }
        if (!this.isSupportedDropTransfer(o)) {
          o.dataTransfer && (o.dataTransfer.dropEffect = "none");
          return;
        }
        let s = !1;
        if (this.editorTransfer.hasData(Ve.prototype)) {
          s = !0;
          const n = this.editorTransfer.getData(Ve.prototype);
          if (Array.isArray(n)) {
            const r = n[0].identifier;
            if (this.group.id === r.groupId && this.group.getIndexOfEditor(r.editor) === this.group.count - 1) {
              o.dataTransfer && (o.dataTransfer.dropEffect = "none");
              return;
            }
          }
        }
        s || o.dataTransfer && (o.dataTransfer.dropEffect = "copy"), this.updateDropFeedback(e, !0);
      },
      onDragLeave: (o) => {
        this.updateDropFeedback(e, !1), e.classList.remove("scroll");
      },
      onDragEnd: (o) => {
        this.updateDropFeedback(e, !1), e.classList.remove("scroll");
      },
      onDrop: (o) => {
        this.updateDropFeedback(e, !1), e.classList.remove("scroll"), o.target === e && this.onDrop(o, this.group.count, e);
      }
    })), this._register(S(e, I.MOUSE_WHEEL, (o) => {
      const s = this.group.activeEditor;
      if (!s || this.group.count < 2)
        return;
      if (this.accessor.partOptions.scrollToSwitchTabs === !0) {
        if (o.shiftKey)
          return;
      } else if (!o.shiftKey)
        return;
      const n = Date.now();
      if (n - this.lastMouseWheelEventTime < ge.MOUSE_WHEEL_EVENT_THRESHOLD - 2 * (Math.abs(o.deltaX) + Math.abs(o.deltaY)))
        return;
      this.lastMouseWheelEventTime = n;
      let r;
      if (o.deltaX + o.deltaY < -ge.MOUSE_WHEEL_DISTANCE_THRESHOLD)
        r = -1;
      else if (o.deltaX + o.deltaY > ge.MOUSE_WHEEL_DISTANCE_THRESHOLD)
        r = 1;
      else
        return;
      const a = this.group.getEditorByIndex(this.group.getIndexOfEditor(s) + r);
      a && (this.group.openEditor(a), U.stop(o, !0));
    }));
    const i = (o) => {
      U.stop(o);
      let s = e;
      o instanceof MouseEvent && (s = new kt(o)), this.contextMenuService.showContextMenu({
        getAnchor: () => s,
        menuId: k.EditorTabsBarContext,
        contextKeyService: this.contextKeyService,
        menuActionOptions: { shouldForwardArgs: !0 },
        getActionsContext: () => ({ groupId: this.group.id }),
        getKeyBinding: (n) => this.getKeybinding(n),
        onHide: () => this.group.focus()
      });
    };
    this._register(S(e, Ne.Contextmenu, (o) => i(o))), this._register(S(e, I.CONTEXT_MENU, (o) => i(o)));
  }
  doHandleDecorationsChange() {
    this.layout(this.dimensions);
  }
  updateEditorActionsToolbar() {
    super.updateEditorActionsToolbar(), this.layout(this.dimensions);
  }
  openEditor(e) {
    this.handleOpenedEditors();
  }
  openEditors(e) {
    this.handleOpenedEditors();
  }
  handleOpenedEditors() {
    var n, r;
    const [e, t] = Yi(this.tabsContainer, this.tabsScrollbar);
    for (let a = e.children.length; a < this.group.count; a++)
      e.appendChild(this.createTab(a, e, t));
    const i = this.didActiveEditorChange(), o = this.activeTabLabel, s = this.tabLabels.length;
    this.computeTabLabels(), i || s !== this.tabLabels.length || !this.equalsEditorInputLabel(o, this.activeTabLabel) ? (this.redraw({ forceRevealActiveTab: !0 }), (n = this.breadcrumbsControl) == null || n.update()) : (this.layout(this.dimensions, { forceRevealActiveTab: !0 }), (r = this.breadcrumbsControl) == null || r.revealLast());
  }
  didActiveEditorChange() {
    var e, t, i;
    return !!(!((e = this.activeTabLabel) != null && e.editor) && this.group.activeEditor || (t = this.activeTabLabel) != null && t.editor && !this.group.activeEditor || !((i = this.activeTabLabel) != null && i.editor) || !this.group.isActive(this.activeTabLabel.editor));
  }
  equalsEditorInputLabel(e, t) {
    return e === t ? !0 : !e || !t ? !1 : e.name === t.name && e.description === t.description && e.forceDescription === t.forceDescription && e.title === t.title && e.ariaLabel === t.ariaLabel;
  }
  beforeCloseEditor(e) {
    if (this.isMouseOverTabs && this.accessor.partOptions.tabSizing === "fixed") {
      const t = this.group.isLast(e);
      this.updateTabsFixedWidth(!t);
    }
  }
  closeEditor(e) {
    this.handleClosedEditors();
  }
  closeEditors(e) {
    this.handleClosedEditors();
  }
  handleClosedEditors() {
    var e, t;
    if (this.group.activeEditor) {
      const i = L(this.tabsContainer);
      for (; i.children.length > this.group.count; )
        (e = i.lastChild) == null || e.remove(), le(this.tabDisposables.pop());
      this.computeTabLabels(), this.redraw({ forceRevealActiveTab: !0 });
    } else
      this.tabsContainer && Ut(this.tabsContainer), this.tabDisposables = le(this.tabDisposables), this.tabResourceLabels.clear(), this.tabLabels = [], this.activeTabLabel = void 0, this.tabActionBars = [], this.clearEditorActionsToolbar(), (t = this.breadcrumbsControl) == null || t.update();
  }
  moveEditor(e, t, i) {
    const o = this.tabLabels[t];
    this.tabLabels.splice(t, 1), this.tabLabels.splice(i, 0, o), this.forEachTab(
      (s, n, r, a, d, h) => {
        this.redrawTab(s, n, r, a, d, h);
      },
      Math.min(t, i),
      Math.max(t, i)
    ), this.layout(this.dimensions, { forceRevealActiveTab: !0 });
  }
  pinEditor(e) {
    this.withTab(e, (t, i, o, s, n) => this.redrawTabLabel(t, i, o, s, n));
  }
  stickEditor(e) {
    this.doHandleStickyEditorChange(e);
  }
  unstickEditor(e) {
    this.doHandleStickyEditorChange(e);
  }
  doHandleStickyEditorChange(e) {
    this.withTab(e, (t, i, o, s, n, r) => this.redrawTab(t, i, o, s, n, r)), this.forEachTab((t, i, o, s, n) => {
      this.redrawTabBorders(i, o);
    }), this.layout(this.dimensions, { forceRevealActiveTab: !0 });
  }
  setActive(e) {
    this.forEachTab((t, i, o, s, n, r) => {
      this.redrawTabActiveAndDirty(e, t, o, r);
    }), this.updateEditorActionsToolbar(), this.layout(this.dimensions, { forceRevealActiveTab: !0 });
  }
  updateEditorLabel(e) {
    this.updateEditorLabelScheduler.schedule();
  }
  doUpdateEditorLabels() {
    this.computeTabLabels(), this.forEachTab((e, t, i, o, s) => {
      this.redrawTabLabel(e, t, i, o, s);
    }), this.layout(this.dimensions);
  }
  updateEditorDirty(e) {
    this.withTab(e, (t, i, o, s, n, r) => this.redrawTabActiveAndDirty(this.accessor.activeGroup === this.group, t, o, r));
  }
  updateOptions(e, t) {
    e.labelFormat !== t.labelFormat && this.computeTabLabels(), e.titleScrollbarSizing !== t.titleScrollbarSizing && this.updateTabsScrollbarSizing(), (e.tabSizingFixedMinWidth !== t.tabSizingFixedMinWidth || e.tabSizingFixedMaxWidth !== t.tabSizingFixedMaxWidth || e.tabSizing !== t.tabSizing) && this.updateTabSizing(!0), (e.labelFormat !== t.labelFormat || e.tabCloseButton !== t.tabCloseButton || e.tabSizing !== t.tabSizing || e.pinnedTabSizing !== t.pinnedTabSizing || e.showIcons !== t.showIcons || e.hasIcons !== t.hasIcons || e.highlightModifiedTabs !== t.highlightModifiedTabs || e.wrapTabs !== t.wrapTabs || !Bh(e.decorations, t.decorations)) && this.redraw();
  }
  updateStyles() {
    this.redraw();
  }
  forEachTab(e, t, i) {
    this.group.editors.forEach((o, s) => {
      typeof t == "number" && t > s || typeof i == "number" && i < s || this.doWithTab(s, o, e);
    });
  }
  withTab(e, t) {
    this.doWithTab(this.group.getIndexOfEditor(e), e, t);
  }
  doWithTab(e, t, i) {
    const s = L(this.tabsContainer).children[e], n = this.tabResourceLabels.get(e), r = this.tabLabels[e], a = this.tabActionBars[e];
    s && n && r && i(t, e, s, n, r, a);
  }
  createTab(e, t, i) {
    const o = document.createElement("div");
    o.draggable = !0, o.setAttribute("role", "tab"), o.classList.add("tab"), this._register(zt.addTarget(o));
    const s = document.createElement("div");
    s.classList.add("tab-border-top-container"), o.appendChild(s);
    const n = this.tabResourceLabels.create(o), r = document.createElement("div");
    r.classList.add("tab-actions"), o.appendChild(r);
    const a = new Gg({ groupId: this.group.id, editorIndex: e }), d = new Ro(r, { ariaLabel: u("ariaLabelTabActions", "Tab actions"), actionRunner: a });
    d.onWillRun((m) => {
      m.action.id === this.closeEditorAction.id && this.blockRevealActiveTabOnce();
    });
    const h = Gr(d, M(Th(this.tabActionBars, d))), g = document.createElement("div");
    g.classList.add("tab-border-bottom-container"), o.appendChild(g);
    const p = this.registerTabListeners(o, e, t, i);
    return this.tabDisposables.push(Gr(p, h, a, n)), o;
  }
  registerTabListeners(e, t, i, o) {
    const s = new Z(), n = (a, d) => {
      if (e.blur(), a instanceof MouseEvent && (a.button !== 0 || Ze && a.ctrlKey)) {
        a.button === 1 && a.preventDefault();
        return;
      }
      if (this.originatesFromTabActionBar(a))
        return;
      const h = this.group.getEditorByIndex(t);
      h && this.group.openEditor(h, { preserveFocus: d, activation: Zi.ACTIVATE });
    }, r = (a) => {
      U.stop(a);
      const d = this.group.getEditorByIndex(t);
      d && this.onContextMenu(d, a, e);
    };
    s.add(S(e, I.MOUSE_DOWN, (a) => n(a, !1))), s.add(S(e, Ne.Tap, (a) => n(a, !0))), s.add(S(e, Ne.Change, (a) => {
      o.setScrollPosition({ scrollLeft: o.getScrollPosition().scrollLeft - a.translationX });
    })), s.add(S(e, I.MOUSE_UP, (a) => {
      U.stop(a), e.blur();
    })), s.add(S(e, I.AUXCLICK, (a) => {
      a.button === 1 && (U.stop(a, !0), this.blockRevealActiveTabOnce(), this.closeEditorAction.run({ groupId: this.group.id, editorIndex: t }));
    })), s.add(S(e, I.KEY_DOWN, (a) => {
      const d = new yt(a);
      d.shiftKey && d.keyCode === 68 && r(a);
    })), s.add(S(e, Ne.Contextmenu, (a) => {
      r(a);
    })), s.add(S(e, I.KEY_UP, (a) => {
      const d = new yt(a);
      let h = !1;
      if (d.equals(3) || d.equals(10)) {
        h = !0;
        const g = this.group.getEditorByIndex(t);
        g && this.group.openEditor(g);
      } else if ([15, 17, 16, 18, 14, 13].some((g) => d.equals(g))) {
        let g;
        d.equals(15) || d.equals(16) ? g = t - 1 : d.equals(17) || d.equals(18) ? g = t + 1 : d.equals(14) ? g = 0 : g = this.group.count - 1;
        const p = this.group.getEditorByIndex(g);
        p && (h = !0, this.group.openEditor(p, { preserveFocus: !0 }), i.childNodes[g].focus());
      }
      h && U.stop(a, !0), o.setScrollPosition({
        scrollLeft: i.scrollLeft
      });
    }));
    for (const a of [Ne.Tap, I.DBLCLICK])
      s.add(S(e, a, (d) => {
        if (a === I.DBLCLICK)
          U.stop(d);
        else if (d.tapCount !== 2)
          return;
        const h = this.group.getEditorByIndex(t);
        h && this.group.isPinned(h) ? this.accessor.partOptions.doubleClickTabToToggleEditorGroupSizes && this.accessor.arrangeGroups(2, this.group) : this.group.pinEditor(h);
      }));
    return s.add(S(e, I.CONTEXT_MENU, (a) => {
      U.stop(a, !0);
      const d = this.group.getEditorByIndex(t);
      d && this.onContextMenu(d, a, e);
    }, !0)), s.add(S(e, I.DRAG_START, (a) => {
      const d = this.group.getEditorByIndex(t);
      d && (this.editorTransfer.setData([new Ve({ editor: d, groupId: this.group.id })], Ve.prototype), a.dataTransfer && (a.dataTransfer.effectAllowed = "copyMove"), this.doFillResourceDataTransfers([d], a), e.classList.add("dragged"), Zr(() => e.classList.remove("dragged")));
    })), s.add(new Nr(e, {
      onDragEnter: (a) => {
        if (e.classList.add("dragged-over"), !this.isSupportedDropTransfer(a)) {
          a.dataTransfer && (a.dataTransfer.dropEffect = "none");
          return;
        }
        let d = !1;
        if (this.editorTransfer.hasData(Ve.prototype)) {
          d = !0;
          const h = this.editorTransfer.getData(Ve.prototype);
          if (Array.isArray(h)) {
            const g = h[0].identifier;
            if (g.editor === this.group.getEditorByIndex(t) && g.groupId === this.group.id) {
              a.dataTransfer && (a.dataTransfer.dropEffect = "none");
              return;
            }
          }
        }
        d || a.dataTransfer && (a.dataTransfer.dropEffect = "copy"), this.updateDropFeedback(e, !0, t);
      },
      onDragOver: (a, d) => {
        if (d >= ge.DRAG_OVER_OPEN_TAB_THRESHOLD) {
          const h = this.group.getEditorByIndex(t);
          h && this.group.activeEditor !== h && this.group.openEditor(h, { preserveFocus: !0 });
        }
      },
      onDragLeave: () => {
        e.classList.remove("dragged-over"), this.updateDropFeedback(e, !1, t);
      },
      onDragEnd: () => {
        e.classList.remove("dragged-over"), this.updateDropFeedback(e, !1, t), this.editorTransfer.clearData(Ve.prototype);
      },
      onDrop: (a) => {
        e.classList.remove("dragged-over"), this.updateDropFeedback(e, !1, t), this.onDrop(a, t, i);
      }
    })), s;
  }
  isSupportedDropTransfer(e) {
    if (this.groupTransfer.hasData(Ye.prototype)) {
      const t = this.groupTransfer.getData(Ye.prototype);
      return !(Array.isArray(t) && t[0].identifier === this.group.id);
    }
    return !!(this.editorTransfer.hasData(Ve.prototype) || e.dataTransfer && e.dataTransfer.types.length > 0);
  }
  updateDropFeedback(e, t, i) {
    const o = typeof i == "number", s = typeof i == "number" ? this.group.getEditorByIndex(i) : void 0, n = o && !!s && this.group.isActive(s), r = o ? this.getColor(n ? Qr : Ar) : "";
    e.style.backgroundColor = (t ? this.getColor(Ln) : r) || "";
    const a = this.getColor(co);
    a && t ? (e.style.outlineWidth = "2px", e.style.outlineStyle = "dashed", e.style.outlineColor = a, e.style.outlineOffset = o ? "-5px" : "-3px") : (e.style.outlineWidth = "", e.style.outlineStyle = "", e.style.outlineColor = a || "", e.style.outlineOffset = "");
  }
  computeTabLabels() {
    const { labelFormat: e } = this.accessor.partOptions, { verbosity: t, shortenDuplicates: i } = this.getLabelConfigFlags(e), o = [];
    let s = -1;
    for (let n = 0; n < this.group.editors.length; n++) {
      const r = this.group.editors[n];
      o.push({
        editor: r,
        name: r.getName(),
        description: r.getDescription(t),
        forceDescription: r.hasCapability(64),
        title: r.getTitle(2),
        ariaLabel: Hm(r, n, this.group, this.editorGroupService.count)
      }), r === this.group.activeEditor && (s = n);
    }
    i && this.shortenTabLabels(o), this.tabLabels = o, this.activeTabLabel = o[s];
  }
  shortenTabLabels(e) {
    const t = /* @__PURE__ */ new Map();
    for (const i of e)
      typeof i.description == "string" ? dr(t, i.name, []).push(i) : i.description = "";
    for (const [, i] of t) {
      if (i.length === 1 && !i[0].forceDescription) {
        i[0].description = "";
        continue;
      }
      const o = /* @__PURE__ */ new Map();
      for (const a of i)
        dr(o, a.description, []).push(a);
      let s = !1;
      for (const [, a] of o)
        if (!s && a.length > 1) {
          const [d, ...h] = a.map(({ editor: g }) => g.getDescription(2));
          s = h.some((g) => g !== d);
        }
      if (s) {
        o.clear();
        for (const a of i)
          a.description = a.editor.getDescription(2), dr(o, a.description, []).push(a);
      }
      const n = [];
      for (const [a] of o)
        n.push(a);
      if (n.length === 1) {
        for (const a of o.get(n[0]) || [])
          a.forceDescription || (a.description = "");
        continue;
      }
      const r = Pm(n, this.path.sep);
      n.forEach((a, d) => {
        for (const h of o.get(a) || [])
          h.description = r[d];
      });
    }
  }
  getLabelConfigFlags(e) {
    switch (e) {
      case "short":
        return { verbosity: 0, shortenDuplicates: !1 };
      case "medium":
        return { verbosity: 1, shortenDuplicates: !1 };
      case "long":
        return { verbosity: 2, shortenDuplicates: !1 };
      default:
        return { verbosity: 1, shortenDuplicates: !0 };
    }
  }
  redraw(e) {
    if (this.tabsAndActionsContainer) {
      let t = this.getColor(Mm);
      !t && qc(this.theme.type) && (t = this.getColor(Br) || this.getColor(Oe)), t ? (this.tabsAndActionsContainer.classList.add("tabs-border-bottom"), this.tabsAndActionsContainer.style.setProperty("--tabs-border-bottom-color", t.toString())) : (this.tabsAndActionsContainer.classList.remove("tabs-border-bottom"), this.tabsAndActionsContainer.style.removeProperty("--tabs-border-bottom-color"));
    }
    this.forEachTab((t, i, o, s, n, r) => {
      this.redrawTab(t, i, o, s, n, r);
    }), this.updateEditorActionsToolbar(), this.layout(this.dimensions, e);
  }
  redrawTab(e, t, i, o, s, n) {
    const r = this.group.isSticky(t), a = this.accessor.partOptions;
    this.redrawTabLabel(e, t, i, o, s);
    const d = r ? this.unpinEditorAction : this.closeEditorAction;
    n.hasAction(d) || (n.isEmpty() || n.clear(), n.push(d, { icon: !0, label: !1, keybinding: this.getKeybindingLabel(d) }));
    const h = r && a.pinnedTabSizing === "compact" ? "off" : a.tabCloseButton;
    for (const p of ["off", "left", "right"])
      i.classList.toggle(`tab-actions-${p}`, h === p);
    const g = r && a.pinnedTabSizing === "shrink" ? "shrink" : a.tabSizing;
    for (const p of ["fit", "shrink", "fixed"])
      i.classList.toggle(`sizing-${p}`, g === p);
    i.classList.toggle("has-icon", a.showIcons && a.hasIcons), i.classList.toggle("sticky", r);
    for (const p of ["normal", "compact", "shrink"])
      i.classList.toggle(`sticky-${p}`, r && a.pinnedTabSizing === p);
    if (!a.wrapTabs && r && a.pinnedTabSizing !== "normal") {
      let p = 0;
      switch (a.pinnedTabSizing) {
        case "compact":
          p = ge.TAB_WIDTH.compact;
          break;
        case "shrink":
          p = ge.TAB_WIDTH.shrink;
          break;
      }
      i.style.left = `${t * p}px`;
    } else
      i.style.left = "auto";
    this.redrawTabBorders(t, i), this.redrawTabActiveAndDirty(this.accessor.activeGroup === this.group, e, i, n);
  }
  redrawTabLabel(e, t, i, o, s) {
    var m, C, b;
    const n = this.accessor.partOptions;
    let r, a = !1, d = !!((m = n.decorations) != null && m.badges), h;
    n.pinnedTabSizing === "compact" && this.group.isSticky(t) ? (r = n.showIcons && n.hasIcons ? "" : (C = s.name) == null ? void 0 : C.charAt(0).toUpperCase(), h = "", a = !0, d = !1) : (r = s.name, h = s.description || ""), s.ariaLabel && (i.setAttribute("aria-label", s.ariaLabel), i.setAttribute("aria-description", ""));
    const g = s.title || "";
    i.title = g, o.setResource({ name: r, description: h, resource: me.getOriginalUri(e, { supportSideBySide: ie.BOTH }) }, {
      title: g,
      extraClasses: ti(["tab-label", d ? "tab-label-has-badge" : void 0].concat(e.getLabelExtraClasses())),
      italic: !this.group.isPinned(e),
      forceLabel: a,
      fileDecorations: {
        colors: !!((b = n.decorations) != null && b.colors),
        badges: d
      }
    });
    const p = me.getOriginalUri(e, { supportSideBySide: ie.PRIMARY });
    p ? i.setAttribute("data-resource-name", zm(p)) : i.removeAttribute("data-resource-name");
  }
  redrawTabActiveAndDirty(e, t, i, o) {
    const s = this.group.isActive(t), n = this.doRedrawTabDirty(e, s, t, i);
    this.doRedrawTabActive(e, !n, t, i, o);
  }
  doRedrawTabActive(e, t, i, o, s) {
    if (this.group.isActive(i)) {
      o.classList.add("active"), o.setAttribute("aria-selected", "true"), o.tabIndex = 0, o.style.backgroundColor = this.getColor(e ? Qr : Lh) || "";
      const n = this.getColor(e ? Um : jm);
      n ? (o.classList.add("tab-border-bottom"), o.style.setProperty("--tab-border-bottom-color", n.toString())) : (o.classList.remove("tab-border-bottom"), o.style.removeProperty("--tab-border-bottom-color"));
      const r = t ? this.getColor(e ? qm : $m) : void 0;
      r ? (o.classList.add("tab-border-top"), o.style.setProperty("--tab-border-top-color", r.toString())) : (o.classList.remove("tab-border-top"), o.style.removeProperty("--tab-border-top-color")), o.style.color = this.getColor(e ? Fh : Xh) || "", s.setFocusable(!0);
    } else
      o.classList.remove("active"), o.setAttribute("aria-selected", "false"), o.tabIndex = -1, o.style.backgroundColor = this.getColor(e ? Ar : Kh) || "", o.style.boxShadow = "", o.style.color = this.getColor(e ? eb : tb) || "", s.setFocusable(!1);
  }
  doRedrawTabDirty(e, t, i, o) {
    let s = !1;
    if (i.isDirty() && !i.isSaving())
      if (o.classList.add("dirty"), this.accessor.partOptions.highlightModifiedTabs) {
        let n;
        e && t ? n = this.getColor(ib) : e && !t ? n = this.getColor(ob) : !e && t ? n = this.getColor(sb) : n = this.getColor(nb), n && (s = !0, o.classList.add("dirty-border-top"), o.style.setProperty("--tab-dirty-border-top-color", n));
      } else
        o.classList.remove("dirty-border-top"), o.style.removeProperty("--tab-dirty-border-top-color");
    else
      o.classList.remove("dirty", "dirty-border-top"), o.style.removeProperty("--tab-dirty-border-top-color");
    return s;
  }
  redrawTabBorders(e, t) {
    const s = (this.group.isSticky(e) && this.group.stickyCount === e + 1 ? this.getColor(rb) : void 0) || this.getColor(Br) || this.getColor(Oe);
    t.style.borderRight = s ? `1px solid ${s}` : "", t.style.outlineColor = this.getColor(co) || "";
  }
  prepareEditorActions(e) {
    return this.accessor.activeGroup === this.group ? e : {
      primary: e.primary.filter((i) => i.id === Yh),
      secondary: e.secondary
    };
  }
  getHeight() {
    const e = this.breadcrumbsControl && !this.breadcrumbsControl.isHidden();
    return this.dimensions.used ? {
      total: this.dimensions.used.height,
      offset: e ? this.dimensions.used.height - $.HEIGHT : this.dimensions.used.height
    } : this.computeHeight();
  }
  computeHeight() {
    var i;
    let e;
    this.accessor.partOptions.wrapTabs && ((i = this.tabsAndActionsContainer) != null && i.classList.contains("wrapping")) ? e = this.tabsAndActionsContainer.offsetHeight : e = ge.TAB_HEIGHT;
    const t = e;
    return this.breadcrumbsControl && !this.breadcrumbsControl.isHidden() && (e += $.HEIGHT), { total: e, offset: t };
  }
  layout(e, t) {
    if (Object.assign(this.dimensions, e), !this.layoutScheduler.value) {
      const i = Zr(() => {
        var o;
        this.doLayout(this.dimensions, (o = this.layoutScheduler.value) == null ? void 0 : o.options), this.layoutScheduler.clear();
      });
      this.layoutScheduler.value = { options: t, dispose: () => i.dispose() };
    }
    return t != null && t.forceRevealActiveTab && (this.layoutScheduler.value.options = {
      ...this.layoutScheduler.value.options,
      forceRevealActiveTab: !0
    }), this.dimensions.used || (this.dimensions.used = new H(e.container.width, this.computeHeight().total)), this.dimensions.used;
  }
  doLayout(e, t) {
    const i = this.group.activeEditor ? this.getTabAndIndex(this.group.activeEditor) : void 0;
    if (i && e.container !== H.None && e.available !== H.None) {
      this.doLayoutBreadcrumbs(e);
      const [n, r] = i;
      this.doLayoutTabs(n, r, e, t);
    }
    const o = this.dimensions.used, s = this.dimensions.used = new H(e.container.width, this.computeHeight().total);
    o && o.height !== s.height && this.group.relayout();
  }
  handleBreadcrumbsEnablementChange() {
    this.group.relayout();
  }
  doLayoutBreadcrumbs(e) {
    this.breadcrumbsControl && !this.breadcrumbsControl.isHidden() && this.breadcrumbsControl.layout(new H(e.container.width, $.HEIGHT));
  }
  doLayoutTabs(e, t, i, o) {
    this.doLayoutTabsWrapping(i) || this.doLayoutTabsNonWrapping(e, t, o);
  }
  doLayoutTabsWrapping(e) {
    const [t, i, o, s] = Yi(this.tabsAndActionsContainer, this.tabsContainer, this.editorToolbarContainer, this.tabsScrollbar), n = t.classList.contains("wrapping");
    let r = n;
    function a(d) {
      r = d, t.classList.toggle("wrapping", r), i.style.setProperty("--last-tab-margin-right", r ? `${o.offsetWidth}px` : "0");
    }
    if (this.accessor.partOptions.wrapTabs) {
      const d = i.offsetWidth, h = i.scrollWidth, g = () => {
        const p = this.getLastTab();
        return p ? !(p.offsetWidth + o.offsetWidth - e.available.width > 1) : !0;
      };
      (r || h > d && g()) && a(!0), r && (i.offsetHeight > e.available.height || h === d && i.offsetHeight === ge.TAB_HEIGHT || !g()) && a(!1);
    } else
      n && a(!1);
    if (r && !n) {
      const d = i.offsetWidth;
      s.setScrollDimensions({
        width: d,
        scrollWidth: d
      });
    }
    if (r) {
      const d = /* @__PURE__ */ new Map();
      let h, g;
      for (const p of i.children) {
        const m = p, C = m.offsetTop;
        C !== h && (h = C, g && d.set(g, !0)), g = m, d.set(m, !1);
      }
      g && d.set(g, !0);
      for (const [p, m] of d)
        p.classList.toggle("last-in-row", m);
    }
    return r;
  }
  doLayoutTabsNonWrapping(e, t, i) {
    const [o, s] = Yi(this.tabsContainer, this.tabsScrollbar), n = o.offsetWidth, r = o.scrollWidth;
    let a = 0;
    if (this.group.stickyCount > 0) {
      let O = 0;
      switch (this.accessor.partOptions.pinnedTabSizing) {
        case "compact":
          O = ge.TAB_WIDTH.compact;
          break;
        case "shrink":
          O = ge.TAB_WIDTH.shrink;
          break;
      }
      a = this.group.stickyCount * O;
    }
    let d = this.accessor.partOptions.pinnedTabSizing !== "normal" && this.group.isSticky(t), h = n - a;
    this.group.stickyCount > 0 && h < ge.TAB_WIDTH.fit ? (o.classList.add("disable-sticky-tabs"), h = n, a = 0, d = !1) : o.classList.remove("disable-sticky-tabs");
    let g, p;
    this.blockRevealActiveTab || (g = e.offsetLeft, p = e.offsetWidth);
    const { width: m, scrollWidth: C } = s.getScrollDimensions();
    s.setScrollDimensions({
      width: n,
      scrollWidth: r
    });
    const b = m !== n || C !== r;
    if (this.blockRevealActiveTab || typeof g != "number" || typeof p != "number" || d || !b && !(i != null && i.forceRevealActiveTab)) {
      this.blockRevealActiveTab = !1;
      return;
    }
    const v = s.getScrollPosition().scrollLeft, J = p <= h, R = g - a;
    J && v + h < R + p ? s.setScrollPosition({
      scrollLeft: v + (R + p - (v + h))
    }) : (v > R || !J) && s.setScrollPosition({
      scrollLeft: R
    });
  }
  getTabAndIndex(e) {
    const t = this.group.getIndexOfEditor(e), i = this.getTabAtIndex(t);
    if (i)
      return [i, t];
  }
  getTabAtIndex(e) {
    if (e >= 0)
      return L(this.tabsContainer).children[e];
  }
  getLastTab() {
    return this.getTabAtIndex(this.group.count - 1);
  }
  blockRevealActiveTabOnce() {
    this.blockRevealActiveTab = !0;
  }
  originatesFromTabActionBar(e) {
    let t;
    return e instanceof MouseEvent ? t = e.target || e.srcElement : t = e.initialTarget, !!nn(t, "action-item", "tab");
  }
  async onDrop(e, t, i) {
    if (U.stop(e, !0), this.updateDropFeedback(i, !1), i.classList.remove("scroll"), this.groupTransfer.hasData(Ye.prototype)) {
      const o = this.groupTransfer.getData(Ye.prototype);
      if (Array.isArray(o)) {
        const s = this.accessor.getGroup(o[0].identifier);
        if (s) {
          const n = { index: t };
          this.isMoveOperation(e, s.id) || (n.mode = 0), this.accessor.mergeGroup(s, this.group, n);
        }
        this.group.focus(), this.groupTransfer.clearData(Ye.prototype);
      }
    } else if (this.editorTransfer.hasData(Ve.prototype)) {
      const o = this.editorTransfer.getData(Ve.prototype);
      if (Array.isArray(o)) {
        const s = o[0].identifier, n = this.accessor.getGroup(s.groupId);
        n && (this.isMoveOperation(e, s.groupId, s.editor) ? n.moveEditor(s.editor, this.group, { index: t }) : n.copyEditor(s.editor, this.group, { index: t })), this.group.focus(), this.editorTransfer.clearData(Ve.prototype);
      }
    } else if (this.treeItemsTransfer.hasData(Rt.prototype)) {
      const o = this.treeItemsTransfer.getData(Rt.prototype);
      if (Array.isArray(o)) {
        const s = [];
        for (const n of o) {
          const r = await this.treeViewsDragAndDropService.removeDragOperationTransfer(n.identifier);
          if (r) {
            const a = await Oh(r);
            s.push(...a.map(
              (d) => ({ ...d, options: { ...d.options, pinned: !0, index: t } })
            ));
          }
        }
        this.editorService.openEditors(s, this.group, { validateTrust: !0 });
      }
      this.treeItemsTransfer.clearData(Rt.prototype);
    } else
      this.instantiationService.createInstance(Hh, { allowWorkspaceOpen: !1 }).handleDrop(e, () => this.group, () => this.group.focus(), t);
  }
  isMoveOperation(e, t, i) {
    return i != null && i.hasCapability(8) ? !0 : !(e.ctrlKey && !Ze || e.altKey && Ze) || t === this.group.id;
  }
  dispose() {
    super.dispose(), this.tabDisposables = le(this.tabDisposables);
  }
}, ge.SCROLLBAR_SIZES = {
  default: 3,
  large: 10
}, ge.TAB_WIDTH = {
  compact: 38,
  shrink: 80,
  fit: 120
}, ge.TAB_HEIGHT = 35, ge.DRAG_OVER_OPEN_TAB_THRESHOLD = 1500, ge.MOUSE_WHEEL_EVENT_THRESHOLD = 150, ge.MOUSE_WHEEL_DISTANCE_THRESHOLD = 1.5, ge);
Ia = y([
  l(3, Ie),
  l(4, W),
  l(5, F),
  l(6, be),
  l(7, We),
  l(8, lt),
  l(9, Is),
  l(10, z),
  l(11, x),
  l(12, _e),
  l(13, D),
  l(14, Pn),
  l(15, ce),
  l(16, $c),
  l(17, Zs)
], Ia);
Xc((c, e) => {
  const t = c.getColor(Br);
  t && e.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container > .title > .tabs-and-actions-container.wrapping .tabs-container > .tab {
				border-bottom: 1px solid ${t};
			}
		`);
  const i = c.getColor(co);
  i && e.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container.active > .title .tabs-container > .tab.active,
			.monaco-workbench .part.editor > .content .editor-group-container.active > .title .tabs-container > .tab.active:hover  {
				outline: 1px solid;
				outline-offset: -5px;
			}

			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab.active {
				outline: 1px dotted;
				outline-offset: -5px;
			}

			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab:hover  {
				outline: 1px dashed;
				outline-offset: -5px;
			}

			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab.active > .tab-actions .action-label,
			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab.active:hover > .tab-actions .action-label,
			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab.dirty > .tab-actions .action-label,
			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab.sticky > .tab-actions .action-label,
			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab:hover > .tab-actions .action-label {
				opacity: 1 !important;
			}
		`);
  const o = c.getColor(Oe);
  o && e.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container > .title .editor-actions {
				outline: 1px solid ${o}
			}
		`);
  const s = c.getColor(ab);
  s && e.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container.active > .title .tabs-container > .tab:hover  {
				background-color: ${s} !important;
			}
		`);
  const n = c.getColor(cb);
  n && e.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab:hover  {
				background-color: ${n} !important;
			}
		`);
  const r = c.getColor(db);
  r && e.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container.active > .title .tabs-container > .tab:hover  {
				color: ${r} !important;
			}
		`);
  const a = c.getColor(lb);
  a && e.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab:hover  {
				color: ${a} !important;
			}
		`);
  const d = c.getColor(hb);
  d && e.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container.active > .title .tabs-container > .tab:hover > .tab-border-bottom-container {
				display: block;
				position: absolute;
				left: 0;
				pointer-events: none;
				width: 100%;
				z-index: 10;
				bottom: 0;
				height: 1px;
				background-color: ${d};
			}
		`);
  const h = c.getColor(ub);
  if (h && e.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab:hover > .tab-border-bottom-container  {
				display: block;
				position: absolute;
				left: 0;
				pointer-events: none;
				width: 100%;
				z-index: 10;
				bottom: 0;
				height: 1px;
				background-color: ${h};
			}
		`), !qc(c.type) && !gb && !i) {
    const g = pb(c), p = c.getColor(ed), m = c.getColor(Ph), C = c.getColor(Ln);
    let b;
    m && p && (b = m.flatten(p, p, g));
    let v;
    m && p && C && p && (v = m.flatten(p, C, p, g));
    const J = (se, ne, pt = !1) => `
			.monaco-workbench .part.editor > .content:not(.dragged-over) .editor-group-container${pt ? ".active" : ""} > .title .tabs-container > .tab.sizing-shrink:not(.dragged):not(.sticky-compact):hover > .tab-label > .monaco-icon-label-container::after,
			.monaco-workbench .part.editor > .content:not(.dragged-over) .editor-group-container${pt ? ".active" : ""} > .title .tabs-container > .tab.sizing-fixed:not(.dragged):not(.sticky-compact):hover > .tab-label > .monaco-icon-label-container::after {
				background: linear-gradient(to left, ${se}, transparent) !important;
			}

			.monaco-workbench .part.editor > .content.dragged-over .editor-group-container${pt ? ".active" : ""} > .title .tabs-container > .tab.sizing-shrink:not(.dragged):not(.sticky-compact):hover > .tab-label > .monaco-icon-label-container::after,
			.monaco-workbench .part.editor > .content.dragged-over .editor-group-container${pt ? ".active" : ""} > .title .tabs-container > .tab.sizing-fixed:not(.dragged):not(.sticky-compact):hover > .tab-label > .monaco-icon-label-container::after {
				background: linear-gradient(to left, ${ne}, transparent) !important;
			}
		`;
    if (s && b && v) {
      const se = s.flatten(b), ne = s.flatten(v);
      e.addRule(J(se, ne, !0));
    }
    if (n && b && v) {
      const se = n.flatten(b), ne = n.flatten(v);
      e.addRule(J(se, ne));
    }
    if (C && v) {
      const se = C.flatten(v);
      e.addRule(`
				.monaco-workbench .part.editor > .content.dragged-over .editor-group-container.active > .title .tabs-container > .tab.sizing-shrink.dragged-over:not(.active):not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after,
				.monaco-workbench .part.editor > .content.dragged-over .editor-group-container:not(.active) > .title .tabs-container > .tab.sizing-shrink.dragged-over:not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after,
				.monaco-workbench .part.editor > .content.dragged-over .editor-group-container.active > .title .tabs-container > .tab.sizing-fixed.dragged-over:not(.active):not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after,
				.monaco-workbench .part.editor > .content.dragged-over .editor-group-container:not(.active) > .title .tabs-container > .tab.sizing-fixed.dragged-over:not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after {
					background: linear-gradient(to left, ${se}, transparent) !important;
				}
		`);
    }
    const R = (se, ne, pt, ni) => `
				.monaco-workbench .part.editor > .content:not(.dragged-over) .editor-group-container${pt ? ".active" : ":not(.active)"} > .title .tabs-container > .tab.sizing-shrink${ni ? ".active" : ""}:not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after,
				.monaco-workbench .part.editor > .content:not(.dragged-over) .editor-group-container${pt ? ".active" : ":not(.active)"} > .title .tabs-container > .tab.sizing-fixed${ni ? ".active" : ""}:not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after {
					background: linear-gradient(to left, ${se}, transparent);
				}

				.monaco-workbench .part.editor > .content.dragged-over .editor-group-container${pt ? ".active" : ":not(.active)"} > .title .tabs-container > .tab.sizing-shrink${ni ? ".active" : ""}:not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after,
				.monaco-workbench .part.editor > .content.dragged-over .editor-group-container${pt ? ".active" : ":not(.active)"} > .title .tabs-container > .tab.sizing-fixed${ni ? ".active" : ""}:not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after {
					background: linear-gradient(to left, ${ne}, transparent);
				}
		`, O = c.getColor(Qr);
    if (O && b && v) {
      const se = O.flatten(b), ne = O.flatten(v);
      e.addRule(R(se, ne, !0, !0));
    }
    const Je = c.getColor(Lh);
    if (Je && b && v) {
      const se = Je.flatten(b), ne = Je.flatten(v);
      e.addRule(R(se, ne, !1, !0));
    }
    const Jt = c.getColor(Ar);
    if (Jt && b && v) {
      const se = Jt.flatten(b), ne = Jt.flatten(v);
      e.addRule(R(se, ne, !0, !1));
    }
    const Q = c.getColor(Kh);
    if (Q && b && v) {
      const se = Q.flatten(b), ne = Q.flatten(v);
      e.addRule(R(se, ne, !1, !1));
    }
  }
});
let Ja = class extends E {
  get minimumWidth() {
    var e;
    return ((e = this._activeEditorPane) == null ? void 0 : e.minimumWidth) ?? ol.width;
  }
  get minimumHeight() {
    var e;
    return ((e = this._activeEditorPane) == null ? void 0 : e.minimumHeight) ?? ol.height;
  }
  get maximumWidth() {
    var e;
    return ((e = this._activeEditorPane) == null ? void 0 : e.maximumWidth) ?? sl.width;
  }
  get maximumHeight() {
    var e;
    return ((e = this._activeEditorPane) == null ? void 0 : e.maximumHeight) ?? sl.height;
  }
  get activeEditorPane() {
    return this._activeEditorPane;
  }
  constructor(e, t, i, o, s, n, r, a, d) {
    super(), this.editorGroupParent = e, this.editorPanesParent = t, this.groupView = i, this.layoutService = o, this.instantiationService = s, this.editorProgressService = n, this.workspaceTrustService = r, this.logService = a, this.dialogService = d, this._onDidFocus = this._register(new w()), this.onDidFocus = this._onDidFocus.event, this._onDidChangeSizeConstraints = this._register(new w()), this.onDidChangeSizeConstraints = this._onDidChangeSizeConstraints.event, this._activeEditorPane = null, this.editorPanes = [], this.activeEditorPaneDisposables = this._register(new Z()), this.editorOperation = this._register(new bb(this.editorProgressService)), this.editorPanesRegistry = N.as(Ci.EditorPane), this.registerListeners();
  }
  registerListeners() {
    this._register(this.workspaceTrustService.onDidChangeTrust(() => this.onDidChangeWorkspaceTrust()));
  }
  onDidChangeWorkspaceTrust() {
    var i, o;
    const e = (i = this._activeEditorPane) == null ? void 0 : i.input, t = (o = this._activeEditorPane) == null ? void 0 : o.options;
    e != null && e.hasCapability(16) && this.groupView.openEditor(e, t);
  }
  async openEditor(e, t, i = /* @__PURE__ */ Object.create(null)) {
    try {
      return await this.doOpenEditor(this.getEditorPaneDescriptor(e), e, t, i);
    } catch (o) {
      return t != null && t.ignoreError ? { error: o } : this.doShowError(o, e, t, i);
    }
  }
  async doShowError(e, t, i, o) {
    this.logService.error(e);
    let s = !1;
    if ((i == null ? void 0 : i.source) === Mh.USER && (!nl(e) || e.allowDialog) && (s = await this.doShowErrorDialog(e, t)), s)
      return { error: e };
    const n = { ...i };
    return Qi(e) || (n.error = e), {
      ...await this.doOpenEditor(bw.DESCRIPTOR, t, n, o),
      error: e
    };
  }
  async doShowErrorDialog(e, t) {
    let i = ft.Error, o, s = go(e), n;
    nl(e) && (n = e.actions, i = e.forceSeverity ?? ft.Error, e.forceMessage && (o = e.message, s = void 0)), o || (o = u("editorOpenErrorDialog", "Unable to open '{0}'", t.getName()));
    const r = [];
    if (n && n.length > 0)
      for (const g of n)
        r.push({
          label: g.label,
          run: () => g
        });
    else
      r.push({
        label: u({ key: "ok", comment: ["&& denotes a mnemonic"] }, "&&OK"),
        run: () => {
        }
      });
    let a;
    r.length === 1 && (a = {
      run: () => {
        d = !0;
      }
    });
    let d = !1;
    const { result: h } = await this.dialogService.prompt({
      type: i,
      message: o,
      detail: s,
      buttons: r,
      cancelButton: a
    });
    if (h) {
      const g = h.run();
      g instanceof Promise && g.catch((p) => this.dialogService.error(go(p))), d = !0;
    }
    return d;
  }
  async doOpenEditor(e, t, i, o = /* @__PURE__ */ Object.create(null)) {
    const s = this.doShowEditorPane(e), n = document.activeElement, { changed: r, cancelled: a } = await this.doSetInput(s, t, i, o), d = !i || !i.preserveFocus;
    return !a && d && this.shouldRestoreFocus(n) && s.focus(), { pane: s, changed: r, cancelled: a };
  }
  shouldRestoreFocus(e) {
    if (!this.layoutService.isRestored() || !e)
      return !0;
    const t = document.activeElement;
    return !!(!t || t === document.body || e === t || t.tagName !== "INPUT" && t.tagName !== "TEXTAREA" || Nt(t, this.editorGroupParent));
  }
  getEditorPaneDescriptor(e) {
    return e.hasCapability(16) && !this.workspaceTrustService.isWorkspaceTrusted() ? Cw.DESCRIPTOR : L(this.editorPanesRegistry.getEditorPane(e));
  }
  doShowEditorPane(e) {
    if (this._activeEditorPane && e.describes(this._activeEditorPane))
      return this._activeEditorPane;
    this.doHideActiveEditorPane();
    const t = this.doCreateEditorPane(e);
    this.doSetActiveEditorPane(t);
    const i = L(t.getContainer());
    return this.editorPanesParent.appendChild(i), hi(i), t.setVisible(!0, this.groupView), this.pagePosition && t.layout(new H(this.pagePosition.width, this.pagePosition.height), { top: this.pagePosition.top, left: this.pagePosition.left }), this.boundarySashes && t.setBoundarySashes(this.boundarySashes), t;
  }
  doCreateEditorPane(e) {
    const t = this.doInstantiateEditorPane(e);
    if (!t.getContainer()) {
      const i = document.createElement("div");
      i.classList.add("editor-instance"), t.create(i);
    }
    return t;
  }
  doInstantiateEditorPane(e) {
    const t = this.editorPanes.find((o) => e.describes(o));
    if (t)
      return t;
    const i = this._register(e.instantiate(this.instantiationService));
    return this.editorPanes.push(i), i;
  }
  doSetActiveEditorPane(e) {
    this._activeEditorPane = e, this.activeEditorPaneDisposables.clear(), e && (this.activeEditorPaneDisposables.add(e.onDidChangeSizeConstraints((t) => this._onDidChangeSizeConstraints.fire(t))), this.activeEditorPaneDisposables.add(e.onDidFocus(() => this._onDidFocus.fire()))), this._onDidChangeSizeConstraints.fire(void 0);
  }
  async doSetInput(e, t, i, o) {
    var a;
    const s = (a = e.input) == null ? void 0 : a.matches(t);
    if (s && !(i != null && i.forceReload))
      return e.setOptions(i), { changed: !1, cancelled: !1 };
    const n = this.editorOperation.start(this.layoutService.isRestored() ? 800 : 3200);
    let r = !1;
    try {
      e.clearInput(), await e.setInput(t, i, o, n.token), n.isCurrent() || (r = !0);
    } catch (d) {
      if (!n.isCurrent())
        r = !0;
      else
        throw d;
    } finally {
      n.stop();
    }
    return { changed: !s, cancelled: r };
  }
  doHideActiveEditorPane() {
    if (!this._activeEditorPane)
      return;
    this.editorOperation.stop(), this.safeRun(() => {
      var t;
      return (t = this._activeEditorPane) == null ? void 0 : t.clearInput();
    }), this.safeRun(() => {
      var t;
      return (t = this._activeEditorPane) == null ? void 0 : t.setVisible(!1, this.groupView);
    });
    const e = this._activeEditorPane.getContainer();
    e && (this.editorPanesParent.removeChild(e), gi(e)), this.doSetActiveEditorPane(null);
  }
  closeEditor(e) {
    var t;
    (t = this._activeEditorPane) != null && t.input && e.matches(this._activeEditorPane.input) && this.doHideActiveEditorPane();
  }
  setVisible(e) {
    this.safeRun(() => {
      var t;
      return (t = this._activeEditorPane) == null ? void 0 : t.setVisible(e, this.groupView);
    });
  }
  layout(e) {
    this.pagePosition = e, this.safeRun(() => {
      var t;
      return (t = this._activeEditorPane) == null ? void 0 : t.layout(new H(e.width, e.height), e);
    });
  }
  setBoundarySashes(e) {
    this.boundarySashes = e, this.safeRun(() => {
      var t;
      return (t = this._activeEditorPane) == null ? void 0 : t.setBoundarySashes(e);
    });
  }
  safeRun(e) {
    try {
      e();
    } catch (t) {
      this.logService.error(t);
    }
  }
};
Ja = y([
  l(3, Pe),
  l(4, W),
  l(5, Qc),
  l(6, mb),
  l(7, rt),
  l(8, Yc)
], Ja);
var hy = '.monaco-workbench .part.editor>.content .editor-group-container>.title>.label-container{align-items:center;display:flex;flex:auto;height:35px;justify-content:flex-start;overflow:hidden}.monaco-workbench .part.editor>.content .editor-group-container>.title>.label-container>.title-label{line-height:35px;overflow:hidden;padding-left:20px;position:relative;text-overflow:ellipsis}.monaco-workbench .part.editor>.content .editor-group-container>.title>.label-container>.title-label>.monaco-icon-label-container{flex:initial}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .no-tabs.title-label{flex:none}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control{flex:1 50%;margin-left:.45em;overflow:hidden}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item{font-size:.9em}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control.preview .monaco-breadcrumb-item{font-style:italic}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item:before{background-image:none;content:"/";height:inherit;opacity:1;width:inherit}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control.backslash-path .monaco-breadcrumb-item:before{content:"\\\\"}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item.root_folder+.monaco-breadcrumb-item:before,.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item.root_folder:before,.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control.relative-path .monaco-breadcrumb-item:nth-child(2):before,.monaco-workbench.windows .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item:nth-child(2):before{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item.root_folder:after{content:"\\00a0\\00a0";padding:0}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item:last-child{padding-right:4px}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item .codicon[class*=codicon-symbol-]{padding:0 1px}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item .codicon:last-child{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-icon-label:before{height:18px;padding-right:2px}.monaco-workbench .part.editor>.content .editor-group-container>.title>.title-actions{display:flex;flex:initial;height:35px;opacity:.5;padding-right:8px}.monaco-workbench .part.editor>.content .editor-group-container>.title>.title-actions .action-item{margin-right:4px}.monaco-workbench .part.editor>.content .editor-group-container.active>.title>.title-actions{opacity:1}';
oe(hy, {});
const Gn = class Gn extends fn {
  constructor() {
    super(...arguments), this.activeLabel = /* @__PURE__ */ Object.create(null);
  }
  create(e) {
    const t = this.titleContainer = e;
    t.draggable = !0, this.registerContainerListeners(t), this._register(zt.addTarget(t));
    const i = document.createElement("div");
    i.classList.add("label-container"), t.appendChild(i), this.editorLabel = this._register(this.instantiationService.createInstance(Cb, i, void 0)).element, this._register(S(this.editorLabel.element, I.CLICK, (s) => this.onTitleLabelClick(s))), this.createBreadcrumbsControl(i, { showFileIcons: !1, showSymbolIcons: !0, showDecorationColors: !1, widgetStyles: { ..._h, breadcrumbsBackground: mi.transparent.toString() }, showPlaceholder: !1 }), t.classList.toggle("breadcrumbs", !!this.breadcrumbsControl), this._register(M(() => t.classList.remove("breadcrumbs")));
    const o = document.createElement("div");
    o.classList.add("title-actions"), t.appendChild(o), this.createEditorActionsToolBar(o);
  }
  registerContainerListeners(e) {
    this.enableGroupDragging(e), this._register(S(e, I.DBLCLICK, (t) => this.onTitleDoubleClick(t))), this._register(S(e, I.AUXCLICK, (t) => this.onTitleAuxClick(t))), this._register(S(e, Ne.Tap, (t) => this.onTitleTap(t)));
    for (const t of [I.CONTEXT_MENU, Ne.Contextmenu])
      this._register(S(e, t, (i) => {
        this.group.activeEditor && this.onContextMenu(this.group.activeEditor, i, e);
      }));
  }
  onTitleLabelClick(e) {
    U.stop(e, !1), setTimeout(() => this.quickInputService.quickAccess.show());
  }
  onTitleDoubleClick(e) {
    U.stop(e), this.group.pinEditor();
  }
  onTitleAuxClick(e) {
    e.button === 1 && this.group.activeEditor && (U.stop(e, !0), this.group.closeEditor(this.group.activeEditor));
  }
  onTitleTap(e) {
    const t = e.initialTarget;
    !(t instanceof HTMLElement) || !this.editorLabel || !Nt(t, this.editorLabel.element) || setTimeout(() => this.quickInputService.quickAccess.show(), 50);
  }
  openEditor(e) {
    this.doHandleOpenEditor();
  }
  openEditors(e) {
    this.doHandleOpenEditor();
  }
  doHandleOpenEditor() {
    this.ifActiveEditorChanged(() => this.redraw()) || this.ifActiveEditorPropertiesChanged(() => this.redraw());
  }
  beforeCloseEditor(e) {
  }
  closeEditor(e) {
    this.ifActiveEditorChanged(() => this.redraw());
  }
  closeEditors(e) {
    this.ifActiveEditorChanged(() => this.redraw());
  }
  moveEditor(e, t, i) {
    this.ifActiveEditorChanged(() => this.redraw());
  }
  pinEditor(e) {
    this.ifEditorIsActive(e, () => this.redraw());
  }
  stickEditor(e) {
  }
  unstickEditor(e) {
  }
  setActive(e) {
    this.redraw();
  }
  updateEditorLabel(e) {
    this.ifEditorIsActive(e, () => this.redraw());
  }
  updateEditorDirty(e) {
    this.ifEditorIsActive(e, () => {
      const t = L(this.titleContainer);
      e.isDirty() && !e.isSaving() ? t.classList.add("dirty") : t.classList.remove("dirty");
    });
  }
  updateOptions(e, t) {
    (e.labelFormat !== t.labelFormat || !Bh(e.decorations, t.decorations)) && this.redraw();
  }
  updateStyles() {
    this.redraw();
  }
  handleBreadcrumbsEnablementChange() {
    L(this.titleContainer).classList.toggle("breadcrumbs", !!this.breadcrumbsControl), this.redraw();
  }
  ifActiveEditorChanged(e) {
    return !this.activeLabel.editor && this.group.activeEditor || this.activeLabel.editor && !this.group.activeEditor || !this.activeLabel.editor || !this.group.isActive(this.activeLabel.editor) ? (e(), !0) : !1;
  }
  ifActiveEditorPropertiesChanged(e) {
    !this.activeLabel.editor || !this.group.activeEditor || this.activeLabel.pinned !== this.group.isPinned(this.group.activeEditor) && e();
  }
  ifEditorIsActive(e, t) {
    this.group.isActive(e) && t();
  }
  redraw() {
    var r, a;
    const e = ui(this.group.activeEditor), t = this.accessor.partOptions, i = e ? this.group.isPinned(e) : !1, o = this.accessor.activeGroup === this.group;
    this.activeLabel = { editor: e, pinned: i }, this.breadcrumbsControl && (o ? (this.breadcrumbsControl.update(), this.breadcrumbsControl.domNode.classList.toggle("preview", !i)) : this.breadcrumbsControl.hide());
    const [s, n] = Yi(this.titleContainer, this.editorLabel);
    if (!e)
      s.classList.remove("dirty"), n.clear(), this.clearEditorActionsToolbar();
    else {
      this.updateEditorDirty(e);
      const { labelFormat: d } = this.accessor.partOptions;
      let h;
      this.breadcrumbsControl && !this.breadcrumbsControl.isHidden() || d === "default" && !o ? h = "" : h = e.getDescription(this.getVerbosity(d)) || "";
      let g = e.getTitle(2);
      h === g && (g = ""), n.setResource({
        resource: me.getOriginalUri(e, { supportSideBySide: ie.BOTH }),
        name: e.getName(),
        description: h
      }, {
        title: g,
        italic: !i,
        extraClasses: ["no-tabs", "title-label"].concat(e.getLabelExtraClasses()),
        fileDecorations: {
          colors: !!((r = t.decorations) != null && r.colors),
          badges: !!((a = t.decorations) != null && a.badges)
        }
      }), o ? s.style.color = this.getColor(Fh) || "" : s.style.color = this.getColor(Xh) || "", this.updateEditorActionsToolbar();
    }
  }
  getVerbosity(e) {
    switch (e) {
      case "short":
        return 0;
      case "long":
        return 2;
      default:
        return 1;
    }
  }
  prepareEditorActions(e) {
    return this.accessor.activeGroup === this.group ? e : {
      primary: e.primary.filter((i) => i.id === zh || i.id === Yh),
      secondary: e.secondary
    };
  }
  getHeight() {
    return {
      total: Gn.HEIGHT,
      offset: 0
    };
  }
  layout(e) {
    var t;
    return (t = this.breadcrumbsControl) == null || t.layout(void 0), new H(e.container.width, this.getHeight().total);
  }
};
Gn.HEIGHT = 35;
let Va = Gn;
const xg = { text: u("watermark.showCommands", "Show All Commands"), id: "workbench.action.showCommands" }, uy = { text: u("watermark.quickAccess", "Go to File"), id: "workbench.action.quickOpen" }, gy = { text: u("watermark.openFile", "Open File"), id: "workbench.action.files.openFile", mac: !1 }, py = { text: u("watermark.openFolder", "Open Folder"), id: "workbench.action.files.openFolder", mac: !1 }, my = { text: u("watermark.openFileFolder", "Open File or Folder"), id: "workbench.action.files.openFileFolder", mac: !0 }, by = { text: u("watermark.openRecent", "Open Recent"), id: "workbench.action.openRecent" }, Cy = { text: u("watermark.newUntitledFile", "New Untitled Text File"), id: "workbench.action.files.newUntitledFile" }, fy = Object.assign({ mac: !0 }, Cy), vy = { text: u("watermark.findInFiles", "Find in Files"), id: "workbench.action.findInFiles" }, wy = { text: u(
  { key: "watermark.toggleTerminal", comment: ["toggle is a verb here"] },
  "Toggle Terminal"
), id: "workbench.action.terminal.toggleTerminal", when: f.equals("terminalProcessSupported", !0) }, yy = { text: u("watermark.startDebugging", "Start Debugging"), id: "workbench.action.debug.start", when: f.equals("terminalProcessSupported", !0) }, ky = { text: u(
  { key: "watermark.toggleFullscreen", comment: ["toggle is a verb here"] },
  "Toggle Full Screen"
), id: "workbench.action.toggleFullScreen", when: f.equals("terminalProcessSupported", !0).negate() }, Sy = { text: u("watermark.showSettings", "Show Settings"), id: "workbench.action.openSettings", when: f.equals("terminalProcessSupported", !0).negate() }, Ml = [
  xg,
  gy,
  py,
  my,
  by,
  fy
], zl = [
  xg,
  uy,
  vy,
  yy,
  wy,
  ky,
  Sy
];
let Za = class extends E {
  constructor(e, t, i, o, s, n, r) {
    super(), this.lifecycleService = t, this.keybindingService = i, this.contextService = o, this.contextKeyService = s, this.configurationService = n, this.telemetryService = r, this.transientDisposables = this._register(new Z()), this.enabled = !1;
    const a = lr(".editor-group-watermark", [
      lr(".letterpress"),
      lr(".shortcuts@shortcuts")
    ]);
    ae(e, a.root), this.shortcuts = a.shortcuts, this.registerListeners(), this.workbenchState = o.getWorkbenchState(), this.render();
  }
  registerListeners() {
    this.lifecycleService.onDidShutdown(() => this.dispose()), this._register(this.configurationService.onDidChangeConfiguration((i) => {
      i.affectsConfiguration("workbench.tips.enabled") && this.render();
    })), this._register(this.contextService.onDidChangeWorkbenchState((i) => {
      this.workbenchState !== i && (this.workbenchState = i, this.render());
    }));
    const e = [...Ml, ...zl].filter((i) => i.when !== void 0).map((i) => i.when), t = /* @__PURE__ */ new Set();
    e.forEach((i) => i.keys().forEach((o) => t.add(o))), this._register(this.contextKeyService.onDidChangeContext((i) => {
      i.affectsSome(t) && this.render();
    }));
  }
  render() {
    const e = this.configurationService.getValue("workbench.tips.enabled");
    if (e === this.enabled || (this.enabled = e, this.clear(), !e))
      return;
    const t = ae(this.shortcuts, Y(".watermark-box"));
    (this.workbenchState !== 1 ? zl : Ml).filter((s) => !("when" in s) || this.contextKeyService.contextMatchesRules(s.when)).filter((s) => !("mac" in s) || s.mac === (Ze && !ot)).filter((s) => !!Te.getCommand(s.id));
    const o = () => {
      Ut(t);
    };
    o(), this.transientDisposables.add(this.keybindingService.onDidUpdateKeybindings(o)), this.telemetryService.publicLog("watermark:open");
  }
  clear() {
    Ut(this.shortcuts), this.transientDisposables.clear();
  }
  dispose() {
    super.dispose(), this.clear();
  }
};
Za = y([
  l(1, xo),
  l(2, be),
  l(3, at),
  l(4, F),
  l(5, x),
  l(6, Xe)
], Za);
let Mi = class yi extends Hn {
  static createNew(e, t, i) {
    return i.createInstance(yi, e, null, t);
  }
  static createFromSerialized(e, t, i, o) {
    return o.createInstance(yi, t, e, i);
  }
  static createCopy(e, t, i, o) {
    return o.createInstance(yi, t, e, i);
  }
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m, C, b) {
    super(n), this.accessor = e, this._index = i, this.instantiationService = o, this.contextKeyService = s, this.telemetryService = r, this.keybindingService = a, this.menuService = d, this.contextMenuService = h, this.fileDialogService = g, this.editorService = p, this.filesConfigurationService = m, this.uriIdentityService = C, this.logService = b, this._onDidFocus = this._register(new w()), this.onDidFocus = this._onDidFocus.event, this._onWillDispose = this._register(new w()), this.onWillDispose = this._onWillDispose.event, this._onDidModelChange = this._register(new w()), this.onDidModelChange = this._onDidModelChange.event, this._onDidActiveEditorChange = this._register(new w()), this.onDidActiveEditorChange = this._onDidActiveEditorChange.event, this._onDidOpenEditorFail = this._register(new w()), this.onDidOpenEditorFail = this._onDidOpenEditorFail.event, this._onWillCloseEditor = this._register(new w()), this.onWillCloseEditor = this._onWillCloseEditor.event, this._onDidCloseEditor = this._register(new w()), this.onDidCloseEditor = this._onDidCloseEditor.event, this._onWillMoveEditor = this._register(new w()), this.onWillMoveEditor = this._onWillMoveEditor.event, this._onWillOpenEditor = this._register(new w()), this.onWillOpenEditor = this._onWillOpenEditor.event, this.disposedEditorsWorker = this._register(new jh((J) => this.handleDisposedEditors(J), 0)), this.mapEditorToPendingConfirmation = /* @__PURE__ */ new Map(), this.containerToolBarMenuDisposable = this._register(new Re()), this.whenRestoredPromise = new Tr(), this.whenRestored = this.whenRestoredPromise.p, this._disposed = !1, this.element = document.createElement("div"), this._onDidChange = this._register(new Ht()), this.onDidChange = this._onDidChange.event, t instanceof yi ? this.model = this._register(t.model.clone()) : qh(t) ? this.model = this._register(o.createInstance(rl, t)) : this.model = this._register(o.createInstance(rl, void 0)), this.scopedContextKeyService = this._register(this.contextKeyService.createScoped(this.element)), this.element.classList.add("editor-group-container"), this.registerContainerListeners(), this.createContainerToolbar(), this.createContainerContextMenu(), this._register(this.instantiationService.createInstance(Za, this.element)), this.progressBar = this._register(new Bc(this.element, Tc)), this.progressBar.hide(), this.scopedInstantiationService = this.instantiationService.createChild(new rh(
      [F, this.scopedContextKeyService],
      [Qc, this._register(new fb(this.progressBar, this))]
    )), this.handleGroupContextKeys(), this.titleContainer = document.createElement("div"), this.titleContainer.classList.add("title"), this.element.appendChild(this.titleContainer), this.titleAreaControl = this.createTitleAreaControl(), this.editorContainer = document.createElement("div"), this.editorContainer.classList.add("editor-container"), this.element.appendChild(this.editorContainer), this.editorPane = this._register(this.scopedInstantiationService.createInstance(Ja, this.element, this.editorContainer, this)), this._onDidChange.input = this.editorPane.onDidChangeSizeConstraints, this.doTrackFocus(), this.updateTitleContainer(), this.updateContainer(), this.updateStyles(), (this.restoreEditors(t) ?? Promise.resolve()).finally(() => {
      this.whenRestoredPromise.complete();
    }), this.registerListeners();
  }
  handleGroupContextKeys() {
    const e = vb.bindTo(this.scopedContextKeyService), t = Rh.bindTo(this.scopedContextKeyService), i = Gh.bindTo(this.scopedContextKeyService), o = xh.bindTo(this.scopedContextKeyService), s = Dh.bindTo(this.scopedContextKeyService), n = wb.bindTo(this.scopedContextKeyService), r = Qh.bindTo(this.scopedContextKeyService), a = new Re(), d = () => {
      a.clear();
      const h = this.model.activeEditor;
      h ? (e.set(h.isDirty() && !h.isSaving()), a.value = h.onDidChangeDirty(() => {
        e.set(h.isDirty() && !h.isSaving());
      })) : e.set(!1);
    };
    this._register(this.onDidModelChange((h) => {
      switch (h.kind) {
        case 2:
          r.set(this.isLocked);
          break;
        case 6:
        case 4:
        case 3:
        case 5:
          i.set(this.model.isFirst(this.model.activeEditor)), o.set(this.model.isLast(this.model.activeEditor));
          break;
        case 9:
          h.editor && h.editor === this.model.activeEditor && t.set(this.model.isPinned(this.model.activeEditor));
          break;
        case 10:
          h.editor && h.editor === this.model.activeEditor && s.set(this.model.isSticky(this.model.activeEditor));
          break;
      }
      n.set(this.count);
    })), this._register(this.onDidActiveEditorChange(() => {
      d();
    })), d();
  }
  registerContainerListeners() {
    this._register(S(this.element, I.DBLCLICK, (e) => {
      this.isEmpty && (U.stop(e), this.editorService.openEditor({
        resource: void 0,
        options: {
          pinned: !0,
          override: Ke.id
        }
      }, this.id));
    })), this._register(S(this.element, I.AUXCLICK, (e) => {
      this.isEmpty && e.button === 1 && (U.stop(e, !0), this.accessor.removeGroup(this));
    }));
  }
  createContainerToolbar() {
    const e = document.createElement("div");
    e.classList.add("editor-group-container-toolbar"), this.element.appendChild(e);
    const t = this._register(new Ro(e, {
      ariaLabel: u("ariaLabelGroupActions", "Empty editor group actions")
    })), i = this._register(this.menuService.createMenu(k.EmptyEditorGroup, this.scopedContextKeyService)), o = () => {
      const s = { primary: [], secondary: [] };
      this.containerToolBarMenuDisposable.value = M(() => t.clear()), ks(i, { arg: { groupId: this.id }, shouldForwardArgs: !0 }, s, "navigation");
      for (const n of [...s.primary, ...s.secondary]) {
        const r = this.keybindingService.lookupKeybinding(n.id);
        t.push(n, { icon: !0, label: !1, keybinding: r == null ? void 0 : r.getLabel() });
      }
    };
    o(), this._register(i.onDidChange(o));
  }
  createContainerContextMenu() {
    this._register(S(this.element, I.CONTEXT_MENU, (e) => this.onShowContainerContextMenu(e))), this._register(S(this.element, Ne.Contextmenu, () => this.onShowContainerContextMenu()));
  }
  onShowContainerContextMenu(e) {
    if (!this.isEmpty)
      return;
    let t = this.element;
    e instanceof MouseEvent && (t = new kt(e)), this.contextMenuService.showContextMenu({
      menuId: k.EmptyEditorGroupContext,
      contextKeyService: this.contextKeyService,
      getAnchor: () => t,
      onHide: () => {
        this.focus();
      }
    });
  }
  doTrackFocus() {
    const e = this._register(pi(this.element));
    this._register(e.onDidFocus(() => {
      this.isEmpty && this._onDidFocus.fire();
    }));
    const t = (i) => {
      let o;
      if (i instanceof MouseEvent) {
        if (i.button !== 0 || Ze && i.ctrlKey)
          return;
        o = i.target;
      } else
        o = i.initialTarget;
      nn(o, "monaco-action-bar", this.titleContainer) || nn(o, "monaco-breadcrumb-item", this.titleContainer) || setTimeout(() => {
        this.focus();
      });
    };
    this._register(S(this.titleContainer, I.MOUSE_DOWN, (i) => t(i))), this._register(S(this.titleContainer, Ne.Tap, (i) => t(i))), this._register(this.editorPane.onDidFocus(() => {
      this._onDidFocus.fire();
    }));
  }
  updateContainer() {
    this.isEmpty ? (this.element.classList.add("empty"), this.element.tabIndex = 0, this.element.setAttribute("aria-label", u("emptyEditorGroup", "{0} (empty)", this.label))) : (this.element.classList.remove("empty"), this.element.removeAttribute("tabIndex"), this.element.removeAttribute("aria-label")), this.updateStyles();
  }
  updateTitleContainer() {
    this.titleContainer.classList.toggle("tabs", this.accessor.partOptions.showTabs), this.titleContainer.classList.toggle("show-file-icons", this.accessor.partOptions.showIcons);
  }
  createTitleAreaControl() {
    return this.titleAreaControl && (this.titleAreaControl.dispose(), Ut(this.titleContainer)), this.accessor.partOptions.showTabs ? this.titleAreaControl = this.scopedInstantiationService.createInstance(Ia, this.titleContainer, this.accessor, this) : this.titleAreaControl = this.scopedInstantiationService.createInstance(Va, this.titleContainer, this.accessor, this), this.titleAreaControl;
  }
  restoreEditors(e) {
    if (this.count === 0)
      return;
    let t;
    e instanceof yi ? t = Lr(e) : t = /* @__PURE__ */ Object.create(null);
    const i = this.model.activeEditor;
    if (!i)
      return;
    t.pinned = this.model.isPinned(i), t.sticky = this.model.isSticky(i), t.preserveFocus = !0;
    const o = document.activeElement;
    return this.doShowEditor(i, { active: !0, isNew: !1 }, t).then(() => {
      this.accessor.activeGroup === this && o === document.activeElement && this.focus();
    });
  }
  registerListeners() {
    this._register(this.model.onDidModelChange((e) => this.onDidGroupModelChange(e))), this._register(this.accessor.onDidChangeEditorPartOptions((e) => this.onDidChangeEditorPartOptions(e))), this._register(this.accessor.onDidVisibilityChange((e) => this.onDidVisibilityChange(e)));
  }
  onDidGroupModelChange(e) {
    if (this._onDidModelChange.fire(e), !!e.editor)
      switch (e.kind) {
        case 3:
          kb(e) && this.onDidOpenEditor(e.editor, e.editorIndex);
          break;
        case 4:
          yb(e) && this.handleOnDidCloseEditor(e.editor, e.editorIndex, e.context, e.sticky);
          break;
        case 12:
          this.onWillDisposeEditor(e.editor);
          break;
        case 11:
          this.onDidChangeEditorDirty(e.editor);
          break;
        case 7:
          this.onDidChangeEditorLabel(e.editor);
          break;
      }
  }
  onDidOpenEditor(e, t) {
    this.telemetryService.publicLog("editorOpened", this.toEditorTelemetryDescriptor(e)), this.updateContainer();
  }
  handleOnDidCloseEditor(e, t, i, o) {
    this._onWillCloseEditor.fire({ groupId: this.id, editor: e, context: i, index: t, sticky: o });
    const s = [e];
    e instanceof li && s.push(e.primary, e.secondary);
    for (const n of s)
      this.canDispose(n) && n.dispose();
    this.telemetryService.publicLog("editorClosed", this.toEditorTelemetryDescriptor(e)), this.updateContainer(), this._onDidCloseEditor.fire({ groupId: this.id, editor: e, context: i, index: t, sticky: o });
  }
  canDispose(e) {
    for (const t of this.accessor.groups)
      if (t instanceof yi && t.model.contains(e, {
        strictEquals: !0,
        supportSideBySide: ie.ANY
      }))
        return !1;
    return !0;
  }
  toEditorTelemetryDescriptor(e) {
    const t = e.getTelemetryDescriptor(), i = me.getOriginalUri(e), o = i ? i.scheme === q.file ? i.fsPath : i.path : void 0;
    if (i && o) {
      let s = Yt(i);
      const n = s.indexOf("?");
      return s = n !== -1 ? s.substr(0, n) : s, t.resource = { mimeType: new $h(Sb(i).join(", ")), scheme: i.scheme, ext: s, path: Ws(o) }, t;
    }
    return t;
  }
  onWillDisposeEditor(e) {
    this.disposedEditorsWorker.work(e);
  }
  handleDisposedEditors(e) {
    let t;
    const i = [];
    for (const o of e) {
      const s = this.model.findEditor(o);
      if (!s)
        continue;
      const n = s[0];
      n.isDisposed() && (this.model.isActive(n) ? t = n : i.push(n));
    }
    for (const o of i)
      this.doCloseEditor(o, !1);
    t && this.doCloseEditor(t, !1);
  }
  onDidChangeEditorPartOptions(e) {
    this.updateTitleContainer(), e.oldPartOptions.showTabs !== e.newPartOptions.showTabs ? (this.createTitleAreaControl(), this.relayout(), this.model.activeEditor && this.titleAreaControl.openEditor(this.model.activeEditor)) : this.titleAreaControl.updateOptions(e.oldPartOptions, e.newPartOptions), this.updateStyles(), e.oldPartOptions.enablePreview && !e.newPartOptions.enablePreview && this.model.previewEditor && this.pinEditor(this.model.previewEditor);
  }
  onDidChangeEditorDirty(e) {
    this.pinEditor(e), this.titleAreaControl.updateEditorDirty(e);
  }
  onDidChangeEditorLabel(e) {
    this.titleAreaControl.updateEditorLabel(e);
  }
  onDidVisibilityChange(e) {
    this.editorPane.setVisible(e);
  }
  get index() {
    return this._index;
  }
  get label() {
    return u("groupLabel", "Group {0}", this._index + 1);
  }
  get ariaLabel() {
    return u("groupAriaLabel", "Editor Group {0}", this._index + 1);
  }
  get disposed() {
    return this._disposed;
  }
  get isEmpty() {
    return this.count === 0;
  }
  get titleHeight() {
    return this.titleAreaControl.getHeight();
  }
  notifyIndexChanged(e) {
    this._index !== e && (this._index = e, this.model.setIndex(e));
  }
  setActive(e) {
    this.active = e, this.element.classList.toggle("active", e), this.element.classList.toggle("inactive", !e), this.titleAreaControl.setActive(e), this.updateStyles(), this.model.setActive(void 0);
  }
  get id() {
    return this.model.id;
  }
  get editors() {
    return this.model.getEditors(1);
  }
  get count() {
    return this.model.count;
  }
  get stickyCount() {
    return this.model.stickyCount;
  }
  get activeEditorPane() {
    return this.editorPane ? ui(this.editorPane.activeEditorPane) : void 0;
  }
  get activeEditor() {
    return this.model.activeEditor;
  }
  get previewEditor() {
    return this.model.previewEditor;
  }
  isPinned(e) {
    return this.model.isPinned(e);
  }
  isSticky(e) {
    return this.model.isSticky(e);
  }
  isActive(e) {
    return this.model.isActive(e);
  }
  contains(e, t) {
    return this.model.contains(e, t);
  }
  getEditors(e, t) {
    return this.model.getEditors(e, t);
  }
  findEditors(e, t) {
    const i = this.uriIdentityService.asCanonicalUri(e);
    return this.getEditors(1).filter((o) => {
      if (o.resource && Be(o.resource, i))
        return !0;
      if ((t == null ? void 0 : t.supportSideBySide) === ie.PRIMARY || (t == null ? void 0 : t.supportSideBySide) === ie.ANY) {
        const s = me.getCanonicalUri(o, { supportSideBySide: ie.PRIMARY });
        if (s && Be(s, i))
          return !0;
      }
      if ((t == null ? void 0 : t.supportSideBySide) === ie.SECONDARY || (t == null ? void 0 : t.supportSideBySide) === ie.ANY) {
        const s = me.getCanonicalUri(o, { supportSideBySide: ie.SECONDARY });
        if (s && Be(s, i))
          return !0;
      }
      return !1;
    });
  }
  getEditorByIndex(e) {
    return this.model.getEditorByIndex(e);
  }
  getIndexOfEditor(e) {
    return this.model.indexOf(e);
  }
  isFirst(e) {
    return this.model.isFirst(e);
  }
  isLast(e) {
    return this.model.isLast(e);
  }
  focus() {
    this.activeEditorPane ? this.activeEditorPane.focus() : this.element.focus(), this._onDidFocus.fire();
  }
  pinEditor(e = this.activeEditor || void 0) {
    if (e && !this.model.isPinned(e)) {
      const t = this.model.pin(e);
      t && this.titleAreaControl.pinEditor(t);
    }
  }
  stickEditor(e = this.activeEditor || void 0) {
    this.doStickEditor(e, !0);
  }
  unstickEditor(e = this.activeEditor || void 0) {
    this.doStickEditor(e, !1);
  }
  doStickEditor(e, t) {
    if (e && this.model.isSticky(e) !== t) {
      const i = this.getIndexOfEditor(e), o = t ? this.model.stick(e) : this.model.unstick(e);
      if (!o)
        return;
      const s = this.getIndexOfEditor(o);
      s !== i && this.titleAreaControl.moveEditor(o, i, s), t ? this.titleAreaControl.stickEditor(o) : this.titleAreaControl.unstickEditor(o);
    }
  }
  async openEditor(e, t) {
    return this.doOpenEditor(e, t, {
      supportSideBySide: ie.BOTH
    });
  }
  async doOpenEditor(e, t, i) {
    var g;
    if (!e || e.isDisposed())
      return;
    this._onWillOpenEditor.fire({ editor: e, groupId: this.id });
    const o = (t == null ? void 0 : t.sticky) || !this.accessor.partOptions.enablePreview || e.isDirty() || ((t == null ? void 0 : t.pinned) ?? typeof (t == null ? void 0 : t.index) == "number") || typeof (t == null ? void 0 : t.index) == "number" && this.model.isSticky(t.index) || e.hasCapability(512), s = {
      index: t ? t.index : void 0,
      pinned: o,
      sticky: (t == null ? void 0 : t.sticky) || typeof (t == null ? void 0 : t.index) == "number" && this.model.isSticky(t.index),
      active: this.count === 0 || !t || !t.inactive,
      supportSideBySide: i == null ? void 0 : i.supportSideBySide
    };
    t != null && t.sticky && typeof (t == null ? void 0 : t.index) == "number" && !this.model.isSticky(t.index) && (s.sticky = !1), !s.active && !s.pinned && this.model.activeEditor && !this.model.isPinned(this.model.activeEditor) && (s.active = !0);
    let n = !1, r = !1;
    if ((t == null ? void 0 : t.activation) === Zi.ACTIVATE ? n = !0 : (t == null ? void 0 : t.activation) === Zi.RESTORE ? r = !0 : (t == null ? void 0 : t.activation) === Zi.PRESERVE ? (n = !1, r = !1) : s.active && (n = !t || !t.preserveFocus, r = !n), typeof s.index == "number") {
      const p = this.model.indexOf(e);
      p !== -1 && p !== s.index && this.doMoveEditorInsideGroup(e, s);
    }
    const { editor: a, isNew: d } = this.model.openEditor(e, s);
    d && this.count === 1 && this.accessor.groups.length > 1 && a.editorId && (g = this.accessor.partOptions.autoLockGroups) != null && g.has(a.editorId) && this.lock(!0);
    const h = this.doShowEditor(a, { active: !!s.active, isNew: d }, t, i);
    return n ? this.accessor.activateGroup(this) : r && this.accessor.restoreGroup(this), h;
  }
  doShowEditor(e, t, i, o) {
    let s;
    return t.active ? s = (async () => {
      const { pane: n, changed: r, cancelled: a, error: d } = await this.editorPane.openEditor(e, i, { newInGroup: t.isNew });
      if (!a) {
        if (r && this._onDidActiveEditorChange.fire({ editor: e }), d && this._onDidOpenEditorFail.fire(e), !n && this.activeEditor === e) {
          const h = !i || !i.preserveFocus;
          this.doCloseEditor(e, h, { fromError: !0 });
        }
        return n;
      }
    })() : s = Promise.resolve(void 0), o != null && o.skipTitleUpdate || this.titleAreaControl.openEditor(e), s;
  }
  async openEditors(e) {
    const t = ti(e).filter(({ editor: r }) => !r.isDisposed()), i = td(t);
    if (!i)
      return;
    const o = {
      supportSideBySide: ie.BOTH
    };
    await this.doOpenEditor(i.editor, i.options, o);
    const s = t.slice(1), n = this.getIndexOfEditor(i.editor) + 1;
    return await eu.settled(s.map(({ editor: r, options: a }, d) => this.doOpenEditor(r, {
      ...a,
      inactive: !0,
      pinned: !0,
      index: n + d
    }, {
      ...o,
      skipTitleUpdate: !0
    }))), this.titleAreaControl.openEditors(s.map(({ editor: r }) => r)), ui(this.editorPane.activeEditorPane);
  }
  moveEditors(e, t) {
    const i = {
      skipTitleUpdate: this !== t
    };
    for (const { editor: o, options: s } of e)
      this.moveEditor(o, t, s, i);
    if (i.skipTitleUpdate) {
      const o = e.map(({ editor: s }) => s);
      t.titleAreaControl.openEditors(o), this.titleAreaControl.closeEditors(o);
    }
  }
  moveEditor(e, t, i, o) {
    this === t ? this.doMoveEditorInsideGroup(e, i) : this.doMoveOrCopyEditorAcrossGroups(e, t, i, { ...o, keepCopy: !1 });
  }
  doMoveEditorInsideGroup(e, t) {
    const i = t ? t.index : void 0;
    if (typeof i != "number")
      return;
    const o = this.model.indexOf(e);
    if (o === -1 || o === i)
      return;
    const s = this.model.getEditorByIndex(o);
    s && (this.model.moveEditor(s, i), this.model.pin(s), this.titleAreaControl.moveEditor(s, o, i), this.titleAreaControl.pinEditor(s));
  }
  doMoveOrCopyEditorAcrossGroups(e, t, i, o) {
    const s = o == null ? void 0 : o.keepCopy, n = Lr(this, e, {
      ...i,
      pinned: !0,
      sticky: !s && this.model.isSticky(e)
    });
    s || this._onWillMoveEditor.fire({
      groupId: this.id,
      editor: e,
      target: t.id
    }), t.doOpenEditor(s ? e.copy() : e, n, o), s || this.doCloseEditor(e, !1, { ...o, context: Si.MOVE });
  }
  copyEditors(e, t) {
    const i = {
      skipTitleUpdate: this !== t
    };
    for (const { editor: o, options: s } of e)
      this.copyEditor(o, t, s, i);
    if (i.skipTitleUpdate) {
      const o = e.map(({ editor: s }) => s);
      t.titleAreaControl.openEditors(o);
    }
  }
  copyEditor(e, t, i, o) {
    this === t ? this.doMoveEditorInsideGroup(e, i) : this.doMoveOrCopyEditorAcrossGroups(e, t, i, { ...o, keepCopy: !0 });
  }
  async closeEditor(e = this.activeEditor || void 0, t) {
    return this.doCloseEditorWithConfirmationHandling(e, t);
  }
  async doCloseEditorWithConfirmationHandling(e = this.activeEditor || void 0, t, i) {
    return !e || await this.handleCloseConfirmation([e]) ? !1 : (this.doCloseEditor(e, t != null && t.preserveFocus ? !1 : void 0, i), !0);
  }
  doCloseEditor(e, t = this.accessor.activeGroup === this, i) {
    i != null && i.skipTitleUpdate || this.titleAreaControl.beforeCloseEditor(e), this.model.isActive(e) ? this.doCloseActiveEditor(t, i) : this.doCloseInactiveEditor(e, i), i != null && i.skipTitleUpdate || this.titleAreaControl.closeEditor(e);
  }
  doCloseActiveEditor(e = this.accessor.activeGroup === this, t) {
    const i = this.activeEditor, o = this.shouldRestoreFocus(this.element), s = this.accessor.partOptions.closeEmptyGroups;
    if (s && this.active && this.count === 1) {
      const a = this.accessor.getGroups(1)[1];
      a && (o ? a.focus() : this.accessor.activateGroup(a));
    }
    i && this.model.closeEditor(i, t == null ? void 0 : t.context);
    const n = this.model.activeEditor;
    if (n) {
      const r = !e;
      let a;
      r && this.accessor.activeGroup !== this && (a = Zi.PRESERVE);
      const d = {
        preserveFocus: r,
        activation: a,
        ignoreError: t == null ? void 0 : t.fromError
      };
      this.doOpenEditor(n, d);
    } else
      i && this.editorPane.closeEditor(i), o && !s && this.focus(), this._onDidActiveEditorChange.fire({ editor: void 0 }), s && this.accessor.removeGroup(this);
  }
  shouldRestoreFocus(e) {
    const t = document.activeElement;
    return t === document.body ? !0 : Nt(t, e);
  }
  doCloseInactiveEditor(e, t) {
    this.model.closeEditor(e, t == null ? void 0 : t.context);
  }
  async handleCloseConfirmation(e) {
    if (!e.length)
      return !1;
    const t = e.shift();
    let i = this.mapEditorToPendingConfirmation.get(t);
    i || (i = this.doHandleCloseConfirmation(t), this.mapEditorToPendingConfirmation.set(t, i));
    let o;
    try {
      o = await i;
    } finally {
      this.mapEditorToPendingConfirmation.delete(t);
    }
    return o || this.handleCloseConfirmation(e);
  }
  async doHandleCloseConfirmation(e, t) {
    var n;
    if (!this.shouldConfirmClose(e) || e instanceof li && this.model.contains(e.primary) || this.accessor.groups.some((r) => {
      if (r === this)
        return !1;
      const a = r;
      return !!(a.contains(e, { supportSideBySide: ie.BOTH }) || e instanceof li && a.contains(e.primary));
    }))
      return !1;
    let i = 2, o = 1, s = !1;
    if (!e.hasCapability(4) && !(t != null && t.skipAutoSave) && !e.closeHandler && (this.filesConfigurationService.getAutoSaveMode() === 3 ? (s = !0, i = 0, o = 3) : Oc && (Qt || Ib) && this.filesConfigurationService.getAutoSaveMode() === 4 && (s = !0, i = 0, o = 4)), !s)
      if ((!this.activeEditor || !this.activeEditor.matches(e)) && await this.doOpenEditor(e), typeof ((n = e.closeHandler) == null ? void 0 : n.confirm) == "function")
        i = await e.closeHandler.confirm([{ editor: e, groupId: this.id }]);
      else {
        let r;
        e instanceof li ? r = e.primary.getName() : r = e.getName(), i = await this.fileDialogService.showSaveConfirm([r]);
      }
    if (!e.closeHandler && !this.shouldConfirmClose(e))
      return i === 2;
    switch (i) {
      case 0:
        return !await e.save(this.id, { reason: o }) && s ? this.doHandleCloseConfirmation(e, { skipAutoSave: !0 }) : e.isDirty();
      case 1:
        try {
          return await e.revert(this.id), e.isDirty();
        } catch (r) {
          return this.logService.error(r), await e.revert(this.id, { soft: !0 }), e.isDirty();
        }
      case 2:
        return !0;
    }
  }
  shouldConfirmClose(e) {
    return e.closeHandler ? e.closeHandler.showConfirm() : e.isDirty() && !e.isSaving();
  }
  async closeEditors(e, t) {
    if (this.isEmpty)
      return !0;
    const i = this.doGetEditorsToClose(e);
    return await this.handleCloseConfirmation(i.slice(0)) ? !1 : (this.doCloseEditors(i, t), !0);
  }
  doGetEditorsToClose(e) {
    if (Array.isArray(e))
      return e;
    const t = e, i = typeof t.direction == "number";
    let o = this.model.getEditors(i ? 1 : 0, t);
    return t.savedOnly ? o = o.filter((s) => !s.isDirty() || s.isSaving()) : i && t.except ? o = t.direction === 0 ? o.slice(0, this.model.indexOf(t.except, o)) : o.slice(this.model.indexOf(t.except, o) + 1) : t.except && (o = o.filter((s) => t.except && !s.matches(t.except))), o;
  }
  doCloseEditors(e, t) {
    let i = !1;
    for (const o of e)
      this.isActive(o) ? i = !0 : this.doCloseInactiveEditor(o);
    i && this.doCloseActiveEditor(t != null && t.preserveFocus ? !1 : void 0), e.length && this.titleAreaControl.closeEditors(e);
  }
  async closeAllEditors(e) {
    return this.isEmpty ? (this.accessor.partOptions.closeEmptyGroups && this.accessor.removeGroup(this), !0) : await this.handleCloseConfirmation(this.model.getEditors(0, e)) ? !1 : (this.doCloseAllEditors(e), !0);
  }
  doCloseAllEditors(e) {
    const t = [];
    for (const i of this.model.getEditors(1, e))
      this.isActive(i) || this.doCloseInactiveEditor(i), t.push(i);
    this.activeEditor && t.includes(this.activeEditor) && this.doCloseActiveEditor(), t.length && this.titleAreaControl.closeEditors(t);
  }
  async replaceEditors(e) {
    let t;
    const i = [];
    for (let { editor: o, replacement: s, forceReplaceDirty: n, options: r } of e) {
      const a = this.getIndexOfEditor(o);
      if (a >= 0) {
        const d = this.isActive(o);
        r ? r.index = a : r = { index: a }, r.inactive = !d, r.pinned = r.pinned ?? !0;
        const h = { editor: o, replacement: s, forceReplaceDirty: n, options: r };
        d ? t = h : i.push(h);
      }
    }
    for (const { editor: o, replacement: s, forceReplaceDirty: n, options: r } of i)
      if (await this.doOpenEditor(s, r), !o.matches(s)) {
        let a = !1;
        if (n ? (this.doCloseEditor(o, !1, { context: Si.REPLACE }), a = !0) : a = await this.doCloseEditorWithConfirmationHandling(o, { preserveFocus: !0 }, { context: Si.REPLACE }), !a)
          return;
      }
    if (t) {
      const o = this.doOpenEditor(t.replacement, t.options);
      t.editor.matches(t.replacement) || (t.forceReplaceDirty ? this.doCloseEditor(t.editor, !1, { context: Si.REPLACE }) : await this.doCloseEditorWithConfirmationHandling(t.editor, { preserveFocus: !0 }, { context: Si.REPLACE })), await o;
    }
  }
  get isLocked() {
    return this.accessor.groups.length === 1 ? !1 : this.model.isLocked;
  }
  lock(e) {
    this.accessor.groups.length === 1 && (e = !1), this.model.lock(e);
  }
  updateStyles() {
    const e = this.isEmpty;
    e ? this.element.style.backgroundColor = this.getColor(Jb) || "" : this.element.style.backgroundColor = "";
    const t = this.getColor(Vb) || this.getColor(Oe);
    !e && t ? (this.titleContainer.classList.add("title-border-bottom"), this.titleContainer.style.setProperty("--title-border-bottom-color", t)) : (this.titleContainer.classList.remove("title-border-bottom"), this.titleContainer.style.removeProperty("--title-border-bottom-color"));
    const { showTabs: i } = this.accessor.partOptions;
    this.titleContainer.style.backgroundColor = this.getColor(i ? Ph : Zb) || "", this.editorContainer.style.backgroundColor = this.getColor(ed) || "";
  }
  get minimumWidth() {
    return this.editorPane.minimumWidth;
  }
  get minimumHeight() {
    return this.editorPane.minimumHeight;
  }
  get maximumWidth() {
    return this.editorPane.maximumWidth;
  }
  get maximumHeight() {
    return this.editorPane.maximumHeight;
  }
  get proportionalLayout() {
    return this.lastLayout ? !(this.lastLayout.width === this.minimumWidth || this.lastLayout.height === this.minimumHeight) : !0;
  }
  layout(e, t, i, o) {
    this.lastLayout = { width: e, height: t, top: i, left: o }, this.element.classList.toggle("max-height-478px", t <= 478);
    const s = this.titleAreaControl.layout({
      container: new H(e, t),
      available: new H(e, t - this.editorPane.minimumHeight)
    }), n = Math.max(0, t - s.height);
    this.editorContainer.style.height = `${n}px`, this.editorPane.layout({ width: e, height: n, top: i + s.height, left: o });
  }
  relayout() {
    if (this.lastLayout) {
      const { width: e, height: t, top: i, left: o } = this.lastLayout;
      this.layout(e, t, i, o);
    }
  }
  setBoundarySashes(e) {
    this.editorPane.setBoundarySashes(e);
  }
  toJSON() {
    return this.model.serialize();
  }
  dispose() {
    this._disposed = !0, this._onWillDispose.fire(), this.titleAreaControl.dispose(), super.dispose();
  }
};
Mi = y([
  l(3, W),
  l(4, F),
  l(5, z),
  l(6, Xe),
  l(7, be),
  l(8, lt),
  l(9, Ie),
  l(10, Uh),
  l(11, D),
  l(12, Js),
  l(13, Li),
  l(14, rt)
], Mi);
var Iy = "#monaco-workbench-editor-drop-overlay{height:100%;left:0;position:absolute;width:100%;z-index:10000}#monaco-workbench-editor-drop-overlay>.editor-group-overlay-indicator{align-items:center;display:flex;height:100%;justify-content:center;left:0;opacity:0;pointer-events:none;position:absolute;top:0;width:100%}.monaco-workbench:not(.reduce-motion) #monaco-workbench-editor-drop-overlay>.editor-group-overlay-indicator{transition:opacity .15s ease-out}#monaco-workbench-editor-drop-overlay .editor-group-overlay-drop-into-prompt{line-height:normal;margin:.2em;opacity:0;padding:.6em;text-align:center}.monaco-workbench:not(.reduce-motion) #monaco-workbench-editor-drop-overlay .editor-group-overlay-drop-into-prompt{transition:opacity .15s ease-out}#monaco-workbench-editor-drop-overlay .editor-group-overlay-drop-into-prompt i{background-color:hsla(0,0%,100%,.05);border:1px solid hsla(0,0%,80%,.4);border-radius:5px;font-style:normal;margin:0 1px;padding:0 8px}.monaco-workbench:not(.reduce-motion) #monaco-workbench-editor-drop-overlay>.editor-group-overlay-indicator.overlay-move-transition{transition:top 70ms ease-out,left 70ms ease-out,width 70ms ease-out,height 70ms ease-out,opacity .15s ease-out}";
oe(Iy, {});
function Dg(c) {
  return c.getValue("editor.dropIntoEditor.enabled");
}
function Ng(c) {
  return c.shiftKey;
}
var ko;
let Wa = (ko = class extends Hn {
  get disposed() {
    return !!this._disposed;
  }
  constructor(e, t, i, o, s, n, r, a, d) {
    super(i), this.accessor = e, this.groupView = t, this.configurationService = o, this.instantiationService = s, this.editorService = n, this.editorGroupService = r, this.treeViewsDragAndDropService = a, this.contextService = d, this.editorTransfer = Pt.getInstance(), this.groupTransfer = Pt.getInstance(), this.treeItemsTransfer = Pt.getInstance(), this.cleanupOverlayScheduler = this._register(new Ss(() => this.dispose(), 300)), this.enableDropIntoEditor = Dg(this.configurationService) && this.isDropIntoActiveEditorEnabled(), this.create();
  }
  create() {
    const e = this.getOverlayOffsetHeight(), t = this.container = document.createElement("div");
    t.id = ko.OVERLAY_ID, t.style.top = `${e}px`, this.groupView.element.appendChild(t), this.groupView.element.classList.add("dragged-over"), this._register(M(() => {
      this.groupView.element.removeChild(t), this.groupView.element.classList.remove("dragged-over");
    })), this.overlay = document.createElement("div"), this.overlay.classList.add("editor-group-overlay-indicator"), t.appendChild(this.overlay), this.enableDropIntoEditor && (this.dropIntoPromptElement = Wb(u(
      "dropIntoEditorPrompt",
      "Hold __{0}__ to drop into editor",
      Ze ? "" : "Shift"
    ), {}), this.dropIntoPromptElement.classList.add("editor-group-overlay-drop-into-prompt"), this.overlay.appendChild(this.dropIntoPromptElement)), this.registerListeners(t), this.updateStyles();
  }
  updateStyles() {
    const e = L(this.overlay);
    e.style.backgroundColor = this.getColor(Ln) || "";
    const t = this.getColor(co);
    if (e.style.outlineColor = t || "", e.style.outlineOffset = t ? "-2px" : "", e.style.outlineStyle = t ? "dashed" : "", e.style.outlineWidth = t ? "2px" : "", this.dropIntoPromptElement) {
      this.dropIntoPromptElement.style.backgroundColor = this.getColor(_b) ?? "", this.dropIntoPromptElement.style.color = this.getColor(Eb) ?? "";
      const i = this.getColor(Rb);
      i ? (this.dropIntoPromptElement.style.borderWidth = "1px", this.dropIntoPromptElement.style.borderStyle = "solid", this.dropIntoPromptElement.style.borderColor = i) : this.dropIntoPromptElement.style.borderWidth = "0";
    }
  }
  registerListeners(e) {
    this._register(new Nr(e, {
      onDragEnter: (t) => {
      },
      onDragOver: (t) => {
        if (this.enableDropIntoEditor && Ng(t)) {
          this.dispose();
          return;
        }
        const i = this.groupTransfer.hasData(Ye.prototype), o = this.editorTransfer.hasData(Ve.prototype);
        !o && !i && t.dataTransfer && (t.dataTransfer.dropEffect = "copy");
        let s = !0;
        if (i)
          s = this.isCopyOperation(t);
        else if (o) {
          const r = this.editorTransfer.getData(Ve.prototype);
          Array.isArray(r) && (s = this.isCopyOperation(t, r[0].identifier));
        }
        if (!s) {
          const r = this.findSourceGroupView();
          if (r === this.groupView && (i || o && r.count < 2)) {
            this.hideOverlay();
            return;
          }
        }
        let n = !!this.editorGroupService.partOptions.splitOnDragAndDrop;
        this.isToggleSplitOperation(t) && (n = !n), this.positionOverlay(t.offsetX, t.offsetY, i, n), this.cleanupOverlayScheduler.isScheduled() && this.cleanupOverlayScheduler.cancel();
      },
      onDragLeave: (t) => this.dispose(),
      onDragEnd: (t) => this.dispose(),
      onDrop: (t) => {
        U.stop(t, !0), this.dispose(), this.currentDropOperation && this.handleDrop(t, this.currentDropOperation.splitDirection);
      }
    })), this._register(S(e, I.MOUSE_OVER, () => {
      this.cleanupOverlayScheduler.isScheduled() || this.cleanupOverlayScheduler.schedule();
    }));
  }
  isDropIntoActiveEditorEnabled() {
    var e;
    return !!((e = this.groupView.activeEditor) != null && e.hasCapability(128));
  }
  findSourceGroupView() {
    if (this.groupTransfer.hasData(Ye.prototype)) {
      const e = this.groupTransfer.getData(Ye.prototype);
      if (Array.isArray(e))
        return this.accessor.getGroup(e[0].identifier);
    } else if (this.editorTransfer.hasData(Ve.prototype)) {
      const e = this.editorTransfer.getData(Ve.prototype);
      if (Array.isArray(e))
        return this.accessor.getGroup(e[0].identifier.groupId);
    }
  }
  async handleDrop(e, t) {
    const i = () => {
      let o;
      return typeof t == "number" ? o = this.accessor.addGroup(this.groupView, t) : o = this.groupView, o;
    };
    if (this.groupTransfer.hasData(Ye.prototype)) {
      const o = this.groupTransfer.getData(Ye.prototype);
      if (Array.isArray(o)) {
        const s = this.accessor.getGroup(o[0].identifier);
        if (s) {
          if (typeof t != "number" && s === this.groupView)
            return;
          let n;
          if (typeof t == "number")
            this.isCopyOperation(e) ? n = this.accessor.copyGroup(s, this.groupView, t) : n = this.accessor.moveGroup(s, this.groupView, t);
          else {
            let r;
            this.isCopyOperation(e) && (r = { mode: 0 }), this.accessor.mergeGroup(s, this.groupView, r);
          }
          n && this.accessor.activateGroup(n);
        }
        this.groupTransfer.clearData(Ye.prototype);
      }
    } else if (this.editorTransfer.hasData(Ve.prototype)) {
      const o = this.editorTransfer.getData(Ve.prototype);
      if (Array.isArray(o)) {
        const s = o[0].identifier, n = this.accessor.getGroup(s.groupId);
        if (n) {
          const r = this.isCopyOperation(e, s);
          let a;
          if (this.editorGroupService.partOptions.closeEmptyGroups && n.count === 1 && typeof t == "number" && !r)
            a = this.accessor.moveGroup(n, this.groupView, t);
          else {
            if (a = i(), n === a)
              return;
            const d = Lr(n, s.editor, {
              pinned: !0,
              sticky: n.isSticky(s.editor)
            });
            r ? n.copyEditor(s.editor, a, d) : n.moveEditor(s.editor, a, d);
          }
          a.focus();
        }
        this.editorTransfer.clearData(Ve.prototype);
      }
    } else if (this.treeItemsTransfer.hasData(Rt.prototype)) {
      const o = this.treeItemsTransfer.getData(Rt.prototype);
      if (Array.isArray(o)) {
        const s = [];
        for (const n of o) {
          const r = await this.treeViewsDragAndDropService.removeDragOperationTransfer(n.identifier);
          if (r) {
            const a = await Oh(r);
            s.push(...a.map((d) => ({ ...d, options: { ...d.options, pinned: !0 } })));
          }
        }
        s.length && this.editorService.openEditors(s, i(), { validateTrust: !0 });
      }
      this.treeItemsTransfer.clearData(Rt.prototype);
    } else
      this.instantiationService.createInstance(Hh, { allowWorkspaceOpen: !ot || Gb(this.contextService.getWorkspace()) }).handleDrop(e, () => i(), (s) => s == null ? void 0 : s.focus());
  }
  isCopyOperation(e, t) {
    return t != null && t.editor.hasCapability(8) ? !1 : e.ctrlKey && !Ze || e.altKey && Ze;
  }
  isToggleSplitOperation(e) {
    return e.altKey && !Ze || e.shiftKey && Ze;
  }
  positionOverlay(e, t, i, o) {
    const s = this.accessor.partOptions.openSideBySideDirection === "right", n = this.groupView.element.clientWidth, r = this.groupView.element.clientHeight - this.getOverlayOffsetHeight();
    let a, d;
    o ? (i ? a = s ? 0.3 : 0.1 : a = 0.1, i ? d = s ? 0.1 : 0.3 : d = 0.1) : (a = 0, d = 0);
    const h = n * a, g = r * d, p = n / 3, m = r / 3;
    let C;
    switch (e > h && e < n - h && t > g && t < r - g ? C = void 0 : s ? e < p ? C = 2 : e > p * 2 ? C = 3 : t < r / 2 ? C = 0 : C = 1 : t < m ? C = 0 : t > m * 2 ? C = 1 : e < n / 2 ? C = 2 : C = 3, C) {
      case 0:
        this.doPositionOverlay({ top: "0", left: "0", width: "100%", height: "50%" }), this.toggleDropIntoPrompt(!1);
        break;
      case 1:
        this.doPositionOverlay({ top: "50%", left: "0", width: "100%", height: "50%" }), this.toggleDropIntoPrompt(!1);
        break;
      case 2:
        this.doPositionOverlay({ top: "0", left: "0", width: "50%", height: "100%" }), this.toggleDropIntoPrompt(!1);
        break;
      case 3:
        this.doPositionOverlay({ top: "0", left: "50%", width: "50%", height: "100%" }), this.toggleDropIntoPrompt(!1);
        break;
      default:
        this.doPositionOverlay({ top: "0", left: "0", width: "100%", height: "100%" }), this.toggleDropIntoPrompt(!0);
    }
    const b = L(this.overlay);
    b.style.opacity = "1", setTimeout(() => b.classList.add("overlay-move-transition"), 0), this.currentDropOperation = { splitDirection: C };
  }
  doPositionOverlay(e) {
    const [t, i] = Yi(this.container, this.overlay), o = this.getOverlayOffsetHeight();
    o ? t.style.height = `calc(100% - ${o}px)` : t.style.height = "100%", i.style.top = e.top, i.style.left = e.left, i.style.width = e.width, i.style.height = e.height;
  }
  getOverlayOffsetHeight() {
    return !this.groupView.isEmpty && this.accessor.partOptions.showTabs ? this.groupView.titleHeight.offset : 0;
  }
  hideOverlay() {
    const e = L(this.overlay);
    this.doPositionOverlay({ top: "0", left: "0", width: "100%", height: "100%" }), e.style.opacity = "0", e.classList.remove("overlay-move-transition"), this.currentDropOperation = void 0;
  }
  toggleDropIntoPrompt(e) {
    this.dropIntoPromptElement && (this.dropIntoPromptElement.style.opacity = e ? "1" : "0");
  }
  contains(e) {
    return e === this.container || e === this.overlay;
  }
  dispose() {
    super.dispose(), this._disposed = !0;
  }
}, ko.OVERLAY_ID = "monaco-workbench-editor-drop-overlay", ko);
Wa = y([
  l(2, z),
  l(3, x),
  l(4, W),
  l(5, D),
  l(6, ce),
  l(7, $c),
  l(8, at)
], Wa);
let _a = class extends Hn {
  constructor(e, t, i, o, s, n) {
    super(o), this.accessor = e, this.container = t, this.delegate = i, this.configurationService = s, this.instantiationService = n, this.counter = 0, this.editorTransfer = Pt.getInstance(), this.groupTransfer = Pt.getInstance(), this.registerListeners();
  }
  get overlay() {
    if (this._overlay && !this._overlay.disposed)
      return this._overlay;
  }
  registerListeners() {
    this._register(S(this.container, I.DRAG_ENTER, (e) => this.onDragEnter(e))), this._register(S(this.container, I.DRAG_LEAVE, () => this.onDragLeave())), [this.container, window].forEach((e) => this._register(S(e, I.DRAG_END, () => this.onDragEnd())));
  }
  onDragEnter(e) {
    if (Dg(this.configurationService) && Ng(e))
      return;
    if (this.counter++, !this.editorTransfer.hasData(Ve.prototype) && !this.groupTransfer.hasData(Ye.prototype) && e.dataTransfer) {
      const i = N.as(xb.DragAndDropContribution).getAll(), o = Array.from(i).map((s) => s.dataFormatKey);
      if (!Db(e, io.FILES, Fr.FILES, io.RESOURCES, Fr.EDITORS, ...o)) {
        e.dataTransfer.dropEffect = "none";
        return;
      }
    }
    this.updateContainer(!0);
    const t = e.target;
    if (t && (this.overlay && !this.overlay.contains(t) && this.disposeOverlay(), !this.overlay)) {
      const i = this.findTargetGroupView(t);
      i && (this._overlay = this.instantiationService.createInstance(Wa, this.accessor, i));
    }
  }
  onDragLeave() {
    this.counter--, this.counter === 0 && this.updateContainer(!1);
  }
  onDragEnd() {
    this.counter = 0, this.updateContainer(!1), this.disposeOverlay();
  }
  findTargetGroupView(e) {
    return this.accessor.groups.find((i) => {
      var o, s;
      return Nt(e, i.element) || ((s = (o = this.delegate).containsGroup) == null ? void 0 : s.call(o, i));
    });
  }
  updateContainer(e) {
    this.container.classList.toggle("dragged-over", e);
  }
  dispose() {
    super.dispose(), this.disposeOverlay();
  }
  disposeOverlay() {
    this.overlay && (this.overlay.dispose(), this._overlay = void 0);
  }
};
_a = y([
  l(3, z),
  l(4, x),
  l(5, W)
], _a);
const Xo = {
  targetWidth: 900,
  leftMarginRatio: 0.1909,
  rightMarginRatio: 0.1909
}, wr = { type: "distribute" };
function Ul(c) {
  const e = Y(".centered-layout-margin");
  return e.style.height = "100%", c && (e.style.backgroundColor = c.toString()), {
    element: e,
    layout: () => {
    },
    minimumSize: 60,
    maximumSize: Number.POSITIVE_INFINITY,
    onDidChange: _.None
  };
}
function Jy(c, e) {
  return {
    element: c.element,
    get maximumSize() {
      return c.maximumWidth;
    },
    get minimumSize() {
      return c.minimumWidth;
    },
    onDidChange: _.map(c.onDidChange, (t) => t && t.width),
    layout: (t, i, o) => c.layout(t, e(), (o == null ? void 0 : o.top) ?? 0, ((o == null ? void 0 : o.left) ?? 0) + i)
  };
}
class Vy {
  constructor(e, t, i = { ...Xo }) {
    this.container = e, this.view = t, this.state = i, this.lastLayoutPosition = { width: 0, height: 0, left: 0, top: 0 }, this.didLayout = !1, this.splitViewDisposables = new Z(), this.centeredLayoutFixedWidth = !0, this._boundarySashes = {}, this.container.appendChild(this.view.element), this.container.style.overflow = "hidden";
  }
  get minimumWidth() {
    return this.splitView ? this.splitView.minimumSize : this.view.minimumWidth;
  }
  get maximumWidth() {
    return this.splitView ? this.splitView.maximumSize : this.view.maximumWidth;
  }
  get minimumHeight() {
    return this.view.minimumHeight;
  }
  get maximumHeight() {
    return this.view.maximumHeight;
  }
  get onDidChange() {
    return this.view.onDidChange;
  }
  get boundarySashes() {
    return this._boundarySashes;
  }
  set boundarySashes(e) {
    this._boundarySashes = e, this.splitView && (this.splitView.orthogonalStartSash = e.top, this.splitView.orthogonalEndSash = e.bottom);
  }
  layout(e, t, i, o) {
    this.lastLayoutPosition = { width: e, height: t, top: i, left: o }, this.splitView ? (this.splitView.layout(e, this.lastLayoutPosition), (!this.didLayout || this.centeredLayoutFixedWidth) && this.resizeSplitViews()) : this.view.layout(e, t, i, o), this.didLayout = !0;
  }
  resizeSplitViews() {
    if (this.splitView)
      if (this.centeredLayoutFixedWidth) {
        const e = Math.min(this.lastLayoutPosition.width, this.state.targetWidth), t = (this.lastLayoutPosition.width - e) / 2;
        this.splitView.resizeView(0, Math.floor(t)), this.splitView.resizeView(1, e), this.splitView.resizeView(2, Math.ceil(t));
      } else {
        const e = this.state.leftMarginRatio * this.lastLayoutPosition.width, t = this.state.rightMarginRatio * this.lastLayoutPosition.width, i = this.lastLayoutPosition.width - e - t;
        this.splitView.resizeView(0, e), this.splitView.resizeView(1, i), this.splitView.resizeView(2, t);
      }
  }
  setFixedWidth(e) {
    this.centeredLayoutFixedWidth = e, this.splitView && (this.updateState(), this.resizeSplitViews());
  }
  updateState() {
    this.splitView && (this.state.targetWidth = this.splitView.getViewSize(1), this.state.leftMarginRatio = this.splitView.getViewSize(0) / this.lastLayoutPosition.width, this.state.rightMarginRatio = this.splitView.getViewSize(2) / this.lastLayoutPosition.width);
  }
  isActive() {
    return !!this.splitView;
  }
  styles(e) {
    this.style = e, this.splitView && this.emptyViews && (this.splitView.style(this.style), this.emptyViews[0].element.style.backgroundColor = this.style.background.toString(), this.emptyViews[1].element.style.backgroundColor = this.style.background.toString());
  }
  activate(e) {
    var t;
    if (e !== this.isActive())
      if (e) {
        this.container.removeChild(this.view.element), this.splitView = new ss(this.container, {
          inverseAltBehavior: !0,
          orientation: 1,
          styles: this.style
        }), this.splitView.orthogonalStartSash = this.boundarySashes.top, this.splitView.orthogonalEndSash = this.boundarySashes.bottom, this.splitViewDisposables.add(this.splitView.onDidSashChange(() => {
          this.splitView && this.updateState();
        })), this.splitViewDisposables.add(this.splitView.onDidSashReset(() => {
          this.state = { ...Xo }, this.resizeSplitViews();
        })), this.splitView.layout(this.lastLayoutPosition.width, this.lastLayoutPosition);
        const i = this.style ? this.style.background : void 0;
        this.emptyViews = [Ul(i), Ul(i)], this.splitView.addView(this.emptyViews[0], wr, 0), this.splitView.addView(Jy(this.view, () => this.lastLayoutPosition.height), wr, 1), this.splitView.addView(this.emptyViews[1], wr, 2), this.resizeSplitViews();
      } else
        this.splitView && this.container.removeChild(this.splitView.el), this.splitViewDisposables.clear(), (t = this.splitView) == null || t.dispose(), this.splitView = void 0, this.emptyViews = void 0, this.container.appendChild(this.view.element), this.view.layout(this.lastLayoutPosition.width, this.lastLayoutPosition.height, this.lastLayoutPosition.top, this.lastLayoutPosition.left);
  }
  isDefault(e) {
    return this.centeredLayoutFixedWidth ? e.targetWidth === Xo.targetWidth : e.leftMarginRatio === Xo.leftMarginRatio && e.rightMarginRatio === Xo.rightMarginRatio;
  }
  dispose() {
    this.splitViewDisposables.dispose(), this.splitView && (this.splitView.dispose(), this.splitView = void 0);
  }
}
class Zy {
  constructor() {
    this.element = Y(".grid-view-container"), this._onDidChange = new Ht(), this.onDidChange = this._onDidChange.event;
  }
  get minimumWidth() {
    return this.gridWidget ? this.gridWidget.minimumWidth : 0;
  }
  get maximumWidth() {
    return this.gridWidget ? this.gridWidget.maximumWidth : Number.POSITIVE_INFINITY;
  }
  get minimumHeight() {
    return this.gridWidget ? this.gridWidget.minimumHeight : 0;
  }
  get maximumHeight() {
    return this.gridWidget ? this.gridWidget.maximumHeight : Number.POSITIVE_INFINITY;
  }
  get gridWidget() {
    return this._gridWidget;
  }
  set gridWidget(e) {
    this.element.innerText = "", e ? (this.element.appendChild(e.element), this._onDidChange.input = e.onDidChange) : this._onDidChange.input = _.None, this._gridWidget = e;
  }
  layout(e, t, i, o) {
    var s;
    (s = this.gridWidget) == null || s.layout(e, t, i, o);
  }
  dispose() {
    this._onDidChange.dispose();
  }
}
var it;
let Ea = (it = class extends er {
  constructor(e, t, i, o, s) {
    super("workbench.parts.editor", { hasTitle: !1 }, t, o, s), this.instantiationService = e, this.configurationService = i, this._onDidLayout = this._register(new w()), this.onDidLayout = this._onDidLayout.event, this._onDidChangeActiveGroup = this._register(new w()), this.onDidChangeActiveGroup = this._onDidChangeActiveGroup.event, this._onDidChangeGroupIndex = this._register(new w()), this.onDidChangeGroupIndex = this._onDidChangeGroupIndex.event, this._onDidChangeGroupLocked = this._register(new w()), this.onDidChangeGroupLocked = this._onDidChangeGroupLocked.event, this._onDidActivateGroup = this._register(new w()), this.onDidActivateGroup = this._onDidActivateGroup.event, this._onDidAddGroup = this._register(new w()), this.onDidAddGroup = this._onDidAddGroup.event, this._onDidRemoveGroup = this._register(new w()), this.onDidRemoveGroup = this._onDidRemoveGroup.event, this._onDidMoveGroup = this._register(new w()), this.onDidMoveGroup = this._onDidMoveGroup.event, this.onDidSetGridWidget = this._register(new w()), this._onDidChangeSizeConstraints = this._register(new Ht()), this.onDidChangeSizeConstraints = _.any(this.onDidSetGridWidget.event, this._onDidChangeSizeConstraints.event), this._onDidScroll = this._register(new Ht()), this.onDidScroll = _.any(this.onDidSetGridWidget.event, this._onDidScroll.event), this._onDidChangeEditorPartOptions = this._register(new w()), this.onDidChangeEditorPartOptions = this._onDidChangeEditorPartOptions.event, this.workspaceMemento = this.getMemento(1, 1), this.profileMemento = this.getMemento(0, 1), this.groupViews = /* @__PURE__ */ new Map(), this.mostRecentActiveGroups = [], this.gridWidgetView = this._register(new Zy()), this.enforcedPartOptions = [], this._partOptions = al(this.configurationService, this.themeService), this._top = 0, this._left = 0, this.sideGroup = {
      openEditor: (n, r) => {
        const [a] = this.instantiationService.invokeFunction((d) => ug(d, { editor: n, options: r }, uo));
        return a.openEditor(n, r);
      }
    }, this._isReady = !1, this.whenReadyPromise = new Tr(), this.whenReady = this.whenReadyPromise.p, this.whenRestoredPromise = new Tr(), this.whenRestored = this.whenRestoredPromise.p, this.priority = 2, this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => this.onConfigurationUpdated(e))), this._register(this.themeService.onDidFileIconThemeChange(() => this.handleChangedPartOptions()));
  }
  onConfigurationUpdated(e) {
    Nb(e) && this.handleChangedPartOptions();
  }
  handleChangedPartOptions() {
    const e = this._partOptions, t = al(this.configurationService, this.themeService);
    for (const i of this.enforcedPartOptions)
      Object.assign(t, i);
    this._partOptions = t, this._onDidChangeEditorPartOptions.fire({ oldPartOptions: e, newPartOptions: t });
  }
  get partOptions() {
    return this._partOptions;
  }
  enforcePartOptions(e) {
    return this.enforcedPartOptions.push(e), this.handleChangedPartOptions(), M(() => {
      this.enforcedPartOptions.splice(this.enforcedPartOptions.indexOf(e), 1), this.handleChangedPartOptions();
    });
  }
  get contentDimension() {
    return this._contentDimension;
  }
  get activeGroup() {
    return this._activeGroup;
  }
  get groups() {
    return Array.from(this.groupViews.values());
  }
  get count() {
    return this.groupViews.size;
  }
  get orientation() {
    return this.gridWidget && this.gridWidget.orientation === 0 ? 1 : 0;
  }
  get isReady() {
    return this._isReady;
  }
  get hasRestorableState() {
    return !!this.workspaceMemento[it.EDITOR_PART_UI_STATE_STORAGE_KEY];
  }
  getGroups(e = 0) {
    switch (e) {
      case 0:
        return this.groups;
      case 1: {
        const t = ti(this.mostRecentActiveGroups.map((i) => this.getGroup(i)));
        return oo([...t, ...this.groups]);
      }
      case 2: {
        const t = [];
        return this.gridWidget && this.fillGridNodes(t, this.gridWidget.getViews()), t;
      }
    }
  }
  fillGridNodes(e, t) {
    Ei(t) ? t.children.forEach((i) => this.fillGridNodes(e, i)) : e.push(t.view);
  }
  getGroup(e) {
    return this.groupViews.get(e);
  }
  findGroup(e, t = this.activeGroup, i) {
    if (typeof e.direction == "number")
      return this.doFindGroupByDirection(e.direction, t, i);
    if (typeof e.location == "number")
      return this.doFindGroupByLocation(e.location, t, i);
    throw new Error("invalid arguments");
  }
  doFindGroupByDirection(e, t, i) {
    const o = this.assertGroupView(t), s = this.gridWidget.getNeighborViews(o, this.toGridViewDirection(e), i);
    return s.sort((n, r) => this.mostRecentActiveGroups.indexOf(n.id) - this.mostRecentActiveGroups.indexOf(r.id)), s[0];
  }
  doFindGroupByLocation(e, t, i) {
    const o = this.assertGroupView(t), s = this.getGroups(2), n = s.indexOf(o);
    switch (e) {
      case 0:
        return s[0];
      case 1:
        return s[s.length - 1];
      case 2: {
        let r = s[n + 1];
        return !r && i && (r = this.doFindGroupByLocation(0, t)), r;
      }
      case 3: {
        let r = s[n - 1];
        return !r && i && (r = this.doFindGroupByLocation(1, t)), r;
      }
    }
  }
  activateGroup(e) {
    const t = this.assertGroupView(e);
    return this.doSetGroupActive(t), this._onDidActivateGroup.fire(t), t;
  }
  restoreGroup(e) {
    const t = this.assertGroupView(e);
    return this.doRestoreGroup(t), t;
  }
  getSize(e) {
    const t = this.assertGroupView(e);
    return this.gridWidget.getViewSize(t);
  }
  setSize(e, t) {
    const i = this.assertGroupView(e);
    this.gridWidget.resizeView(i, t);
  }
  arrangeGroups(e, t = this.activeGroup) {
    if (!(this.count < 2) && this.gridWidget)
      switch (e) {
        case 1:
          this.gridWidget.distributeViewSizes();
          break;
        case 0:
          this.gridWidget.maximizeViewSize(t);
          break;
        case 2:
          this.isGroupMaximized(t) ? this.arrangeGroups(1) : this.arrangeGroups(0);
          break;
      }
  }
  isGroupMaximized(e) {
    return this.gridWidget.isViewSizeMaximized(e);
  }
  setGroupOrientation(e) {
    if (!this.gridWidget)
      return;
    const t = e === 0 ? 1 : 0;
    this.gridWidget.orientation !== t && (this.gridWidget.orientation = t);
  }
  applyLayout(e) {
    const t = this.shouldRestoreFocus(this.container);
    let i = 0;
    function o(a) {
      for (const d of a)
        Array.isArray(d.groups) ? o(d.groups) : i++;
    }
    o(e.groups);
    let s = this.getGroups(2);
    if (i < s.length) {
      const a = s[i - 1];
      s.forEach((d, h) => {
        h >= i && this.mergeGroup(d, a);
      }), s = this.getGroups(2);
    }
    const n = this.activeGroup, r = Rg({
      orientation: this.toGridViewOrientation(
        e.orientation,
        this.isTwoDimensionalGrid() ? this.gridWidget.orientation : xt(this.gridWidget.orientation)
      ),
      groups: e.groups
    });
    this.doCreateGridControlWithState(r, n.id, s), this.doLayout(this._contentDimension), this.updateContainer();
    for (const a of this.getGroups(2))
      s.includes(a) || this._onDidAddGroup.fire(a);
    this.notifyGroupIndexChange(), t && this._activeGroup.focus();
  }
  getLayout() {
    const e = this.gridWidget.serialize(), t = e.orientation === 1 ? 0 : 1, i = this.serializedNodeToGroupLayoutArgument(e.root);
    return {
      orientation: t,
      groups: i.groups
    };
  }
  serializedNodeToGroupLayoutArgument(e) {
    return e.type === "branch" ? {
      size: e.size,
      groups: e.data.map((t) => this.serializedNodeToGroupLayoutArgument(t))
    } : { size: e.size };
  }
  shouldRestoreFocus(e) {
    if (!e)
      return !1;
    const t = document.activeElement;
    return t === document.body ? !0 : Nt(t, e);
  }
  isTwoDimensionalGrid() {
    const e = this.gridWidget.getViews();
    return Ei(e) ? e.children.some((t) => Ei(t)) : !1;
  }
  addGroup(e, t, i) {
    const o = this.assertGroupView(e), s = this.doAddGroup(o, t);
    return i != null && i.activate && this.doSetGroupActive(s), s;
  }
  doAddGroup(e, t, i) {
    const o = this.groupViews.size > 1 && this.isGroupMaximized(e), s = this.doCreateGroupView(i);
    return this.gridWidget.addView(s, this.getSplitSizingStyle(), e, this.toGridViewDirection(t)), this.updateContainer(), this._onDidAddGroup.fire(s), this.notifyGroupIndexChange(), o && this.arrangeGroups(0, s), s;
  }
  getSplitSizingStyle() {
    switch (this._partOptions.splitSizing) {
      case "distribute":
        return no.Distribute;
      case "split":
        return no.Split;
      default:
        return no.Auto;
    }
  }
  doCreateGroupView(e) {
    let t;
    e instanceof Mi ? t = Mi.createCopy(e, this, this.count, this.instantiationService) : qh(e) ? t = Mi.createFromSerialized(e, this, this.count, this.instantiationService) : t = Mi.createNew(this, this.count, this.instantiationService), this.groupViews.set(t.id, t);
    const i = new Z();
    return i.add(t.onDidFocus(() => {
      this.doSetGroupActive(t);
    })), i.add(t.onDidModelChange((o) => {
      switch (o.kind) {
        case 2:
          this._onDidChangeGroupLocked.fire(t);
          break;
        case 1:
          this._onDidChangeGroupIndex.fire(t);
          break;
      }
    })), i.add(t.onDidActiveEditorChange(() => {
      this.updateContainer();
    })), _.once(t.onWillDispose)(() => {
      le(i), this.groupViews.delete(t.id), this.doUpdateMostRecentActive(t);
    }), t;
  }
  doSetGroupActive(e) {
    if (this._activeGroup === e)
      return;
    const t = this._activeGroup;
    this._activeGroup = e, this.doUpdateMostRecentActive(e, !0), t == null || t.setActive(!1), e.setActive(!0), this.doRestoreGroup(e), this._onDidChangeActiveGroup.fire(e);
  }
  doRestoreGroup(e) {
    if (this.gridWidget) {
      const t = this.gridWidget.getViewSize(e);
      (t.width === e.minimumWidth || t.height === e.minimumHeight) && this.arrangeGroups(0, e);
    }
  }
  doUpdateMostRecentActive(e, t) {
    const i = this.mostRecentActiveGroups.indexOf(e.id);
    i !== -1 && this.mostRecentActiveGroups.splice(i, 1), t && this.mostRecentActiveGroups.unshift(e.id);
  }
  toGridViewDirection(e) {
    switch (e) {
      case 0:
        return 0;
      case 1:
        return 1;
      case 2:
        return 2;
      case 3:
        return 3;
    }
  }
  toGridViewOrientation(e, t) {
    return typeof e == "number" ? e === 0 ? 1 : 0 : t;
  }
  removeGroup(e) {
    const t = this.assertGroupView(e);
    if (this.count !== 1) {
      if (t.isEmpty)
        return this.doRemoveEmptyGroup(t);
      this.doRemoveGroupWithEditors(t);
    }
  }
  doRemoveGroupWithEditors(e) {
    const t = this.getGroups(1);
    let i;
    this._activeGroup === e ? i = t[1] : i = t[0], this.mergeGroup(e, i);
  }
  doRemoveEmptyGroup(e) {
    var i;
    const t = this.shouldRestoreFocus(this.container);
    if (this._activeGroup === e) {
      const s = this.getGroups(1)[1];
      this.activateGroup(s);
    }
    this.gridWidget.removeView(e, this.getSplitSizingStyle()), e.dispose(), t && this._activeGroup.focus(), this.notifyGroupIndexChange(), this.updateContainer(), this.count === 1 && ((i = td(this.groups)) == null || i.lock(!1)), this._onDidRemoveGroup.fire(e);
  }
  moveGroup(e, t, i) {
    const o = this.assertGroupView(e), s = this.assertGroupView(t);
    if (o.id === s.id)
      throw new Error("Cannot move group into its own");
    const n = this.shouldRestoreFocus(o.element);
    return this.gridWidget.moveView(o, this.getSplitSizingStyle(), s, this.toGridViewDirection(i)), n && o.focus(), this._onDidMoveGroup.fire(o), this.notifyGroupIndexChange(), o;
  }
  copyGroup(e, t, i) {
    const o = this.assertGroupView(e), s = this.assertGroupView(t), n = this.shouldRestoreFocus(o.element), r = this.doAddGroup(s, i, o);
    return n && r.focus(), r;
  }
  mergeGroup(e, t, i) {
    const o = this.assertGroupView(e), s = this.assertGroupView(t), n = [];
    let r = i && typeof i.index == "number" ? i.index : s.count;
    for (const a of o.editors) {
      const d = !o.isActive(a) || this._activeGroup !== o, g = { index: o.isSticky(a) ? void 0 : r, inactive: d, preserveFocus: d };
      n.push({ editor: a, options: g }), r++;
    }
    return (i == null ? void 0 : i.mode) === 0 ? o.copyEditors(n, s) : o.moveEditors(n, s), o.isEmpty && !o.disposed && this.removeGroup(o), s;
  }
  mergeAllGroups(e = this.activeGroup) {
    for (const t of this.getGroups(1))
      t !== e && this.mergeGroup(t, e);
    return e;
  }
  assertGroupView(e) {
    let t;
    if (typeof e == "number" ? t = this.getGroup(e) : t = e, !t)
      throw new Error("Invalid editor group provided!");
    return t;
  }
  createEditorDropTarget(e, t) {
    return this.instantiationService.createInstance(_a, this, e, t);
  }
  get minimumWidth() {
    return Math.min(this.centeredLayoutWidget.minimumWidth, this.layoutService.getMaximumEditorDimensions().width);
  }
  get maximumWidth() {
    return this.centeredLayoutWidget.maximumWidth;
  }
  get minimumHeight() {
    return Math.min(this.centeredLayoutWidget.minimumHeight, this.layoutService.getMaximumEditorDimensions().height);
  }
  get maximumHeight() {
    return this.centeredLayoutWidget.maximumHeight;
  }
  get snap() {
    return this.layoutService.getPanelAlignment() === "center";
  }
  get onDidChange() {
    return _.any(this.centeredLayoutWidget.onDidChange, this.onDidSetGridWidget.event);
  }
  get gridSeparatorBorder() {
    return this.theme.getColor(Qb) || this.theme.getColor(Oe) || mi.transparent;
  }
  updateStyles() {
    const e = L(this.container);
    e.style.backgroundColor = this.getColor(ed) || "";
    const t = { separatorBorder: this.gridSeparatorBorder, background: this.theme.getColor(Ab) || mi.transparent };
    this.gridWidget.style(t), this.centeredLayoutWidget.styles(t);
  }
  createContentArea(e, t) {
    return this.element = e, this.container = document.createElement("div"), this.container.classList.add("content"), e.appendChild(this.container), this.doCreateGridControl(t), this.centeredLayoutWidget = this._register(new Vy(
      this.container,
      this.gridWidgetView,
      this.profileMemento[it.EDITOR_PART_CENTERED_VIEW_STORAGE_KEY]
    )), this._register(this.onDidChangeEditorPartOptions((i) => this.centeredLayoutWidget.setFixedWidth(i.newPartOptions.centeredLayoutFixedWidth ?? !1))), this.setupDragAndDropSupport(e, this.container), this.whenReadyPromise.complete(), this._isReady = !0, eu.settled(this.groups.map((i) => i.whenRestored)).finally(() => {
      this.whenRestoredPromise.complete();
    }), this.container;
  }
  setupDragAndDropSupport(e, t) {
    this._register(this.createEditorDropTarget(t, /* @__PURE__ */ Object.create(null)));
    const i = document.createElement("div");
    i.classList.add("drop-block-overlay"), e.appendChild(i), this._register(Bb(i, () => i.classList.remove("visible"))), this._register(is.INSTANCE.registerTarget(this.element, {
      onDragStart: (h) => i.classList.add("visible"),
      onDragEnd: (h) => i.classList.remove("visible")
    }));
    let o, s, n, r;
    const a = (h) => {
      !this.layoutService.isVisible("workbench.parts.panel") && h === this.layoutService.getPanelPosition() ? this.layoutService.setPartHidden(!1, "workbench.parts.panel") : !this.layoutService.isVisible("workbench.parts.auxiliarybar") && h === (this.layoutService.getSideBarPosition() === 1 ? 0 : 1) && this.layoutService.setPartHidden(!1, "workbench.parts.auxiliarybar");
    }, d = () => {
      o && (clearTimeout(o), o = void 0), s && (clearTimeout(s), s = void 0);
    };
    this._register(is.INSTANCE.registerTarget(i, {
      onDragOver: (h) => {
        U.stop(h.eventData, !0), h.eventData.dataTransfer && (h.eventData.dataTransfer.dropEffect = "none");
        const g = i.getBoundingClientRect();
        let p, m;
        const C = 100;
        h.eventData.clientX < g.left + C && (p = 0), h.eventData.clientX > g.right - C && (p = 1), h.eventData.clientY > g.bottom - C && (m = 2), o && p !== n && (clearTimeout(o), o = void 0), s && m !== r && (clearTimeout(s), s = void 0), !o && p !== void 0 && (n = p, o = setTimeout(() => a(p), 200)), !s && m !== void 0 && (r = m, s = setTimeout(() => a(m), 200));
      },
      onDragLeave: () => d(),
      onDragEnd: () => d(),
      onDrop: () => d()
    }));
  }
  centerLayout(e) {
    this.centeredLayoutWidget.activate(e), this._activeGroup.focus();
  }
  isLayoutCentered() {
    return this.centeredLayoutWidget ? this.centeredLayoutWidget.isActive() : !1;
  }
  doCreateGridControl(e) {
    let t = !1;
    if ((!e || e.restorePreviousState) && (t = !this.doCreateGridControlWithPreviousState()), !this.gridWidget || t) {
      const i = this.doCreateGroupView();
      this.doSetGridWidget(new Wi(i)), this.doSetGroupActive(i);
    }
    this.updateContainer(), this.notifyGroupIndexChange();
  }
  doCreateGridControlWithPreviousState() {
    const e = this.workspaceMemento[it.EDITOR_PART_UI_STATE_STORAGE_KEY];
    if (e != null && e.serializedGrid)
      try {
        this.mostRecentActiveGroups = e.mostRecentActiveGroups, this.doCreateGridControlWithState(e.serializedGrid, e.activeGroup), this._activeGroup.focus();
      } catch (t) {
        return ho(new Error(
          `Error restoring editor grid widget: ${t} (with state: ${JSON.stringify(e)})`
        )), this.groupViews.forEach((i) => i.dispose()), this.groupViews.clear(), this.mostRecentActiveGroups = [], !1;
      }
    return !0;
  }
  doCreateGridControlWithState(e, t, i) {
    let o;
    i ? o = i.slice(0) : o = [];
    const s = [], n = Wi.deserialize(e, {
      fromJSON: (r) => {
        let a;
        return o.length > 0 ? a = o.shift() : a = this.doCreateGroupView(r), s.push(a), a.id === t && this.doSetGroupActive(a), a;
      }
    }, { styles: { separatorBorder: this.gridSeparatorBorder } });
    this._activeGroup || this.doSetGroupActive(s[0]), this.mostRecentActiveGroups.some((r) => !this.getGroup(r)) && (this.mostRecentActiveGroups = s.map((r) => r.id)), this.doSetGridWidget(n);
  }
  doSetGridWidget(e) {
    let t = {};
    this.gridWidget && (t = this.gridWidget.boundarySashes, this.gridWidget.dispose()), this.gridWidget = e, this.gridWidget.boundarySashes = t, this.gridWidgetView.gridWidget = e, this._onDidChangeSizeConstraints.input = e.onDidChange, this._onDidScroll.input = e.onDidScroll, this.onDidSetGridWidget.fire(void 0);
  }
  updateContainer() {
    L(this.container).classList.toggle("empty", this.isEmpty);
  }
  notifyGroupIndexChange() {
    this.getGroups(2).forEach((e, t) => e.notifyIndexChanged(t));
  }
  get isEmpty() {
    return this.count === 1 && this._activeGroup.isEmpty;
  }
  setBoundarySashes(e) {
    this.gridWidget.boundarySashes = e, this.centeredLayoutWidget.boundarySashes = e;
  }
  layout(e, t, i, o) {
    this._top = i, this._left = o;
    const s = super.layoutContents(e, t).contentSize;
    this.doLayout(H.lift(s), i, o);
  }
  doLayout(e, t = this._top, i = this._left) {
    this._contentDimension = e, this.centeredLayoutWidget.layout(this._contentDimension.width, this._contentDimension.height, t, i), this._onDidLayout.fire(e);
  }
  saveState() {
    if (this.gridWidget) {
      const e = {
        serializedGrid: this.gridWidget.serialize(),
        activeGroup: this._activeGroup.id,
        mostRecentActiveGroups: this.mostRecentActiveGroups
      };
      this.isEmpty ? delete this.workspaceMemento[it.EDITOR_PART_UI_STATE_STORAGE_KEY] : this.workspaceMemento[it.EDITOR_PART_UI_STATE_STORAGE_KEY] = e;
    }
    if (this.centeredLayoutWidget) {
      const e = this.centeredLayoutWidget.state;
      this.centeredLayoutWidget.isDefault(e) ? delete this.profileMemento[it.EDITOR_PART_CENTERED_VIEW_STORAGE_KEY] : this.profileMemento[it.EDITOR_PART_CENTERED_VIEW_STORAGE_KEY] = e;
    }
    super.saveState();
  }
  toJSON() {
    return {
      type: "workbench.parts.editor"
    };
  }
  dispose() {
    var e;
    this.groupViews.forEach((t) => t.dispose()), this.groupViews.clear(), (e = this.gridWidget) == null || e.dispose(), super.dispose();
  }
}, it.EDITOR_PART_UI_STATE_STORAGE_KEY = "editorpart.state", it.EDITOR_PART_CENTERED_VIEW_STORAGE_KEY = "editorpart.centeredview", it);
Ea = y([
  l(0, W),
  l(1, z),
  l(2, x),
  l(3, ee),
  l(4, Pe)
], Ea);
V.registerCommandAndKeybindingRule({
  weight: 200,
  when: Tb,
  primary: 2051,
  mac: {
    primary: 259
  },
  id: tu,
  handler: async (c, e) => {
    const t = c.get(D), i = c.get(B), o = c.get(_e), s = c.get(ht), n = _s(e, i, t, s);
    if (n.length) {
      const r = n.filter((p) => p.scheme === q.untitled), a = n.filter((p) => p.scheme !== q.untitled), g = (await Promise.all(a.map(async (p) => {
        const m = s.findClosest(p);
        return m || await o.stat(p);
      }))).filter((p) => !p.isDirectory).map((p) => ({
        resource: p.resource,
        options: { pinned: !0 }
      })).concat(...r.map(
        (p) => ({ resource: p, options: { pinned: !0 } })
      ));
      await t.openEditors(g, uo);
    }
  }
});
V.registerCommandAndKeybindingRule({
  weight: 200 + 10,
  when: f.and(et, ct.toNegated()),
  primary: 3,
  mac: {
    primary: 2066
  },
  id: "explorer.openAndPassFocus",
  handler: async (c, e) => {
    const t = c.get(D), o = c.get(ht).getContext(!0);
    o.length && await t.openEditors(o.map(
      (s) => ({ resource: s.resource, options: { preserveFocus: !1, pinned: !0 } })
    ));
  }
});
const yr = "showModifications";
let ci = [];
V.registerCommandAndKeybindingRule({
  id,
  when: void 0,
  weight: 200,
  primary: St(2089, 34),
  handler: async (c, e) => {
    const t = c.get(W), i = c.get(Do), o = c.get(D), s = c.get(_e);
    let n = !1;
    if (ci.length === 0) {
      n = !0;
      const a = t.createInstance(rn);
      ci.push(a), ci.push(i.registerTextModelContentProvider(yr, a));
    }
    const r = Es(e, c.get(B), o);
    if (r && s.hasProvider(r)) {
      const a = Le(r), d = u("modifiedLabel", "{0} (in file)  {1}", a, a);
      try {
        await rn.open(r, yr, d, o, { pinned: !0 }), n && ci.push(o.onDidVisibleEditorsChange(() => {
          o.editors.some(
            (h) => !!me.getCanonicalUri(h, { supportSideBySide: ie.SECONDARY, filterByScheme: yr })
          ) || (ci = le(ci));
        }));
      } catch {
        ci = le(ci);
      }
    }
  }
});
let Ra, kr;
Te.registerCommand({
  id: iu,
  handler: (c, e) => {
    const t = c.get(B);
    Ra = Es(e, t, c.get(D)), kr || (kr = od.bindTo(c.get(F))), kr.set(!0);
  }
});
Te.registerCommand({
  id: ou,
  handler: async (c, e) => {
    const t = c.get(D), i = c.get(ht), o = _s(e, c.get(B), t, i);
    return o.length === 2 ? t.openEditor({
      original: { resource: o[0] },
      modified: { resource: o[1] },
      options: { pinned: !0 }
    }) : !0;
  }
});
Te.registerCommand({
  id: su,
  handler: (c, e) => {
    const t = c.get(D), i = c.get(B), o = Es(e, i, t);
    Ra && o && t.openEditor({
      original: { resource: Ra },
      modified: { resource: o },
      options: { pinned: !0 }
    });
  }
});
async function Dd(c, e, t, i, o) {
  if (c.length) {
    const s = Qt ? `\r
` : `
`;
    let n;
    if (e) {
      const a = o.getValue("explorer.copyRelativePathSeparator");
      (a === "/" || a === "\\") && (n = a);
    }
    const r = c.map(
      (a) => i.getUriLabel(a, { relative: e, noPrefix: !0, separator: n })
    ).join(s);
    await t.writeText(r);
  }
}
const Qg = async (c, e) => {
  const t = _s(e, c.get(B), c.get(D), c.get(ht));
  await Dd(t, !1, c.get(Xn), c.get(Ft), c.get(x));
};
V.registerCommandAndKeybindingRule({
  weight: 200,
  when: Fi.focus.toNegated(),
  primary: 2593,
  win: {
    primary: 1569
  },
  id: Rs,
  handler: Qg
});
V.registerCommandAndKeybindingRule({
  weight: 200,
  when: Fi.focus,
  primary: St(2089, 2593),
  win: {
    primary: 1569
  },
  id: Rs,
  handler: Qg
});
const Ag = async (c, e) => {
  const t = _s(e, c.get(B), c.get(D), c.get(ht));
  await Dd(t, !0, c.get(Xn), c.get(Ft), c.get(x));
};
V.registerCommandAndKeybindingRule({
  weight: 200,
  when: Fi.focus.toNegated(),
  primary: 3617,
  win: {
    primary: St(2089, 3105)
  },
  id: Gs,
  handler: Ag
});
V.registerCommandAndKeybindingRule({
  weight: 200,
  when: Fi.focus,
  primary: St(2089, 3617),
  win: {
    primary: St(2089, 3105)
  },
  id: Gs,
  handler: Ag
});
V.registerCommandAndKeybindingRule({
  weight: 200,
  when: void 0,
  primary: St(2089, 46),
  id: "workbench.action.files.copyPathOfActiveFile",
  handler: async (c) => {
    const t = c.get(D).activeEditor, i = me.getOriginalUri(t, { supportSideBySide: ie.PRIMARY });
    await Dd(i ? [i] : [], !1, c.get(Xn), c.get(Ft), c.get(x));
  }
});
Te.registerCommand({
  id: nu,
  handler: async (c, e) => {
    const t = c.get(Mn), i = c.get(at), o = c.get(ht), s = Es(e, c.get(B), c.get(D));
    if (s && i.isInsideWorkspace(s)) {
      const n = await t.openView(Lb, !1);
      n && (n.setExpanded(!0), await o.select(s, "force"), n.focus());
    } else {
      const n = await t.openView(Fb.ID, !1);
      n && (n.setExpanded(!0), n.focus());
    }
  }
});
Te.registerCommand({
  id: ru,
  handler: async (c, e) => {
    const t = c.get(D), i = Es(e, c.get(B), c.get(D));
    if (i)
      return t.openEditor({ resource: i, options: { override: Po.PICK, source: Mh.USER } });
  }
});
async function Nd(c, e) {
  var a;
  const t = c.get(B), i = c.get(ce), o = c.get(No), s = c.get(Qo);
  let n = lu(t);
  if (!n) {
    const d = i.activeGroup;
    d.activeEditor && (n = [], d.activeEditor instanceof li && !(e != null && e.saveAs) && !(d.activeEditor.primary.hasCapability(4) || d.activeEditor.secondary.hasCapability(4)) ? (n.push({ groupId: d.id, editor: d.activeEditor.primary }), n.push({ groupId: d.id, editor: d.activeEditor.secondary })) : n.push({ groupId: d.id, editor: d.activeEditor }));
  }
  if (!n || n.length === 0)
    return;
  await Qd(c, n, e);
  const r = o.getFocusedCodeEditor();
  if (r instanceof cd) {
    const d = (a = r.getModel()) == null ? void 0 : a.uri;
    if (d && !n.some(
      ({ editor: h }) => Be(me.getCanonicalUri(h, { supportSideBySide: ie.PRIMARY }), d)
    )) {
      const h = s.files.get(d);
      h != null && h.isReadonly() || await s.save(d, e);
    }
  }
}
function Bg(c, e, t) {
  const i = [];
  for (const o of e)
    for (const s of o.getEditors(0))
      s.isDirty() && i.push({ groupId: o.id, editor: s });
  return Qd(c, i, t);
}
async function Qd(c, e, t) {
  const i = c.get(D), o = c.get(We), s = c.get(W);
  try {
    await i.save(e, t);
  } catch (n) {
    Qi(n) || o.notify({
      id: e.map(({ editor: r }) => {
        var a;
        return Ws((a = r.resource) == null ? void 0 : a.toString());
      }).join(),
      severity: xi.Error,
      message: u(
        { key: "genericSaveError", comment: ["{0} is the resource that failed to save and {1} the error message"] },
        "Failed to save '{0}': {1}",
        e.map(({ editor: r }) => r.getName()).join(", "),
        go(n, !1)
      ),
      actions: {
        primary: [
          we({ id: "workbench.action.files.saveEditors", label: u("retry", "Retry"), run: () => s.invokeFunction((r) => Qd(r, e, t)) }),
          we({ id: "workbench.action.files.revertEditors", label: u("discard", "Discard"), run: () => i.revert(e) })
        ]
      }
    });
  }
}
V.registerCommandAndKeybindingRule({
  when: void 0,
  weight: 200,
  primary: 2097,
  id: sd,
  handler: (c) => Nd(c, { reason: 1, force: !0 })
});
V.registerCommandAndKeybindingRule({
  when: void 0,
  weight: 200,
  primary: St(2089, 49),
  win: { primary: St(2089, 3121) },
  id: au,
  handler: (c) => Nd(c, { reason: 1, force: !0, skipSaveParticipants: !0 })
});
V.registerCommandAndKeybindingRule({
  id: cu,
  weight: 200,
  when: void 0,
  primary: 3121,
  handler: (c) => Nd(c, { reason: 1, saveAs: !0 })
});
V.registerCommandAndKeybindingRule({
  when: void 0,
  weight: 200,
  primary: void 0,
  mac: { primary: 2609 },
  win: { primary: St(2089, 49) },
  id: Xb,
  handler: (c) => Bg(c, c.get(ce).getGroups(1), { reason: 1 })
});
Te.registerCommand({
  id: nd,
  handler: (c, e, t) => {
    const i = c.get(ce), o = Kb(t, c.get(B), c.get(ce));
    let s;
    return o.length ? s = ti(o.map((n) => i.getGroup(n.groupId))) : s = i.getGroups(1), Bg(c, s, { reason: 1 });
  }
});
Te.registerCommand({
  id: du,
  handler: async (c) => (await c.get(D).saveAll({ includeUntitled: !1, reason: 1 })).success
});
Te.registerCommand({
  id: rd,
  handler: async (c) => {
    const e = c.get(We), t = c.get(B), i = c.get(ce), o = c.get(D);
    let s = lu(t);
    if (!s) {
      const n = i.activeGroup;
      n.activeEditor && (s = [{ groupId: n.id, editor: n.activeEditor }]);
    }
    if (!(!s || s.length === 0))
      try {
        await o.revert(s.filter(({ editor: n }) => !n.hasCapability(4)), { force: !0 });
      } catch (n) {
        e.error(u("genericRevertError", "Failed to revert '{0}': {1}", s.map(({ editor: r }) => r.getName()).join(", "), go(n, !1)));
      }
  }
});
Te.registerCommand({
  id: hu,
  handler: (c, e) => {
    const t = c.get(Yb), i = c.get(at), o = c.get(Li), s = i.getWorkspace(), n = _s(e, c.get(B), c.get(D), c.get(ht)).filter(
      (r) => s.folders.some((a) => o.extUri.isEqual(a.uri, r))
    );
    return n.length === 0 ? c.get(Bi).executeCommand(Ob.ID) : t.removeFolders(n);
  }
});
V.registerCommandAndKeybindingRule({
  weight: 200 + 10,
  when: f.and(
    et,
    zn,
    uu.negate()
  ),
  primary: 15,
  id: Hb,
  handler: (c) => {
    const t = c.get(ii).getActivePaneComposite(0);
    if ((t == null ? void 0 : t.getId()) !== Mt)
      return;
    t.getViewPaneContainer().getExplorerView().previousCompressedStat();
  }
});
V.registerCommandAndKeybindingRule({
  weight: 200 + 10,
  when: f.and(
    et,
    zn,
    gu.negate()
  ),
  primary: 17,
  id: Pb,
  handler: (c) => {
    const t = c.get(ii).getActivePaneComposite(0);
    if ((t == null ? void 0 : t.getId()) !== Mt)
      return;
    t.getViewPaneContainer().getExplorerView().nextCompressedStat();
  }
});
V.registerCommandAndKeybindingRule({
  weight: 200 + 10,
  when: f.and(
    et,
    zn,
    uu.negate()
  ),
  primary: 14,
  id: Mb,
  handler: (c) => {
    const t = c.get(ii).getActivePaneComposite(0);
    if ((t == null ? void 0 : t.getId()) !== Mt)
      return;
    t.getViewPaneContainer().getExplorerView().firstCompressedStat();
  }
});
V.registerCommandAndKeybindingRule({
  weight: 200 + 10,
  when: f.and(
    et,
    zn,
    gu.negate()
  ),
  primary: 13,
  id: zb,
  handler: (c) => {
    const t = c.get(ii).getActivePaneComposite(0);
    if ((t == null ? void 0 : t.getId()) !== Mt)
      return;
    t.getViewPaneContainer().getExplorerView().lastCompressedStat();
  }
});
V.registerCommandAndKeybindingRule({
  weight: 200,
  when: null,
  primary: ot ? Qt ? St(2089, 44) : 2604 : 2092,
  secondary: ot ? [2092] : void 0,
  id: ad,
  description: {
    description: pu,
    args: [
      {
        isOptional: !0,
        name: "New Untitled Text File arguments",
        description: "The editor view type or language ID if known",
        schema: {
          type: "object",
          properties: {
            viewType: {
              type: "string"
            },
            languageId: {
              type: "string"
            }
          }
        }
      }
    ]
  },
  handler: async (c, e) => {
    await c.get(D).openEditor({
      resource: void 0,
      options: {
        override: e == null ? void 0 : e.viewType,
        pinned: !0
      },
      languageId: e == null ? void 0 : e.languageId
    });
  }
});
Te.registerCommand({
  id: Ub,
  handler: async (c, e) => {
    const t = c.get(D), i = c.get(Uh), o = c.get(_e), s = u("newFileCommand.saveLabel", "Create File"), n = on(await i.defaultFilePath(), (e == null ? void 0 : e.fileName) ?? "Untitled.txt"), r = await i.showSaveDialog({ saveLabel: s, title: s, defaultUri: n });
    r && (await o.createFile(r, void 0, { overwrite: !0 }), await t.openEditor({
      resource: r,
      options: {
        override: e == null ? void 0 : e.viewType,
        pinned: !0
      },
      languageId: e == null ? void 0 : e.languageId
    }));
  }
});
let At = class Tg extends jb {
  get typeId() {
    return dd;
  }
  get editorId() {
    return Ke.id;
  }
  get capabilities() {
    let e = 32;
    return this.model ? this.model.isReadonly() && (e |= 2) : this.fileService.hasProvider(this.resource) ? this.filesConfigurationService.isReadonly(this.resource) && (e |= 2) : e |= 4, e & 2 || (e |= 128), e;
  }
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m, C, b, v) {
    super(e, t, C, d, g, p, m), this.instantiationService = a, this.textModelResolverService = h, this.pathService = b, this.textResourceConfigurationService = v, this.forceOpenAs = 0, this.model = void 0, this.cachedTextFileModelReference = void 0, this.modelListeners = this._register(new Z()), this.model = this.textFileService.files.get(e), i && this.setPreferredName(i), o && this.setPreferredDescription(o), s && this.setPreferredEncoding(s), n && this.setPreferredLanguageId(n), typeof r == "string" && this.setPreferredContents(r), this._register(this.textFileService.files.onDidCreate((J) => this.onDidCreateTextFileModel(J))), this.model && this.registerModelListeners(this.model);
  }
  onDidCreateTextFileModel(e) {
    Be(e.resource, this.resource) && (this.model = e, this.registerModelListeners(e));
  }
  registerModelListeners(e) {
    this.modelListeners.clear(), this.modelListeners.add(e.onDidChangeDirty(() => this._onDidChangeDirty.fire())), this.modelListeners.add(e.onDidChangeReadonly(() => this._onDidChangeCapabilities.fire())), this.modelListeners.add(e.onDidSaveError(() => this._onDidChangeDirty.fire())), this.modelListeners.add(_.once(e.onWillDispose)(() => {
      this.modelListeners.clear(), this.model = void 0;
    }));
  }
  getName() {
    return this.preferredName || super.getName();
  }
  setPreferredName(e) {
    this.allowLabelOverride() && this.preferredName !== e && (this.preferredName = e, this._onDidChangeLabel.fire());
  }
  allowLabelOverride() {
    return this.resource.scheme !== this.pathService.defaultUriScheme && this.resource.scheme !== q.vscodeUserData && this.resource.scheme !== q.file && this.resource.scheme !== q.vscodeRemote;
  }
  getPreferredName() {
    return this.preferredName;
  }
  isReadonly() {
    return this.model ? this.model.isReadonly() : this.filesConfigurationService.isReadonly(this.resource);
  }
  getDescription(e) {
    return this.preferredDescription || super.getDescription(e);
  }
  setPreferredDescription(e) {
    this.allowLabelOverride() && this.preferredDescription !== e && (this.preferredDescription = e, this._onDidChangeLabel.fire());
  }
  getPreferredDescription() {
    return this.preferredDescription;
  }
  getEncoding() {
    return this.model ? this.model.getEncoding() : this.preferredEncoding;
  }
  getPreferredEncoding() {
    return this.preferredEncoding;
  }
  async setEncoding(e, t) {
    var i;
    return this.setPreferredEncoding(e), (i = this.model) == null ? void 0 : i.setEncoding(e, t);
  }
  setPreferredEncoding(e) {
    this.preferredEncoding = e, this.setForceOpenAsText();
  }
  getLanguageId() {
    return this.model ? this.model.getLanguageId() : this.preferredLanguageId;
  }
  getPreferredLanguageId() {
    return this.preferredLanguageId;
  }
  setLanguageId(e, t) {
    var i;
    this.setPreferredLanguageId(e), (i = this.model) == null || i.setLanguageId(e, t);
  }
  setPreferredLanguageId(e) {
    this.preferredLanguageId = e, this.setForceOpenAsText();
  }
  setPreferredContents(e) {
    this.preferredContents = e, this.setForceOpenAsText();
  }
  setForceOpenAsText() {
    this.forceOpenAs = 1;
  }
  setForceOpenAsBinary() {
    this.forceOpenAs = 2;
  }
  isDirty() {
    var e;
    return !!((e = this.model) != null && e.isDirty());
  }
  isSaving() {
    var e, t, i;
    return (e = this.model) != null && e.hasState(0) || (t = this.model) != null && t.hasState(3) || (i = this.model) != null && i.hasState(5) ? !1 : this.filesConfigurationService.getAutoSaveMode() === 1 ? !0 : super.isSaving();
  }
  prefersEditorPane(e) {
    return this.forceOpenAs === 2 ? e.find((t) => t.typeId === mu) : e.find((t) => t.typeId === bu);
  }
  resolve(e) {
    return this.forceOpenAs === 2 ? this.doResolveAsBinary() : this.doResolveAsText(e);
  }
  async doResolveAsText(e) {
    try {
      const t = this.preferredContents;
      this.preferredContents = void 0, await this.textFileService.files.resolve(this.resource, {
        languageId: this.preferredLanguageId,
        encoding: this.preferredEncoding,
        contents: typeof t == "string" ? qb(t) : void 0,
        reload: { async: !0 },
        allowBinary: this.forceOpenAs === 1,
        reason: 1,
        limits: this.ensureLimits(e)
      }), this.cachedTextFileModelReference || (this.cachedTextFileModelReference = await this.textModelResolverService.createModelReference(this.resource));
      const i = this.cachedTextFileModelReference.object;
      return this.isDisposed() && this.disposeModelReference(), i;
    } catch (t) {
      if (t.textFileOperationResult === 0)
        return this.doResolveAsBinary();
      throw t;
    }
  }
  ensureLimits(e) {
    if (e != null && e.limits)
      return e.limits;
    const t = $b(this.resource);
    let i;
    const o = this.textResourceConfigurationService.inspect(this.resource, null, "workbench.editorLargeFileConfirmation");
    return eC(o) && (i = o.value * Cu.MB), {
      size: i ?? t
    };
  }
  async doResolveAsBinary() {
    const e = this.instantiationService.createInstance(gg, this.preferredResource, this.getName());
    return await e.resolve(), e;
  }
  isResolved() {
    return !!this.model;
  }
  async rename(e, t) {
    return {
      editor: {
        resource: t,
        encoding: this.getEncoding(),
        options: {
          viewState: cl(this, e, this.editorService)
        }
      }
    };
  }
  toUntyped(e) {
    const t = {
      resource: this.preferredResource,
      forceFile: !0,
      options: {
        override: this.editorId
      }
    };
    return typeof (e == null ? void 0 : e.preserveViewState) == "number" && (t.encoding = this.getEncoding(), t.languageId = this.getLanguageId(), t.contents = (() => {
      const i = this.textFileService.files.get(this.resource);
      if (i != null && i.isDirty())
        return i.textEditorModel.getValue();
    })(), t.options = {
      ...t.options,
      viewState: cl(this, e.preserveViewState, this.editorService)
    }), t;
  }
  matches(e) {
    return this === e ? !0 : e instanceof Tg ? Be(e.resource, this.resource) : an(e) ? super.matches(e) : !1;
  }
  dispose() {
    this.model = void 0, this.disposeModelReference(), super.dispose();
  }
  disposeModelReference() {
    le(this.cachedTextFileModelReference), this.cachedTextFileModelReference = void 0;
  }
};
At = y([
  l(7, W),
  l(8, Qo),
  l(9, Do),
  l(10, Ft),
  l(11, _e),
  l(12, Js),
  l(13, D),
  l(14, Pn),
  l(15, Go)
], At);
const Lg = "saveConflictResolutionContext", Ga = "conflictResolution", Ad = "learnMoreDirtyWriteError", Fg = u(
  "userGuide",
  "Use the actions in the editor tool bar to either undo your changes or overwrite the content of the file with your changes."
);
let xa = class extends E {
  constructor(e, t, i, o, s, n, r) {
    super(), this.notificationService = e, this.textFileService = t, this.contextKeyService = i, this.editorService = o, this.instantiationService = n, this.storageService = r, this.messages = new Et(), this.conflictResolutionContext = new K(Lg, !1, !0).bindTo(this.contextKeyService), this.activeConflictResolutionResource = void 0;
    const a = this._register(n.createInstance(rn));
    this._register(s.registerTextModelContentProvider(Ga, a)), this.textFileService.files.saveErrorHandler = this, this.registerListeners();
  }
  registerListeners() {
    this._register(this.textFileService.files.onDidSave((e) => this.onFileSavedOrReverted(e.model.resource))), this._register(this.textFileService.files.onDidRevert((e) => this.onFileSavedOrReverted(e.resource))), this._register(this.editorService.onDidActiveEditorChange(() => this.onActiveEditorChanged()));
  }
  onActiveEditorChanged() {
    let e = !1, t;
    const i = this.editorService.activeEditor;
    if (i instanceof ld) {
      const o = i.original.resource;
      (o == null ? void 0 : o.scheme) === Ga && (e = !0, t = i.modified.resource);
    }
    this.conflictResolutionContext.set(e), this.activeConflictResolutionResource = t;
  }
  onFileSavedOrReverted(e) {
    const t = this.messages.get(e);
    t && (t.close(), this.messages.delete(e));
  }
  onSaveError(e, t) {
    var h;
    const i = e, o = t.resource;
    let s;
    const n = [], r = [];
    if (i.fileOperationResult === 3)
      if (this.activeConflictResolutionResource && Be(this.activeConflictResolutionResource, t.resource)) {
        if (this.storageService.getBoolean(Ad, -1))
          return;
        s = Fg, n.push(this.instantiationService.createInstance(vn)), r.push(this.instantiationService.createInstance(Da));
      } else
        s = u(
          "staleSaveError",
          "Failed to save '{0}': The content of the file is newer. Please compare your version with the file contents or overwrite the content of the file with your changes.",
          Le(o)
        ), n.push(this.instantiationService.createInstance(Na, t)), n.push(this.instantiationService.createInstance(Gy, t)), r.push(this.instantiationService.createInstance(Aa));
    else {
      const g = i.fileOperationResult === 5, p = g && ((h = i.options) == null ? void 0 : h.unlock), m = i.fileOperationResult === 6, C = o.scheme === q.file;
      C && (m || p) ? n.push(this.instantiationService.createInstance(Wy, t, !!p)) : g ? n.push(this.instantiationService.createInstance(Ry, t)) : n.push(this.instantiationService.createInstance(_y, t)), n.push(this.instantiationService.createInstance(Qa, t)), n.push(this.instantiationService.createInstance(Ey, t)), g ? p && C ? s = Qt ? u(
        "readonlySaveErrorAdmin",
        "Failed to save '{0}': File is read-only. Select 'Overwrite as Admin' to retry as administrator.",
        Le(o)
      ) : u(
        "readonlySaveErrorSudo",
        "Failed to save '{0}': File is read-only. Select 'Overwrite as Sudo' to retry as superuser.",
        Le(o)
      ) : s = u(
        "readonlySaveError",
        "Failed to save '{0}': File is read-only. Select 'Overwrite' to attempt to make it writeable.",
        Le(o)
      ) : C && m ? s = Qt ? u(
        "permissionDeniedSaveError",
        "Failed to save '{0}': Insufficient permissions. Select 'Retry as Admin' to retry as administrator.",
        Le(o)
      ) : u(
        "permissionDeniedSaveErrorSudo",
        "Failed to save '{0}': Insufficient permissions. Select 'Retry as Sudo' to retry as superuser.",
        Le(o)
      ) : s = u(
        { key: "genericSaveError", comment: ["{0} is the resource that failed to save and {1} the error message"] },
        "Failed to save '{0}': {1}",
        Le(o),
        go(e, !1)
      );
    }
    const a = { primary: n, secondary: r }, d = this.notificationService.notify({
      id: `${Ws(t.resource.toString())}`,
      severity: xi.Error,
      message: s,
      actions: a
    });
    _.once(d.onDidClose)(() => {
      le(n), le(r);
    }), this.messages.set(t.resource, d);
  }
  dispose() {
    super.dispose(), this.messages.clear();
  }
};
xa = y([
  l(0, We),
  l(1, Qo),
  l(2, F),
  l(3, D),
  l(4, Do),
  l(5, W),
  l(6, ee)
], xa);
let vn = class extends j {
  constructor(e) {
    super("workbench.files.action.resolveConflictLearnMore", u("learnMore", "Learn More")), this.openerService = e;
  }
  async run() {
    await this.openerService.open(A.parse("https://go.microsoft.com/fwlink/?linkid=868264"));
  }
};
vn = y([
  l(0, Ti)
], vn);
let Da = class extends j {
  constructor(e) {
    super("workbench.files.action.resolveConflictLearnMoreDoNotShowAgain", u("dontShowAgain", "Don't Show Again")), this.storageService = e;
  }
  async run(e) {
    this.storageService.store(Ad, !0, -1, 0), e.dispose();
  }
};
Da = y([
  l(0, ee)
], Da);
let Na = class extends j {
  constructor(e, t, i, o, s) {
    super("workbench.files.action.resolveConflict", u("compareChanges", "Compare")), this.model = e, this.editorService = t, this.notificationService = i, this.instantiationService = o, this.productService = s;
  }
  async run() {
    if (!this.model.isDisposed()) {
      const e = this.model.resource, t = Le(e), i = u(
        "saveConflictDiffLabel",
        "{0} (in file)  {1} (in {2}) - Resolve save conflict",
        t,
        t,
        this.productService.nameLong
      );
      await rn.open(e, Ga, i, this.editorService, { pinned: !0 });
      const o = { primary: [this.instantiationService.createInstance(vn)] }, s = this.notificationService.notify({
        id: `${Ws(e.toString())}`,
        severity: xi.Info,
        message: Fg,
        actions: o,
        neverShowAgain: { id: Ad, isSecondary: !0 }
      });
      _.once(s.onDidClose)(() => le(o.primary));
    }
  }
};
Na = y([
  l(1, D),
  l(2, We),
  l(3, W),
  l(4, lh)
], Na);
class Wy extends j {
  constructor(e, t) {
    super("workbench.files.action.saveModelElevated", t ? Qt ? u("overwriteElevated", "Overwrite as Admin...") : u("overwriteElevatedSudo", "Overwrite as Sudo...") : Qt ? u("saveElevated", "Retry as Admin...") : u("saveElevatedSudo", "Retry as Sudo...")), this.model = e, this.triedToUnlock = t;
  }
  async run() {
    this.model.isDisposed() || await this.model.save({
      writeElevated: !0,
      writeUnlock: this.triedToUnlock,
      reason: 1
    });
  }
}
class _y extends j {
  constructor(e) {
    super("workbench.files.action.saveModel", u("retry", "Retry")), this.model = e;
  }
  async run() {
    this.model.isDisposed() || await this.model.save({ reason: 1 });
  }
}
class Ey extends j {
  constructor(e) {
    super("workbench.files.action.discardModel", u("discard", "Discard")), this.model = e;
  }
  async run() {
    this.model.isDisposed() || await this.model.revert();
  }
}
let Qa = class extends j {
  constructor(e, t) {
    super("workbench.files.action.saveModelAs", fu), this.model = e, this.editorService = t;
  }
  async run() {
    if (!this.model.isDisposed()) {
      const e = this.findEditor();
      e && await this.editorService.save(e, { saveAs: !0, reason: 1 });
    }
  }
  findEditor() {
    let e;
    const t = this.editorService.findEditors(this.model.resource, { supportSideBySide: ie.PRIMARY });
    for (const i of t)
      if (i.editor instanceof At) {
        e = i;
        break;
      } else
        e || (e = i);
    return e;
  }
};
Qa = y([
  l(1, D)
], Qa);
class Ry extends j {
  constructor(e) {
    super("workbench.files.action.unlock", u("overwrite", "Overwrite")), this.model = e;
  }
  async run() {
    this.model.isDisposed() || await this.model.save({ writeUnlock: !0, reason: 1 });
  }
}
class Gy extends j {
  constructor(e) {
    super("workbench.files.action.saveIgnoreModifiedSince", u("overwrite", "Overwrite")), this.model = e;
  }
  async run() {
    this.model.isDisposed() || await this.model.save({ ignoreModifiedSince: !0, reason: 1 });
  }
}
let Aa = class extends j {
  constructor(e) {
    super("workbench.files.action.configureSaveConflict", u("configure", "Configure")), this.preferencesService = e;
  }
  async run() {
    this.preferencesService.openSettings({ query: "files.saveConflictResolution" });
  }
};
Aa = y([
  l(0, Hc)
], Aa);
const si = 10, Xg = "renameFile";
V.registerCommandAndKeybindingRule({
  id: Xg,
  weight: 200 + si,
  when: f.and(et, It.toNegated(), He),
  primary: 60,
  mac: {
    primary: 3
  },
  handler: tC
});
const Kg = "moveFileToTrash";
V.registerCommandAndKeybindingRule({
  id: Kg,
  weight: 200 + si,
  when: f.and(
    et,
    He,
    Un
  ),
  primary: 20,
  mac: {
    primary: 2049,
    secondary: [20]
  },
  handler: iC
});
const tr = "deleteFile";
V.registerCommandAndKeybindingRule({
  id: tr,
  weight: 200 + si,
  when: f.and(et, He),
  primary: 1044,
  mac: {
    primary: 2561
  },
  handler: vu
});
V.registerCommandAndKeybindingRule({
  id: tr,
  weight: 200 + si,
  when: f.and(
    et,
    He,
    Un.toNegated()
  ),
  primary: 20,
  mac: {
    primary: 2049
  },
  handler: vu
});
const Yg = "filesExplorer.cut";
V.registerCommandAndKeybindingRule({
  id: Yg,
  weight: 200 + si,
  when: f.and(et, It.toNegated(), He),
  primary: 2102,
  handler: oC
});
const Og = "filesExplorer.copy";
V.registerCommandAndKeybindingRule({
  id: Og,
  weight: 200 + si,
  when: f.and(et, It.toNegated()),
  primary: 2081,
  handler: sC
});
const Hg = "filesExplorer.paste";
V.registerCommandAndKeybindingRule({
  id: Hg,
  weight: 200 + si,
  when: f.and(et, He),
  primary: 2100,
  handler: nC
});
V.registerCommandAndKeybindingRule({
  id: "filesExplorer.cancelCut",
  weight: 200 + si,
  when: f.and(et, rC),
  primary: 9,
  handler: async (c) => {
    await c.get(ht).setToCopy([], !0);
  }
});
V.registerCommandAndKeybindingRule({
  id: "filesExplorer.openFilePreserveFocus",
  weight: 200 + si,
  when: f.and(et, ct.toNegated()),
  primary: 10,
  handler: aC
});
const Bd = {
  id: Rs,
  title: u("copyPath", "Copy Path")
}, Td = {
  id: Gs,
  title: u("copyRelativePath", "Copy Relative Path")
};
Ld(Rs, Bd.title, ke.IsFileSystemResource, "1_cutcopypaste");
Ld(Gs, Td.title, ke.IsFileSystemResource, "1_cutcopypaste");
Ld(nu, u("revealInSideBar", "Reveal in Explorer View"), ke.IsFileSystemResource, "2_files", 1);
function Ld(c, e, t, i, o) {
  G.appendMenuItem(k.EditorTitleContext, {
    command: { id: c, title: e },
    when: t,
    group: i,
    order: o
  });
}
Pg("workbench.files.action.acceptLocalChanges", u("acceptLocalChanges", "Use your changes and overwrite file contents"), he.check, -10);
Pg("workbench.files.action.revertLocalChanges", u("revertLocalChanges", "Discard your changes and revert to file contents"), he.discard, -9);
function Pg(c, e, t, i, o) {
  G.appendMenuItem(k.EditorTitle, {
    command: { id: c, title: e, icon: t },
    when: f.equals(Lg, !0),
    group: "navigation",
    order: i
  });
}
function gt(c, e, t, i) {
  G.appendMenuItem(k.CommandPalette, {
    command: {
      id: c,
      title: e,
      category: t
    },
    when: i
  });
}
gt(Rs, { value: u("copyPathOfActive", "Copy Path of Active File"), original: "Copy Path of Active File" }, Ce.File);
gt(Gs, { value: u("copyRelativePathOfActive", "Copy Relative Path of Active File"), original: "Copy Relative Path of Active File" }, Ce.File);
gt(sd, { value: wu, original: "Save" }, Ce.File);
gt(au, { value: cC, original: "Save without Formatting" }, Ce.File);
gt(nd, { value: u("saveAllInGroup", "Save All in Group"), original: "Save All in Group" }, Ce.File);
gt(du, { value: u("saveFiles", "Save All Files"), original: "Save All Files" }, Ce.File);
gt(rd, { value: u("revert", "Revert File"), original: "Revert File" }, Ce.File);
gt(id, { value: u("compareActiveWithSaved", "Compare Active File with Saved"), original: "Compare Active File with Saved" }, Ce.File);
gt(cu, { value: fu, original: "Save As..." }, Ce.File);
gt(ku, { value: yu, original: "New File" }, Ce.File, hd.notEqualsTo("0"));
gt(Iu, { value: Su, original: "New Folder" }, Ce.File, hd.notEqualsTo("0"));
gt(ad, { value: pu, original: "New Untitled Text File" }, Ce.File);
const ir = f.or(ke.IsFileSystemResource, ke.Scheme.isEqualTo(q.untitled)), Mg = {
  id: tu,
  title: u("openToSide", "Open to the Side")
};
G.appendMenuItem(k.OpenEditorsContext, {
  group: "navigation",
  order: 10,
  command: Mg,
  when: ir
});
G.appendMenuItem(k.OpenEditorsContext, {
  group: "1_open",
  order: 10,
  command: {
    id: dC,
    title: u("reopenWith", "Reopen Editor With...")
  },
  when: Nh
});
G.appendMenuItem(k.OpenEditorsContext, {
  group: "1_cutcopypaste",
  order: 10,
  command: Bd,
  when: ke.IsFileSystemResource
});
G.appendMenuItem(k.OpenEditorsContext, {
  group: "1_cutcopypaste",
  order: 20,
  command: Td,
  when: ke.IsFileSystemResource
});
G.appendMenuItem(k.OpenEditorsContext, {
  group: "2_save",
  order: 10,
  command: {
    id: sd,
    title: wu,
    precondition: ud
  },
  when: f.or(ke.Scheme.isEqualTo(q.untitled), f.and(xs.toNegated(), Ju.toNegated(), gd.toNegated()))
});
G.appendMenuItem(k.OpenEditorsContext, {
  group: "2_save",
  order: 20,
  command: {
    id: rd,
    title: u("revert", "Revert File"),
    precondition: ud
  },
  when: f.and(xs.toNegated(), Ju.toNegated(), ke.Scheme.notEqualsTo(q.untitled), gd.toNegated())
});
G.appendMenuItem(k.OpenEditorsContext, {
  group: "2_save",
  order: 30,
  command: {
    id: nd,
    title: u("saveAll", "Save All"),
    precondition: lC
  },
  when: xs
});
G.appendMenuItem(k.OpenEditorsContext, {
  group: "3_compare",
  order: 10,
  command: {
    id,
    title: u("compareWithSaved", "Compare with Saved"),
    precondition: ud
  },
  when: f.and(ke.IsFileSystemResource, gd.toNegated(), Xi.toNegated())
});
const zg = {
  id: su,
  title: u("compareWithSelected", "Compare with Selected")
};
G.appendMenuItem(k.OpenEditorsContext, {
  group: "3_compare",
  order: 20,
  command: zg,
  when: f.and(
    ke.HasResource,
    od,
    ir,
    Xi.toNegated()
  )
});
const Ug = {
  id: iu,
  title: u("compareSource", "Select for Compare")
};
G.appendMenuItem(k.OpenEditorsContext, {
  group: "3_compare",
  order: 30,
  command: Ug,
  when: f.and(
    ke.HasResource,
    ir,
    Xi.toNegated()
  )
});
const jg = {
  id: ou,
  title: u("compareSelected", "Compare Selected")
};
G.appendMenuItem(k.OpenEditorsContext, {
  group: "3_compare",
  order: 30,
  command: jg,
  when: f.and(
    ke.HasResource,
    Xi,
    ir
  )
});
G.appendMenuItem(k.OpenEditorsContext, {
  group: "4_close",
  order: 10,
  command: {
    id: zh,
    title: u("close", "Close")
  },
  when: xs.toNegated()
});
G.appendMenuItem(k.OpenEditorsContext, {
  group: "4_close",
  order: 20,
  command: {
    id: hC,
    title: u("closeOthers", "Close Others")
  },
  when: xs.toNegated()
});
G.appendMenuItem(k.OpenEditorsContext, {
  group: "4_close",
  order: 30,
  command: {
    id: uC,
    title: u("closeSaved", "Close Saved")
  }
});
G.appendMenuItem(k.OpenEditorsContext, {
  group: "4_close",
  order: 40,
  command: {
    id: gC,
    title: u("closeAll", "Close All")
  }
});
G.appendMenuItem(k.ExplorerContext, {
  group: "navigation",
  order: 4,
  command: {
    id: ku,
    title: yu,
    precondition: He
  },
  when: ct
});
G.appendMenuItem(k.ExplorerContext, {
  group: "navigation",
  order: 6,
  command: {
    id: Iu,
    title: Su,
    precondition: He
  },
  when: ct
});
G.appendMenuItem(k.ExplorerContext, {
  group: "navigation",
  order: 10,
  command: Mg,
  when: f.and(ct.toNegated(), ke.HasResource)
});
G.appendMenuItem(k.ExplorerContext, {
  group: "navigation",
  order: 20,
  command: {
    id: ru,
    title: u("explorerOpenWith", "Open With...")
  },
  when: f.and(ct.toNegated(), pC)
});
G.appendMenuItem(k.ExplorerContext, {
  group: "3_compare",
  order: 20,
  command: zg,
  when: f.and(ct.toNegated(), ke.HasResource, od, Xi.toNegated())
});
G.appendMenuItem(k.ExplorerContext, {
  group: "3_compare",
  order: 30,
  command: Ug,
  when: f.and(ct.toNegated(), ke.HasResource, Xi.toNegated())
});
G.appendMenuItem(k.ExplorerContext, {
  group: "3_compare",
  order: 30,
  command: jg,
  when: f.and(ct.toNegated(), ke.HasResource, Xi)
});
G.appendMenuItem(k.ExplorerContext, {
  group: "5_cutcopypaste",
  order: 8,
  command: {
    id: Yg,
    title: u("cut", "Cut")
  },
  when: f.and(It.toNegated(), He)
});
G.appendMenuItem(k.ExplorerContext, {
  group: "5_cutcopypaste",
  order: 10,
  command: {
    id: Og,
    title: mC
  },
  when: It.toNegated()
});
G.appendMenuItem(k.ExplorerContext, {
  group: "5_cutcopypaste",
  order: 20,
  command: {
    id: Hg,
    title: bC,
    precondition: f.and(He, CC)
  },
  when: ct
});
G.appendMenuItem(k.ExplorerContext, {
  group: "5b_importexport",
  order: 10,
  command: {
    id: fC,
    title: vC
  },
  when: f.or(f.and(Ho.toNegated(), ke.Scheme.notEqualsTo(q.file)), f.and(Ho, ct.toNegated(), It.toNegated()), f.and(Ho, wC))
});
G.appendMenuItem(k.ExplorerContext, {
  group: "5b_importexport",
  order: 20,
  command: {
    id: yC,
    title: kC
  },
  when: f.and(
    Ho,
    ct,
    He
  )
});
G.appendMenuItem(k.ExplorerContext, {
  group: "6_copypath",
  order: 10,
  command: Bd,
  when: ke.IsFileSystemResource
});
G.appendMenuItem(k.ExplorerContext, {
  group: "6_copypath",
  order: 20,
  command: Td,
  when: ke.IsFileSystemResource
});
G.appendMenuItem(k.ExplorerContext, {
  group: "2_workspace",
  order: 10,
  command: {
    id: SC,
    title: IC
  },
  when: f.and(It, f.or(Vu, Zu.isEqualTo("workspace")))
});
G.appendMenuItem(k.ExplorerContext, {
  group: "2_workspace",
  order: 30,
  command: {
    id: hu,
    title: JC
  },
  when: f.and(It, ct, f.and(hd.notEqualsTo("0"), f.or(Vu, Zu.isEqualTo("workspace"))))
});
G.appendMenuItem(k.ExplorerContext, {
  group: "7_modification",
  order: 10,
  command: {
    id: Xg,
    title: VC,
    precondition: He
  },
  when: It.toNegated()
});
G.appendMenuItem(k.ExplorerContext, {
  group: "7_modification",
  order: 20,
  command: {
    id: Kg,
    title: ZC,
    precondition: He
  },
  alt: {
    id: tr,
    title: u("deleteFile", "Delete Permanently"),
    precondition: He
  },
  when: f.and(It.toNegated(), Un)
});
G.appendMenuItem(k.ExplorerContext, {
  group: "7_modification",
  order: 20,
  command: {
    id: tr,
    title: u("deleteFile", "Delete Permanently"),
    precondition: He
  },
  when: f.and(It.toNegated(), Un.toNegated())
});
for (const c of [k.EmptyEditorGroupContext, k.EditorTabsBarContext])
  G.appendMenuItem(c, { command: { id: ad, title: u("newFile", "New Text File") }, group: "1_file", order: 10 }), G.appendMenuItem(c, { command: { id: "workbench.action.quickOpen", title: u("openFile", "Open File...") }, group: "1_file", order: 20 });
G.appendMenuItem(k.MenubarGoMenu, {
  group: "3_global_nav",
  command: {
    id: "workbench.action.quickOpen",
    title: u(
      { key: "miGotoFile", comment: ["&& denotes a mnemonic"] },
      "Go to &&File..."
    )
  },
  order: 1
});
var xy = ".monaco-workbench .call-hierarchy .message,.monaco-workbench .call-hierarchy .results{display:none}.monaco-workbench .call-hierarchy[data-state=data] .results{display:inherit;height:100%}.monaco-workbench .call-hierarchy[data-state=message] .message{align-items:center;display:flex;height:100%;justify-content:center}.monaco-workbench .call-hierarchy .editor,.monaco-workbench .call-hierarchy .tree{height:100%}.monaco-editor .call-hierarchy .tree{background-color:var(--vscode-peekViewResult-background);color:var(--vscode-peekViewResult-fileForeground)}.monaco-workbench .call-hierarchy .tree .callhierarchy-element{align-items:center;display:flex;flex:1;flex-flow:row nowrap}.monaco-workbench .call-hierarchy .tree .callhierarchy-element .monaco-icon-label{padding-left:4px}.monaco-editor .call-hierarchy .tree .monaco-list:focus .monaco-list-rows>.monaco-list-row.selected:not(.highlighted){background-color:var(--vscode-peekViewResult-selectionBackground);color:var(--vscode-peekViewResult-selectionForeground)!important}.monaco-editor .call-hierarchy .call-decoration{background-color:var(--vscode-peekViewEditor-matchHighlightBackground);border:2px solid var(--vscode-peekViewEditor-matchHighlightBorder);box-sizing:border-box}.monaco-editor .call-hierarchy .editor .monaco-editor .inputarea.ime-input,.monaco-editor .call-hierarchy .editor .monaco-editor .monaco-editor-background{background-color:var(--vscode-peekViewEditor-background)}.monaco-editor .call-hierarchy .editor .monaco-editor .margin{background-color:var(--vscode-peekViewEditorGutter-background)}";
oe(xy, {});
class qs {
  constructor(e, t, i, o) {
    this.item = e, this.locations = t, this.model = i, this.parent = o;
  }
  static compare(e, t) {
    let i = _u(e.item.uri.toString(), t.item.uri.toString());
    return i === 0 && (i = Fe.compareRangesUsingStarts(e.item.range, t.item.range)), i;
  }
}
let Dy = class {
  constructor(e) {
    this.getDirection = e;
  }
  hasChildren() {
    return !0;
  }
  async getChildren(e) {
    if (e instanceof Wu)
      return e.roots.map((o) => new qs(o, void 0, e, void 0));
    const { model: t, item: i } = e;
    return this.getDirection() === "outgoingCalls" ? (await t.resolveOutgoingCalls(i, Ni.None)).map((o) => new qs(o.to, o.fromRanges.map((s) => ({ range: s, uri: i.uri })), t, e)) : (await t.resolveIncomingCalls(i, Ni.None)).map((o) => new qs(o.from, o.fromRanges.map((s) => ({ range: s, uri: o.from.uri })), t, e));
  }
}, Ny = class {
  compare(e, t) {
    return qs.compare(e, t);
  }
}, Qy = class {
  constructor(e) {
    this.getDirection = e;
  }
  getId(e) {
    let t = this.getDirection() + JSON.stringify(e.item.uri) + JSON.stringify(e.item.range);
    return e.parent && (t += this.getId(e.parent)), t;
  }
};
class Ay {
  constructor(e, t) {
    this.icon = e, this.label = t;
  }
}
const xn = class xn {
  constructor() {
    this.templateId = xn.id;
  }
  renderTemplate(e) {
    e.classList.add("callhierarchy-element");
    const t = document.createElement("div");
    e.appendChild(t);
    const i = new pd(e, { supportHighlights: !0 });
    return new Ay(t, i);
  }
  renderElement(e, t, i) {
    var r;
    const { element: o, filterData: s } = e, n = (r = o.item.tags) == null ? void 0 : r.includes(1);
    i.icon.className = "", i.icon.classList.add("inline", ...pe.asClassNameArray(md.toIcon(o.item.kind))), i.label.setLabel(o.item.name, o.item.detail, { labelEscapeNewLines: !0, matches: Di(s), strikethrough: n });
  }
  disposeTemplate(e) {
    e.label.dispose();
  }
};
xn.id = "CallRenderer";
let wn = xn, By = class {
  getHeight(e) {
    return 22;
  }
  getTemplateId(e) {
    return wn.id;
  }
}, Ty = class {
  constructor(e) {
    this.getDirection = e;
  }
  getWidgetAriaLabel() {
    return u("tree.aria", "Call Hierarchy");
  }
  getAriaLabel(e) {
    return this.getDirection() === "outgoingCalls" ? u("from", "calls from {0}", e.item.name) : u("to", "callers of {0}", e.item.name);
  }
}, jl = class {
  static store(e, t) {
    t.store("callHierarchyPeekLayout", JSON.stringify(e), 0, 1);
  }
  static retrieve(e) {
    const t = e.get("callHierarchyPeekLayout", 0, "{}"), i = { ratio: 0.7, height: 17 };
    try {
      return { ...i, ...JSON.parse(t) };
    } catch {
      return i;
    }
  }
  constructor(e, t) {
    this.ratio = e, this.height = t;
  }
};
class Ly extends Vs {
}
var So;
let mo = (So = class extends Eu {
  constructor(e, t, i, o, s, n, r, a, d, h, g) {
    super(e, { showFrame: !0, showArrow: !0, isResizeable: !0, isAccessible: !0 }, g), this._where = t, this._direction = i, this._peekViewService = s, this._editorService = n, this._textModelService = r, this._storageService = a, this._menuService = d, this._contextKeyService = h, this._instantiationService = g, this._treeViewStates = /* @__PURE__ */ new Map(), this._previewDisposable = new Z(), this.create(), this._peekViewService.addExclusiveWidget(e, this), this._applyTheme(o.getColorTheme()), this._disposables.add(o.onDidColorThemeChange(this._applyTheme, this)), this._disposables.add(this._previewDisposable);
  }
  dispose() {
    jl.store(this._layoutInfo, this._storageService), this._splitView.dispose(), this._tree.dispose(), this._editor.dispose(), super.dispose();
  }
  get direction() {
    return this._direction;
  }
  _applyTheme(e) {
    const t = e.getColor(Ru) || mi.transparent;
    this.style({
      arrowColor: t,
      frameColor: t,
      headerBackgroundColor: e.getColor(Gu) || mi.transparent,
      primaryHeadingColor: e.getColor(xu),
      secondaryHeadingColor: e.getColor(Du)
    });
  }
  _fillHead(e) {
    super._fillHead(e, !0);
    const t = this._menuService.createMenu(So.TitleMenu, this._contextKeyService), i = () => {
      const o = [];
      ks(t, void 0, o), this._actionbarWidget.clear(), this._actionbarWidget.push(o, { label: !1, icon: !0 });
    };
    this._disposables.add(t), this._disposables.add(t.onDidChange(i)), i();
  }
  _fillBody(e) {
    this._layoutInfo = jl.retrieve(this._storageService), this._dim = new H(0, 0), this._parent = e, e.classList.add("call-hierarchy");
    const t = document.createElement("div");
    t.classList.add("message"), e.appendChild(t), this._message = t, this._message.tabIndex = 0;
    const i = document.createElement("div");
    i.classList.add("results"), e.appendChild(i), this._splitView = new ss(i, { orientation: 1 });
    const o = document.createElement("div");
    o.classList.add("editor"), i.appendChild(o);
    const s = {
      scrollBeyondLastLine: !1,
      scrollbar: {
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: !0,
        verticalHasArrows: !1,
        horizontalHasArrows: !1,
        alwaysConsumeMouseWheel: !1
      },
      overviewRulerLanes: 2,
      fixedOverflowWidgets: !0,
      minimap: {
        enabled: !1
      }
    };
    this._editor = this._instantiationService.createInstance(cd, o, s, {}, this.editor);
    const n = document.createElement("div");
    n.classList.add("tree"), i.appendChild(n);
    const r = {
      sorter: new Ny(),
      accessibilityProvider: new Ty(() => this._direction),
      identityProvider: new Qy(() => this._direction),
      expandOnlyOnTwistieClick: !0,
      overrideStyles: {
        listBackground: Tu
      }
    };
    this._tree = this._instantiationService.createInstance(Ly, "CallHierarchyPeek", n, new By(), [this._instantiationService.createInstance(wn)], this._instantiationService.createInstance(Dy, () => this._direction), r), this._splitView.addView({
      onDidChange: _.None,
      element: o,
      minimumSize: 200,
      maximumSize: Number.MAX_VALUE,
      layout: (a) => {
        this._dim.height && this._editor.layout({ height: this._dim.height, width: a });
      }
    }, st.Distribute), this._splitView.addView({
      onDidChange: _.None,
      element: n,
      minimumSize: 100,
      maximumSize: Number.MAX_VALUE,
      layout: (a) => {
        this._dim.height && this._tree.layout(this._dim.height, a);
      }
    }, st.Distribute), this._disposables.add(this._splitView.onDidSashChange(() => {
      this._dim.width && (this._layoutInfo.ratio = this._splitView.getViewSize(0) / this._dim.width);
    })), this._disposables.add(this._tree.onDidChangeFocus(this._updatePreview, this)), this._disposables.add(this._editor.onMouseDown((a) => {
      const { event: d, target: h } = a;
      if (d.detail !== 2)
        return;
      const [g] = this._tree.getFocus();
      g && (this.dispose(), this._editorService.openEditor({
        resource: g.item.uri,
        options: { selection: h.range }
      }));
    })), this._disposables.add(this._tree.onMouseDblClick((a) => {
      a.target !== Nu.Twistie && a.element && (this.dispose(), this._editorService.openEditor({
        resource: a.element.item.uri,
        options: { selection: a.element.item.selectionRange, pinned: !0 }
      }));
    })), this._disposables.add(this._tree.onDidChangeSelection((a) => {
      const [d] = a.elements;
      d && a.browserEvent instanceof KeyboardEvent && (this.dispose(), this._editorService.openEditor({
        resource: d.item.uri,
        options: { selection: d.item.selectionRange, pinned: !0 }
      }));
    }));
  }
  async _updatePreview() {
    const [e] = this._tree.getFocus();
    if (!e)
      return;
    this._previewDisposable.clear();
    const t = {
      description: "call-hierarchy-decoration",
      stickiness: 1,
      className: "call-decoration",
      overviewRuler: {
        color: Oi(Qu),
        position: Au.Center
      }
    };
    let i;
    this._direction === "outgoingCalls" ? i = e.parent ? e.parent.item.uri : e.model.root.uri : i = e.item.uri;
    const o = await this._textModelService.createModelReference(i);
    this._editor.setModel(o.object.textEditorModel);
    const s = [];
    let n, r = e.locations;
    r || (r = [{ uri: e.item.uri, range: e.item.selectionRange }]);
    for (const d of r)
      d.uri.toString() === i.toString() && (s.push({ range: d.range, options: t }), n = n ? Fe.plusRange(d.range, n) : d.range);
    if (n) {
      this._editor.revealRangeInCenter(n, 1);
      const d = this._editor.createDecorationsCollection(s);
      this._previewDisposable.add(M(() => d.clear()));
    }
    this._previewDisposable.add(o);
    const a = this._direction === "outgoingCalls" ? u("callFrom", "Calls from '{0}'", e.model.root.name) : u("callsTo", "Callers of '{0}'", e.model.root.name);
    this.setTitle(a);
  }
  showLoading() {
    this._parent.dataset.state = "loading", this.setTitle(u("title.loading", "Loading...")), this._show();
  }
  showMessage(e) {
    this._parent.dataset.state = "message", this.setTitle(""), this.setMetaTitle(""), this._message.innerText = e, this._show(), this._message.focus();
  }
  async showModel(e) {
    this._show();
    const t = this._treeViewStates.get(this._direction);
    await this._tree.setInput(e, t);
    const i = this._tree.getNode(e).children[0];
    await this._tree.expand(i.element), i.children.length === 0 ? this.showMessage(this._direction === "outgoingCalls" ? u("empt.callsFrom", "No calls from '{0}'", e.root.name) : u("empt.callsTo", "No callers of '{0}'", e.root.name)) : (this._parent.dataset.state = "data", (!t || this._tree.getFocus().length === 0) && this._tree.setFocus([i.children[0].element]), this._tree.domFocus(), this._updatePreview());
  }
  getModel() {
    return this._tree.getInput();
  }
  getFocused() {
    return this._tree.getFocus()[0];
  }
  async updateDirection(e) {
    const t = this._tree.getInput();
    t && e !== this._direction && (this._treeViewStates.set(this._direction, this._tree.getViewState()), this._direction = e, await this.showModel(t));
  }
  _show() {
    this._isShowing || (this.editor.revealLineInCenterIfOutsideViewport(this._where.lineNumber, 0), super.show(Fe.fromPositions(this._where), this._layoutInfo.height));
  }
  _onWidth(e) {
    this._dim && this._doLayoutBody(this._dim.height, e);
  }
  _doLayoutBody(e, t) {
    (this._dim.height !== e || this._dim.width !== t) && (super._doLayoutBody(e, t), this._dim = new H(t, e), this._layoutInfo.height = this._viewZone ? this._viewZone.heightInLines : this._layoutInfo.height, this._splitView.layout(t), this._splitView.resizeView(0, t * this._layoutInfo.ratio));
  }
}, So.TitleMenu = new k("callhierarchy/title"), So);
mo = y([
  l(3, z),
  l(4, Bu),
  l(5, D),
  l(6, Do),
  l(7, ee),
  l(8, lt),
  l(9, F),
  l(10, W)
], mo);
const Ba = new K("editorHasCallHierarchyProvider", !1, u(
  "editorHasCallHierarchyProvider",
  "Whether a call hierarchy provider is available"
)), Ts = new K("callHierarchyVisible", !1, u("callHierarchyVisible", "Whether call hierarchy peek is currently showing")), ls = new K(
  "callHierarchyDirection",
  void 0,
  { type: "string", description: u(
    "callHierarchyDirection",
    "Whether call hierarchy shows incoming or outgoing calls"
  ) }
);
function Fy(c) {
  return c === "outgoingCalls" || c === "incomingCalls" ? c : "incomingCalls";
}
var Wt;
let qt = (Wt = class {
  static get(e) {
    return e.getContribution(Wt.Id);
  }
  constructor(e, t, i, o, s) {
    this._editor = e, this._contextKeyService = t, this._storageService = i, this._editorService = o, this._instantiationService = s, this._dispoables = new Z(), this._sessionDisposables = new Z(), this._ctxIsVisible = Ts.bindTo(this._contextKeyService), this._ctxHasProvider = Ba.bindTo(this._contextKeyService), this._ctxDirection = ls.bindTo(this._contextKeyService), this._dispoables.add(_.any(e.onDidChangeModel, e.onDidChangeModelLanguage, hr.onDidChange)(() => {
      this._ctxHasProvider.set(e.hasModel() && hr.has(e.getModel()));
    })), this._dispoables.add(this._sessionDisposables);
  }
  dispose() {
    this._ctxHasProvider.reset(), this._ctxIsVisible.reset(), this._dispoables.dispose();
  }
  async startCallHierarchyFromEditor() {
    if (this._sessionDisposables.clear(), !this._editor.hasModel())
      return;
    const e = this._editor.getModel(), t = this._editor.getPosition();
    if (!hr.has(e))
      return;
    const i = new $e(), o = Wu.create(e, t, i.token), s = Fy(this._storageService.get(Wt._StorageDirection, 0, "incomingCalls"));
    this._showCallHierarchyWidget(t, s, o, i);
  }
  async startCallHierarchyFromCallHierarchy() {
    var s;
    if (!this._widget)
      return;
    const e = this._widget.getModel(), t = this._widget.getFocused();
    if (!t || !e)
      return;
    const i = await this._editorService.openCodeEditor({ resource: t.item.uri }, this._editor);
    if (!i)
      return;
    const o = e.fork(t.item);
    this._sessionDisposables.clear(), (s = Wt.get(i)) == null || s._showCallHierarchyWidget(Fe.lift(o.root.selectionRange).getStartPosition(), this._widget.direction, Promise.resolve(o), new $e());
  }
  _showCallHierarchyWidget(e, t, i, o) {
    this._ctxIsVisible.set(!0), this._ctxDirection.set(t), _.any(this._editor.onDidChangeModel, this._editor.onDidChangeModelLanguage)(this.endCallHierarchy, this, this._sessionDisposables), this._widget = this._instantiationService.createInstance(mo, this._editor, e, t), this._widget.showLoading(), this._sessionDisposables.add(this._widget.onDidClose(() => {
      this.endCallHierarchy(), this._storageService.store(Wt._StorageDirection, this._widget.direction, 0, 0);
    })), this._sessionDisposables.add({ dispose() {
      o.dispose(!0);
    } }), this._sessionDisposables.add(this._widget), i.then((s) => {
      o.token.isCancellationRequested || (s ? (this._sessionDisposables.add(s), this._widget.showModel(s)) : this._widget.showMessage(u("no.item", "No results")));
    }).catch((s) => {
      if (Qi(s)) {
        this.endCallHierarchy();
        return;
      }
      this._widget.showMessage(u("error", "Failed to show call hierarchy"));
    });
  }
  showOutgoingCalls() {
    var e;
    (e = this._widget) == null || e.updateDirection("outgoingCalls"), this._ctxDirection.set("outgoingCalls");
  }
  showIncomingCalls() {
    var e;
    (e = this._widget) == null || e.updateDirection("incomingCalls"), this._ctxDirection.set("incomingCalls");
  }
  endCallHierarchy() {
    this._sessionDisposables.clear(), this._ctxIsVisible.set(!1), this._editor.focus();
  }
}, Wt.Id = "callHierarchy", Wt._StorageDirection = "callHierarchy/defaultDirection", Wt);
qt = y([
  l(1, F),
  l(2, ee),
  l(3, No),
  l(4, W)
], qt);
Lu(qt.Id, qt, 0);
P(class extends Kt {
  constructor() {
    super({
      id: "editor.showCallHierarchy",
      title: { value: u("title", "Peek Call Hierarchy"), original: "Peek Call Hierarchy" },
      menu: {
        id: k.EditorContextPeek,
        group: "navigation",
        order: 1e3,
        when: f.and(Ba, cn.notInPeekEditor)
      },
      keybinding: {
        when: Fi.editorTextFocus,
        weight: 200,
        primary: 1024 + 512 + 38
      },
      precondition: f.and(Ba, cn.notInPeekEditor)
    });
  }
  async runEditorCommand(c, e) {
    var t;
    return (t = qt.get(e)) == null ? void 0 : t.startCallHierarchyFromEditor();
  }
});
P(class extends Kt {
  constructor() {
    super({
      id: "editor.showIncomingCalls",
      title: { value: u("title.incoming", "Show Incoming Calls"), original: "Show Incoming Calls" },
      icon: lo("callhierarchy-incoming", he.callIncoming, u(
        "showIncomingCallsIcons",
        "Icon for incoming calls in the call hierarchy view."
      )),
      precondition: f.and(Ts, ls.isEqualTo("outgoingCalls")),
      keybinding: {
        weight: 200,
        primary: 1024 + 512 + 38
      },
      menu: {
        id: mo.TitleMenu,
        when: ls.isEqualTo("outgoingCalls"),
        order: 1
      }
    });
  }
  runEditorCommand(c, e) {
    var t;
    return (t = qt.get(e)) == null ? void 0 : t.showIncomingCalls();
  }
});
P(class extends Kt {
  constructor() {
    super({
      id: "editor.showOutgoingCalls",
      title: { value: u("title.outgoing", "Show Outgoing Calls"), original: "Show Outgoing Calls" },
      icon: lo("callhierarchy-outgoing", he.callOutgoing, u(
        "showOutgoingCallsIcon",
        "Icon for outgoing calls in the call hierarchy view."
      )),
      precondition: f.and(Ts, ls.isEqualTo("incomingCalls")),
      keybinding: {
        weight: 200,
        primary: 1024 + 512 + 38
      },
      menu: {
        id: mo.TitleMenu,
        when: ls.isEqualTo("incomingCalls"),
        order: 1
      }
    });
  }
  runEditorCommand(c, e) {
    var t;
    return (t = qt.get(e)) == null ? void 0 : t.showOutgoingCalls();
  }
});
P(class extends Kt {
  constructor() {
    super({
      id: "editor.refocusCallHierarchy",
      title: { value: u("title.refocus", "Refocus Call Hierarchy"), original: "Refocus Call Hierarchy" },
      precondition: Ts,
      keybinding: {
        weight: 200,
        primary: 1024 + 3
      }
    });
  }
  async runEditorCommand(c, e) {
    var t;
    return (t = qt.get(e)) == null ? void 0 : t.startCallHierarchyFromCallHierarchy();
  }
});
P(class extends Kt {
  constructor() {
    super({
      id: "editor.closeCallHierarchy",
      title: u("close", "Close"),
      icon: he.close,
      precondition: Ts,
      keybinding: {
        weight: 200 + 10,
        primary: 9,
        when: f.not("config.editor.stablePeek")
      },
      menu: {
        id: mo.TitleMenu,
        order: 1e3
      }
    });
  }
  runEditorCommand(c, e) {
    var t;
    return (t = qt.get(e)) == null ? void 0 : t.endCallHierarchy();
  }
});
var Xy = ".monaco-workbench .type-hierarchy .message,.monaco-workbench .type-hierarchy .results{display:none}.monaco-workbench .type-hierarchy[data-state=data] .results{display:inherit;height:100%}.monaco-workbench .type-hierarchy[data-state=message] .message{align-items:center;display:flex;height:100%;justify-content:center}.monaco-workbench .type-hierarchy .editor,.monaco-workbench .type-hierarchy .tree{height:100%}.monaco-editor .type-hierarchy .tree{background-color:var(--vscode-peekViewResult-background);color:var(--vscode-peekViewResult-fileForeground)}.monaco-editor .type-hierarchy .tree .monaco-list:focus .monaco-list-rows>.monaco-list-row.selected:not(.highlighted){background-color:var(--vscode-peekViewResult-selectionBackground);color:var(--vscode-peekViewResult-selectionForeground)!important}.monaco-workbench .type-hierarchy .tree .typehierarchy-element{align-items:center;display:flex;flex:1;flex-flow:row nowrap}.monaco-workbench .type-hierarchy .tree .typehierarchy-element .monaco-icon-label{padding-left:4px}.monaco-editor .type-hierarchy .type-decoration{background-color:var(--vscode-peekViewEditor-matchHighlightBackground);border:2px solid var(--vscode-peekViewEditor-matchHighlightBorder);box-sizing:border-box}.monaco-editor .type-hierarchy .editor .monaco-editor .inputarea.ime-input,.monaco-editor .type-hierarchy .editor .monaco-editor .monaco-editor-background{background-color:var(--vscode-peekViewEditor-background)}.monaco-editor .type-hierarchy .editor .monaco-editor .margin{background-color:var(--vscode-peekViewEditorGutter-background)}";
oe(Xy, {});
class $s {
  constructor(e, t, i) {
    this.item = e, this.model = t, this.parent = i;
  }
  static compare(e, t) {
    let i = _u(e.item.uri.toString(), t.item.uri.toString());
    return i === 0 && (i = Fe.compareRangesUsingStarts(e.item.range, t.item.range)), i;
  }
}
class Ky {
  constructor(e) {
    this.getDirection = e;
  }
  hasChildren() {
    return !0;
  }
  async getChildren(e) {
    if (e instanceof Fu)
      return e.roots.map((o) => new $s(o, e, void 0));
    const { model: t, item: i } = e;
    return this.getDirection() === "supertypes" ? (await t.provideSupertypes(i, Ni.None)).map((o) => new $s(o, t, e)) : (await t.provideSubtypes(i, Ni.None)).map((o) => new $s(o, t, e));
  }
}
class Yy {
  compare(e, t) {
    return $s.compare(e, t);
  }
}
class Oy {
  constructor(e) {
    this.getDirection = e;
  }
  getId(e) {
    let t = this.getDirection() + JSON.stringify(e.item.uri) + JSON.stringify(e.item.range);
    return e.parent && (t += this.getId(e.parent)), t;
  }
}
class Hy {
  constructor(e, t) {
    this.icon = e, this.label = t;
  }
}
const Dn = class Dn {
  constructor() {
    this.templateId = Dn.id;
  }
  renderTemplate(e) {
    e.classList.add("typehierarchy-element");
    const t = document.createElement("div");
    e.appendChild(t);
    const i = new pd(e, { supportHighlights: !0 });
    return new Hy(t, i);
  }
  renderElement(e, t, i) {
    var r;
    const { element: o, filterData: s } = e, n = (r = o.item.tags) == null ? void 0 : r.includes(1);
    i.icon.classList.add("inline", ...pe.asClassNameArray(md.toIcon(o.item.kind))), i.label.setLabel(o.item.name, o.item.detail, { labelEscapeNewLines: !0, matches: Di(s), strikethrough: n });
  }
  disposeTemplate(e) {
    e.label.dispose();
  }
};
Dn.id = "TypeRenderer";
let yn = Dn;
class Py {
  getHeight(e) {
    return 22;
  }
  getTemplateId(e) {
    return yn.id;
  }
}
class My {
  constructor(e) {
    this.getDirection = e;
  }
  getWidgetAriaLabel() {
    return u("tree.aria", "Type Hierarchy");
  }
  getAriaLabel(e) {
    return this.getDirection() === "supertypes" ? u("supertypes", "supertypes of {0}", e.item.name) : u("subtypes", "subtypes of {0}", e.item.name);
  }
}
class ql {
  static store(e, t) {
    t.store("typeHierarchyPeekLayout", JSON.stringify(e), 0, 1);
  }
  static retrieve(e) {
    const t = e.get("typeHierarchyPeekLayout", 0, "{}"), i = { ratio: 0.7, height: 17 };
    try {
      return { ...i, ...JSON.parse(t) };
    } catch {
      return i;
    }
  }
  constructor(e, t) {
    this.ratio = e, this.height = t;
  }
}
class zy extends Vs {
}
var Io;
let bo = (Io = class extends Eu {
  constructor(e, t, i, o, s, n, r, a, d, h, g) {
    super(e, { showFrame: !0, showArrow: !0, isResizeable: !0, isAccessible: !0 }, g), this._where = t, this._direction = i, this._peekViewService = s, this._editorService = n, this._textModelService = r, this._storageService = a, this._menuService = d, this._contextKeyService = h, this._instantiationService = g, this._treeViewStates = /* @__PURE__ */ new Map(), this._previewDisposable = new Z(), this.create(), this._peekViewService.addExclusiveWidget(e, this), this._applyTheme(o.getColorTheme()), this._disposables.add(o.onDidColorThemeChange(this._applyTheme, this)), this._disposables.add(this._previewDisposable);
  }
  dispose() {
    ql.store(this._layoutInfo, this._storageService), this._splitView.dispose(), this._tree.dispose(), this._editor.dispose(), super.dispose();
  }
  get direction() {
    return this._direction;
  }
  _applyTheme(e) {
    const t = e.getColor(Ru) || mi.transparent;
    this.style({
      arrowColor: t,
      frameColor: t,
      headerBackgroundColor: e.getColor(Gu) || mi.transparent,
      primaryHeadingColor: e.getColor(xu),
      secondaryHeadingColor: e.getColor(Du)
    });
  }
  _fillHead(e) {
    super._fillHead(e, !0);
    const t = this._menuService.createMenu(Io.TitleMenu, this._contextKeyService), i = () => {
      const o = [];
      ks(t, void 0, o), this._actionbarWidget.clear(), this._actionbarWidget.push(o, { label: !1, icon: !0 });
    };
    this._disposables.add(t), this._disposables.add(t.onDidChange(i)), i();
  }
  _fillBody(e) {
    this._layoutInfo = ql.retrieve(this._storageService), this._dim = new H(0, 0), this._parent = e, e.classList.add("type-hierarchy");
    const t = document.createElement("div");
    t.classList.add("message"), e.appendChild(t), this._message = t, this._message.tabIndex = 0;
    const i = document.createElement("div");
    i.classList.add("results"), e.appendChild(i), this._splitView = new ss(i, { orientation: 1 });
    const o = document.createElement("div");
    o.classList.add("editor"), i.appendChild(o);
    const s = {
      scrollBeyondLastLine: !1,
      scrollbar: {
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: !0,
        verticalHasArrows: !1,
        horizontalHasArrows: !1,
        alwaysConsumeMouseWheel: !1
      },
      overviewRulerLanes: 2,
      fixedOverflowWidgets: !0,
      minimap: {
        enabled: !1
      }
    };
    this._editor = this._instantiationService.createInstance(cd, o, s, {}, this.editor);
    const n = document.createElement("div");
    n.classList.add("tree"), i.appendChild(n);
    const r = {
      sorter: new Yy(),
      accessibilityProvider: new My(() => this._direction),
      identityProvider: new Oy(() => this._direction),
      expandOnlyOnTwistieClick: !0,
      overrideStyles: {
        listBackground: Tu
      }
    };
    this._tree = this._instantiationService.createInstance(zy, "TypeHierarchyPeek", n, new Py(), [this._instantiationService.createInstance(yn)], this._instantiationService.createInstance(Ky, () => this._direction), r), this._splitView.addView({
      onDidChange: _.None,
      element: o,
      minimumSize: 200,
      maximumSize: Number.MAX_VALUE,
      layout: (a) => {
        this._dim.height && this._editor.layout({ height: this._dim.height, width: a });
      }
    }, st.Distribute), this._splitView.addView({
      onDidChange: _.None,
      element: n,
      minimumSize: 100,
      maximumSize: Number.MAX_VALUE,
      layout: (a) => {
        this._dim.height && this._tree.layout(this._dim.height, a);
      }
    }, st.Distribute), this._disposables.add(this._splitView.onDidSashChange(() => {
      this._dim.width && (this._layoutInfo.ratio = this._splitView.getViewSize(0) / this._dim.width);
    })), this._disposables.add(this._tree.onDidChangeFocus(this._updatePreview, this)), this._disposables.add(this._editor.onMouseDown((a) => {
      const { event: d, target: h } = a;
      if (d.detail !== 2)
        return;
      const [g] = this._tree.getFocus();
      g && (this.dispose(), this._editorService.openEditor({
        resource: g.item.uri,
        options: { selection: h.range }
      }));
    })), this._disposables.add(this._tree.onMouseDblClick((a) => {
      a.target !== Nu.Twistie && a.element && (this.dispose(), this._editorService.openEditor({
        resource: a.element.item.uri,
        options: { selection: a.element.item.selectionRange, pinned: !0 }
      }));
    })), this._disposables.add(this._tree.onDidChangeSelection((a) => {
      const [d] = a.elements;
      d && a.browserEvent instanceof KeyboardEvent && (this.dispose(), this._editorService.openEditor({
        resource: d.item.uri,
        options: { selection: d.item.selectionRange, pinned: !0 }
      }));
    }));
  }
  async _updatePreview() {
    const [e] = this._tree.getFocus();
    if (!e)
      return;
    this._previewDisposable.clear();
    const t = {
      description: "type-hierarchy-decoration",
      stickiness: 1,
      className: "type-decoration",
      overviewRuler: {
        color: Oi(Qu),
        position: Au.Center
      }
    };
    let i;
    this._direction === "supertypes" ? i = e.parent ? e.parent.item.uri : e.model.root.uri : i = e.item.uri;
    const o = await this._textModelService.createModelReference(i);
    this._editor.setModel(o.object.textEditorModel);
    const s = [];
    let n;
    const r = { uri: e.item.uri, range: e.item.selectionRange };
    if (r.uri.toString() === i.toString() && (s.push({ range: r.range, options: t }), n = n ? Fe.plusRange(r.range, n) : r.range), n) {
      this._editor.revealRangeInCenter(n, 1);
      const d = this._editor.createDecorationsCollection(s);
      this._previewDisposable.add(M(() => d.clear()));
    }
    this._previewDisposable.add(o);
    const a = this._direction === "supertypes" ? u("supertypes", "Supertypes of '{0}'", e.model.root.name) : u("subtypes", "Subtypes of '{0}'", e.model.root.name);
    this.setTitle(a);
  }
  showLoading() {
    this._parent.dataset.state = "loading", this.setTitle(u("title.loading", "Loading...")), this._show();
  }
  showMessage(e) {
    this._parent.dataset.state = "message", this.setTitle(""), this.setMetaTitle(""), this._message.innerText = e, this._show(), this._message.focus();
  }
  async showModel(e) {
    this._show();
    const t = this._treeViewStates.get(this._direction);
    await this._tree.setInput(e, t);
    const i = this._tree.getNode(e).children[0];
    await this._tree.expand(i.element), i.children.length === 0 ? this.showMessage(this._direction === "supertypes" ? u("empt.supertypes", "No supertypes of '{0}'", e.root.name) : u("empt.subtypes", "No subtypes of '{0}'", e.root.name)) : (this._parent.dataset.state = "data", (!t || this._tree.getFocus().length === 0) && this._tree.setFocus([i.children[0].element]), this._tree.domFocus(), this._updatePreview());
  }
  getModel() {
    return this._tree.getInput();
  }
  getFocused() {
    return this._tree.getFocus()[0];
  }
  async updateDirection(e) {
    const t = this._tree.getInput();
    t && e !== this._direction && (this._treeViewStates.set(this._direction, this._tree.getViewState()), this._direction = e, await this.showModel(t));
  }
  _show() {
    this._isShowing || (this.editor.revealLineInCenterIfOutsideViewport(this._where.lineNumber, 0), super.show(Fe.fromPositions(this._where), this._layoutInfo.height));
  }
  _onWidth(e) {
    this._dim && this._doLayoutBody(this._dim.height, e);
  }
  _doLayoutBody(e, t) {
    (this._dim.height !== e || this._dim.width !== t) && (super._doLayoutBody(e, t), this._dim = new H(t, e), this._layoutInfo.height = this._viewZone ? this._viewZone.heightInLines : this._layoutInfo.height, this._splitView.layout(t), this._splitView.resizeView(0, t * this._layoutInfo.ratio));
  }
}, Io.TitleMenu = new k("typehierarchy/title"), Io);
bo = y([
  l(3, z),
  l(4, Bu),
  l(5, D),
  l(6, Do),
  l(7, ee),
  l(8, lt),
  l(9, F),
  l(10, W)
], bo);
const Ta = new K("editorHasTypeHierarchyProvider", !1, u(
  "editorHasTypeHierarchyProvider",
  "Whether a type hierarchy provider is available"
)), Ls = new K("typeHierarchyVisible", !1, u("typeHierarchyVisible", "Whether type hierarchy peek is currently showing")), hs = new K(
  "typeHierarchyDirection",
  void 0,
  { type: "string", description: u(
    "typeHierarchyDirection",
    "whether type hierarchy shows super types or subtypes"
  ) }
);
function Uy(c) {
  return c === "subtypes" || c === "supertypes" ? c : "subtypes";
}
var _t;
let $t = (_t = class {
  static get(e) {
    return e.getContribution(_t.Id);
  }
  constructor(e, t, i, o, s) {
    this._editor = e, this._contextKeyService = t, this._storageService = i, this._editorService = o, this._instantiationService = s, this._disposables = new Z(), this._sessionDisposables = new Z(), this._ctxHasProvider = Ta.bindTo(this._contextKeyService), this._ctxIsVisible = Ls.bindTo(this._contextKeyService), this._ctxDirection = hs.bindTo(this._contextKeyService), this._disposables.add(_.any(e.onDidChangeModel, e.onDidChangeModelLanguage, ur.onDidChange)(() => {
      this._ctxHasProvider.set(e.hasModel() && ur.has(e.getModel()));
    })), this._disposables.add(this._sessionDisposables);
  }
  dispose() {
    this._disposables.dispose();
  }
  async startTypeHierarchyFromEditor() {
    if (this._sessionDisposables.clear(), !this._editor.hasModel())
      return;
    const e = this._editor.getModel(), t = this._editor.getPosition();
    if (!ur.has(e))
      return;
    const i = new $e(), o = Fu.create(e, t, i.token), s = Uy(this._storageService.get(_t._storageDirectionKey, 0, "subtypes"));
    this._showTypeHierarchyWidget(t, s, o, i);
  }
  _showTypeHierarchyWidget(e, t, i, o) {
    this._ctxIsVisible.set(!0), this._ctxDirection.set(t), _.any(this._editor.onDidChangeModel, this._editor.onDidChangeModelLanguage)(this.endTypeHierarchy, this, this._sessionDisposables), this._widget = this._instantiationService.createInstance(bo, this._editor, e, t), this._widget.showLoading(), this._sessionDisposables.add(this._widget.onDidClose(() => {
      this.endTypeHierarchy(), this._storageService.store(_t._storageDirectionKey, this._widget.direction, 0, 0);
    })), this._sessionDisposables.add({ dispose() {
      o.dispose(!0);
    } }), this._sessionDisposables.add(this._widget), i.then((s) => {
      o.token.isCancellationRequested || (s ? (this._sessionDisposables.add(s), this._widget.showModel(s)) : this._widget.showMessage(u("no.item", "No results")));
    }).catch((s) => {
      if (Qi(s)) {
        this.endTypeHierarchy();
        return;
      }
      this._widget.showMessage(u("error", "Failed to show type hierarchy"));
    });
  }
  async startTypeHierarchyFromTypeHierarchy() {
    var s;
    if (!this._widget)
      return;
    const e = this._widget.getModel(), t = this._widget.getFocused();
    if (!t || !e)
      return;
    const i = await this._editorService.openCodeEditor({ resource: t.item.uri }, this._editor);
    if (!i)
      return;
    const o = e.fork(t.item);
    this._sessionDisposables.clear(), (s = _t.get(i)) == null || s._showTypeHierarchyWidget(Fe.lift(o.root.selectionRange).getStartPosition(), this._widget.direction, Promise.resolve(o), new $e());
  }
  showSupertypes() {
    var e;
    (e = this._widget) == null || e.updateDirection("supertypes"), this._ctxDirection.set("supertypes");
  }
  showSubtypes() {
    var e;
    (e = this._widget) == null || e.updateDirection("subtypes"), this._ctxDirection.set("subtypes");
  }
  endTypeHierarchy() {
    this._sessionDisposables.clear(), this._ctxIsVisible.set(!1), this._editor.focus();
  }
}, _t.Id = "typeHierarchy", _t._storageDirectionKey = "typeHierarchy/defaultDirection", _t);
$t = y([
  l(1, F),
  l(2, ee),
  l(3, No),
  l(4, W)
], $t);
Lu($t.Id, $t, 0);
P(class extends Kt {
  constructor() {
    super({
      id: "editor.showTypeHierarchy",
      title: { value: u("title", "Peek Type Hierarchy"), original: "Peek Type Hierarchy" },
      menu: {
        id: k.EditorContextPeek,
        group: "navigation",
        order: 1e3,
        when: f.and(Ta, cn.notInPeekEditor)
      },
      precondition: f.and(Ta, cn.notInPeekEditor)
    });
  }
  async runEditorCommand(c, e) {
    var t;
    return (t = $t.get(e)) == null ? void 0 : t.startTypeHierarchyFromEditor();
  }
});
P(class extends Kt {
  constructor() {
    super({
      id: "editor.showSupertypes",
      title: { value: u("title.supertypes", "Show Supertypes"), original: "Show Supertypes" },
      icon: he.typeHierarchySuper,
      precondition: f.and(Ls, hs.isEqualTo("subtypes")),
      keybinding: {
        weight: 200,
        primary: 1024 + 512 + 38
      },
      menu: {
        id: bo.TitleMenu,
        when: hs.isEqualTo("subtypes"),
        order: 1
      }
    });
  }
  runEditorCommand(c, e) {
    var t;
    return (t = $t.get(e)) == null ? void 0 : t.showSupertypes();
  }
});
P(class extends Kt {
  constructor() {
    super({
      id: "editor.showSubtypes",
      title: { value: u("title.subtypes", "Show Subtypes"), original: "Show Subtypes" },
      icon: he.typeHierarchySub,
      precondition: f.and(Ls, hs.isEqualTo("supertypes")),
      keybinding: {
        weight: 200,
        primary: 1024 + 512 + 38
      },
      menu: {
        id: bo.TitleMenu,
        when: hs.isEqualTo("supertypes"),
        order: 1
      }
    });
  }
  runEditorCommand(c, e) {
    var t;
    return (t = $t.get(e)) == null ? void 0 : t.showSubtypes();
  }
});
P(class extends Kt {
  constructor() {
    super({
      id: "editor.refocusTypeHierarchy",
      title: { value: u("title.refocusTypeHierarchy", "Refocus Type Hierarchy"), original: "Refocus Type Hierarchy" },
      precondition: Ls,
      keybinding: {
        weight: 200,
        primary: 1024 + 3
      }
    });
  }
  async runEditorCommand(c, e) {
    var t;
    return (t = $t.get(e)) == null ? void 0 : t.startTypeHierarchyFromTypeHierarchy();
  }
});
P(class extends Kt {
  constructor() {
    super({
      id: "editor.closeTypeHierarchy",
      title: u("close", "Close"),
      icon: he.close,
      precondition: Ls,
      keybinding: {
        weight: 200 + 10,
        primary: 9,
        when: f.not("config.editor.stablePeek")
      },
      menu: {
        id: bo.TitleMenu,
        order: 1e3
      }
    });
  }
  runEditorCommand(c, e) {
    var t;
    return (t = $t.get(e)) == null ? void 0 : t.endTypeHierarchy();
  }
});
var jy = ".monaco-list .monaco-list-row.focused.selected .outline-element .monaco-highlighted-label,.monaco-list .monaco-list-row.focused.selected .outline-element-decoration{color:inherit!important}.monaco-list .outline-element{align-items:center;display:flex;flex:1;flex-flow:row nowrap}.monaco-list .outline-element .monaco-highlighted-label{color:var(--outline-element-color)}.monaco-breadcrumbs .outline-element .outline-element-decoration,.monaco-list .outline-element .outline-element-decoration{color:var(--outline-element-color);font-size:90%;font-weight:600;margin-left:auto;opacity:.75;padding:0 12px 0 5px;text-align:center}.monaco-breadcrumbs .outline-element .monaco-icon-label-container .monaco-icon-description-container,.monaco-breadcrumbs .outline-element .outline-element-decoration{display:none}.monaco-list .outline-element .outline-element-decoration.bubble{font-family:codicon;font-size:14px;opacity:.4;padding-right:8px}.monaco-list .outline-element .outline-element-icon{margin-right:4px}";
oe(jy, {});
class qy {
  getKeyboardNavigationLabel(e) {
    return e instanceof wt ? e.label : e.symbol.name;
  }
}
class $y {
  constructor(e) {
    this._ariaLabel = e;
  }
  getWidgetAriaLabel() {
    return this._ariaLabel;
  }
  getAriaLabel(e) {
    return e instanceof wt ? e.label : RC(e.symbol.name, e.symbol.kind);
  }
}
class ek {
  getId(e) {
    return e.id;
  }
}
const Yd = class Yd {
  constructor(e, t) {
    this.labelContainer = e, this.label = t;
  }
};
Yd.id = "DocumentSymbolGroupTemplate";
let us = Yd;
const Od = class Od {
  constructor(e, t, i, o) {
    this.container = e, this.iconLabel = t, this.iconClass = i, this.decoration = o;
  }
};
Od.id = "DocumentSymbolTemplate";
let gs = Od;
class tk {
  getHeight(e) {
    return 22;
  }
  getTemplateId(e) {
    return e instanceof wt ? us.id : gs.id;
  }
}
class ik {
  constructor() {
    this.templateId = us.id;
  }
  renderTemplate(e) {
    const t = Y(".outline-element-label");
    return e.classList.add("outline-element"), ae(e, t), new us(t, new GC(t));
  }
  renderElement(e, t, i) {
    i.label.set(e.element.label, Di(e.filterData));
  }
  disposeTemplate(e) {
  }
}
let La = class {
  constructor(e, t, i) {
    this._renderMarker = e, this._configurationService = t, this._themeService = i, this.templateId = gs.id;
  }
  renderTemplate(e) {
    e.classList.add("outline-element");
    const t = new pd(e, { supportHighlights: !0 }), i = Y(".outline-element-icon"), o = Y(".outline-element-decoration");
    return e.prepend(i), e.appendChild(o), new gs(e, t, i, o);
  }
  renderElement(e, t, i) {
    const { element: o } = e, s = ["nowrap"], n = {
      matches: Di(e.filterData),
      labelEscapeNewLines: !0,
      extraClasses: s,
      title: u(
        "title.template",
        "{0} ({1})",
        o.symbol.name,
        WC[o.symbol.kind]
      )
    };
    this._configurationService.getValue("outline.icons") && (i.iconClass.className = "", i.iconClass.classList.add("outline-element-icon", "inline", ...pe.asClassNameArray(md.toIcon(o.symbol.kind)))), o.symbol.tags.indexOf(1) >= 0 && (s.push("deprecated"), n.matches = []), i.iconLabel.setLabel(o.symbol.name, o.symbol.detail, n), this._renderMarker && this._renderMarkerInfo(o, i);
  }
  _renderMarkerInfo(e, t) {
    if (!e.marker) {
      gi(t.decoration), t.container.style.removeProperty("--outline-element-color");
      return;
    }
    const { count: i, topSev: o } = e.marker, s = this._themeService.getColorTheme().getColor(o === Xr.Error ? _C : EC), n = s ? s.toString() : "inherit";
    this._configurationService.getValue("outline.problems.colors") ? t.container.style.setProperty("--outline-element-color", n) : t.container.style.removeProperty("--outline-element-color"), this._configurationService.getValue("outline.problems.badges") ? i > 0 ? (hi(t.decoration), t.decoration.classList.remove("bubble"), t.decoration.innerText = i < 10 ? i.toString() : "+9", t.decoration.title = i === 1 ? u("1.problem", "1 problem in this element") : u("N.problem", "{0} problems in this element", i), t.decoration.style.setProperty("--outline-element-color", n)) : (hi(t.decoration), t.decoration.classList.add("bubble"), t.decoration.innerText = "", t.decoration.title = u("deep.problem", "Contains elements with problems"), t.decoration.style.setProperty("--outline-element-color", n)) : gi(t.decoration);
  }
  disposeTemplate(e) {
    e.iconLabel.dispose();
  }
};
La = y([
  l(1, x),
  l(2, z)
], La);
var Jo;
let ps = (Jo = class {
  constructor(e, t) {
    this._prefix = e, this._textResourceConfigService = t;
  }
  filter(e) {
    const t = bd.get(e);
    if (!(e instanceof vt))
      return !0;
    const i = Jo.kindToConfigName[e.symbol.kind], o = `${this._prefix}.${i}`;
    return this._textResourceConfigService.getValue(t == null ? void 0 : t.uri, o);
  }
}, Jo.kindToConfigName = Object.freeze({
  0: "showFiles",
  1: "showModules",
  2: "showNamespaces",
  3: "showPackages",
  4: "showClasses",
  5: "showMethods",
  6: "showProperties",
  7: "showFields",
  8: "showConstructors",
  9: "showEnums",
  10: "showInterfaces",
  11: "showFunctions",
  12: "showVariables",
  13: "showConstants",
  14: "showStrings",
  15: "showNumbers",
  16: "showBooleans",
  17: "showArrays",
  18: "showObjects",
  19: "showKeys",
  20: "showNull",
  21: "showEnumMembers",
  22: "showStructs",
  23: "showEvents",
  24: "showOperators",
  25: "showTypeParameters"
}), Jo);
ps = y([
  l(1, Go)
], ps);
class ok {
  constructor() {
    this._collator = new Xu(() => new Intl.Collator(void 0, { numeric: !0 }));
  }
  compareByPosition(e, t) {
    return e instanceof wt && t instanceof wt ? e.order - t.order : e instanceof vt && t instanceof vt ? Fe.compareRangesUsingStarts(e.symbol.range, t.symbol.range) || this._collator.value.compare(e.symbol.name, t.symbol.name) : 0;
  }
  compareByType(e, t) {
    return e instanceof wt && t instanceof wt ? e.order - t.order : e instanceof vt && t instanceof vt ? e.symbol.kind - t.symbol.kind || this._collator.value.compare(e.symbol.name, t.symbol.name) : 0;
  }
  compareByName(e, t) {
    return e instanceof wt && t instanceof wt ? e.order - t.order : e instanceof vt && t instanceof vt ? this._collator.value.compare(e.symbol.name, t.symbol.name) || Fe.compareRangesUsingStarts(e.symbol.range, t.symbol.range) : 0;
  }
}
let Fa = class {
  constructor(e, t) {
    this._editor = e, this._textResourceConfigurationService = t, this._breadcrumbs = [];
  }
  getBreadcrumbElements() {
    return this._breadcrumbs;
  }
  clear() {
    this._breadcrumbs = [];
  }
  update(e, t) {
    const i = this._computeBreadcrumbs(e, t);
    this._breadcrumbs = i;
  }
  _computeBreadcrumbs(e, t) {
    let i = e.getItemEnclosingPosition(t);
    if (!i)
      return [];
    const o = [];
    for (; i; ) {
      o.push(i);
      const n = i.parent;
      if (n instanceof bd || n instanceof wt && n.parent && n.parent.children.size === 1)
        break;
      i = n;
    }
    const s = [];
    for (let n = o.length - 1; n >= 0; n--) {
      const r = o[n];
      if (this._isFiltered(r))
        break;
      s.push(r);
    }
    return s.length === 0 ? [] : s;
  }
  _isFiltered(e) {
    if (!(e instanceof vt))
      return !1;
    const t = `breadcrumbs.${ps.kindToConfigName[e.symbol.kind]}`;
    let i;
    return this._editor && this._editor.getModel() && (i = this._editor.getModel().uri), !this._textResourceConfigurationService.getValue(i, t);
  }
};
Fa = y([
  l(1, Go)
], Fa);
let Xa = class {
  get activeElement() {
    const e = this._editor.getPosition();
    if (!(!e || !this._outlineModel))
      return this._outlineModel.getItemEnclosingPosition(e);
  }
  constructor(e, t, i, o, s, n, r, a, d, h) {
    var R;
    this._editor = e, this._languageFeaturesService = o, this._codeEditorService = s, this._outlineModelService = n, this._configurationService = r, this._markerDecorationsService = a, this._disposables = new Z(), this._onDidChange = new w(), this.onDidChange = this._onDidChange.event, this._outlineDisposables = new Z(), this.outlineKind = "documentSymbols", this._breadcrumbsDataSource = new Fa(e, d);
    const g = new tk(), p = [new ik(), h.createInstance(La, !0)], m = {
      getChildren: (O) => O instanceof vt || O instanceof wt ? O.children.values() : O === this && this._outlineModel ? this._outlineModel.children.values() : []
    }, C = new ok(), b = d.getValue((R = e.getModel()) == null ? void 0 : R.uri, "outline.collapseItems"), v = {
      collapseByDefault: t === 2 || t === 1 && b === "alwaysCollapse",
      expandOnlyOnTwistieClick: !0,
      multipleSelectionSupport: !1,
      identityProvider: new ek(),
      keyboardNavigationLabelProvider: new qy(),
      accessibilityProvider: new $y(u("document", "Document Symbols")),
      filter: t === 1 ? h.createInstance(ps, "outline") : t === 2 ? h.createInstance(ps, "breadcrumbs") : void 0
    };
    this.config = {
      breadcrumbsDataSource: this._breadcrumbsDataSource,
      delegate: g,
      renderers: p,
      treeDataSource: m,
      comparator: C,
      options: v,
      quickPickDataSource: { getQuickPickElements: () => {
        throw new Error("not implemented");
      } }
    }, this._disposables.add(o.documentSymbolProvider.onDidChange((O) => this._createOutline())), this._disposables.add(this._editor.onDidChangeModel((O) => this._createOutline())), this._disposables.add(this._editor.onDidChangeModelLanguage((O) => this._createOutline()));
    const J = new Kr();
    this._disposables.add(J), this._disposables.add(this._editor.onDidChangeModelContent((O) => {
      const Je = this._editor.getModel();
      if (Je) {
        const Jt = n.getDebounceValue(Je);
        J.cancelAndSet(() => this._createOutline(O), Jt);
      }
    })), this._disposables.add(this._editor.onDidDispose(() => this._outlineDisposables.clear())), this._createOutline().finally(() => i.open());
  }
  dispose() {
    this._disposables.dispose(), this._outlineDisposables.dispose();
  }
  get isEmpty() {
    return !this._outlineModel || Fs.empty(this._outlineModel);
  }
  get uri() {
    var e;
    return (e = this._outlineModel) == null ? void 0 : e.uri;
  }
  async reveal(e, t, i) {
    const o = bd.get(e);
    !o || !(e instanceof vt) || await this._codeEditorService.openCodeEditor({
      resource: o.uri,
      options: {
        ...t,
        selection: Fe.collapseToStart(e.symbol.selectionRange),
        selectionRevealType: 3
      }
    }, this._editor, i);
  }
  preview(e) {
    if (!(e instanceof vt))
      return E.None;
    const { symbol: t } = e;
    this._editor.revealRangeInCenterIfOutsideViewport(t.range, 0);
    const i = this._editor.createDecorationsCollection([{
      range: t.range,
      options: {
        description: "document-symbols-outline-range-highlight",
        className: "rangeHighlight",
        isWholeLine: !0
      }
    }]);
    return M(() => i.clear());
  }
  captureViewState() {
    const e = this._editor.saveViewState();
    return M(() => {
      e && this._editor.restoreViewState(e);
    });
  }
  async _createOutline(e) {
    if (this._outlineDisposables.clear(), e || this._setOutlineModel(void 0), !this._editor.hasModel())
      return;
    const t = this._editor.getModel();
    if (!this._languageFeaturesService.documentSymbolProvider.has(t))
      return;
    const i = new $e(), o = t.getVersionId(), s = new Kr();
    this._outlineDisposables.add(s), this._outlineDisposables.add(M(() => i.dispose(!0)));
    try {
      const n = await this._outlineModelService.getOrCreate(t, i.token);
      if (i.token.isCancellationRequested)
        return;
      if (Fs.empty(n) || !this._editor.hasModel()) {
        this._setOutlineModel(n);
        return;
      }
      if (e && this._outlineModel && t.getLineCount() >= 25) {
        const r = Fs.size(n), a = t.getValueLength(), d = r / a, h = Fs.size(this._outlineModel), g = a - e.changes.reduce((m, C) => m + C.rangeLength, 0), p = h / g;
        if ((d <= p * 0.5 || d >= p * 1.5) && !await QC(jc(2e3).then(() => !0), i.token, !1))
          return;
      }
      this._applyMarkersToOutline(n), this._outlineDisposables.add(this._markerDecorationsService.onDidChangeMarker((r) => {
        Be(n.uri, r.uri) && (this._applyMarkersToOutline(n), this._onDidChange.fire({}));
      })), this._outlineDisposables.add(this._configurationService.onDidChangeConfiguration((r) => {
        r.affectsConfiguration("outline.problems.enabled") && (this._configurationService.getValue("outline.problems.enabled") ? this._applyMarkersToOutline(n) : n.updateMarker([]), this._onDidChange.fire({})), r.affectsConfiguration("outline") && this._onDidChange.fire({}), r.affectsConfiguration("breadcrumbs") && this._editor.hasModel() && (this._breadcrumbsDataSource.update(n, this._editor.getPosition()), this._onDidChange.fire({}));
      })), this._outlineDisposables.add(this._configurationService.onDidChangeConfiguration((r) => {
        r.affectsConfiguration("outline.icons") && this._onDidChange.fire({}), r.affectsConfiguration("outline") && this._onDidChange.fire({});
      })), this._outlineDisposables.add(this._editor.onDidChangeCursorPosition((r) => {
        s.cancelAndSet(() => {
          !t.isDisposed() && o === t.getVersionId() && this._editor.hasModel() && (this._breadcrumbsDataSource.update(n, this._editor.getPosition()), this._onDidChange.fire({ affectOnlyActiveElement: !0 }));
        }, 150);
      })), this._setOutlineModel(n);
    } catch (n) {
      this._setOutlineModel(void 0), ho(n);
    }
  }
  _applyMarkersToOutline(e) {
    if (!e || !this._configurationService.getValue("outline.problems.enabled"))
      return;
    const t = [];
    for (const [i, o] of this._markerDecorationsService.getLiveMarkers(e.uri))
      (o.severity === Xr.Error || o.severity === Xr.Warning) && t.push({ ...i, severity: o.severity });
    e.updateMarker(t);
  }
  _setOutlineModel(e) {
    var i;
    const t = this._editor.getPosition();
    !t || !e ? (this._outlineModel = void 0, this._breadcrumbsDataSource.clear()) : ((i = this._outlineModel) != null && i.merge(e) || (this._outlineModel = e), this._breadcrumbsDataSource.update(e, t)), this._onDidChange.fire({});
  }
};
Xa = y([
  l(3, xC),
  l(4, No),
  l(5, DC),
  l(6, x),
  l(7, NC),
  l(8, Go),
  l(9, W)
], Xa);
let Ka = class {
  constructor(e) {
    const t = e.registerOutlineCreator(this);
    this.dispose = () => t.dispose();
  }
  matches(e) {
    const t = e.getControl();
    return Yr(t) || dl(t);
  }
  async createOutline(e, t, i) {
    const o = e.getControl();
    let s;
    if (Yr(o) ? s = o : dl(o) && (s = o.getModifiedEditor()), !s)
      return;
    const n = new AC(), r = s.invokeWithinContext((a) => a.get(W).createInstance(Xa, s, t, n));
    return await n.wait(), r;
  }
};
Ka = y([
  l(0, Yn)
], Ka);
N.as(dt.Workbench).registerWorkbenchContribution(Ka, 4);
var sk = ".monaco-workbench .outline-pane{display:flex;flex-direction:column}.monaco-workbench .outline-pane .outline-progress{height:2px;padding-bottom:3px;position:absolute;width:100%}.monaco-workbench .outline-pane .outline-progress .monaco-progress-container,.monaco-workbench .outline-pane .outline-progress .monaco-progress-container .progress-bit{height:2px}.monaco-workbench .outline-pane .outline-tree{height:100%}.monaco-workbench .outline-pane .outline-message{display:none;opacity:.5;padding:10px 22px 0;pointer-events:none;position:absolute;z-index:1}.monaco-workbench .outline-pane.message .outline-message{display:inherit}.monaco-workbench .outline-pane.message .outline-progress{display:none}";
oe(sk, {});
class nk {
  constructor() {
    this._followCursor = !1, this._filterOnType = !0, this._sortBy = 0, this._onDidChange = new w(), this.onDidChange = this._onDidChange.event;
  }
  dispose() {
    this._onDidChange.dispose();
  }
  set followCursor(e) {
    e !== this._followCursor && (this._followCursor = e, this._onDidChange.fire({ followCursor: !0 }));
  }
  get followCursor() {
    return this._followCursor;
  }
  get filterOnType() {
    return this._filterOnType;
  }
  set filterOnType(e) {
    e !== this._filterOnType && (this._filterOnType = e, this._onDidChange.fire({ filterOnType: !0 }));
  }
  set sortBy(e) {
    e !== this._sortBy && (this._sortBy = e, this._onDidChange.fire({ sortBy: !0 }));
  }
  get sortBy() {
    return this._sortBy;
  }
  persist(e) {
    e.store("outline/state", JSON.stringify({
      followCursor: this.followCursor,
      sortBy: this.sortBy,
      filterOnType: this.filterOnType
    }), 1, 1);
  }
  restore(e) {
    const t = e.get("outline/state", 1);
    if (!t)
      return;
    let i;
    try {
      i = JSON.parse(t);
    } catch {
      return;
    }
    this.followCursor = i.followCursor, this.sortBy = i.sortBy ?? 0, typeof i.filterOnType == "boolean" && (this.filterOnType = i.filterOnType);
  }
}
var Ya;
(function(c) {
  c.Id = "outline";
})(Ya || (Ya = {}));
const rk = new K("outlineFollowsCursor", !1), ak = new K("outlineFiltersOnType", !1), ck = new K("outlineSortMode", 0), dk = new K("outlineAllCollapsed", !1);
class lk {
  constructor(e, t) {
    this._comparator = e, this.order = t;
  }
  compare(e, t) {
    return this.order === 2 ? this._comparator.compareByType(e, t) : this.order === 1 ? this._comparator.compareByName(e, t) : this._comparator.compareByPosition(e, t);
  }
}
var vs;
let Oa = (vs = class extends jn {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m) {
    super(e, a, h, r, d, o, i, g, p, m), this._outlineService = t, this._instantiationService = i, this._storageService = s, this._editorService = n, this._disposables = new Z(), this._editorControlDisposables = new Z(), this._editorPaneDisposables = new Z(), this._outlineViewState = new nk(), this._editorListener = new Re(), this._treeStates = new BC(10), this._outlineViewState.restore(this._storageService), this._disposables.add(this._outlineViewState), d.bufferChangeEvents(() => {
      this._ctxFollowsCursor = rk.bindTo(d), this._ctxFilterOnType = ak.bindTo(d), this._ctxSortMode = ck.bindTo(d), this._ctxAllCollapsed = dk.bindTo(d);
    });
    const C = () => {
      this._ctxFollowsCursor.set(this._outlineViewState.followCursor), this._ctxFilterOnType.set(this._outlineViewState.filterOnType), this._ctxSortMode.set(this._outlineViewState.sortBy);
    };
    C(), this._disposables.add(this._outlineViewState.onDidChange(C));
  }
  dispose() {
    this._disposables.dispose(), this._editorPaneDisposables.dispose(), this._editorControlDisposables.dispose(), this._editorListener.dispose(), super.dispose();
  }
  focus() {
    var e;
    (e = this._tree) == null || e.domFocus();
  }
  renderBody(e) {
    super.renderBody(e), this._domNode = e, e.classList.add("outline-pane");
    const t = Y(".outline-progress");
    this._message = Y(".outline-message"), this._progressBar = new Bc(t, Tc), this._treeContainer = Y(".outline-tree"), ae(e, t, this._message, this._treeContainer), this._disposables.add(this.onDidChangeBodyVisibility((i) => {
      if (!i)
        this._editorListener.clear(), this._editorPaneDisposables.clear(), this._editorControlDisposables.clear();
      else if (!this._editorListener.value) {
        const o = _.any(this._editorService.onDidActiveEditorChange, this._outlineService.onDidChange);
        this._editorListener.value = o(() => this._handleEditorChanged(this._editorService.activeEditorPane)), this._handleEditorChanged(this._editorService.activeEditorPane);
      }
    }));
  }
  layoutBody(e, t) {
    var i;
    super.layoutBody(e, t), (i = this._tree) == null || i.layout(e, t), this._treeDimensions = new H(t, e);
  }
  collapseAll() {
    var e;
    (e = this._tree) == null || e.collapseAll();
  }
  expandAll() {
    var e;
    (e = this._tree) == null || e.expandAll();
  }
  get outlineViewState() {
    return this._outlineViewState;
  }
  _showMessage(e) {
    this._domNode.classList.add("message"), this._progressBar.stop().hide(), this._message.innerText = e;
  }
  _captureViewState(e) {
    if (this._tree) {
      const t = this._tree.getInput();
      if (e || (e = t == null ? void 0 : t.uri), t && e)
        return this._treeStates.set(`${t.outlineKind}/${e}`, this._tree.getViewState()), !0;
    }
    return !1;
  }
  _handleEditorChanged(e) {
    this._editorPaneDisposables.clear(), e && this._editorPaneDisposables.add(e.onDidChangeControl(() => {
      this._handleEditorControlChanged(e);
    })), this._handleEditorControlChanged(e);
  }
  async _handleEditorControlChanged(e) {
    var m, C;
    const t = me.getOriginalUri(e == null ? void 0 : e.input), i = this._captureViewState();
    if (this._editorControlDisposables.clear(), !e || !this._outlineService.canCreateOutline(e) || !t)
      return this._showMessage(u("no-editor", "The active editor cannot provide outline information."));
    let o;
    i || (o = new Kr(() => {
      this._showMessage(u("loading", "Loading document symbols for '{0}'...", Le(t)));
    }, 100)), this._progressBar.infinite().show(500);
    const s = new $e();
    this._editorControlDisposables.add(M(() => s.dispose(!0)));
    const n = await this._outlineService.createOutline(e, 1, s.token);
    if (o == null || o.dispose(), !n)
      return;
    if (s.token.isCancellationRequested) {
      n == null || n.dispose();
      return;
    }
    this._editorControlDisposables.add(n), this._progressBar.stop().hide();
    const r = new lk(n.config.comparator, this._outlineViewState.sortBy), a = this._instantiationService.createInstance(Uc, "OutlinePane", this._treeContainer, n.config.delegate, n.config.renderers, n.config.treeDataSource, {
      ...n.config.options,
      sorter: r,
      expandOnDoubleClick: !1,
      expandOnlyOnTwistieClick: !0,
      multipleSelectionSupport: !1,
      hideTwistiesOfChildlessElements: !0,
      defaultFindMode: this._outlineViewState.filterOnType ? Ct.Filter : Ct.Highlight,
      overrideStyles: { listBackground: this.getBackgroundColor() }
    }), d = () => {
      if (n.isEmpty)
        this._showMessage(u("no-symbols", "No symbols found in document '{0}'", Le(t))), this._captureViewState(t), a.setInput(void 0);
      else if (a.getInput())
        this._domNode.classList.remove("message"), a.updateChildren();
      else {
        this._domNode.classList.remove("message");
        const b = this._treeStates.get(`${n.outlineKind}/${n.uri}`);
        a.setInput(n, b && TC.lift(b));
      }
    };
    d(), this._editorControlDisposables.add(n.onDidChange(d)), a.findMode = this._outlineViewState.filterOnType ? Ct.Filter : Ct.Highlight, this._editorControlDisposables.add(this.viewDescriptorService.onDidChangeLocation(({ views: b }) => {
      b.some((v) => v.id === this.id) && a.updateOptions({ overrideStyles: { listBackground: this.getBackgroundColor() } });
    })), this._editorControlDisposables.add(a.onDidChangeFindMode((b) => this._outlineViewState.filterOnType = b === Ct.Filter)), this._editorControlDisposables.add(a.onDidOpen((b) => n.reveal(b.element, b.editorOptions, b.sideBySide)));
    const h = () => {
      if (!this._outlineViewState.followCursor || !n.activeElement)
        return;
      let b = n.activeElement;
      for (; b; ) {
        if (a.getRelativeTop(b) === null && a.reveal(b, 0.5), a.getRelativeTop(b) !== null) {
          a.setFocus([b]), a.setSelection([b]);
          break;
        }
        b = a.getParentElement(b);
      }
    };
    h(), this._editorControlDisposables.add(n.onDidChange(h)), this._editorControlDisposables.add(this._outlineViewState.onDidChange((b) => {
      this._outlineViewState.persist(this._storageService), b.filterOnType && (a.findMode = this._outlineViewState.filterOnType ? Ct.Filter : Ct.Highlight), b.followCursor && h(), b.sortBy && (r.order = this._outlineViewState.sortBy, a.resort());
    }));
    let g;
    this._editorControlDisposables.add(a.onDidChangeFindPattern((b) => {
      a.findMode !== Ct.Highlight && (!g && b ? (g = a.getViewState(), a.expandAll()) : !b && g && (a.setInput(a.getInput(), g), g = void 0));
    }));
    const p = () => {
      this._ctxAllCollapsed.set(a.getNode(null).children.every((b) => !b.collapsible || b.collapsed));
    };
    this._editorControlDisposables.add(a.onDidChangeCollapseState(p)), this._editorControlDisposables.add(a.onDidChangeModel(p)), p(), a.layout((m = this._treeDimensions) == null ? void 0 : m.height, (C = this._treeDimensions) == null ? void 0 : C.width), this._tree = a, this._editorControlDisposables.add(M(() => {
      a.dispose(), this._tree = void 0;
    }));
  }
}, vs.Id = "outline", vs);
Oa = y([
  l(1, Yn),
  l(2, W),
  l(3, Me),
  l(4, ee),
  l(5, D),
  l(6, x),
  l(7, be),
  l(8, F),
  l(9, Ie),
  l(10, Ti),
  l(11, z),
  l(12, Xe)
], Oa);
const hk = lo("outline-view-icon", he.symbolClass, u("outlineViewIcon", "View icon of the outline view."));
N.as(nt.ViewsRegistry).registerViews([{
  id: Ya.Id,
  name: u("name", "Outline"),
  containerIcon: hk,
  ctorDescriptor: new T(Oa),
  canToggleVisibility: !0,
  canMoveView: !0,
  hideByDefault: !1,
  collapsed: !0,
  order: 2,
  weight: 30,
  focusCommand: { id: "outline.focus" }
}], LC);
N.as(Cd.Configuration).registerConfiguration({
  id: "outline",
  order: 117,
  title: u("outlineConfigurationTitle", "Outline"),
  type: "object",
  properties: {
    "outline.icons": {
      description: u("outline.showIcons", "Render Outline elements with icons."),
      type: "boolean",
      default: !0
    },
    "outline.collapseItems": {
      description: u(
        "outline.initialState",
        "Controls whether Outline items are collapsed or expanded."
      ),
      type: "string",
      scope: 5,
      enum: [
        "alwaysCollapse",
        "alwaysExpand"
      ],
      enumDescriptions: [
        u("outline.initialState.collapsed", "Collapse all items."),
        u("outline.initialState.expanded", "Expand all items.")
      ],
      default: "alwaysExpand"
    },
    "outline.problems.enabled": {
      description: u("outline.showProblem", "Show errors and warnings on Outline elements."),
      type: "boolean",
      default: !0
    },
    "outline.problems.colors": {
      description: u(
        "outline.problem.colors",
        "Use colors for errors and warnings on Outline elements."
      ),
      type: "boolean",
      default: !0
    },
    "outline.problems.badges": {
      description: u(
        "outline.problems.badges",
        "Use badges for errors and warnings on Outline elements."
      ),
      type: "boolean",
      default: !0
    },
    "outline.showFiles": {
      type: "boolean",
      scope: 5,
      default: !0,
      markdownDescription: u("filteredTypes.file", "When enabled, Outline shows `file`-symbols.")
    },
    "outline.showModules": {
      type: "boolean",
      scope: 5,
      default: !0,
      markdownDescription: u("filteredTypes.module", "When enabled, Outline shows `module`-symbols.")
    },
    "outline.showNamespaces": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u(
        "filteredTypes.namespace",
        "When enabled, Outline shows `namespace`-symbols."
      )
    },
    "outline.showPackages": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u("filteredTypes.package", "When enabled, Outline shows `package`-symbols.")
    },
    "outline.showClasses": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u("filteredTypes.class", "When enabled, Outline shows `class`-symbols.")
    },
    "outline.showMethods": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u("filteredTypes.method", "When enabled, Outline shows `method`-symbols.")
    },
    "outline.showProperties": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u(
        "filteredTypes.property",
        "When enabled, Outline shows `property`-symbols."
      )
    },
    "outline.showFields": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u("filteredTypes.field", "When enabled, Outline shows `field`-symbols.")
    },
    "outline.showConstructors": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u(
        "filteredTypes.constructor",
        "When enabled, Outline shows `constructor`-symbols."
      )
    },
    "outline.showEnums": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u("filteredTypes.enum", "When enabled, Outline shows `enum`-symbols.")
    },
    "outline.showInterfaces": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u(
        "filteredTypes.interface",
        "When enabled, Outline shows `interface`-symbols."
      )
    },
    "outline.showFunctions": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u(
        "filteredTypes.function",
        "When enabled, Outline shows `function`-symbols."
      )
    },
    "outline.showVariables": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u(
        "filteredTypes.variable",
        "When enabled, Outline shows `variable`-symbols."
      )
    },
    "outline.showConstants": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u(
        "filteredTypes.constant",
        "When enabled, Outline shows `constant`-symbols."
      )
    },
    "outline.showStrings": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u("filteredTypes.string", "When enabled, Outline shows `string`-symbols.")
    },
    "outline.showNumbers": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u("filteredTypes.number", "When enabled, Outline shows `number`-symbols.")
    },
    "outline.showBooleans": {
      type: "boolean",
      scope: 5,
      default: !0,
      markdownDescription: u("filteredTypes.boolean", "When enabled, Outline shows `boolean`-symbols.")
    },
    "outline.showArrays": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u("filteredTypes.array", "When enabled, Outline shows `array`-symbols.")
    },
    "outline.showObjects": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u("filteredTypes.object", "When enabled, Outline shows `object`-symbols.")
    },
    "outline.showKeys": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u("filteredTypes.key", "When enabled, Outline shows `key`-symbols.")
    },
    "outline.showNull": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u("filteredTypes.null", "When enabled, Outline shows `null`-symbols.")
    },
    "outline.showEnumMembers": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u(
        "filteredTypes.enumMember",
        "When enabled, Outline shows `enumMember`-symbols."
      )
    },
    "outline.showStructs": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u("filteredTypes.struct", "When enabled, Outline shows `struct`-symbols.")
    },
    "outline.showEvents": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u("filteredTypes.event", "When enabled, Outline shows `event`-symbols.")
    },
    "outline.showOperators": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u(
        "filteredTypes.operator",
        "When enabled, Outline shows `operator`-symbols."
      )
    },
    "outline.showTypeParameters": {
      type: "boolean",
      default: !0,
      scope: 5,
      markdownDescription: u(
        "filteredTypes.typeParameter",
        "When enabled, Outline shows `typeParameter`-symbols."
      )
    }
  }
});
function Fd(c) {
  c && c.getHTMLElement() !== document.activeElement && c.domFocus();
}
async function uk(c, e) {
  if (!Yu.getValue(c.contextKeyService))
    return e(c);
  const t = c.getFocus(), i = c.getSelection();
  await e(c);
  const o = c.getFocus();
  if (i.length > 1 || !bi(t, i) || bi(t, o))
    return;
  const s = new KeyboardEvent("keydown");
  c.setSelection(o, s);
}
async function Bt(c, e) {
  if (!c)
    return;
  await uk(c, e);
  const t = c.getFocus();
  t.length && c.reveal(t[0]), c.setAnchor(t[0]), Fd(c);
}
V.registerCommandAndKeybindingRule({
  id: "list.focusDown",
  weight: 200,
  when: te,
  primary: 18,
  mac: {
    primary: 18,
    secondary: [300]
  },
  handler: (c, e) => {
    Bt(c.get(B).lastFocusedList, async (t) => {
      const i = new KeyboardEvent("keydown");
      await t.focusNext(typeof e == "number" ? e : 1, !1, i);
    });
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.focusUp",
  weight: 200,
  when: te,
  primary: 16,
  mac: {
    primary: 16,
    secondary: [302]
  },
  handler: (c, e) => {
    Bt(c.get(B).lastFocusedList, async (t) => {
      const i = new KeyboardEvent("keydown");
      await t.focusPrevious(typeof e == "number" ? e : 1, !1, i);
    });
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.focusPageDown",
  weight: 200,
  when: te,
  primary: 12,
  handler: (c) => {
    Bt(c.get(B).lastFocusedList, async (e) => {
      const t = new KeyboardEvent("keydown");
      await e.focusNextPage(t);
    });
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.focusPageUp",
  weight: 200,
  when: te,
  primary: 11,
  handler: (c) => {
    Bt(c.get(B).lastFocusedList, async (e) => {
      const t = new KeyboardEvent("keydown");
      await e.focusPreviousPage(t);
    });
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.focusFirst",
  weight: 200,
  when: te,
  primary: 14,
  handler: (c) => {
    Bt(c.get(B).lastFocusedList, async (e) => {
      const t = new KeyboardEvent("keydown");
      await e.focusFirst(t);
    });
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.focusLast",
  weight: 200,
  when: te,
  primary: 13,
  handler: (c) => {
    Bt(c.get(B).lastFocusedList, async (e) => {
      const t = new KeyboardEvent("keydown");
      await e.focusLast(t);
    });
  }
});
function qg(c, e) {
  if (c instanceof Ds || c instanceof Ns || c instanceof Qs) {
    const t = c, i = t.getFocus() ? t.getFocus()[0] : void 0, o = t.getSelection();
    o && typeof i == "number" && o.indexOf(i) >= 0 ? t.setSelection(o.filter((s) => s !== e)) : typeof i == "number" && t.setSelection(o.concat(i));
  } else if (c instanceof fi || c instanceof vi || c instanceof ut) {
    const t = c, i = t.getFocus() ? t.getFocus()[0] : void 0;
    if (e === i)
      return;
    const o = t.getSelection(), s = new KeyboardEvent("keydown", { shiftKey: !0 });
    o && o.indexOf(i) >= 0 ? t.setSelection(o.filter((n) => n !== e), s) : t.setSelection(o.concat(i), s);
  }
}
V.registerCommandAndKeybindingRule({
  id: "list.expandSelectionDown",
  weight: 200,
  when: f.and(te, fd),
  primary: 1042,
  handler: (c, e) => {
    const t = c.get(B).lastFocusedList;
    if (!t)
      return;
    const i = t.getFocus() ? t.getFocus()[0] : void 0, o = new KeyboardEvent("keydown");
    t.focusNext(typeof e == "number" ? e : 1, !1, o), qg(t, i);
    const s = t.getFocus();
    s.length && t.reveal(s[0]), Fd(t);
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.expandSelectionUp",
  weight: 200,
  when: f.and(te, fd),
  primary: 1040,
  handler: (c, e) => {
    const t = c.get(B).lastFocusedList;
    if (!t)
      return;
    const i = t.getFocus() ? t.getFocus()[0] : void 0, o = new KeyboardEvent("keydown");
    t.focusPrevious(typeof e == "number" ? e : 1, !1, o), qg(t, i);
    const s = t.getFocus();
    s.length && t.reveal(s[0]), Fd(t);
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.collapse",
  weight: 200,
  when: f.and(te, f.or(FC, XC)),
  primary: 15,
  mac: {
    primary: 15,
    secondary: [2064]
  },
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    if (!e || !(e instanceof fi || e instanceof vi || e instanceof ut))
      return;
    const t = e, i = t.getFocus();
    if (i.length === 0)
      return;
    const o = i[0];
    if (!t.collapse(o)) {
      const s = t.getParentElement(o);
      s && Bt(e, (n) => {
        const r = new KeyboardEvent("keydown");
        n.setFocus([s], r);
      });
    }
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.collapseAll",
  weight: 200,
  when: te,
  primary: 2063,
  mac: {
    primary: 2063,
    secondary: [3088]
  },
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    e && !(e instanceof Ds || e instanceof Ns || e instanceof Qs) && e.collapseAll();
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.collapseAllToFocus",
  weight: 200,
  when: te,
  handler: (c) => {
    const e = c.get(B).lastFocusedList, t = Ku("keydown", !0);
    if (e instanceof fi || e instanceof vi || e instanceof ut) {
      const i = e, o = i.getFocus();
      o.length > 0 && i.collapse(o[0], !0), i.setSelection(o, t), i.setAnchor(o[0]);
    }
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.focusParent",
  weight: 200,
  when: te,
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    if (!e || !(e instanceof fi || e instanceof vi || e instanceof ut))
      return;
    const t = e, i = t.getFocus();
    if (i.length === 0)
      return;
    const o = i[0], s = t.getParentElement(o);
    s && Bt(e, (n) => {
      const r = new KeyboardEvent("keydown");
      n.setFocus([s], r);
    });
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.expand",
  weight: 200,
  when: f.and(te, f.or(KC, YC)),
  primary: 17,
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    if (e) {
      if (e instanceof fi || e instanceof vi) {
        const t = e.getFocus();
        if (t.length === 0)
          return;
        const i = t[0];
        if (!e.expand(i)) {
          const o = e.getFirstElementChild(i);
          o && e.getNode(o).visible && Bt(e, (n) => {
            const r = new KeyboardEvent("keydown");
            n.setFocus([o], r);
          });
        }
      } else if (e instanceof ut) {
        const t = e.getFocus();
        if (t.length === 0)
          return;
        const i = t[0];
        e.expand(i).then((o) => {
          if (i && !o) {
            const s = e.getFirstElementChild(i);
            s && e.getNode(s).visible && Bt(e, (r) => {
              const a = new KeyboardEvent("keydown");
              r.setFocus([s], a);
            });
          }
        });
      }
    }
  }
});
function Xd(c, e) {
  const t = c.get(B).lastFocusedList, i = Ku("keydown", e);
  if (t instanceof Ds || t instanceof Ns || t instanceof Qs) {
    const o = t;
    o.setSelection(o.getFocus(), i), o.setAnchor(o.getFocus()[0]);
  } else if (t instanceof fi || t instanceof vi || t instanceof ut) {
    const o = t, s = o.getFocus();
    if (s.length > 0) {
      let n = !0;
      (o.expandOnlyOnTwistieClick === !0 || typeof o.expandOnlyOnTwistieClick != "boolean" && o.expandOnlyOnTwistieClick(s[0])) && (n = !1), n && o.toggleCollapsed(s[0]);
    }
    o.setSelection(s, i), o.setAnchor(s[0]);
  }
}
V.registerCommandAndKeybindingRule({
  id: "list.select",
  weight: 200,
  when: te,
  primary: 3,
  mac: {
    primary: 3,
    secondary: [2066]
  },
  handler: (c) => {
    Xd(c, !1);
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.selectAndPreserveFocus",
  weight: 200,
  when: te,
  handler: (c) => {
    Xd(c, !0);
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.selectAll",
  weight: 200,
  when: f.and(te, fd),
  primary: 2079,
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    if (e instanceof Ds || e instanceof Ns || e instanceof Qs) {
      const t = e, i = new KeyboardEvent("keydown");
      t.setSelection(OC(t.length), i);
    } else if (e instanceof fi || e instanceof vi || e instanceof ut) {
      const t = e, i = t.getFocus(), o = t.getSelection();
      let s;
      i.length > 0 && (o.length === 0 || !o.includes(i[0])) && (s = i[0]), !s && o.length > 0 && (s = o[0]);
      let n;
      s ? n = t.getParentElement(s) : n = void 0;
      const r = [], a = (h) => {
        for (const g of h.children)
          g.visible && (r.push(g.element), g.collapsed || a(g));
      };
      a(t.getNode(n)), n && o.length === r.length && r.unshift(n);
      const d = new KeyboardEvent("keydown");
      t.setSelection(r, d);
    }
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.toggleSelection",
  weight: 200,
  when: te,
  primary: 3075,
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    if (!e)
      return;
    const t = e.getFocus();
    if (t.length === 0)
      return;
    const i = e.getSelection(), o = i.indexOf(t[0]);
    o > -1 ? e.setSelection([...i.slice(0, o), ...i.slice(o + 1)]) : e.setSelection([...i, t[0]]);
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.toggleExpand",
  weight: 200,
  when: te,
  primary: 10,
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    if (e instanceof fi || e instanceof vi || e instanceof ut) {
      const t = e, i = t.getFocus();
      if (i.length > 0 && t.isCollapsible(i[0])) {
        t.toggleCollapsed(i[0]);
        return;
      }
    }
    Xd(c, !0);
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.clear",
  weight: 200,
  when: f.and(te, HC),
  primary: 9,
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    if (!e)
      return;
    const t = e.getSelection(), i = new KeyboardEvent("keydown");
    if (t.length > 1)
      if (Yu.getValue(e.contextKeyService)) {
        const s = e.getFocus();
        e.setSelection([s[0]], i);
      } else
        e.setSelection([], i);
    else
      e.setSelection([], i), e.setFocus([], i);
    e.setAnchor(void 0);
  }
});
Te.registerCommand({
  id: "list.triggerTypeNavigation",
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    e == null || e.triggerTypeNavigation();
  }
});
Te.registerCommand({
  id: "list.toggleFindMode",
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    if (e instanceof vd || e instanceof ut) {
      const t = e;
      t.findMode = t.findMode === Ct.Filter ? Ct.Highlight : Ct.Filter;
    }
  }
});
Te.registerCommandAlias("list.toggleKeyboardNavigation", "list.triggerTypeNavigation");
Te.registerCommandAlias("list.toggleFilterOnType", "list.toggleFindMode");
V.registerCommandAndKeybindingRule({
  id: "list.find",
  weight: 200,
  when: f.and(Ou, PC),
  primary: 2084,
  secondary: [61],
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    e instanceof Ds || e instanceof Ns || e instanceof Qs || (e instanceof vd || e instanceof ut) && e.openFind();
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.closeFind",
  weight: 200,
  when: f.and(Ou, MC),
  primary: 9,
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    (e instanceof vd || e instanceof ut) && e.closeFind();
  }
});
var sh;
V.registerCommandAndKeybindingRule({
  id: "list.scrollUp",
  weight: 200,
  when: f.and(te, (sh = zC) == null ? void 0 : sh.negate()),
  primary: 2064,
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    e && (e.scrollTop -= 10);
  }
});
var nh;
V.registerCommandAndKeybindingRule({
  id: "list.scrollDown",
  weight: 200,
  when: f.and(
    te,
    (nh = UC) == null ? void 0 : nh.negate()
  ),
  primary: 2066,
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    e && (e.scrollTop += 10);
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.scrollLeft",
  weight: 200,
  when: te,
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    e && (e.scrollLeft -= 10);
  }
});
V.registerCommandAndKeybindingRule({
  id: "list.scrollRight",
  weight: 200,
  when: te,
  handler: (c) => {
    const e = c.get(B).lastFocusedList;
    e && (e.scrollLeft += 10);
  }
});
var gk = '.file-icon-themable-tree .align-icon-with-twisty .monaco-tl-twistie:not(.force-twistie):not(.collapsible),.file-icon-themable-tree .monaco-tl-twistie.force-no-twistie,.file-icon-themable-tree.align-icons-and-twisties .monaco-tl-twistie:not(.force-twistie):not(.collapsible),.file-icon-themable-tree.hide-arrows .monaco-tl-twistie:not(.force-twistie){background-image:none!important;padding-right:0!important;visibility:hidden;width:0!important}.file-icon-themable-tree .monaco-list-row .content .monaco-highlighted-label .highlight,.monaco-tl-contents .monaco-highlighted-label .highlight{background-color:var(--vscode-list-filterMatchBackground);color:unset!important;outline:1px dotted var(--vscode-list-filterMatchBorder);outline-offset:-1px}.monaco-workbench .tree-explorer-viewlet-tree-view{height:100%}.monaco-workbench .tree-explorer-viewlet-tree-view .message{display:flex;padding:4px 12px 4px 18px;user-select:text;-webkit-user-select:text}.monaco-workbench .tree-explorer-viewlet-tree-view .message p{margin-bottom:0;margin-top:0;padding-bottom:4px}.monaco-workbench .tree-explorer-viewlet-tree-view .message ul{padding-left:24px}.monaco-workbench .tree-explorer-viewlet-tree-view .message a{color:var(--vscode-textLink-foreground)}.monaco-workbench .tree-explorer-viewlet-tree-view .message.hide{display:none}.monaco-workbench .tree-explorer-viewlet-tree-view .customview-tree{height:100%}.monaco-workbench .tree-explorer-viewlet-tree-view .customview-tree.hide{display:none}.monaco-workbench .pane>.pane-body>.welcome-view{box-sizing:border-box;display:flex;flex-direction:column;height:100%;width:100%}.monaco-workbench .pane>.pane-body.welcome>:not(.welcome-view),.monaco-workbench .pane>.pane-body:not(.welcome)>.welcome-view{display:none}.monaco-workbench .pane>.pane-body .welcome-view-content{align-items:center;box-sizing:border-box;display:flex;flex-direction:column;padding:0 20px 1em}.monaco-workbench .pane>.pane-body .welcome-view-content>.button-container{max-width:300px;width:100%}.monaco-workbench:not(.reduce-motion) .pane>.pane-body .welcome-view-content>.button-container{transition:max-width .2s ease-out}.monaco-workbench .pane>.pane-body .welcome-view-content.wide>.button-container{max-width:100%}.monaco-workbench .pane>.pane-body .welcome-view-content>.button-container>.monaco-button{max-width:300px}.monaco-workbench .pane>.pane-body .welcome-view-content>p{width:100%}.monaco-workbench .pane>.pane-body .welcome-view-content>*{margin-block-end:0;margin-block-start:1em;margin-inline-end:0;margin-inline-start:0}.customview-tree .monaco-list-row .monaco-tl-contents.align-icon-with-twisty:before{display:none}.customview-tree .monaco-list-row .monaco-tl-contents:not(.align-icon-with-twisty):before{display:inline-block}.customview-tree .monaco-list .monaco-list-row{padding-left:0;padding-right:12px}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item{display:flex;flex:1;flex-wrap:nowrap;height:22px;line-height:22px;overflow:hidden;padding-left:3px;text-overflow:ellipsis}.customview-tree .monaco-list .monaco-list-row.selected .custom-view-tree-node-item .custom-view-tree-node-item-checkbox{background-color:var(--vscode-checkbox-selectBackground);border:1px solid var(--vscode-checkbox-selectBorder)}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .custom-view-tree-node-item-checkbox{background-color:var(--vscode-checkbox-background);border:1px solid var(--vscode-checkbox-border);height:16px;margin:3px 6px 3px 0;opacity:1;padding:0;width:16px}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .custom-view-tree-node-item-checkbox.codicon{font-size:13px;line-height:15px}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .monaco-inputbox{flex:1;line-height:normal}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .custom-view-tree-node-item-resourceLabel{flex:1;overflow:hidden;text-overflow:ellipsis}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .monaco-icon-label-container:after{content:"";display:block}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item>.custom-view-tree-node-item-resourceLabel>.custom-view-tree-node-item-icon,.timeline-tree-view .monaco-list .monaco-list-row .custom-view-tree-node-item>.custom-view-tree-node-item-icon{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;align-items:center;background-position:0;background-repeat:no-repeat;background-size:16px;display:flex;height:22px;justify-content:center;padding-right:6px;width:16px}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item>.custom-view-tree-node-item-resourceLabel>.custom-view-tree-node-item-icon.disabled{opacity:.6}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item>.custom-view-tree-node-item-resourceLabel>.custom-view-tree-node-item-icon.codicon.codicon-modifier-spin{margin-left:-6px;padding-left:6px}.customview-tree .monaco-list .monaco-list-row.selected .custom-view-tree-node-item>.custom-view-tree-node-item-resourceLabel>.custom-view-tree-node-item-icon.codicon{color:currentColor!important}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .custom-view-tree-node-item-resourceLabel .monaco-icon-label-container>.monaco-icon-name-container{flex:1}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .custom-view-tree-node-item-resourceLabel:after{margin-right:4px;padding-right:0}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .actions{display:none}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .actions .action-label{padding:2px}.customview-tree .monaco-list .monaco-list-row.focused .custom-view-tree-node-item .actions,.customview-tree .monaco-list .monaco-list-row.selected .custom-view-tree-node-item .actions,.customview-tree .monaco-list .monaco-list-row:hover .custom-view-tree-node-item .actions{display:block}.viewpane-filter-container{cursor:default;display:flex}.viewpane-filter-container.grow{flex:1}.viewpane-filter-container>.viewpane-filter{align-items:center;display:flex;flex:1;position:relative}.viewpane-filter-container>.viewpane-filter .monaco-inputbox{flex:1;font-size:12px;height:24px}.pane-header .viewpane-filter-container>.viewpane-filter .monaco-inputbox .monaco-inputbox{height:20px;line-height:18px}.monaco-workbench.vs .viewpane-filter-container>.viewpane-filter .monaco-inputbox{height:25px}.viewpane-filter-container>.viewpane-filter>.viewpane-filter-controls{align-items:center;bottom:0;display:flex;position:absolute;right:0;top:0}.viewpane-filter-container>.viewpane-filter>.viewpane-filter-controls>.viewpane-filter-badge{border-radius:2px;margin:4px 0;padding:0 8px}.viewpane-filter.small>.viewpane-filter-controls>.viewpane-filter-badge,.viewpane-filter>.viewpane-filter-controls>.viewpane-filter-badge.hidden{display:none}.viewpane-filter>.viewpane-filter-controls>.monaco-action-bar .action-item .action-label.codicon.filter{padding:2px}.panel>.title .monaco-action-bar .action-item.viewpane-filter-container{margin-right:10px;max-width:400px;min-width:150px}.pane-body .viewpane-filter-container:not(:empty){flex:1;height:auto;margin:10px 20px}.pane-body .viewpane-filter-container>.viewpane-filter>.viewpane-filter-controls .monaco-action-bar .action-item{margin-right:4px}.viewpane-filter>.viewpane-filter-controls .monaco-action-bar .action-label.codicon.codicon-filter.checked{background-color:var(--vscode-inputOption-activeBackground);border-color:var(--vscode-inputOption-activeBorder);color:var(--vscode-inputOption-activeForeground)}';
oe(gk, {});
class pk extends j {
  constructor(e, t) {
    super("vs.tree.collapse", u("collapse all", "Collapse All"), "collapse-all", t), this.viewer = e;
  }
  async run() {
    this.viewer.collapseAll(), this.viewer.setSelection([]), this.viewer.setFocus([]);
  }
}
class mk extends E {
  constructor() {
    super(...arguments), this._onDidChangeCheckboxState = this._register(new w()), this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event;
  }
  setCheckboxState(e) {
    this._onDidChangeCheckboxState.fire([e]);
  }
}
const Nn = class Nn extends E {
  constructor(e, t, i) {
    super(), this.checkboxStateHandler = t, this.hoverDelegate = i, this.isDisposed = !1, this._onDidChangeState = new w(), this.onDidChangeState = this._onDidChangeState.event, this.checkboxContainer = e;
  }
  render(e) {
    e.checkbox && (this.toggle ? (this.toggle.checked = e.checkbox.isChecked, this.toggle.setIcon(this.toggle.checked ? he.check : void 0)) : this.createCheckbox(e));
  }
  createCheckbox(e) {
    e.checkbox && (this.toggle = new jC({
      isChecked: e.checkbox.isChecked,
      title: "",
      icon: e.checkbox.isChecked ? he.check : void 0,
      ...Hu
    }), this.setHover(e.checkbox), this.setAccessibilityInformation(e.checkbox), this.toggle.domNode.classList.add(Nn.checkboxClass), ae(this.checkboxContainer, this.toggle.domNode), this.registerListener(e));
  }
  registerListener(e) {
    this.toggle && (this._register({ dispose: () => this.removeCheckbox() }), this._register(this.toggle), this._register(this.toggle.onChange(() => {
      this.setCheckbox(e);
    })));
  }
  setHover(e) {
    this.toggle && (this.hover ? this.hover.update(e.tooltip) : (this.hover = Pu(this.hoverDelegate, this.toggle.domNode, this.checkboxHoverContent(e)), this._register(this.hover)));
  }
  setCheckbox(e) {
    this.toggle && e.checkbox && (e.checkbox.isChecked = this.toggle.checked, this.toggle.setIcon(this.toggle.checked ? he.check : void 0), this.setHover(e.checkbox), this.setAccessibilityInformation(e.checkbox), this.checkboxStateHandler.setCheckboxState(e));
  }
  checkboxHoverContent(e) {
    return e.tooltip ? e.tooltip : e.isChecked ? u("checked", "Checked") : u("unchecked", "Unchecked");
  }
  setAccessibilityInformation(e) {
    this.toggle && e.accessibilityInformation && (this.toggle.domNode.ariaLabel = e.accessibilityInformation.label, e.accessibilityInformation.role && (this.toggle.domNode.role = e.accessibilityInformation.role));
  }
  removeCheckbox() {
    const e = this.checkboxContainer.children;
    for (const t of e)
      this.checkboxContainer.removeChild(t);
  }
};
Nn.checkboxClass = "custom-view-tree-node-item-checkbox";
let kn = Nn, Ha = class extends jn {
  constructor(e, t, i, o, s, n, r, a, d, h, g) {
    super({ ...e, titleMenuId: k.ViewTitle, donotForwardArgs: !1 }, t, i, o, s, n, r, a, d, h);
    const { treeView: p } = N.as(nt.ViewsRegistry).getView(e.id);
    this.treeView = p, this._register(this.treeView.onDidChangeActions(() => this.updateActions(), this)), this._register(this.treeView.onDidChangeTitle((m) => this.updateTitle(m))), this._register(this.treeView.onDidChangeDescription((m) => this.updateTitleDescription(m))), this._register(M(() => {
      this._container && this.treeView.container && this._container === this.treeView.container && this.treeView.setVisibility(!1);
    })), this._register(this.onDidChangeBodyVisibility(() => this.updateTreeVisibility())), this._register(this.treeView.onDidChangeWelcomeState(() => this._onDidChangeViewWelcomeState.fire())), e.title !== this.treeView.title && this.updateTitle(this.treeView.title), e.titleDescription !== this.treeView.description && this.updateTitleDescription(this.treeView.description), this._actionRunner = new tp(g, () => this.treeView.getSelection()), this.updateTreeVisibility();
  }
  focus() {
    super.focus(), this.treeView.focus();
  }
  renderBody(e) {
    this._container = e, super.renderBody(e), this.renderTreeView(e);
  }
  shouldShowWelcome() {
    return (this.treeView.dataProvider === void 0 || !!this.treeView.dataProvider.isTreeEmpty) && this.treeView.message === void 0;
  }
  layoutBody(e, t) {
    super.layoutBody(e, t), this.layoutTreeView(e, t);
  }
  getOptimalWidth() {
    return this.treeView.getOptimalWidth();
  }
  renderTreeView(e) {
    this.treeView.show(e);
  }
  layoutTreeView(e, t) {
    this.treeView.layout(e, t);
  }
  updateTreeVisibility() {
    this.treeView.setVisibility(this.isBodyVisible());
  }
  getActionRunner() {
    return this._actionRunner;
  }
  getActionsContext() {
    return { $treeViewId: this.id, $focusedTreeItem: !0, $selectedTreeItems: !0 };
  }
};
Ha = y([
  l(1, be),
  l(2, Ie),
  l(3, x),
  l(4, F),
  l(5, Me),
  l(6, W),
  l(7, Ti),
  l(8, z),
  l(9, Xe),
  l(10, We)
], Ha);
class Sr {
  constructor() {
    this.label = { label: "root" }, this.handle = "0", this.parentHandle = void 0, this.collapsibleState = Gt.Expanded, this.children = void 0;
  }
}
function $g(c, e) {
  const t = Te.getCommand(c.originalId ? c.originalId : c.id);
  if (t) {
    const i = G.getCommand(t.id), o = i && i.precondition;
    if (o)
      return e.contextMatchesRules(o);
  }
  return !0;
}
function $l(c) {
  return !!c && typeof c != "string" && "element" in c && "dispose" in c;
}
const bk = u(
  "no-dataprovider",
  "There is no data provider registered that can provide view data."
), ep = new K("customTreeView", !1);
class Ck extends Vs {
}
let Pa = class extends E {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m, C, b) {
    super(), this.id = e, this._title = t, this.themeService = i, this.instantiationService = o, this.commandService = s, this.configurationService = n, this.progressService = r, this.contextMenuService = a, this.keybindingService = d, this.notificationService = h, this.viewDescriptorService = g, this.hoverService = p, this.contextKeyService = m, this.activityService = C, this.logService = b, this.isVisible = !1, this._hasIconForParentNode = !1, this._hasIconForLeafNode = !1, this.focused = !1, this._canSelectMany = !1, this._manuallyManageCheckboxes = !1, this.elementsToRefresh = [], this.lastSelection = [], this._onDidExpandItem = this._register(new w()), this.onDidExpandItem = this._onDidExpandItem.event, this._onDidCollapseItem = this._register(new w()), this.onDidCollapseItem = this._onDidCollapseItem.event, this._onDidChangeSelectionAndFocus = this._register(new w()), this.onDidChangeSelectionAndFocus = this._onDidChangeSelectionAndFocus.event, this._onDidChangeVisibility = this._register(new w()), this.onDidChangeVisibility = this._onDidChangeVisibility.event, this._onDidChangeActions = this._register(new w()), this.onDidChangeActions = this._onDidChangeActions.event, this._onDidChangeWelcomeState = this._register(new w()), this.onDidChangeWelcomeState = this._onDidChangeWelcomeState.event, this._onDidChangeTitle = this._register(new w()), this.onDidChangeTitle = this._onDidChangeTitle.event, this._onDidChangeDescription = this._register(new w()), this.onDidChangeDescription = this._onDidChangeDescription.event, this._onDidChangeCheckboxState = this._register(new w()), this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event, this._onDidCompleteRefresh = this._register(new w()), this._isInitialized = !1, this._height = 0, this._width = 0, this.refreshing = !1, this.root = new Sr(), this.lastActive = this.root;
  }
  initialize() {
    this._isInitialized || (this._isInitialized = !0, this.contextKeyService.bufferChangeEvents(() => {
      this.initializeShowCollapseAllAction(), this.initializeCollapseAllToggle(), this.initializeShowRefreshAction();
    }), this.treeViewDnd = this.instantiationService.createInstance(Ua, this.id), this._dragAndDropController && (this.treeViewDnd.controller = this._dragAndDropController), this._register(this.configurationService.onDidChangeConfiguration((e) => {
      e.affectsConfiguration("explorer.decorations") && this.doRefresh([this.root]);
    })), this._register(this.viewDescriptorService.onDidChangeLocation(({ views: e, from: t, to: i }) => {
      var o;
      e.some((s) => s.id === this.id) && ((o = this.tree) == null || o.updateOptions({ overrideStyles: { listBackground: this.viewLocation === 1 ? Er : tn } }));
    })), this.registerActions(), this.create());
  }
  get viewContainer() {
    return this.viewDescriptorService.getViewContainerByViewId(this.id);
  }
  get viewLocation() {
    return this.viewDescriptorService.getViewLocationById(this.id);
  }
  get dragAndDropController() {
    return this._dragAndDropController;
  }
  set dragAndDropController(e) {
    this._dragAndDropController = e, this.treeViewDnd && (this.treeViewDnd.controller = e);
  }
  get dataProvider() {
    return this._dataProvider;
  }
  set dataProvider(e) {
    if (e) {
      const t = this;
      this._dataProvider = new class {
        constructor() {
          this._isEmpty = !0, this._onDidChangeEmpty = new w(), this.onDidChangeEmpty = this._onDidChangeEmpty.event;
        }
        get isTreeEmpty() {
          return this._isEmpty;
        }
        async getChildren(i) {
          let o;
          const s = [];
          if (i && i.children ? o = i.children : (i = i ?? t.root, i.children = await (i instanceof Sr ? e.getChildren() : e.getChildren(i)), o = i.children ?? [], o.forEach((n) => {
            var r, a;
            n.parent = i, !t.manuallyManageCheckboxes && ((r = i == null ? void 0 : i.checkbox) == null ? void 0 : r.isChecked) === !0 && ((a = n.checkbox) == null ? void 0 : a.isChecked) === !1 && (n.checkbox.isChecked = !0, s.push(n));
          })), i instanceof Sr) {
            const n = this._isEmpty;
            this._isEmpty = o.length === 0, n !== this._isEmpty && this._onDidChangeEmpty.fire();
          }
          return s.length > 0 && t._onDidChangeCheckboxState.fire(s), o;
        }
      }(), this._dataProvider.onDidChangeEmpty && this._register(this._dataProvider.onDidChangeEmpty(() => {
        this.updateCollapseAllToggle(), this._onDidChangeWelcomeState.fire();
      })), this.updateMessage(), this.refresh();
    } else
      this._dataProvider = void 0, this.updateMessage();
    this._onDidChangeWelcomeState.fire();
  }
  get message() {
    return this._message;
  }
  set message(e) {
    this._message = e, this.updateMessage(), this._onDidChangeWelcomeState.fire();
  }
  get title() {
    return this._title;
  }
  set title(e) {
    this._title = e, this._onDidChangeTitle.fire(this._title);
  }
  get description() {
    return this._description;
  }
  set description(e) {
    this._description = e, this._onDidChangeDescription.fire(this._description);
  }
  get badge() {
    return this._badge;
  }
  set badge(e) {
    var t, i;
    if (!(((t = this._badge) == null ? void 0 : t.value) === (e == null ? void 0 : e.value) && ((i = this._badge) == null ? void 0 : i.tooltip) === (e == null ? void 0 : e.tooltip)) && (this._badgeActivity && (this._badgeActivity.dispose(), this._badgeActivity = void 0), this._badge = e, e)) {
      const o = {
        badge: new to(e.value, () => e.tooltip),
        priority: 50
      };
      this._badgeActivity = this.activityService.showViewActivity(this.id, o);
    }
  }
  get canSelectMany() {
    return this._canSelectMany;
  }
  set canSelectMany(e) {
    var i;
    const t = this._canSelectMany;
    this._canSelectMany = e, this._canSelectMany !== t && ((i = this.tree) == null || i.updateOptions({ multipleSelectionSupport: this.canSelectMany }));
  }
  get manuallyManageCheckboxes() {
    return this._manuallyManageCheckboxes;
  }
  set manuallyManageCheckboxes(e) {
    this._manuallyManageCheckboxes = e;
  }
  get hasIconForParentNode() {
    return this._hasIconForParentNode;
  }
  get hasIconForLeafNode() {
    return this._hasIconForLeafNode;
  }
  get visible() {
    return this.isVisible;
  }
  initializeShowCollapseAllAction(e = !1) {
    return this.collapseAllContext || (this.collapseAllContextKey = new K(`treeView.${this.id}.enableCollapseAll`, e, u(
      "treeView.enableCollapseAll",
      "Whether the the tree view with id {0} enables collapse all.",
      this.id
    )), this.collapseAllContext = this.collapseAllContextKey.bindTo(this.contextKeyService)), !0;
  }
  get showCollapseAllAction() {
    var e;
    return this.initializeShowCollapseAllAction(), !!((e = this.collapseAllContext) != null && e.get());
  }
  set showCollapseAllAction(e) {
    var t;
    this.initializeShowCollapseAllAction(e), (t = this.collapseAllContext) == null || t.set(e);
  }
  initializeShowRefreshAction(e = !1) {
    this.refreshContext || (this.refreshContextKey = new K(`treeView.${this.id}.enableRefresh`, e, u(
      "treeView.enableRefresh",
      "Whether the tree view with id {0} enables refresh.",
      this.id
    )), this.refreshContext = this.refreshContextKey.bindTo(this.contextKeyService));
  }
  get showRefreshAction() {
    var e;
    return this.initializeShowRefreshAction(), !!((e = this.refreshContext) != null && e.get());
  }
  set showRefreshAction(e) {
    var t;
    this.initializeShowRefreshAction(e), (t = this.refreshContext) == null || t.set(e);
  }
  registerActions() {
    const e = this;
    this._register(P(class extends ye {
      constructor() {
        super({
          id: `workbench.actions.treeView.${e.id}.refresh`,
          title: u("refresh", "Refresh"),
          menu: {
            id: k.ViewTitle,
            when: f.and(f.equals("view", e.id), e.refreshContextKey),
            group: "navigation",
            order: Number.MAX_SAFE_INTEGER - 1
          },
          icon: he.refresh
        });
      }
      async run() {
        return e.refresh();
      }
    })), this._register(P(class extends ye {
      constructor() {
        super({
          id: `workbench.actions.treeView.${e.id}.collapseAll`,
          title: u("collapseAll", "Collapse All"),
          menu: {
            id: k.ViewTitle,
            when: f.and(f.equals("view", e.id), e.collapseAllContextKey),
            group: "navigation",
            order: Number.MAX_SAFE_INTEGER
          },
          precondition: e.collapseAllToggleContextKey,
          icon: he.collapseAll
        });
      }
      async run() {
        if (e.tree)
          return new pk(e.tree, !0).run();
      }
    }));
  }
  setVisibility(e) {
    this.initialize(), e = !!e, this.isVisible !== e && (this.isVisible = e, this.tree && (this.isVisible ? hi(this.tree.getHTMLElement()) : gi(this.tree.getHTMLElement()), this.isVisible && this.elementsToRefresh.length && this.dataProvider && (this.doRefresh(this.elementsToRefresh), this.elementsToRefresh = [])), $C(() => {
      this.dataProvider && this._onDidChangeVisibility.fire(this.isVisible);
    }), this.visible && this.activate());
  }
  focus(e = !0, t) {
    if (this.tree && this.root.children && this.root.children.length > 0) {
      const i = t ?? this.tree.getSelection()[0];
      i && e && this.tree.reveal(i, 0.5), this.tree.domFocus();
    } else
      this.tree ? this.tree.domFocus() : this.domNode.focus();
  }
  show(e) {
    this._container = e, ae(e, this.domNode);
  }
  create() {
    this.domNode = Y(".tree-explorer-viewlet-tree-view"), this.messageElement = ae(this.domNode, Y(".message")), this.updateMessage(), this.treeContainer = ae(this.domNode, Y(".customview-tree")), this.treeContainer.classList.add("file-icon-themable-tree", "show-file-icons");
    const e = this._register(pi(this.domNode));
    this._register(e.onDidFocus(() => this.focused = !0)), this._register(e.onDidBlur(() => this.focused = !1));
  }
  createTree() {
    const e = Ac.bind(void 0, this.instantiationService), t = this._register(this.instantiationService.createInstance(Ma, this.id));
    this.treeLabels = this._register(this.instantiationService.createInstance(On, this));
    const i = this.instantiationService.createInstance(wk, this, (h) => this.progressService.withProgress({ location: this.id }, () => h)), o = new yk(this.themeService), s = this._register(new mk()), n = this.instantiationService.createInstance(ms, this.id, t, this.treeLabels, e, o, s, this.manuallyManageCheckboxes);
    this._register(n.onDidChangeCheckboxState((h) => this._onDidChangeCheckboxState.fire(h)));
    const r = this._title;
    this.tree = this._register(this.instantiationService.createInstance(Ck, this.id, this.treeContainer, new vk(), [n], i, {
      identityProvider: new fk(),
      accessibilityProvider: {
        getAriaLabel(h) {
          if (h.accessibilityInformation)
            return h.accessibilityInformation.label;
          if (os(h.tooltip))
            return h.tooltip;
          {
            if (h.resourceUri && !h.label)
              return null;
            let g = "";
            return h.label && (g += h.label.label + " "), h.description && (g += h.description), g;
          }
        },
        getRole(h) {
          var g;
          return ((g = h.accessibilityInformation) == null ? void 0 : g.role) ?? "treeitem";
        },
        getWidgetAriaLabel() {
          return r;
        }
      },
      keyboardNavigationLabelProvider: {
        getKeyboardNavigationLabel: (h) => h.label ? h.label.label : h.resourceUri ? Le(A.revive(h.resourceUri)) : void 0
      },
      expandOnlyOnTwistieClick: (h) => !!h.command || !!h.checkbox || this.configurationService.getValue("workbench.tree.expandMode") === "doubleClick",
      collapseByDefault: (h) => h.collapsibleState !== Gt.Expanded,
      multipleSelectionSupport: this.canSelectMany,
      dnd: this.treeViewDnd,
      overrideStyles: {
        listBackground: this.viewLocation === 1 ? Er : tn
      }
    })), t.setContextKeyService(this.tree.contextKeyService), o.tree = this.tree;
    const a = new tp(this.notificationService, () => this.tree.getSelection());
    n.actionRunner = a, this.tree.contextKeyService.createKey(this.id, !0), ep.bindTo(this.tree.contextKeyService).set(!0), this._register(this.tree.onContextMenu((h) => this.onContextMenu(t, h, a))), this._register(this.tree.onDidChangeSelection((h) => {
      var g;
      this.lastSelection = h.elements, this.lastActive = ((g = this.tree) == null ? void 0 : g.getFocus()[0]) ?? this.lastActive, this._onDidChangeSelectionAndFocus.fire({ selection: this.lastSelection, focus: this.lastActive });
    })), this._register(this.tree.onDidChangeFocus((h) => {
      var g;
      h.elements.length && h.elements[0] !== this.lastActive && (this.lastActive = h.elements[0], this.lastSelection = ((g = this.tree) == null ? void 0 : g.getSelection()) ?? this.lastSelection, this._onDidChangeSelectionAndFocus.fire({ selection: this.lastSelection, focus: this.lastActive }));
    })), this._register(this.tree.onDidChangeCollapseState((h) => {
      if (!h.node.element)
        return;
      const g = Array.isArray(h.node.element.element) ? h.node.element.element[0] : h.node.element.element;
      h.node.collapsed ? this._onDidCollapseItem.fire(g) : this._onDidExpandItem.fire(g);
    })), this.tree.setInput(this.root).then(() => this.updateContentAreas()), this._register(this.tree.onDidOpen(async (h) => {
      if (!h.browserEvent || h.browserEvent.target && h.browserEvent.target.classList.contains(kn.checkboxClass))
        return;
      const g = this.tree.getSelection(), p = await this.resolveCommand(g.length === 1 ? g[0] : void 0);
      if (p && $g(p, this.contextKeyService)) {
        let m = p.arguments || [];
        (p.id === ef || p.id === tf) && (m = [...m, h]);
        try {
          await this.commandService.executeCommand(p.id, ...m);
        } catch (C) {
          this.notificationService.error(C);
        }
      }
    })), this._register(t.onDidChange((h) => {
      var g, p;
      (g = this.tree) != null && g.hasNode(h) && ((p = this.tree) == null || p.rerender(h));
    }));
  }
  async resolveCommand(e) {
    let t = e == null ? void 0 : e.command;
    return e && !t && e instanceof wd && e.hasResolve && (await e.resolve(new $e().token), t = e.command), t;
  }
  onContextMenu(e, t, i) {
    this.hoverService.hideHover();
    const o = t.element;
    if (o === null)
      return;
    const s = t.browserEvent;
    s.preventDefault(), s.stopPropagation(), this.tree.setFocus([o]);
    const n = e.getResourceContextActions(o);
    n.length && this.contextMenuService.showContextMenu({
      getAnchor: () => t.anchor,
      getActions: () => n,
      getActionViewItem: (r) => {
        const a = this.keybindingService.lookupKeybinding(r.id);
        if (a)
          return new of(r, r, { label: !0, keybinding: a.getLabel() });
      },
      onHide: (r) => {
        r && this.tree.domFocus();
      },
      getActionsContext: () => ({ $treeViewId: this.id, $treeItemHandle: o.handle }),
      actionRunner: i
    });
  }
  updateMessage() {
    this._message ? this.showMessage(this._message) : this.dataProvider ? this.hideMessage() : this.showMessage(bk), this.updateContentAreas();
  }
  showMessage(e) {
    $l(this._messageValue) && this._messageValue.dispose(), _i(e) && !this.markdownRenderer && (this.markdownRenderer = this.instantiationService.createInstance(kh, {})), this._messageValue = _i(e) ? this.markdownRenderer.render(e) : e, this.messageElement && (this.messageElement.classList.remove("hide"), this.resetMessageElement(), typeof this._messageValue == "string" && !Hr(this._messageValue) ? this.messageElement.textContent = this._messageValue : $l(this._messageValue) && this.messageElement.appendChild(this._messageValue.element), this.layout(this._height, this._width));
  }
  hideMessage() {
    var e;
    this.resetMessageElement(), (e = this.messageElement) == null || e.classList.add("hide"), this.layout(this._height, this._width);
  }
  resetMessageElement() {
    this.messageElement && Ut(this.messageElement);
  }
  layout(e, t) {
    var i;
    if (e && t && this.messageElement && this.treeContainer) {
      this._height = e, this._width = t;
      const o = e - sf(this.messageElement);
      this.treeContainer.style.height = o + "px", (i = this.tree) == null || i.layout(o, t);
    }
  }
  getOptimalWidth() {
    if (this.tree) {
      const e = this.tree.getHTMLElement(), t = [].slice.call(e.querySelectorAll(".outline-item-label > a"));
      return nf(e, t);
    }
    return 0;
  }
  async refresh(e) {
    if (this.dataProvider && this.tree) {
      this.refreshing && await _.toPromise(this._onDidCompleteRefresh.event), e || (e = [this.root], this.elementsToRefresh = []);
      for (const t of e)
        t.children = void 0;
      if (this.isVisible)
        return this.doRefresh(e);
      if (this.elementsToRefresh.length) {
        const t = /* @__PURE__ */ new Set();
        this.elementsToRefresh.forEach((i) => t.add(i.handle));
        for (const i of e)
          t.has(i.handle) || this.elementsToRefresh.push(i);
      } else
        this.elementsToRefresh.push(...e);
    }
  }
  async expand(e) {
    const t = this.tree;
    if (t)
      try {
        e = Array.isArray(e) ? e : [e];
        for (const i of e)
          await t.expand(i, !1);
      } catch {
      }
  }
  isCollapsed(e) {
    var t;
    return !!((t = this.tree) != null && t.isCollapsed(e));
  }
  setSelection(e) {
    var t;
    (t = this.tree) == null || t.setSelection(e);
  }
  getSelection() {
    var e;
    return ((e = this.tree) == null ? void 0 : e.getSelection()) ?? [];
  }
  setFocus(e) {
    this.tree && (e ? (this.focus(!0, e), this.tree.setFocus([e])) : this.tree.setFocus([]));
  }
  async reveal(e) {
    if (this.tree)
      return this.tree.reveal(e);
  }
  async doRefresh(e) {
    const t = this.tree;
    if (t && this.visible) {
      this.refreshing = !0;
      const i = t.getSelection();
      try {
        await Promise.all(e.map((s) => t.updateChildren(s, !0, !0)));
      } catch (s) {
        this.logService.error(s);
      }
      const o = t.getSelection();
      (i.length !== o.length || i.some((s, n) => s.handle !== o[n].handle)) && (this.lastSelection = o, this._onDidChangeSelectionAndFocus.fire({ selection: this.lastSelection, focus: this.lastActive })), this.refreshing = !1, this._onDidCompleteRefresh.fire(), this.updateContentAreas(), this.focused && this.focus(!1), this.updateCollapseAllToggle();
    }
  }
  initializeCollapseAllToggle() {
    this.collapseAllToggleContext || (this.collapseAllToggleContextKey = new K(`treeView.${this.id}.toggleCollapseAll`, !1, u(
      "treeView.toggleCollapseAll",
      "Whether collapse all is toggled for the tree view with id {0}.",
      this.id
    )), this.collapseAllToggleContext = this.collapseAllToggleContextKey.bindTo(this.contextKeyService));
  }
  updateCollapseAllToggle() {
    var e;
    this.showCollapseAllAction && (this.initializeCollapseAllToggle(), (e = this.collapseAllToggleContext) == null || e.set(!!this.root.children && this.root.children.length > 0 && this.root.children.some((t) => t.collapsibleState !== Gt.None)));
  }
  updateContentAreas() {
    const e = !this.root.children || this.root.children.length === 0;
    this._messageValue && e && !this.refreshing && this.treeContainer ? (this.dragAndDropController || this.treeContainer.classList.add("hide"), this.domNode.setAttribute("tabindex", "0")) : this.treeContainer && (this.treeContainer.classList.remove("hide"), this.domNode.removeAttribute("tabindex"));
  }
  get container() {
    return this._container;
  }
};
Pa = y([
  l(2, z),
  l(3, W),
  l(4, Bi),
  l(5, x),
  l(6, Kn),
  l(7, Ie),
  l(8, be),
  l(9, We),
  l(10, Me),
  l(11, Lt),
  l(12, F),
  l(13, Eo),
  l(14, rt)
], Pa);
class fk {
  getId(e) {
    return e.handle;
  }
}
class vk {
  getHeight(e) {
    return ms.ITEM_HEIGHT;
  }
  getTemplateId(e) {
    return ms.TREE_TEMPLATE_ID;
  }
}
class wk {
  constructor(e, t) {
    this.treeView = e, this.withProgress = t;
  }
  hasChildren(e) {
    return !!this.treeView.dataProvider && e.collapsibleState !== Gt.None;
  }
  async getChildren(e) {
    let t = [];
    if (this.treeView.dataProvider)
      try {
        t = await this.withProgress(this.treeView.dataProvider.getChildren(e)) ?? [];
      } catch (i) {
        if (!i.message.startsWith("Bad progress location:"))
          throw i;
      }
    return t;
  }
}
var Gi;
let ms = (Gi = class extends E {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m) {
    super(), this.treeViewId = e, this.menus = t, this.labels = i, this.actionViewItemProvider = o, this.aligner = s, this.checkboxStateHandler = n, this.manuallyManageCheckboxes = r, this.themeService = a, this.configurationService = d, this.labelService = h, this.hoverService = g, this.treeViewsService = p, this.contextKeyService = m, this._onDidChangeCheckboxState = this._register(new w()), this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event, this._hasCheckbox = !1, this._renderedElements = /* @__PURE__ */ new Map(), this._hoverDelegate = {
      showHover: (C) => this.hoverService.showHover(C),
      delay: this.configurationService.getValue("workbench.hover.delay")
    }, this._register(this.themeService.onDidFileIconThemeChange(() => this.rerender())), this._register(this.themeService.onDidColorThemeChange(() => this.rerender())), this._register(n.onDidChangeCheckboxState((C) => {
      this.updateCheckboxes(C);
    }));
  }
  get templateId() {
    return Gi.TREE_TEMPLATE_ID;
  }
  set actionRunner(e) {
    this._actionRunner = e;
  }
  renderTemplate(e) {
    e.classList.add("custom-view-tree-node-item");
    const t = ae(e, Y("")), i = this.labels.create(e, { supportHighlights: !0, hoverDelegate: this._hoverDelegate }), o = Sh(i.element, Y(".custom-view-tree-node-item-icon")), s = ae(i.element, Y(".actions")), n = new Ro(s, {
      actionViewItemProvider: this.actionViewItemProvider
    });
    return { resourceLabel: i, icon: o, checkboxContainer: t, actionBar: n, container: e, elementDisposable: new Z() };
  }
  getHover(e, t, i) {
    return !(i instanceof wd) || !i.hasResolve ? t && !i.tooltip ? void 0 : i.tooltip === void 0 ? e : os(i.tooltip) ? i.tooltip !== "" ? i.tooltip : void 0 : { markdown: i.tooltip, markdownNotSupportedFallback: t ? void 0 : qC(i.tooltip) } : {
      markdown: typeof i.tooltip == "string" ? i.tooltip : (o) => new Promise((s) => {
        i.resolve(o).then(() => s(i.tooltip));
      }),
      markdownNotSupportedFallback: t ? void 0 : e ?? ""
    };
  }
  renderElement(e, t, i) {
    var b;
    const o = e.element, s = o.resourceUri ? A.revive(o.resourceUri) : null, n = o.label ? o.label : s ? { label: Le(s) } : void 0, r = os(o.description) ? o.description : s && o.description === !0 ? this.labelService.getUriLabel(Vi(s), { relative: !0 }) : void 0, a = n ? n.label : void 0, d = n && n.highlights && a ? n.highlights.map(([v, J]) => {
      if (v < 0 && (v = a.length + v), J < 0 && (J = a.length + J), v >= a.length || J > a.length)
        return { start: 0, end: 0 };
      if (v > J) {
        const R = v;
        v = J, J = R;
      }
      return { start: v, end: J };
    }) : void 0, h = this.themeService.getColorTheme().type === Hi.LIGHT ? o.icon : o.iconDark, g = h ? A.revive(h) : void 0, p = this.getHover(a, s, o);
    i.actionBar.clear(), i.icon.style.color = "";
    let m = !0;
    if (o.command && (m = $g(o.command, this.contextKeyService)), this.renderCheckbox(o, i), s) {
      const v = this.configurationService.getValue("explorer.decorations"), J = s || A.parse("missing:_icon_resource");
      i.resourceLabel.setResource({ name: a, description: r, resource: J }, {
        fileKind: this.getFileKind(o),
        title: p,
        hideIcon: this.shouldHideResourceLabelIcon(g, o.themeIcon),
        fileDecorations: v,
        extraClasses: ["custom-view-tree-node-item-resourceLabel"],
        matches: d || Di(e.filterData),
        strikethrough: n == null ? void 0 : n.strikethrough,
        disabledCommand: !m,
        labelEscapeNewLines: !0
      });
    } else
      i.resourceLabel.setResource({ name: a, description: r }, {
        title: p,
        hideIcon: !0,
        extraClasses: ["custom-view-tree-node-item-resourceLabel"],
        matches: d || Di(e.filterData),
        strikethrough: n == null ? void 0 : n.strikethrough,
        disabledCommand: !m,
        labelEscapeNewLines: !0
      });
    if (g)
      i.icon.className = "custom-view-tree-node-item-icon", i.icon.style.backgroundImage = Mc(g);
    else {
      let v;
      this.shouldShowThemeIcon(!!s, o.themeIcon) && (v = pe.asClassName(o.themeIcon), o.themeIcon.color && (i.icon.style.color = ((b = this.themeService.getColorTheme().getColor(o.themeIcon.color.id)) == null ? void 0 : b.toString()) ?? "")), i.icon.className = v ? `custom-view-tree-node-item-icon ${v}` : "", i.icon.style.backgroundImage = "";
    }
    m || (i.icon.className = i.icon.className + " disabled", i.container.parentElement && (i.container.parentElement.className = i.container.parentElement.className + " disabled")), i.actionBar.context = { $treeViewId: this.treeViewId, $treeItemHandle: o.handle };
    const C = this.menus.getResourceActions(o);
    C.menu && i.elementDisposable.add(C.menu), i.actionBar.push(C.actions, { icon: !0, label: !1 }), this._actionRunner && (i.actionBar.actionRunner = this._actionRunner), this.setAlignment(i.container, o), this.treeViewsService.addRenderedTreeItemElement(o, i.container), this._renderedElements.set(e.element.handle, { original: e, rendered: i });
  }
  rerender() {
    const e = new Set(this._renderedElements.keys());
    for (const t of e) {
      const i = this._renderedElements.get(t);
      i && (this.disposeElement(i.original, 0, i.rendered), this.renderElement(i.original, 0, i.rendered));
    }
  }
  renderCheckbox(e, t) {
    if (e.checkbox) {
      if (this._hasCheckbox || (this._hasCheckbox = !0, this.rerender()), !t.checkbox) {
        const i = new kn(
          t.checkboxContainer,
          this.checkboxStateHandler,
          this._hoverDelegate
        );
        t.checkbox = i;
      }
      t.checkbox.render(e);
    } else
      t.checkbox && (t.checkbox.dispose(), t.checkbox = void 0);
  }
  setAlignment(e, t) {
    e.parentElement.classList.toggle("align-icon-with-twisty", !this._hasCheckbox && this.aligner.alignIconWithTwisty(t));
  }
  shouldHideResourceLabelIcon(e, t) {
    return !!e || !!t && !this.isFileKindThemeIcon(t);
  }
  shouldShowThemeIcon(e, t) {
    return t ? !(e && this.isFileKindThemeIcon(t)) : !1;
  }
  isFolderThemeIcon(e) {
    return (e == null ? void 0 : e.id) === Or.id;
  }
  isFileKindThemeIcon(e) {
    return e ? e.id === ll.id || this.isFolderThemeIcon(e) : !1;
  }
  getFileKind(e) {
    if (e.themeIcon)
      switch (e.themeIcon.id) {
        case ll.id:
          return Ae.FILE;
        case Or.id:
          return Ae.FOLDER;
      }
    return e.collapsibleState === Gt.Collapsed || e.collapsibleState === Gt.Expanded ? Ae.FOLDER : Ae.FILE;
  }
  updateCheckboxes(e) {
    const t = [];
    if (!this.manuallyManageCheckboxes) {
      for (const i of e)
        if (i.checkbox !== void 0) {
          let o = function(r) {
            for (const a of r.children ?? [])
              a.checkbox !== void 0 && r.checkbox !== void 0 && a.checkbox.isChecked !== r.checkbox.isChecked && (a.checkbox.isChecked = r.checkbox.isChecked, t.push(a), o(a));
          }, n = function(r) {
            if (r.parent && r.parent.checkbox !== void 0 && r.parent.children) {
              if (s.has(r.parent))
                return;
              s.add(r.parent);
              let a = !1, d = !1;
              for (const h of r.parent.children) {
                if (a && d)
                  break;
                h.checkbox !== void 0 && (h.checkbox.isChecked ? d = !0 : a = !0);
              }
              d && !a && r.parent.checkbox.isChecked !== !0 ? (r.parent.checkbox.isChecked = !0, t.push(r.parent), n(r.parent)) : a && r.parent.checkbox.isChecked !== !1 && (r.parent.checkbox.isChecked = !1, t.push(r.parent), n(r.parent));
            }
          };
          o(i);
          const s = /* @__PURE__ */ new Set();
          n(i);
        }
    }
    e = e.concat(t), e.forEach((i) => {
      var s;
      const o = this._renderedElements.get(i.handle);
      o && ((s = o.rendered.checkbox) == null || s.render(i));
    }), this._onDidChangeCheckboxState.fire(e);
  }
  disposeElement(e, t, i) {
    var o;
    i.elementDisposable.clear(), this._renderedElements.delete(e.element.handle), this.treeViewsService.removeRenderedTreeItemElement(e.element), (o = i.checkbox) == null || o.dispose(), i.checkbox = void 0;
  }
  disposeTemplate(e) {
    e.resourceLabel.dispose(), e.actionBar.dispose(), e.elementDisposable.dispose();
  }
}, Gi.ITEM_HEIGHT = 22, Gi.TREE_TEMPLATE_ID = "treeExplorer", Gi);
ms = y([
  l(7, z),
  l(8, x),
  l(9, Ft),
  l(10, Lt),
  l(11, Mu),
  l(12, F)
], ms);
class yk extends E {
  constructor(e) {
    super(), this.themeService = e;
  }
  set tree(e) {
    this._tree = e;
  }
  alignIconWithTwisty(e) {
    if (e.collapsibleState !== Gt.None || !this.hasIcon(e))
      return !1;
    if (this._tree) {
      const t = this._tree.getParentElement(e) || this._tree.getInput();
      return this.hasIcon(t) ? !!t.children && t.children.some(
        (i) => i.collapsibleState !== Gt.None && !this.hasIcon(i)
      ) : !!t.children && t.children.every((i) => i.collapsibleState === Gt.None || !this.hasIcon(i));
    } else
      return !1;
  }
  hasIcon(e) {
    if (this.themeService.getColorTheme().type === Hi.LIGHT ? e.icon : e.iconDark)
      return !0;
    if (e.resourceUri || e.themeIcon) {
      const i = this.themeService.getFileIconTheme();
      return (e.themeIcon ? e.themeIcon.id === Or.id : e.collapsibleState !== Gt.None) ? i.hasFileIcons && i.hasFolderIcons : i.hasFileIcons;
    }
    return !1;
  }
}
class tp extends Tn {
  constructor(e, t) {
    super(), this.getSelectedResources = t, this._register(this.onDidRun((i) => {
      i.error && !Qi(i.error) && e.error(u(
        "command-error",
        "Error running command {1}: {0}. This is likely caused by the extension that contributes {1}.",
        i.error.message,
        i.action.id
      ));
    }));
  }
  async runAction(e, t) {
    const i = this.getSelectedResources();
    let o, s = !1;
    i.length > 1 && (o = i.map((n) => ((n.handle === t.$treeItemHandle || t.$selectedTreeItems) && (s = !0), { $treeViewId: t.$treeViewId, $treeItemHandle: n.handle }))), s || (o = void 0), await e.run(t, o);
  }
}
let Ma = class extends E {
  constructor(e, t) {
    super(), this.id = e, this.menuService = t, this._onDidChange = new w(), this.onDidChange = this._onDidChange.event;
  }
  getResourceActions(e) {
    const t = this.getActions(k.ViewItemContext, e, !0);
    return { menu: t.menu, actions: t.primary };
  }
  getResourceContextActions(e) {
    return this.getActions(k.ViewItemContext, e).secondary;
  }
  setContextKeyService(e) {
    this.contextKeyService = e;
  }
  getActions(e, t, i = !1) {
    if (!this.contextKeyService)
      return { primary: [], secondary: [] };
    const o = this.contextKeyService.createOverlay([
      ["view", this.id],
      ["viewItem", t.contextValue]
    ]), s = this.menuService.createMenu(e, o), a = { primary: [], secondary: [], menu: s };
    return sn(s, { shouldForwardArgs: !0 }, a, "inline"), i ? this._register(s.onDidChange(() => this._onDidChange.fire(t))) : s.dispose(), a;
  }
  dispose() {
    this.contextKeyService = void 0, super.dispose();
  }
};
Ma = y([
  l(1, lt)
], Ma);
let za = class extends Pa {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m, C, b, v, J, R) {
    super(e, t, o, s, n, r, a, d, h, g, p, C, m, v, R), this.extensionId = i, this.extensionService = b, this.telemetryService = J, this.activated = !1;
  }
  activate() {
    this.activated || (this.telemetryService.publicLog2("Extension:ViewActivate", {
      extensionId: new $h(this.extensionId),
      id: this.id
    }), this.createTree(), this.progressService.withProgress({ location: this.id }, () => this.extensionService.activateByEvent(`onView:${this.id}`)).then(() => jc(2e3)).then(() => {
      this.updateMessage();
    }), this.activated = !0);
  }
};
za = y([
  l(3, z),
  l(4, W),
  l(5, Bi),
  l(6, x),
  l(7, Kn),
  l(8, Ie),
  l(9, be),
  l(10, We),
  l(11, Me),
  l(12, F),
  l(13, Lt),
  l(14, ei),
  l(15, Eo),
  l(16, Xe),
  l(17, rt)
], za);
let Ua = class {
  constructor(e, t, i, o, s) {
    this.treeId = e, this.labelService = t, this.instantiationService = i, this.treeViewsDragAndDropService = o, this.logService = s, this.treeItemsTransfer = Pt.getInstance(), this.treeMimeType = `application/vnd.code.tree.${e.toLowerCase()}`;
  }
  set controller(e) {
    this.dndController = e;
  }
  handleDragAndLog(e, t, i, o) {
    return e.handleDrag(t, i, o).then((s) => {
      if (s) {
        const n = [];
        for (const r of s)
          r[0] !== this.treeMimeType && e.dragMimeTypes.findIndex((a) => a === r[0]) < 0 && n.push(r[0]);
        n.length && this.logService.warn(`Drag and drop controller for tree ${this.treeId} adds the following data transfer types but does not declare them in dragMimeTypes: ${n.join(", ")}`);
      }
      return s;
    });
  }
  addExtensionProvidedTransferTypes(e, t) {
    var o;
    if (!e.dataTransfer || !this.dndController)
      return;
    const i = An();
    this.dragCancellationToken = new $e(), this.treeViewsDragAndDropService.addDragOperationTransfer(i, this.handleDragAndLog(this.dndController, t, i, this.dragCancellationToken.token)), this.treeItemsTransfer.setData([new Rt(i)], Rt.prototype), e.dataTransfer.clearData(Mo.text), this.dndController.dragMimeTypes.find((s) => s === Mo.uriList) && ((o = e.dataTransfer) == null || o.setData(io.RESOURCES, "")), this.dndController.dragMimeTypes.forEach((s) => {
      var n;
      (n = e.dataTransfer) == null || n.setData(s, "");
    });
  }
  addResourceInfoToTransfer(e, t) {
    if (t.length && e.dataTransfer) {
      this.instantiationService.invokeFunction((o) => Ah(o, t, e));
      const i = t.filter((o) => o.scheme === q.file).map((o) => o.fsPath);
      i.length && e.dataTransfer.setData(Fr.FILES, JSON.stringify(i));
    }
  }
  onDragStart(e, t) {
    if (t.dataTransfer) {
      const i = e.getData(), o = [], s = {
        id: this.treeId,
        itemHandles: []
      };
      i.forEach((n) => {
        s.itemHandles.push(n.handle), n.resourceUri && o.push(A.revive(n.resourceUri));
      }), this.addResourceInfoToTransfer(t, o), this.addExtensionProvidedTransferTypes(t, s.itemHandles), t.dataTransfer.setData(this.treeMimeType, JSON.stringify(s));
    }
  }
  debugLog(e) {
    e.size ? this.logService.debug(`TreeView dragged mime types: ${Array.from(e).join(", ")}`) : this.logService.debug("TreeView dragged with no supported mime types.");
  }
  onDragOver(e, t, i, o) {
    const s = hl(o.dataTransfer), n = new Set(Array.from(s, (d) => d[0]));
    if (o.dataTransfer) {
      for (const d of o.dataTransfer.items)
        if (d.kind === "file" || d.type === io.RESOURCES.toLowerCase()) {
          n.add(Mo.uriList);
          break;
        }
    }
    this.debugLog(n);
    const r = this.dndController;
    return !r || !o.dataTransfer || r.dropMimeTypes.length === 0 ? !1 : Array.from(n).some((d, h) => d === this.treeMimeType ? !0 : r.dropMimeTypes.indexOf(d) >= 0) ? { accept: !0, bubble: 0, autoExpand: !0 } : !1;
  }
  getDragURI(e) {
    return this.dndController ? e.resourceUri ? A.revive(e.resourceUri).toString() : e.handle : null;
  }
  getDragLabel(e) {
    if (!this.dndController)
      return;
    if (e.length > 1)
      return String(e.length);
    const t = e[0];
    return t.label ? t.label.label : t.resourceUri ? this.labelService.getUriLabel(A.revive(t.resourceUri)) : void 0;
  }
  async drop(e, t, i, o) {
    const s = this.dndController;
    if (!o.dataTransfer || !s)
      return;
    let n, r;
    this.treeItemsTransfer.hasData(Rt.prototype) && (r = this.treeItemsTransfer.getData(Rt.prototype)[0].identifier);
    const a = hl(o.dataTransfer, !0), d = new rf();
    for (const [g, p] of a)
      if ((g === this.treeMimeType || s.dropMimeTypes.includes(g) || p.asFile() && s.dropMimeTypes.includes(io.FILES.toLowerCase())) && (d.append(g, p), g === this.treeMimeType))
        try {
          n = JSON.parse(await p.asString());
        } catch {
        }
    const h = await this.treeViewsDragAndDropService.removeDragOperationTransfer(r);
    if (h)
      for (const [g, p] of h)
        d.append(g, p);
    return s.handleDrop(d, t, Ni.None, r, n == null ? void 0 : n.id, n == null ? void 0 : n.itemHandles);
  }
  onDragEnd(e) {
    var t, i;
    ((t = e.dataTransfer) == null ? void 0 : t.dropEffect) === "none" && ((i = this.dragCancellationToken) == null || i.cancel());
  }
};
Ua = y([
  l(1, Ft),
  l(2, W),
  l(3, $c),
  l(4, rt)
], Ua);
const Ir = "workbench.view.remote", Qn = class Qn extends E {
  constructor(e, t, i, o, s, n, r, a) {
    super(), this.notificationService = e, this.remoteExplorerService = t, this.openerService = i, this.externalOpenerService = o, this.tunnelService = s, this.hostService = n, this.logService = r, this.contextKeyService = a, this.alreadyOpenedOnce = /* @__PURE__ */ new Set(), this.lastNotifyTime = /* @__PURE__ */ new Date(), this.lastNotifyTime.setFullYear(this.lastNotifyTime.getFullYear() - 1);
  }
  async doAction(e) {
    var i, o;
    this.logService.trace(`ForwardedPorts: (OnAutoForwardedAction) Starting action for ${(i = e[0]) == null ? void 0 : i.tunnelRemotePort}`), this.doActionTunnels = e;
    const t = await this.portNumberHeuristicDelay();
    if (this.logService.trace(`ForwardedPorts: (OnAutoForwardedAction) Heuristic chose ${t == null ? void 0 : t.tunnelRemotePort}`), t) {
      const s = await this.remoteExplorerService.tunnelModel.getAttributes([{ port: t.tunnelRemotePort, host: t.tunnelRemoteHost }]), n = (o = s == null ? void 0 : s.get(t.tunnelRemotePort)) == null ? void 0 : o.onAutoForward;
      switch (this.logService.trace(`ForwardedPorts: (OnAutoForwardedAction) onAutoForward action is ${n}`), n) {
        case Xs.OpenBrowserOnce: {
          if (this.alreadyOpenedOnce.has(t.localAddress))
            break;
          this.alreadyOpenedOnce.add(t.localAddress);
        }
        case Xs.OpenBrowser: {
          const r = Ks(t.tunnelRemoteHost, t.tunnelRemotePort);
          await pr.run(this.remoteExplorerService.tunnelModel, this.openerService, r);
          break;
        }
        case Xs.OpenPreview: {
          const r = Ks(t.tunnelRemoteHost, t.tunnelRemotePort);
          await gr.run(this.remoteExplorerService.tunnelModel, this.openerService, this.externalOpenerService, r);
          break;
        }
        case Xs.Silent:
          break;
        default: {
          const r = (/* @__PURE__ */ new Date()).getTime() - this.lastNotifyTime.getTime();
          this.logService.trace(`ForwardedPorts: (OnAutoForwardedAction) time elapsed since last notification ${r} ms`), r > Qn.NOTIFY_COOL_DOWN && await this.showNotification(t);
        }
      }
    }
  }
  hide(e) {
    var t;
    this.doActionTunnels && (this.doActionTunnels = this.doActionTunnels.filter((i) => !e.includes(i.tunnelRemotePort))), this.lastShownPort && e.indexOf(this.lastShownPort) >= 0 && ((t = this.lastNotification) == null || t.close());
  }
  async portNumberHeuristicDelay() {
    if (this.logService.trace("ForwardedPorts: (OnAutoForwardedAction) Starting heuristic delay"), !this.doActionTunnels || this.doActionTunnels.length === 0)
      return;
    this.doActionTunnels = this.doActionTunnels.sort((t, i) => t.tunnelRemotePort - i.tunnelRemotePort);
    const e = this.doActionTunnels.shift();
    return e.tunnelRemotePort % 1e3 === 0 ? (this.logService.trace(`ForwardedPorts: (OnAutoForwardedAction) Heuristic chose tunnel because % 1000: ${e.tunnelRemotePort}`), this.newerTunnel = e, e) : e.tunnelRemotePort < 1e4 && e.tunnelRemotePort !== 9229 ? (this.logService.trace(`ForwardedPorts: (OnAutoForwardedAction) Heuristic chose tunnel because < 10000: ${e.tunnelRemotePort}`), this.newerTunnel = e, e) : (this.logService.trace(`ForwardedPorts: (OnAutoForwardedAction) Waiting for "better" tunnel than ${e.tunnelRemotePort}`), this.newerTunnel = void 0, new Promise((t) => {
      setTimeout(() => {
        var i;
        this.newerTunnel ? t(void 0) : (i = this.doActionTunnels) != null && i.includes(e) ? t(e) : t(void 0);
      }, 3e3);
    }));
  }
  basicMessage(e) {
    return u(
      "remote.tunnelsView.automaticForward",
      "Your application running on port {0} is available.  ",
      e.tunnelRemotePort
    );
  }
  linkMessage() {
    return u(
      { key: "remote.tunnelsView.notificationLink2", comment: ["[See all forwarded ports]({0}) is a link. Only translate `See all forwarded ports`. Do not change brackets and parentheses or {0}"] },
      "[See all forwarded ports]({0})",
      `command:${af.ID}.focus`
    );
  }
  async showNotification(e) {
    var o;
    if (!await this.hostService.hadLastFocus())
      return;
    (o = this.lastNotification) == null || o.close();
    let t = this.basicMessage(e);
    const i = [this.openBrowserChoice(e)];
    (!ot || cf.getValue(this.contextKeyService)) && i.push(this.openPreviewChoice(e)), e.tunnelLocalPort !== e.tunnelRemotePort && this.tunnelService.canElevate && this.tunnelService.isPortPrivileged(e.tunnelRemotePort) && (t += u(
      "remote.tunnelsView.elevationMessage",
      "You'll need to run as superuser to use port {0} locally.  ",
      e.tunnelRemotePort
    ), i.unshift(this.elevateChoice(e))), e.privacy === ul.Private && ot && this.tunnelService.canChangePrivacy && i.push(this.makePublicChoice(e)), t += this.linkMessage(), this.lastNotification = this.notificationService.prompt(ft.Info, t, i, { neverShowAgain: { id: "remote.tunnelsView.autoForwardNeverShow", isSecondary: !0 } }), this.lastShownPort = e.tunnelRemotePort, this.lastNotifyTime = /* @__PURE__ */ new Date(), this.lastNotification.onDidClose(() => {
      this.lastNotification = void 0, this.lastShownPort = void 0;
    });
  }
  makePublicChoice(e) {
    return {
      label: u("remote.tunnelsView.makePublic", "Make Public"),
      run: async () => {
        const t = df(this.remoteExplorerService.tunnelModel.forwarded, e.tunnelRemoteHost, e.tunnelRemotePort);
        return await this.remoteExplorerService.close({ host: e.tunnelRemoteHost, port: e.tunnelRemotePort }, gl.Other), this.remoteExplorerService.forward({
          remote: { host: e.tunnelRemoteHost, port: e.tunnelRemotePort },
          local: e.tunnelLocalPort,
          name: t == null ? void 0 : t.name,
          elevateIfNeeded: !0,
          privacy: ul.Public,
          source: t == null ? void 0 : t.source
        });
      }
    };
  }
  openBrowserChoice(e) {
    const t = Ks(e.tunnelRemoteHost, e.tunnelRemotePort);
    return {
      label: pr.LABEL,
      run: () => pr.run(this.remoteExplorerService.tunnelModel, this.openerService, t)
    };
  }
  openPreviewChoice(e) {
    const t = Ks(e.tunnelRemoteHost, e.tunnelRemotePort);
    return {
      label: gr.LABEL,
      run: () => gr.run(this.remoteExplorerService.tunnelModel, this.openerService, this.externalOpenerService, t)
    };
  }
  elevateChoice(e) {
    return {
      label: u(
        "remote.tunnelsView.elevationButton",
        "Use Port {0} as Sudo...",
        e.tunnelRemotePort
      ),
      run: async () => {
        var i;
        await this.remoteExplorerService.close({ host: e.tunnelRemoteHost, port: e.tunnelRemotePort }, gl.Other);
        const t = await this.remoteExplorerService.forward({
          remote: { host: e.tunnelRemoteHost, port: e.tunnelRemotePort },
          local: e.tunnelRemotePort,
          elevateIfNeeded: !0,
          source: lf
        });
        t && ((i = this.lastNotification) == null || i.close(), this.lastShownPort = t.tunnelRemotePort, this.lastNotification = this.notificationService.prompt(ft.Info, this.basicMessage(t) + this.linkMessage(), [this.openBrowserChoice(t), this.openPreviewChoice(e)], { neverShowAgain: { id: "remote.tunnelsView.autoForwardNeverShow", isSecondary: !0 } }), this.lastNotification.onDidClose(() => {
          this.lastNotification = void 0, this.lastShownPort = void 0;
        }));
      }
    };
  }
};
Qn.NOTIFY_COOL_DOWN = 5e3;
let eh = Qn;
const Jr = {
  webviewState: "webviewState"
};
let ja = class ip extends jn {
  static getOriginStore(e) {
    return this._originStore ?? (this._originStore = new hf("webviewViews.origins", e)), this._originStore;
  }
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m, C, b, v, J) {
    super({ ...e, titleMenuId: k.ViewTitle, showActions: uf.WhenExpanded }, n, o, t, i, h, s, r, d, a), this.activityService = g, this.extensionService = p, this.progressService = m, this.storageService = C, this.viewService = b, this.webviewService = v, this.webviewViewService = J, this._webview = this._register(new Re()), this._webviewDisposables = this._register(new Z()), this._activated = !1, this._onDidChangeVisibility = this._register(new w()), this.onDidChangeVisibility = this._onDidChangeVisibility.event, this._onDispose = this._register(new w()), this.onDispose = this._onDispose.event, this.extensionId = e.fromExtensionId, this.defaultTitle = this.title, this.memento = new Uu(`webviewView.${this.id}`, C), this.viewState = this.memento.getMemento(1, 1), this._register(this.onDidChangeBodyVisibility(() => this.updateTreeVisibility())), this._register(this.webviewViewService.onNewResolverRegistered((R) => {
      R.viewType === this.id && this.updateTreeVisibility();
    })), this.updateTreeVisibility();
  }
  dispose() {
    this._onDispose.fire(), clearTimeout(this._repositionTimeout), super.dispose();
  }
  focus() {
    var e;
    super.focus(), (e = this._webview.value) == null || e.focus();
  }
  renderBody(e) {
    super.renderBody(e), this._container = e, this._rootContainer = void 0, this._resizeObserver || (this._resizeObserver = new ResizeObserver(() => {
      setTimeout(() => {
        this.layoutWebview();
      }, 0);
    }), this._register(M(() => {
      this._resizeObserver.disconnect();
    })), this._resizeObserver.observe(e));
  }
  saveState() {
    this._webview.value && (this.viewState[Jr.webviewState] = this._webview.value.state), this.memento.saveMemento(), super.saveState();
  }
  layoutBody(e, t) {
    super.layoutBody(e, t), this.layoutWebview(new H(t, e));
  }
  updateTreeVisibility() {
    var e, t;
    this.isBodyVisible() ? (this.activate(), (e = this._webview.value) == null || e.claim(this, void 0)) : (t = this._webview.value) == null || t.release(this);
  }
  activate() {
    if (this._activated)
      return;
    this._activated = !0;
    const e = this.extensionId ? ip.getOriginStore(this.storageService).getOrigin(this.id, this.extensionId) : void 0, t = this.webviewService.createWebviewOverlay({
      origin: e,
      providedViewType: this.id,
      title: this.title,
      options: { purpose: "webviewView" },
      contentOptions: {},
      extension: this.extensionId ? { id: this.extensionId } : void 0
    });
    t.state = this.viewState[Jr.webviewState], this._webview.value = t, this._container && this.layoutWebview(), this._webviewDisposables.add(M(() => {
      var o;
      (o = this._webview.value) == null || o.release(this);
    })), this._webviewDisposables.add(t.onDidUpdateState(() => {
      this.viewState[Jr.webviewState] = t.state;
    }));
    for (const o of [I.DRAG, I.DRAG_END, I.DRAG_ENTER, I.DRAG_LEAVE, I.DRAG_START])
      this._webviewDisposables.add(S(this._webview.value.container, o, (s) => {
        s.preventDefault(), s.stopImmediatePropagation(), this.dropTargetElement.dispatchEvent(new DragEvent(s.type, s));
      }));
    this._webviewDisposables.add(new gf(() => this._webview.value));
    const i = this._webviewDisposables.add(new $e());
    this.withProgress(async () => {
      await this.extensionService.activateByEvent(`onView:${this.id}`);
      const o = this, s = {
        webview: t,
        onDidChangeVisibility: this.onDidChangeBodyVisibility,
        onDispose: this.onDispose,
        get title() {
          return o.setTitle;
        },
        set title(n) {
          o.updateTitle(n);
        },
        get description() {
          return o.titleDescription;
        },
        set description(n) {
          o.updateTitleDescription(n);
        },
        get badge() {
          return o.badge;
        },
        set badge(n) {
          o.updateBadge(n);
        },
        dispose: () => {
          this._activated = !1, this._webview.clear(), this._webviewDisposables.clear();
        },
        show: (n) => {
          this.viewService.openView(this.id, !n);
        }
      };
      await this.webviewViewService.resolve(this.id, s, i.token);
    });
  }
  updateTitle(e) {
    this.setTitle = e, super.updateTitle(typeof e == "string" ? e : this.defaultTitle);
  }
  updateBadge(e) {
    var t, i;
    if (!(((t = this.badge) == null ? void 0 : t.value) === (e == null ? void 0 : e.value) && ((i = this.badge) == null ? void 0 : i.tooltip) === (e == null ? void 0 : e.tooltip)) && (this.activity && (this.activity.dispose(), this.activity = void 0), this.badge = e, e)) {
      const o = {
        badge: new to(e.value, () => e.tooltip),
        priority: 150
      };
      this.activityService.showViewActivity(this.id, o);
    }
  }
  async withProgress(e) {
    return this.progressService.withProgress({ location: this.id, delay: 500 }, e);
  }
  onDidScrollRoot() {
    this.layoutWebview();
  }
  doLayoutWebview(e) {
    const t = this._webview.value;
    !this._container || !t || ((!this._rootContainer || !this._rootContainer.isConnected) && (this._rootContainer = this.findRootContainer(this._container)), t.layoutWebviewOverElement(this._container, e, this._rootContainer));
  }
  layoutWebview(e) {
    this.doLayoutWebview(e), clearTimeout(this._repositionTimeout), this._repositionTimeout = setTimeout(() => this.doLayoutWebview(e), 200);
  }
  findRootContainer(e) {
    return ui(nn(e, "monaco-scrollable-element"));
  }
};
ja = y([
  l(1, x),
  l(2, F),
  l(3, Ie),
  l(4, W),
  l(5, be),
  l(6, Ti),
  l(7, Xe),
  l(8, z),
  l(9, Me),
  l(10, Eo),
  l(11, ei),
  l(12, Kn),
  l(13, ee),
  l(14, Mn),
  l(15, As),
  l(16, zu)
], ja);
const th = {
  type: "object",
  properties: {
    id: {
      description: u(
        { key: "vscode.extension.contributes.views.containers.id", comment: ["Contribution refers to those that an extension contributes to VS Code through an extension/contribution point. "] },
        "Unique id used to identify the container in which views can be contributed using 'views' contribution point"
      ),
      type: "string",
      pattern: "^[a-zA-Z0-9_-]+$"
    },
    title: {
      description: u(
        "vscode.extension.contributes.views.containers.title",
        "Human readable string used to render the container"
      ),
      type: "string"
    },
    icon: {
      description: u(
        "vscode.extension.contributes.views.containers.icon",
        "Path to the container icon. Icons are 24x24 centered on a 50x40 block and have a fill color of 'rgb(215, 218, 224)' or '#d7dae0'. It is recommended that icons be in SVG, though any image file type is accepted."
      ),
      type: "string"
    }
  },
  required: ["id", "title", "icon"]
}, kk = {
  description: u(
    "vscode.extension.contributes.viewsContainers",
    "Contributes views containers to the editor"
  ),
  type: "object",
  properties: {
    activitybar: {
      description: u(
        "views.container.activitybar",
        "Contribute views containers to Activity Bar"
      ),
      type: "array",
      items: th
    },
    panel: {
      description: u("views.container.panel", "Contribute views containers to Panel"),
      type: "array",
      items: th
    }
  }
};
var di;
(function(c) {
  c.Tree = "tree", c.Webview = "webview";
})(di || (di = {}));
var zi;
(function(c) {
  c.Visible = "visible", c.Hidden = "hidden", c.Collapsed = "collapsed";
})(zi || (zi = {}));
const Ko = {
  type: "object",
  required: ["id", "name"],
  defaultSnippets: [{ body: { id: "${1:id}", name: "${2:name}" } }],
  properties: {
    type: {
      markdownDescription: u(
        "vscode.extension.contributes.view.type",
        "Type of the view. This can either be `tree` for a tree view based view or `webview` for a webview based view. The default is `tree`."
      ),
      type: "string",
      enum: [
        "tree",
        "webview"
      ],
      markdownEnumDescriptions: [
        u(
          "vscode.extension.contributes.view.tree",
          "The view is backed by a `TreeView` created by `createTreeView`."
        ),
        u(
          "vscode.extension.contributes.view.webview",
          "The view is backed by a `WebviewView` registered by `registerWebviewViewProvider`."
        )
      ]
    },
    id: {
      markdownDescription: u(
        "vscode.extension.contributes.view.id",
        "Identifier of the view. This should be unique across all views. It is recommended to include your extension id as part of the view id. Use this to register a data provider through `vscode.window.registerTreeDataProviderForView` API. Also to trigger activating your extension by registering `onView:${id}` event to `activationEvents`."
      ),
      type: "string"
    },
    name: {
      description: u(
        "vscode.extension.contributes.view.name",
        "The human-readable name of the view. Will be shown"
      ),
      type: "string"
    },
    when: {
      description: u(
        "vscode.extension.contributes.view.when",
        "Condition which must be true to show this view"
      ),
      type: "string"
    },
    icon: {
      description: u(
        "vscode.extension.contributes.view.icon",
        "Path to the view icon. View icons are displayed when the name of the view cannot be shown. It is recommended that icons be in SVG, though any image file type is accepted."
      ),
      type: "string"
    },
    contextualTitle: {
      description: u(
        "vscode.extension.contributes.view.contextualTitle",
        "Human-readable context for when the view is moved out of its original location. By default, the view's container name will be used."
      ),
      type: "string"
    },
    visibility: {
      description: u(
        "vscode.extension.contributes.view.initialState",
        "Initial state of the view when the extension is first installed. Once the user has changed the view state by collapsing, moving, or hiding the view, the initial state will not be used again."
      ),
      type: "string",
      enum: [
        "visible",
        "hidden",
        "collapsed"
      ],
      default: "visible",
      enumDescriptions: [
        u(
          "vscode.extension.contributes.view.initialState.visible",
          "The default initial state for the view. In most containers the view will be expanded, however; some built-in containers (explorer, scm, and debug) show all contributed views collapsed regardless of the `visibility`."
        ),
        u(
          "vscode.extension.contributes.view.initialState.hidden",
          "The view will not be shown in the view container, but will be discoverable through the views menu and other view entry points and can be un-hidden by the user."
        ),
        u(
          "vscode.extension.contributes.view.initialState.collapsed",
          "The view will show in the view container, but will be collapsed."
        )
      ]
    },
    initialSize: {
      type: "number",
      description: u(
        "vscode.extension.contributs.view.size",
        "The initial size of the view. The size will behave like the css 'flex' property, and will set the initial size when the view is first shown. In the side bar, this is the height of the view. This value is only respected when the same extension owns both the view and the view container."
      )
    }
  }
}, Sk = {
  type: "object",
  required: ["id", "name"],
  properties: {
    id: {
      description: u(
        "vscode.extension.contributes.view.id",
        "Identifier of the view. This should be unique across all views. It is recommended to include your extension id as part of the view id. Use this to register a data provider through `vscode.window.registerTreeDataProviderForView` API. Also to trigger activating your extension by registering `onView:${id}` event to `activationEvents`."
      ),
      type: "string"
    },
    name: {
      description: u(
        "vscode.extension.contributes.view.name",
        "The human-readable name of the view. Will be shown"
      ),
      type: "string"
    },
    when: {
      description: u(
        "vscode.extension.contributes.view.when",
        "Condition which must be true to show this view"
      ),
      type: "string"
    },
    group: {
      description: u("vscode.extension.contributes.view.group", "Nested group in the viewlet"),
      type: "string"
    },
    remoteName: {
      description: u(
        "vscode.extension.contributes.view.remoteName",
        "The name of the remote type associated with this view"
      ),
      type: ["string", "array"],
      items: {
        type: "string"
      }
    }
  }
}, Ik = {
  description: u("vscode.extension.contributes.views", "Contributes views to the editor"),
  type: "object",
  properties: {
    explorer: {
      description: u(
        "views.explorer",
        "Contributes views to Explorer container in the Activity bar"
      ),
      type: "array",
      items: Ko,
      default: []
    },
    debug: {
      description: u("views.debug", "Contributes views to Debug container in the Activity bar"),
      type: "array",
      items: Ko,
      default: []
    },
    scm: {
      description: u("views.scm", "Contributes views to SCM container in the Activity bar"),
      type: "array",
      items: Ko,
      default: []
    },
    test: {
      description: u("views.test", "Contributes views to Test container in the Activity bar"),
      type: "array",
      items: Ko,
      default: []
    },
    remote: {
      description: u(
        "views.remote",
        "Contributes views to Remote container in the Activity bar. To contribute to this container, enableProposedApi needs to be turned on"
      ),
      type: "array",
      items: Sk,
      default: []
    }
  },
  additionalProperties: {
    description: u("views.contributed", "Contributes views to contributed views container"),
    type: "array",
    items: Ko,
    default: []
  }
}, op = yd.registerExtensionPoint({
  extensionPoint: "viewsContainers",
  jsonSchema: kk
}), Jk = yd.registerExtensionPoint({
  extensionPoint: "views",
  deps: [op],
  jsonSchema: Ik,
  activationEventsGenerator: (c, e) => {
    for (const t of c)
      for (const i of Object.values(t))
        for (const o of i)
          o.id && e.push(`onView:${o.id}`);
  }
}), Vk = 7;
let qa = class {
  constructor(e, t) {
    this.instantiationService = e, this.logService = t, this.viewContainersRegistry = N.as(nt.ViewContainersRegistry), this.viewsRegistry = N.as(nt.ViewsRegistry), this.handleAndRegisterCustomViewContainers(), this.handleAndRegisterCustomViews();
    let i = new $e();
    V.registerCommandAndKeybindingRule({
      id: "workbench.action.showTreeHover",
      handler: async (o, ...s) => {
        i.cancel(), i = new $e();
        const n = o.get(B), r = o.get(Mu), a = o.get(Lt), d = n.lastFocusedList;
        if (!(d instanceof ut))
          return;
        const h = d.getFocus();
        if (!h || h.length === 0)
          return;
        const g = h[0];
        if (g instanceof wd && await g.resolve(i.token), !g.tooltip)
          return;
        const p = r.getRenderedTreeElement(g);
        p && a.showHover({
          content: g.tooltip,
          target: p,
          hoverPosition: 2,
          hideOnHover: !1
        }, !0);
      },
      weight: 200,
      primary: St(2089, 2087),
      when: f.and(ep, te)
    });
  }
  handleAndRegisterCustomViewContainers() {
    op.setHandler((e, { added: t, removed: i }) => {
      i.length && this.removeCustomViewContainers(i), t.length && this.addCustomViewContainers(t, this.viewContainersRegistry.all);
    });
  }
  addCustomViewContainers(e, t) {
    const i = N.as(nt.ViewContainersRegistry);
    let o = Vk + i.all.filter((n) => !!n.extensionId && i.getViewContainerLocation(n) === 0).length, s = 5 + i.all.filter((n) => !!n.extensionId && i.getViewContainerLocation(n) === 1).length + 1;
    for (const { value: n, collector: r, description: a } of e)
      Object.entries(n).forEach(([d, h]) => {
        if (this.isValidViewsContainer(h, r))
          switch (d) {
            case "activitybar":
              o = this.registerCustomViewContainers(h, a, o, t, 0);
              break;
            case "panel":
              s = this.registerCustomViewContainers(h, a, s, t, 1);
              break;
          }
      });
  }
  removeCustomViewContainers(e) {
    const t = N.as(nt.ViewContainersRegistry), i = e.reduce((o, s) => (o.add(s.description.identifier), o), new pl());
    for (const o of t.all)
      if (o.extensionId && i.has(o.extensionId)) {
        const s = this.viewsRegistry.getViews(o);
        s.length && this.viewsRegistry.moveViews(s, this.getDefaultViewContainer()), this.deregisterCustomViewContainer(o);
      }
  }
  isValidViewsContainer(e, t) {
    if (!Array.isArray(e))
      return t.error(u("viewcontainer requirearray", "views containers must be an array")), !1;
    for (const i of e) {
      if (typeof i.id != "string" && Hr(i.id))
        return t.error(u(
          "requireidstring",
          "property `{0}` is mandatory and must be of type `string` with non-empty value. Only alphanumeric characters, '_', and '-' are allowed.",
          "id"
        )), !1;
      if (!/^[a-z0-9_-]+$/i.test(i.id))
        return t.error(u(
          "requireidstring",
          "property `{0}` is mandatory and must be of type `string` with non-empty value. Only alphanumeric characters, '_', and '-' are allowed.",
          "id"
        )), !1;
      if (typeof i.title != "string")
        return t.error(u(
          "requirestring",
          "property `{0}` is mandatory and must be of type `string`",
          "title"
        )), !1;
      if (typeof i.icon != "string")
        return t.error(u(
          "requirestring",
          "property `{0}` is mandatory and must be of type `string`",
          "icon"
        )), !1;
      if (Hr(i.title))
        return t.warn(u(
          "requirenonemptystring",
          "property `{0}` is mandatory and must be of type `string` with non-empty value",
          "title"
        )), !0;
    }
    return !0;
  }
  registerCustomViewContainers(e, t, i, o, s) {
    return e.forEach((n) => {
      const a = pe.fromString(n.icon) || on(t.extensionLocation, n.icon), d = `workbench.view.extension.${n.id}`, h = n.title || d, g = this.registerCustomViewContainer(d, h, a, i++, t.identifier, s);
      if (o.length) {
        const p = [];
        for (const m of o)
          g !== m && p.push(...this.viewsRegistry.getViews(m).filter((C) => C.originalContainerId === n.id));
        p.length && this.viewsRegistry.moveViews(p, g);
      }
    }), i;
  }
  registerCustomViewContainer(e, t, i, o, s, n) {
    let r = this.viewContainersRegistry.get(e);
    return r || (r = this.viewContainersRegistry.registerViewContainer({
      id: e,
      title: t,
      extensionId: s,
      ctorDescriptor: new T(Fc, [e, { mergeViewWithContainerWhenSingleView: !0 }]),
      hideIfEmpty: !0,
      order: o,
      icon: i
    }, n)), r;
  }
  deregisterCustomViewContainer(e) {
    this.viewContainersRegistry.deregisterViewContainer(e), N.as(cs.Viewlets).deregisterPaneComposite(e.id);
  }
  handleAndRegisterCustomViews() {
    Jk.setHandler((e, { added: t, removed: i }) => {
      i.length && this.removeViews(i), t.length && this.addViews(t);
    });
  }
  addViews(e) {
    const t = /* @__PURE__ */ new Set(), i = [];
    for (const o of e) {
      const { value: s, collector: n } = o;
      Object.entries(s).forEach(([r, a]) => {
        var p;
        if (!this.isValidViewDescriptors(a, n))
          return;
        if (r === "remote" && !pf(o.description, "contribViewsRemote")) {
          n.warn(u(
            "ViewContainerRequiresProposedAPI",
            `View container '{0}' requires 'enabledApiProposals: ["contribViewsRemote"]' to be added to 'Remote'.`,
            r
          ));
          return;
        }
        const d = this.getViewContainer(r);
        d || n.warn(u(
          "ViewContainerDoesnotExist",
          "View container '{0}' does not exist and all views registered to it will be added to 'Explorer'.",
          r
        ));
        const h = d || this.getDefaultViewContainer(), g = [];
        for (let m = 0; m < a.length; m++) {
          const C = a[m];
          if (t.has(C.id)) {
            n.error(u(
              "duplicateView1",
              "Cannot register multiple views with same id `{0}`",
              C.id
            ));
            continue;
          }
          if (this.viewsRegistry.getView(C.id) !== null) {
            n.error(u("duplicateView2", "A view with id `{0}` is already registered.", C.id));
            continue;
          }
          const b = ju.equals(o.description.identifier, h.extensionId) ? m + 1 : h.viewOrderDelegate ? h.viewOrderDelegate.getOrder(C.group) : void 0;
          let v;
          typeof C.icon == "string" && (v = pe.fromString(C.icon) || on(o.description.extensionLocation, C.icon));
          const J = this.convertInitialVisibility(C.visibility), R = this.getViewType(C.type);
          if (!R) {
            n.error(u("unknownViewType", "Unknown view type `{0}`.", C.type));
            continue;
          }
          let O;
          typeof C.initialSize == "number" && (((p = h.extensionId) == null ? void 0 : p.value) === o.description.identifier.value ? O = C.initialSize : this.logService.warn(`${o.description.identifier.value} tried to set the view size of ${C.id} but it was ignored because the view container does not belong to it.`));
          const Je = {
            type: R,
            ctorDescriptor: R === di.Tree ? new T(Ha) : new T(ja),
            id: C.id,
            name: C.name,
            when: f.deserialize(C.when),
            containerIcon: v || (d == null ? void 0 : d.icon),
            containerTitle: C.contextualTitle || (d == null ? void 0 : d.title),
            canToggleVisibility: !0,
            canMoveView: (d == null ? void 0 : d.id) !== Ir,
            treeView: R === di.Tree ? this.instantiationService.createInstance(za, C.id, C.name, o.description.identifier.value) : void 0,
            collapsed: this.showCollapsed(h) || J === zi.Collapsed,
            order: b,
            extensionId: o.description.identifier,
            originalContainerId: r,
            group: C.group,
            remoteAuthority: C.remoteName || C.remoteAuthority,
            virtualWorkspace: C.virtualWorkspace,
            hideByDefault: J === zi.Hidden,
            workspace: (d == null ? void 0 : d.id) === Ir ? !0 : void 0,
            weight: O
          };
          t.add(Je.id), g.push(Je);
        }
        i.push({ viewContainer: h, views: g });
      });
    }
    this.viewsRegistry.registerViews2(i);
  }
  getViewType(e) {
    if (e === di.Webview)
      return di.Webview;
    if (!e || e === di.Tree)
      return di.Tree;
  }
  getDefaultViewContainer() {
    return this.viewContainersRegistry.get(Mt);
  }
  removeViews(e) {
    const t = e.reduce((i, o) => (i.add(o.description.identifier), i), new pl());
    for (const i of this.viewContainersRegistry.all) {
      const o = this.viewsRegistry.getViews(i).filter((s) => s.extensionId && t.has(s.extensionId));
      if (o.length) {
        this.viewsRegistry.deregisterViews(o, i);
        for (const s of o) {
          const n = s;
          n.treeView && n.treeView.dispose();
        }
      }
    }
  }
  convertInitialVisibility(e) {
    if (Object.values(zi).includes(e))
      return e;
  }
  isValidViewDescriptors(e, t) {
    if (!Array.isArray(e))
      return t.error(u("requirearray", "views must be an array")), !1;
    for (const i of e) {
      if (typeof i.id != "string")
        return t.error(u(
          "requirestring",
          "property `{0}` is mandatory and must be of type `string`",
          "id"
        )), !1;
      if (typeof i.name != "string")
        return t.error(u(
          "requirestring",
          "property `{0}` is mandatory and must be of type `string`",
          "name"
        )), !1;
      if (i.when && typeof i.when != "string")
        return t.error(u(
          "optstring",
          "property `{0}` can be omitted or must be of type `string`",
          "when"
        )), !1;
      if (i.icon && typeof i.icon != "string")
        return t.error(u(
          "optstring",
          "property `{0}` can be omitted or must be of type `string`",
          "icon"
        )), !1;
      if (i.contextualTitle && typeof i.contextualTitle != "string")
        return t.error(u(
          "optstring",
          "property `{0}` can be omitted or must be of type `string`",
          "contextualTitle"
        )), !1;
      if (i.visibility && !this.convertInitialVisibility(i.visibility))
        return t.error(u(
          "optenum",
          "property `{0}` can be omitted or must be one of {1}",
          "visibility",
          Object.values(zi).join(", ")
        )), !1;
    }
    return !0;
  }
  getViewContainer(e) {
    switch (e) {
      case "explorer":
        return this.viewContainersRegistry.get(Mt);
      case "debug":
        return this.viewContainersRegistry.get(bl);
      case "scm":
        return this.viewContainersRegistry.get(ml);
      case "remote":
        return this.viewContainersRegistry.get(Ir);
      default:
        return this.viewContainersRegistry.get(`workbench.view.extension.${e}`);
    }
  }
  showCollapsed(e) {
    switch (e.id) {
      case Mt:
      case ml:
      case bl:
        return !0;
    }
    return !1;
  }
};
qa = y([
  l(0, W),
  l(1, rt)
], qa);
const Zk = N.as(dt.Workbench);
Zk.registerWorkbenchContribution(qa, 1);
var ws;
let $a = (ws = class {
  constructor(e) {
    this._webviewWorkbenchService = e;
  }
  canSerialize(e) {
    return this._webviewWorkbenchService.shouldPersist(e);
  }
  serialize(e) {
    if (!this._webviewWorkbenchService.shouldPersist(e))
      return;
    const t = this.toJson(e);
    try {
      return JSON.stringify(t);
    } catch {
      return;
    }
  }
  deserialize(e, t) {
    const i = this.fromJson(JSON.parse(t));
    return this._webviewWorkbenchService.openRevivedWebview({
      webviewInitInfo: {
        providedViewType: i.providedId,
        origin: i.origin,
        title: i.title,
        options: i.webviewOptions,
        contentOptions: i.contentOptions,
        extension: i.extension
      },
      viewType: i.viewType,
      title: i.title,
      iconPath: i.iconPath,
      state: i.state,
      group: i.group
    });
  }
  fromJson(e) {
    return {
      ...e,
      extension: sp(e.extensionId, e.extensionLocation),
      iconPath: Wk(e.iconPath),
      state: _k(e.state),
      webviewOptions: e.options,
      contentOptions: np(e.options)
    };
  }
  toJson(e) {
    var t, i;
    return {
      origin: e.webview.origin,
      viewType: e.viewType,
      providedId: e.providedId,
      title: e.getName(),
      options: { ...e.webview.options, ...e.webview.contentOptions },
      extensionLocation: (t = e.extension) == null ? void 0 : t.location,
      extensionId: (i = e.extension) == null ? void 0 : i.id.value,
      state: e.webview.state,
      iconPath: e.iconPath ? { light: e.iconPath.light, dark: e.iconPath.dark } : void 0,
      group: e.group
    };
  }
}, ws.ID = ns.typeId, ws);
$a = y([
  l(0, qu)
], $a);
function sp(c, e) {
  if (!c)
    return;
  const t = Sn(e);
  if (t)
    return {
      id: new ju(c),
      location: t
    };
}
function Wk(c) {
  if (!c)
    return;
  const e = Sn(c.light), t = Sn(c.dark);
  return e && t ? { light: e, dark: t } : void 0;
}
function Sn(c) {
  if (c)
    try {
      return typeof c == "string" ? A.parse(c) : A.from(c);
    } catch {
      return;
    }
}
function _k(c) {
  return typeof c == "string" ? c : void 0;
}
function np(c) {
  var e;
  return {
    ...c,
    localResourceRoots: (e = c.localResourceRoots) == null ? void 0 : e.map((t) => Sn(t))
  };
}
var ys;
ys = class extends $a {
  constructor(e, t, i) {
    super(e), this._instantiationService = t, this._webviewService = i;
  }
  serialize(e) {
    const t = e.isDirty(), i = {
      ...this.toJson(e),
      editorResource: e.resource.toJSON(),
      dirty: t,
      backupId: t ? e.backupId : void 0
    };
    try {
      return JSON.stringify(i);
    } catch {
      return;
    }
  }
  fromJson(e) {
    return {
      ...super.fromJson(e),
      editorResource: A.from(e.editorResource),
      dirty: e.dirty
    };
  }
  deserialize(e, t) {
    const i = this.fromJson(JSON.parse(t)), o = rp(this._webviewService, i), s = this._instantiationService.createInstance(qe, { resource: i.editorResource, viewType: i.viewType }, o, { startsDirty: i.dirty, backupId: i.backupId });
    return typeof i.group == "number" && s.updateGroup(i.group), s;
  }
}, ys.ID = qe.typeId;
function rp(c, e) {
  const t = c.createWebviewOverlay({
    providedViewType: e.viewType,
    origin: e.origin,
    title: void 0,
    options: {
      purpose: "customEditor",
      enableFindWidget: e.webviewOptions.enableFindWidget,
      retainContextWhenHidden: e.webviewOptions.retainContextWhenHidden
    },
    contentOptions: e.contentOptions,
    extension: e.extension
  });
  return t.state = e.state, t;
}
let ec = class extends E {
  constructor(e, t, i, o, s) {
    super(), this._instantiationService = e, this._workingCopyBackupService = i, this._webviewService = o, this._register(t.registerHandler(this));
  }
  handles(e) {
    return e.resource.scheme === q.vscodeCustomEditor;
  }
  isOpen(e, t) {
    if (!this.handles(e))
      return !1;
    if (e.resource.authority === "jupyter-notebook-ipynb" && t instanceof bf)
      try {
        const i = JSON.parse(e.resource.query), o = A.from(i);
        return Be(o, t.resource);
      } catch {
        return !1;
      }
    if (!(t instanceof qe) || e.resource.authority !== t.viewType.replace(/[^a-z0-9\-_]/gi, "-").toLowerCase())
      return !1;
    try {
      const i = JSON.parse(e.resource.query), o = A.from(i);
      return Be(o, t.resource);
    } catch {
      return !1;
    }
  }
  async createEditor(e) {
    var r, a;
    const t = await this._workingCopyBackupService.resolve(e);
    if (!(t != null && t.meta))
      throw new Error(`No backup found for custom editor: ${e.resource}`);
    const i = t.meta, o = sp((r = i.extension) == null ? void 0 : r.id, (a = i.extension) == null ? void 0 : a.location), s = rp(this._webviewService, {
      viewType: i.viewType,
      origin: i.webview.origin,
      webviewOptions: i.webview.options,
      contentOptions: np(i.webview.options),
      state: i.webview.state,
      extension: o
    }), n = this._instantiationService.createInstance(qe, { resource: A.revive(i.editorResource), viewType: i.viewType }, s, { backupId: i.backupId });
    return n.updateGroup(0), n;
  }
};
ec = y([
  l(0, W),
  l(1, kd),
  l(2, mf),
  l(3, As),
  l(4, $u)
], ec);
N.as(Ci.EditorPane).registerEditorPane(Bs.create(rs, rs.ID, "Webview Editor"), [
  new T(qe)
]);
N.as(dt.Workbench).registerWorkbenchContribution(ec, 1);
const or = f.and(f.equals("activeEditor", rs.ID), Fi.focus.toNegated()), Ui = class Ui extends ye {
  constructor() {
    super({
      id: Ui.ID,
      title: Ui.LABEL,
      keybinding: {
        when: f.and(
          or,
          eg
        ),
        primary: 2084,
        weight: 100
      }
    });
  }
  run(e) {
    var t;
    (t = sr(e)) == null || t.showFind();
  }
};
Ui.ID = "editor.action.webvieweditor.showFind", Ui.LABEL = u("editor.action.webvieweditor.showFind", "Show find");
let tc = Ui;
const ji = class ji extends ye {
  constructor() {
    super({
      id: ji.ID,
      title: ji.LABEL,
      keybinding: {
        when: f.and(
          or,
          tg
        ),
        primary: 9,
        weight: 100
      }
    });
  }
  run(e) {
    var t;
    (t = sr(e)) == null || t.hideFind();
  }
};
ji.ID = "editor.action.webvieweditor.hideFind", ji.LABEL = u("editor.action.webvieweditor.hideFind", "Stop find");
let ic = ji;
const qi = class qi extends ye {
  constructor() {
    super({
      id: qi.ID,
      title: qi.LABEL,
      keybinding: {
        when: f.and(
          or,
          Sd
        ),
        primary: 3,
        weight: 100
      }
    });
  }
  run(e) {
    var t;
    (t = sr(e)) == null || t.runFindAction(!1);
  }
};
qi.ID = "editor.action.webvieweditor.findNext", qi.LABEL = u("editor.action.webvieweditor.findNext", "Find next");
let oc = qi;
const $i = class $i extends ye {
  constructor() {
    super({
      id: $i.ID,
      title: $i.LABEL,
      keybinding: {
        when: f.and(
          or,
          Sd
        ),
        primary: 1027,
        weight: 100
      }
    });
  }
  run(e) {
    var t;
    (t = sr(e)) == null || t.runFindAction(!0);
  }
};
$i.ID = "editor.action.webvieweditor.findPrevious", $i.LABEL = u("editor.action.webvieweditor.findPrevious", "Find previous");
let sc = $i;
const eo = class eo extends ye {
  constructor() {
    super({
      id: eo.ID,
      title: { value: eo.LABEL, original: "Reload Webviews" },
      category: Ce.Developer,
      menu: [{
        id: k.CommandPalette
      }]
    });
  }
  async run(e) {
    const t = e.get(As);
    for (const i of t.webviews)
      i.reload();
  }
};
eo.ID = "workbench.action.webview.reloadWebviewAction", eo.LABEL = u("refreshWebviewLabel", "Reload Webviews");
let nc = eo;
function sr(c) {
  const t = c.get(D).activeEditor;
  return t instanceof ns ? t.webview : void 0;
}
N.as(Ci.EditorPane).registerEditorPane(Bs.create(rs, rs.ID, u("webview.editor.label", "webview editor")), [new T(ns)]);
let rc = class extends E {
  constructor(e) {
    super(), this.editorGroupService = e, this.editorGroupService.whenReady.then(() => this.editorGroupService.groups.forEach((t) => {
      this.registerGroupListener(t);
    })), this._register(this.editorGroupService.onDidAddGroup((t) => this.registerGroupListener(t)));
  }
  registerGroupListener(e) {
    const t = e.onWillOpenEditor((i) => this.onEditorOpening(i.editor, e));
    _.once(e.onWillDispose)(() => {
      t.dispose();
    });
  }
  onEditorOpening(e, t) {
    if (!(e instanceof ns) || e.typeId !== ns.typeId || t.contains(e))
      return;
    let i;
    const o = this.editorGroupService.groups;
    for (const s of o)
      if (s.contains(e)) {
        i = s;
        break;
      }
    i && i.closeEditor(e);
  }
};
rc = y([
  l(0, ce)
], rc);
const Ek = N.as(dt.Workbench);
Ek.registerWorkbenchContribution(rc, 1);
P(tc);
P(ic);
P(oc);
P(sc);
P(nc);
N.as(Cd.Configuration).registerConfiguration(Cf);
var Rk = '@keyframes wiggle{0%{transform:rotate(0) scale(1)}15%,45%{transform:rotate(.04turn) scale(1.1)}30%,60%{transform:rotate(-.04turn) scale(1.2)}to{transform:rotate(0) scale(1)}}.monaco-workbench .statusbar DIV#status\\.languageStatus A>SPAN.codicon.wiggle{animation-duration:.8s;animation-iteration-count:1;animation-name:wiggle}@keyframes flash{0%{background-color:initial}50%{background-color:var(--vscode-statusBarItem-prominentBackground)}to{background-color:initial}}.monaco-workbench .statusbar DIV#status\\.languageStatus.flash A{animation-duration:.8s;animation-iteration-count:1;animation-name:flash}.monaco-workbench .hover-language-status{display:flex;padding:4px 8px}.monaco-workbench .hover-language-status:not(:last-child){border-bottom:1px solid var(--vscode-notifications-border)}.monaco-workbench .hover-language-status>.severity{display:none;flex:1;margin:auto;padding-right:8px}.monaco-workbench .hover-language-status>.severity.sev3{color:var(--vscode-notificationsErrorIcon-foreground)}.monaco-workbench .hover-language-status>.severity.sev2{color:var(--vscode-notificationsInfoIcon-foreground)}.monaco-workbench .hover-language-status>.severity.show{display:inherit}.monaco-workbench .hover-language-status>.element{display:flex;flex-grow:100;justify-content:space-between;vertical-align:middle}.monaco-workbench .hover-language-status>.element>.left>.detail:not(:empty):before{content:"\\2013";opacity:.6;padding:0 4px}.monaco-workbench .hover-language-status>.element>.left>.label:empty{display:none}.monaco-workbench .hover-language-status>.element .left{margin:auto 0}.monaco-workbench .hover-language-status>.element .right{display:flex;margin:auto 0}.monaco-workbench .hover-language-status>.element .right:not(:empty){padding-left:16px}.monaco-workbench .hover-language-status>.element .right .monaco-link{margin:auto 0;white-space:nowrap}.monaco-workbench .hover-language-status>.element .right .monaco-action-bar:not(:first-child){padding-left:8px}';
oe(Rk, {});
class ih {
  constructor(e, t) {
    this.combined = e, this.dedicated = t;
  }
  isEqual(e) {
    return bi(this.combined, e.combined) && bi(this.dedicated, e.dedicated);
  }
}
let ac = class {
  constructor(e, t) {
    this._storageService = e, this._key = t;
  }
  get value() {
    return this._storageService.getNumber(this._key, 0, 0);
  }
  increment() {
    const e = this.value + 1;
    return this._storageService.store(this._key, e, 0, 1), e;
  }
};
ac = y([
  l(0, ee)
], ac);
var Ue;
let cc = (Ue = class {
  constructor(e, t, i, o, s) {
    this._languageStatusService = e, this._statusBarService = t, this._editorService = i, this._openerService = o, this._storageService = s, this._disposables = new Z(), this._dedicated = /* @__PURE__ */ new Set(), this._dedicatedEntries = /* @__PURE__ */ new Map(), this._renderDisposables = new Z(), s.onDidChangeValue(this._handleStorageChange, this, this._disposables), this._restoreState(), this._interactionCounter = new ac(s, "languageStatus.interactCount"), e.onDidChange(this._update, this, this._disposables), i.onDidActiveEditorChange(this._update, this, this._disposables), this._update(), t.onDidChangeEntryVisibility((n) => {
      !n.visible && this._dedicated.has(n.id) && (this._dedicated.delete(n.id), this._update(), this._storeState());
    }, this._disposables);
  }
  dispose() {
    var e;
    this._disposables.dispose(), (e = this._combinedEntry) == null || e.dispose(), le(this._dedicatedEntries.values()), this._renderDisposables.dispose();
  }
  _handleStorageChange(e) {
    e.key === Ue._keyDedicatedItems && (this._restoreState(), this._update());
  }
  _restoreState() {
    const e = this._storageService.get(Ue._keyDedicatedItems, 0, "[]");
    try {
      const t = JSON.parse(e);
      this._dedicated = new Set(t);
    } catch {
      this._dedicated.clear();
    }
  }
  _storeState() {
    if (this._dedicated.size === 0)
      this._storageService.remove(Ue._keyDedicatedItems, 0);
    else {
      const e = JSON.stringify(Array.from(this._dedicated.keys()));
      this._storageService.store(Ue._keyDedicatedItems, e, 0, 0);
    }
  }
  _createViewModel(e) {
    if (!(e != null && e.hasModel()))
      return new ih([], []);
    const t = this._languageStatusService.getLanguageStatus(e.getModel()), i = [], o = [];
    for (const s of t)
      this._dedicated.has(s.id) && o.push(s), i.push(s);
    return new ih(i, o);
  }
  _update() {
    var o, s;
    const e = Id(this._editorService.activeTextEditorControl), t = this._createViewModel(e);
    if ((o = this._model) != null && o.isEqual(t))
      return;
    if (this._renderDisposables.clear(), this._model = t, e == null || e.onDidChangeModelLanguage(this._update, this, this._renderDisposables), t.combined.length === 0)
      (s = this._combinedEntry) == null || s.dispose(), this._combinedEntry = void 0;
    else {
      const [n] = t.combined, r = n.severity >= ft.Warning, a = Ue._severityToComboCodicon(n.severity);
      let d = !1;
      const h = [], g = document.createElement("div");
      for (const v of t.combined) {
        const J = t.dedicated.includes(v);
        g.appendChild(this._renderStatus(v, r, J, this._renderDisposables)), h.push(this._asAriaLabel(v)), d = d || !J && v.busy;
      }
      const p = {
        name: u("langStatus.name", "Editor Language Status"),
        ariaLabel: u(
          "langStatus.aria",
          "Editor Language Status: {0}",
          h.join(", next: ")
        ),
        tooltip: g,
        command: Pr,
        text: d ? `${a}$(sync~spin)` : a
      };
      this._combinedEntry ? this._combinedEntry.update(p) : this._combinedEntry = this._statusBarService.addEntry(p, Ue._id, 1, { id: "status.editor.mode", alignment: 0, compact: !0 });
      const m = this._interactionCounter.value >= 3, C = document.querySelector(".monaco-workbench .statusbar DIV#status\\.languageStatus A>SPAN.codicon"), b = document.querySelector(".monaco-workbench .statusbar DIV#status\\.languageStatus");
      if (C instanceof HTMLElement && b) {
        const v = "wiggle", J = "flash";
        d ? (C.classList.remove(v), b.classList.remove(J)) : (C.classList.toggle(v, r || !m), this._renderDisposables.add(S(C, "animationend", (R) => C.classList.remove(v))), b.classList.toggle(J, r), this._renderDisposables.add(S(b, "animationend", (R) => b.classList.remove(J))));
      }
      if (!m) {
        const v = document.querySelector(".monaco-workbench .context-view");
        if (v instanceof HTMLElement) {
          const J = new MutationObserver(() => {
            document.contains(g) && (this._interactionCounter.increment(), J.disconnect());
          });
          J.observe(v, { childList: !0, subtree: !0 }), this._renderDisposables.add(M(() => J.disconnect()));
        }
      }
    }
    const i = /* @__PURE__ */ new Map();
    for (const n of t.dedicated) {
      const r = Ue._asStatusbarEntry(n);
      let a = this._dedicatedEntries.get(n.id);
      a ? (a.update(r), this._dedicatedEntries.delete(n.id)) : a = this._statusBarService.addEntry(r, n.id, 1, { id: "status.editor.mode", alignment: 1 }), i.set(n.id, a);
    }
    le(this._dedicatedEntries.values()), this._dedicatedEntries = i;
  }
  _renderStatus(e, t, i, o) {
    const s = document.createElement("div");
    s.classList.add("hover-language-status");
    const n = document.createElement("div");
    n.classList.add("severity", `sev${e.severity}`), n.classList.toggle("show", t);
    const r = Ue._severityToSingleCodicon(e.severity);
    ae(n, ...Ms(r)), s.appendChild(n);
    const a = document.createElement("div");
    a.classList.add("element"), s.appendChild(a);
    const d = document.createElement("div");
    d.classList.add("left"), a.appendChild(d);
    const h = document.createElement("span");
    h.classList.add("label"), ae(h, ...Ms(e.busy ? `$(sync~spin)${e.label}` : e.label)), d.appendChild(h);
    const g = document.createElement("span");
    g.classList.add("detail"), this._renderTextPlus(g, e.detail, o), d.appendChild(g);
    const p = document.createElement("div");
    p.classList.add("right"), a.appendChild(p);
    const { command: m } = e;
    m && o.add(new Cl(p, {
      label: m.title,
      title: m.tooltip,
      href: A.from({
        scheme: "command",
        path: m.id,
        query: m.arguments && JSON.stringify(m.arguments)
      }).toString()
    }, void 0, this._openerService));
    const C = new Ro(p, {});
    o.add(C);
    let b;
    return i ? b = new j("unpin", u("unpin", "Remove from Status Bar"), pe.asClassName(he.pinned), !0, () => {
      this._dedicated.delete(e.id), this._statusBarService.updateEntryVisibility(e.id, !1), this._update(), this._storeState();
    }) : b = new j("pin", u("pin", "Add to Status Bar"), pe.asClassName(he.pin), !0, () => {
      this._dedicated.add(e.id), this._statusBarService.updateEntryVisibility(e.id, !0), this._update(), this._storeState();
    }), C.push(b, { icon: !0, label: !1 }), o.add(b), s;
  }
  static _severityToComboCodicon(e) {
    switch (e) {
      case ft.Error:
        return "$(bracket-error)";
      case ft.Warning:
        return "$(bracket-dot)";
      default:
        return "$(bracket)";
    }
  }
  static _severityToSingleCodicon(e) {
    switch (e) {
      case ft.Error:
        return "$(error)";
      case ft.Warning:
        return "$(info)";
      default:
        return "$(check)";
    }
  }
  _renderTextPlus(e, t, i) {
    for (const o of ff(t).nodes)
      if (typeof o == "string") {
        const s = Ms(o);
        ae(e, ...s);
      } else
        i.add(new Cl(e, o, void 0, this._openerService));
  }
  _asAriaLabel(e) {
    return e.accessibilityInfo ? e.accessibilityInfo.label : e.detail ? u("aria.1", "{0}, {1}", e.label, e.detail) : u("aria.2", "{0}", e.label);
  }
  static _asStatusbarEntry(e) {
    var o, s, n;
    let t, i;
    return e.severity === ft.Warning ? (t = Oi(yf), i = Oi(kf)) : e.severity === ft.Error && (t = Oi(Sf), i = Oi(If)), {
      name: u("name.pattern", "{0} (Language Status)", e.name),
      text: e.busy ? `${e.label}$(sync~spin)` : e.label,
      ariaLabel: ((o = e.accessibilityInfo) == null ? void 0 : o.label) ?? e.label,
      role: (s = e.accessibilityInfo) == null ? void 0 : s.role,
      tooltip: ((n = e.command) == null ? void 0 : n.tooltip) || new vf(e.detail, { isTrusted: !0, supportThemeIcons: !0 }),
      color: t,
      backgroundColor: i,
      command: e.command
    };
  }
}, Ue._id = "status.languageStatus", Ue._keyDedicatedItems = "languageStatus.dedicated", Ue);
cc = y([
  l(0, wf),
  l(1, oi),
  l(2, D),
  l(3, Ti),
  l(4, ee)
], cc);
N.as(dt.Workbench).registerWorkbenchContribution(cc, 3);
P(class extends ye {
  constructor() {
    super({
      id: "editor.inlayHints.Reset",
      title: {
        value: u("reset", "Reset Language Status Interaction Counter"),
        original: "Reset Language Status Interaction Counter"
      },
      category: Ce.View,
      f1: !0
    });
  }
  run(c) {
    c.get(ee).remove("languageStatus.interactCount", 0);
  }
});
const Gk = new K("notebookEditable", !0), dc = "editor.detectLanguage";
var Vo;
let lc = (Vo = class {
  constructor(e, t, i, o, s, n) {
    this._languageDetectionService = e, this._statusBarService = t, this._configurationService = i, this._editorService = o, this._languageService = s, this._keybindingService = n, this._disposables = new Z(), this._delayer = new ig(1e3), this._renderDisposables = new Z(), o.onDidActiveEditorChange(() => this._update(!0), this, this._disposables), this._update(!1);
  }
  dispose() {
    var e;
    this._disposables.dispose(), this._delayer.dispose(), (e = this._combinedEntry) == null || e.dispose(), this._renderDisposables.dispose();
  }
  _update(e) {
    var t;
    e && ((t = this._combinedEntry) == null || t.dispose(), this._combinedEntry = void 0), this._delayer.trigger(() => this._doUpdate());
  }
  async _doUpdate() {
    var a, d;
    const e = Id(this._editorService.activeTextEditorControl);
    this._renderDisposables.clear(), e == null || e.onDidChangeModelLanguage(() => this._update(!0), this, this._renderDisposables), e == null || e.onDidChangeModelContent(() => this._update(!1), this, this._renderDisposables);
    const t = e == null ? void 0 : e.getModel(), i = t == null ? void 0 : t.uri, o = t == null ? void 0 : t.getLanguageId(), s = this._configurationService.getValue("workbench.editor.languageDetectionHints");
    if (!(typeof s == "object" && (s == null ? void 0 : s.untitledEditors)) || (i == null ? void 0 : i.scheme) !== q.untitled || !o || !i)
      (a = this._combinedEntry) == null || a.dispose(), this._combinedEntry = void 0;
    else {
      const h = await this._languageDetectionService.detectLanguage(i), g = { jsonc: "json" }, p = t.getLanguageId();
      if (h && h !== p && g[p] !== h) {
        const m = this._languageService.getLanguageName(h) || h;
        let C = u("status.autoDetectLanguage", "Accept Detected Language: {0}", m);
        const b = this._keybindingService.lookupKeybinding(dc), v = b == null ? void 0 : b.getLabel();
        v && (C += ` (${v})`);
        const J = {
          name: u("langDetection.name", "Language Detection"),
          ariaLabel: u("langDetection.aria", "Change to Detected Language: {0}", h),
          tooltip: C,
          command: dc,
          text: "$(lightbulb-autofix)"
        };
        this._combinedEntry ? this._combinedEntry.update(J) : this._combinedEntry = this._statusBarService.addEntry(J, Vo._id, 1, { id: "status.editor.mode", alignment: 1, compact: !0 });
      } else
        (d = this._combinedEntry) == null || d.dispose(), this._combinedEntry = void 0;
    }
  }
}, Vo._id = "status.languageDetectionStatus", Vo);
lc = y([
  l(0, og),
  l(1, oi),
  l(2, x),
  l(3, D),
  l(4, fh),
  l(5, be)
], lc);
N.as(dt.Workbench).registerWorkbenchContribution(lc, 3);
P(class extends ye {
  constructor() {
    super({
      id: dc,
      title: { value: u("detectlang", "Detect Language from Content"), original: "Detect Language from Content" },
      f1: !0,
      precondition: f.and(Gk.toNegated(), Fi.editorTextFocus),
      keybinding: { primary: 1570, weight: 200 }
    });
  }
  async run(c) {
    var n, r;
    const e = c.get(D), t = c.get(og), i = Id(e.activeTextEditorControl), o = c.get(We), s = (n = i == null ? void 0 : i.getModel()) == null ? void 0 : n.uri;
    if (s) {
      const a = await t.detectLanguage(s);
      a ? (r = i.getModel()) == null || r.setLanguage(a, Jf) : o.warn(u("noDetection", "Unable to detect editor language"));
    }
  }
});
let hc = class extends E {
  constructor(e, t, i, o, s, n, r) {
    super(), this.editorService = e, this.textFileService = t, this.lifecycleService = i, this.hostService = o, this.codeEditorService = s, this.filesConfigurationService = n, this.workingCopyEditorService = r, this.ensureDirtyFilesAreOpenedWorker = this._register(new jh(
      (a) => this.ensureDirtyTextFilesAreOpened(a),
      this.getDirtyTextFileTrackerDelay()
    )), this.registerListeners();
  }
  registerListeners() {
    this._register(this.textFileService.files.onDidChangeDirty((e) => this.ensureDirtyFilesAreOpenedWorker.work(e.resource))), this._register(this.textFileService.files.onDidSaveError((e) => this.ensureDirtyFilesAreOpenedWorker.work(e.resource))), this._register(this.textFileService.untitled.onDidChangeDirty((e) => this.ensureDirtyFilesAreOpenedWorker.work(e.resource))), this._register(this.hostService.onDidChangeFocus((e) => e ? this.reloadVisibleTextFileEditors() : void 0)), this.lifecycleService.onDidShutdown(() => this.dispose());
  }
  getDirtyTextFileTrackerDelay() {
    return 800;
  }
  ensureDirtyTextFilesAreOpened(e) {
    this.doEnsureDirtyTextFilesAreOpened(oo(e.filter((t) => {
      if (!this.textFileService.isDirty(t))
        return !1;
      const i = this.textFileService.files.get(t);
      if (i != null && i.hasState(2) || t.scheme !== q.untitled && this.filesConfigurationService.getAutoSaveMode() === 1 && !(i != null && i.hasState(5)) || this.editorService.isOpened({ resource: t, typeId: t.scheme === q.untitled ? Vf.ID : dd, editorId: Ke.id }))
        return !1;
      const o = i ?? this.textFileService.untitled.get(t);
      return !(o && this.workingCopyEditorService.findEditor(o));
    }), (t) => t.toString()));
  }
  doEnsureDirtyTextFilesAreOpened(e) {
    e.length && this.editorService.openEditors(e.map((t) => ({
      resource: t,
      options: { inactive: !0, pinned: !0, preserveFocus: !0 }
    })));
  }
  reloadVisibleTextFileEditors() {
    oo(ti(this.codeEditorService.listCodeEditors().map((e) => {
      var o;
      const t = (o = e.getModel()) == null ? void 0 : o.uri;
      if (!t)
        return;
      const i = this.textFileService.files.get(t);
      if (!(!i || i.isDirty() || !i.isResolved()))
        return i;
    })), (e) => e.resource.toString()).forEach((e) => this.textFileService.files.resolve(e.resource, { reload: { async: !0 } }));
  }
};
hc = y([
  l(0, D),
  l(1, Qo),
  l(2, xo),
  l(3, Ai),
  l(4, No),
  l(5, Js),
  l(6, kd)
], hc);
var Zo;
let In = (Zo = class extends fw {
  constructor(e, t, i, o, s) {
    super(Zo.ID, {
      openInternal: (n, r) => this.openInternal(n, r)
    }, e, t, o), this.editorResolverService = i, this.editorGroupService = s;
  }
  async openInternal(e, t) {
    var i;
    if (e instanceof At && ((i = this.group) != null && i.activeEditor)) {
      const o = this.group.activeEditor, s = o == null ? void 0 : o.toUntyped();
      if (!s)
        return;
      let n = await this.editorResolverService.resolveEditor({
        ...s,
        options: {
          ...t,
          override: Po.PICK
        }
      }, this.group);
      if (n === 2)
        n = void 0;
      else if (n === 1)
        return;
      if (sg(n))
        for (const r of n.editor instanceof ld ? [n.editor.original, n.editor.modified] : [n.editor])
          r instanceof At && (r.setForceOpenAsText(), r.setPreferredLanguageId(Jd));
      await (this.group ?? this.editorGroupService.activeGroup).replaceEditors([{
        editor: o,
        replacement: (n == null ? void 0 : n.editor) ?? e,
        options: {
          ...(n == null ? void 0 : n.options) ?? t
        }
      }]);
    }
  }
  getTitle() {
    return this.input ? this.input.getName() : u("binaryFileEditor", "Binary File Viewer");
  }
}, Zo.ID = mu, Zo);
In = y([
  l(0, Xe),
  l(1, z),
  l(2, Zs),
  l(3, ee),
  l(4, ce)
], In);
let uc = class extends E {
  constructor(e, t, i, o, s, n, r) {
    super(), this.fileService = e, this.configurationService = t, this.contextService = i, this.notificationService = o, this.openerService = s, this.uriIdentityService = n, this.hostService = r, this.watchedWorkspaces = new Et((a) => this.uriIdentityService.extUri.getComparisonKey(a)), this.registerListeners(), this.refresh();
  }
  registerListeners() {
    this._register(this.contextService.onDidChangeWorkspaceFolders((e) => this.onDidChangeWorkspaceFolders(e))), this._register(this.contextService.onDidChangeWorkbenchState(() => this.onDidChangeWorkbenchState())), this._register(this.configurationService.onDidChangeConfiguration((e) => this.onDidChangeConfiguration(e))), this._register(this.fileService.onDidWatchError((e) => this.onDidWatchError(e)));
  }
  onDidChangeWorkspaceFolders(e) {
    for (const t of e.removed)
      this.unwatchWorkspace(t);
    for (const t of e.added)
      this.watchWorkspace(t);
  }
  onDidChangeWorkbenchState() {
    this.refresh();
  }
  onDidChangeConfiguration(e) {
    (e.affectsConfiguration("files.watcherExclude") || e.affectsConfiguration("files.watcherInclude")) && this.refresh();
  }
  onDidWatchError(e) {
    const t = e.toString();
    t.indexOf("ENOSPC") >= 0 ? this.notificationService.prompt(xi.Warning, u(
      "enospcError",
      "Unable to watch for file changes in this large workspace folder. Please follow the instructions link to resolve this issue."
    ), [{
      label: u("learnMore", "Instructions"),
      run: () => this.openerService.open(A.parse("https://go.microsoft.com/fwlink/?linkid=867693"))
    }], {
      sticky: !0,
      neverShowAgain: { id: "ignoreEnospcError", isSecondary: !0, scope: Wf.WORKSPACE }
    }) : t.indexOf("EUNKNOWN") >= 0 && this.notificationService.prompt(xi.Warning, u(
      "eshutdownError",
      "File changes watcher stopped unexpectedly. A reload of the window may enable the watcher again unless the workspace cannot be watched for file changes."
    ), [{
      label: u("reload", "Reload"),
      run: () => this.hostService.reload()
    }], {
      sticky: !0,
      priority: _f.SILENT
    });
  }
  watchWorkspace(e) {
    var n, r;
    const t = [], i = this.configurationService.getValue({ resource: e.uri });
    if ((n = i.files) != null && n.watcherExclude)
      for (const a in i.files.watcherExclude)
        i.files.watcherExclude[a] === !0 && t.push(a);
    const o = new Et((a) => this.uriIdentityService.extUri.getComparisonKey(a));
    if (o.set(e.uri, e.uri), (r = i.files) != null && r.watcherInclude) {
      for (const a of i.files.watcherInclude)
        if (a)
          if (Ef(a)) {
            const d = A.file(a).with({ scheme: e.uri.scheme });
            this.uriIdentityService.extUri.isEqualOrParent(d, e.uri) && o.set(d, d);
          } else {
            const d = e.toResource(a);
            o.set(d, d);
          }
    }
    const s = new Z();
    for (const [, a] of o)
      s.add(this.fileService.watch(a, { recursive: !0, excludes: t }));
    this.watchedWorkspaces.set(e.uri, s);
  }
  unwatchWorkspace(e) {
    this.watchedWorkspaces.has(e.uri) && (le(this.watchedWorkspaces.get(e.uri)), this.watchedWorkspaces.delete(e.uri));
  }
  refresh() {
    this.unwatchWorkspaces();
    for (const e of this.contextService.getWorkspace().folders)
      this.watchWorkspace(e);
  }
  unwatchWorkspaces() {
    for (const [, e] of this.watchedWorkspaces)
      e.dispose();
    this.watchedWorkspaces.clear();
  }
  dispose() {
    super.dispose(), this.unwatchWorkspaces();
  }
};
uc = y([
  l(0, Zf),
  l(1, x),
  l(2, at),
  l(3, We),
  l(4, Ti),
  l(5, Li),
  l(6, Ai)
], uc);
let gc = class extends E {
  constructor(e, t, i, o) {
    super(), this.lifecycleService = e, this.activityService = t, this.workingCopyService = i, this.filesConfigurationService = o, this.badgeHandle = this._register(new Re()), this.lastKnownDirtyCount = 0, this.updateActivityBadge(), this.registerListeners();
  }
  registerListeners() {
    this._register(this.workingCopyService.onDidChangeDirty((e) => this.onWorkingCopyDidChangeDirty(e))), this.lifecycleService.onDidShutdown(() => this.dispose());
  }
  onWorkingCopyDidChangeDirty(e) {
    const t = e.isDirty();
    t && !(e.capabilities & 2) && this.filesConfigurationService.getAutoSaveMode() === 1 || (t || this.lastKnownDirtyCount > 0) && this.updateActivityBadge();
  }
  updateActivityBadge() {
    const e = this.lastKnownDirtyCount = this.workingCopyService.dirtyCount;
    e > 0 ? this.badgeHandle.value = this.activityService.showViewContainerActivity(Mt, {
      badge: new to(e, (t) => t === 1 ? u("dirtyFile", "1 unsaved file") : u("dirtyFiles", "{0} unsaved files", e)),
      clazz: "explorer-viewlet-label"
    }) : this.badgeHandle.clear();
  }
};
gc = y([
  l(0, xo),
  l(1, Eo),
  l(2, ng),
  l(3, Js)
], gc);
let pc = class extends E {
  constructor(e, t, i) {
    super(), this.textEditorService = t, this.fileService = i, this._register(e.registerHandler(this));
  }
  handles(e) {
    return e.typeId === fl && this.fileService.canHandleResource(e.resource);
  }
  handlesSync(e) {
    return e.typeId === fl && this.fileService.hasProvider(e.resource);
  }
  isOpen(e, t) {
    return this.handlesSync(e) ? Be(e.resource, t.resource) : !1;
  }
  createEditor(e) {
    return this.textEditorService.createTextEditor({ resource: e.resource, forceFile: !0 });
  }
};
pc = y([
  l(0, kd),
  l(1, rg),
  l(2, _e)
], pc);
var Wo;
let Jn = (Wo = class extends Rf {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m, C, b, v, J) {
    super(Wo.ID, e, o, n, r, d, a, h, t), this.paneCompositeService = i, this.contextService = s, this.textFileService = g, this.explorerService = p, this.uriIdentityService = m, this.pathService = C, this.configurationService = b, this.preferencesService = v, this.hostService = J, this._register(this.fileService.onDidFilesChange((R) => this.onDidFilesChange(R))), this._register(this.fileService.onDidRunOperation((R) => this.onDidRunOperation(R)));
  }
  onDidFilesChange(e) {
    for (const t of e.rawDeleted)
      this.clearEditorViewState(t);
  }
  onDidRunOperation(e) {
    e.operation === 2 && e.target && this.moveEditorViewState(e.resource, e.target.resource, this.uriIdentityService.extUri);
  }
  getTitle() {
    return this.input ? this.input.getName() : u("textFileEditor", "Text File Editor");
  }
  get input() {
    return this._input;
  }
  async setInput(e, t, i, o) {
    Ys("code/willSetInputToTextFileEditor"), await super.setInput(e, t, i, o);
    try {
      const s = await e.resolve(t);
      if (o.isCancellationRequested)
        return;
      if (s instanceof gg)
        return this.openAsBinary(e, t);
      const n = s, r = L(this.editorControl);
      if (r.setModel(n.textEditorModel), !Gf(t == null ? void 0 : t.viewState)) {
        const a = this.loadEditorViewState(e, i);
        a && (t != null && t.selection && (a.cursorState = []), r.restoreViewState(a));
      }
      t && xf(t, r, 1), r.updateOptions(this.getReadonlyConfiguration(n.isReadonly())), r.handleInitialized && r.handleInitialized();
    } catch (s) {
      await this.handleSetInputError(s, e, t);
    }
    Ys("code/didSetInputToTextFileEditor");
  }
  async handleSetInputError(e, t, i) {
    if (e.textFileOperationResult === 0)
      return this.openAsBinary(t, i);
    if (e.fileOperationResult === 0) {
      const o = [];
      throw o.push(we({
        id: "workbench.files.action.openFolder",
        label: u("openFolder", "Open Folder"),
        run: async () => this.hostService.openWindow([{ folderUri: t.resource }], { forceNewWindow: !0 })
      })), this.contextService.isInsideWorkspace(t.preferredResource) && o.push(we({
        id: "workbench.files.action.reveal",
        label: u("reveal", "Reveal Folder"),
        run: async () => (await this.paneCompositeService.openPaneComposite(Mt, 0, !0), this.explorerService.select(t.preferredResource, !0))
      })), vl(u("fileIsDirectory", "The file is not displayed in the text editor because it is a directory."), o, { forceMessage: !0 });
    }
    if (e.fileOperationResult === 7 && this.group) {
      let o;
      throw e instanceof Df ? o = u(
        "fileTooLargeForHeapErrorWithSize",
        "The file is not displayed in the text editor because it is very large ({0}).",
        Cu.formatSize(e.size)
      ) : o = u(
        "fileTooLargeForHeapErrorWithoutSize",
        "The file is not displayed in the text editor because it is very large."
      ), Nf(this.group, t, i, o, this.preferencesService);
    }
    throw e.fileOperationResult === 1 && await this.pathService.hasValidBasename(t.preferredResource) ? vl(new ag(u(
      "unavailableResourceErrorEditorText",
      "The editor could not be opened because the file was not found."
    ), 1), [
      we({
        id: "workbench.files.action.createMissingFile",
        label: u("createFile", "Create File"),
        run: async () => (await this.textFileService.create([{ resource: t.preferredResource }]), this.editorService.openEditor({
          resource: t.preferredResource,
          options: {
            pinned: !0
          }
        }))
      })
    ], {
      allowDialog: !0
    }) : e;
  }
  openAsBinary(e, t) {
    const i = this.configurationService.getValue("workbench.editor.defaultBinaryEditor"), o = this.group ?? this.editorGroupService.activeGroup, s = {
      ...t,
      activation: Zi.PRESERVE
    };
    i && i !== "" && i !== Ke.id ? this.doOpenAsBinaryInDifferentEditor(o, i, e, s) : this.doOpenAsBinaryInSameEditor(o, i, e, s);
  }
  doOpenAsBinaryInDifferentEditor(e, t, i, o) {
    this.editorService.replaceEditors([{
      editor: i,
      replacement: { resource: i.resource, options: { ...o, override: t } }
    }], e);
  }
  doOpenAsBinaryInSameEditor(e, t, i, o) {
    t === Ke.id ? (i.setForceOpenAsText(), i.setPreferredLanguageId(Jd), o = { ...o, forceReload: !0 }) : i.setForceOpenAsBinary(), e.openEditor(i, o);
  }
  clearInput() {
    var e;
    super.clearInput(), (e = this.editorControl) == null || e.setModel(null);
  }
  createEditorControl(e, t) {
    Ys("code/willCreateTextFileEditorControl"), super.createEditorControl(e, t), Ys("code/didCreateTextFileEditorControl");
  }
  tracksEditorViewState(e) {
    return e instanceof At;
  }
  tracksDisposedEditorViewState() {
    return !0;
  }
}, Wo.ID = bu, Wo);
Jn = y([
  l(0, Xe),
  l(1, _e),
  l(2, ii),
  l(3, W),
  l(4, at),
  l(5, ee),
  l(6, Go),
  l(7, D),
  l(8, z),
  l(9, ce),
  l(10, Qo),
  l(11, ht),
  l(12, Li),
  l(13, Pn),
  l(14, x),
  l(15, Hc),
  l(16, Ai)
], Jn);
let mc = class {
  constructor(e) {
    e.registerFormatter({
      scheme: q.file,
      formatting: {
        label: "${authority}${path}",
        separator: zo,
        tildify: !Qt,
        normalizeDriveLetter: Qt,
        authorityPrefix: zo + zo,
        workspaceSuffix: ""
      }
    });
  }
};
mc = y([
  l(0, Ft)
], mc);
N.as(Ci.EditorPane).registerEditorPane(Bs.create(Jn, Jn.ID, u("textFileEditor", "Text File Editor")), [
  new T(At)
]);
N.as(Ci.EditorPane).registerEditorPane(Bs.create(In, In.ID, u("binaryFileEditor", "Binary File Editor")), [
  new T(At)
]);
N.as(Ci.EditorFactory).registerFileEditorFactory({
  typeId: dd,
  createFileEditor: (c, e, t, i, o, s, n, r) => r.createInstance(At, c, e, t, i, o, s, n),
  isFileEditor: (c) => c instanceof At
});
N.as(dt.Workbench).registerWorkbenchContribution(pc, 2);
N.as(dt.Workbench).registerWorkbenchContribution(Qf, 1);
N.as(dt.Workbench).registerWorkbenchContribution(hc, 1);
N.as(dt.Workbench).registerWorkbenchContribution(xa, 1);
N.as(dt.Workbench).registerWorkbenchContribution(mc, 1);
N.as(dt.Workbench).registerWorkbenchContribution(uc, 3);
N.as(dt.Workbench).registerWorkbenchContribution(gc, 1);
cg.addImplementation(110, "explorer", (c) => {
  const e = c.get(qn), t = c.get(ht), o = c.get(x).getValue().explorer.enableUndo;
  return t.hasViewFocus() && e.canUndo(ds) && o ? (e.undo(ds), !0) : !1;
});
dg.addImplementation(110, "explorer", (c) => {
  const e = c.get(qn), t = c.get(ht), o = c.get(x).getValue().explorer.enableUndo;
  return t.hasViewFocus() && e.canRedo(ds) && o ? (e.redo(ds), !0) : !1;
});
Af.registerLanguage({
  id: Jd,
  aliases: ["Binary"],
  mimetypes: ["text/x-code-binary"]
});
var je;
let bc = (je = class extends E {
  constructor(e, t, i, o, s, n, r, a, d) {
    super(), this.editorGroupService = e, this.instantiationService = t, this.configurationService = i, this.quickInputService = o, this.notificationService = s, this.telemetryService = n, this.storageService = r, this.extensionService = a, this.logService = d, this._onDidChangeEditorRegistrations = this._register(new Bf()), this.onDidChangeEditorRegistrations = this._onDidChangeEditorRegistrations.event, this._editors = /* @__PURE__ */ new Map(), this._flattenedEditors = /* @__PURE__ */ new Map(), this._shouldReFlattenEditors = !0, this.cache = new Set(
      JSON.parse(this.storageService.get(je.cacheStorageID, 0, JSON.stringify([])))
    ), this.storageService.remove(je.cacheStorageID, 0), this._register(this.storageService.onWillSaveState(() => {
      this.cacheEditors();
    })), this.extensionService.onDidRegisterExtensions(() => {
      this.cache = void 0;
    });
  }
  resolveUntypedInputAndGroup(e, t) {
    const i = e, [o, s] = this.instantiationService.invokeFunction(ug, i, t);
    return [i, o, s];
  }
  async resolveEditor(e, t) {
    var g, p, m, C;
    if (this._flattenedEditors = this._flattenEditorsMap(), wl(e))
      return this.doResolveSideBySideEditor(e, t);
    const i = this.resolveUntypedInputAndGroup(e, t);
    if (!i)
      return 2;
    const [o, s, n] = i;
    n && (o.options = { ...o.options, activation: n });
    let r = me.getCanonicalUri(o, { supportSideBySide: ie.PRIMARY });
    if (this.cache && r && this.resourceMatchesCache(r) && await this.extensionService.whenInstalledExtensionsRegistered(), r === void 0)
      r = A.from({ scheme: q.untitled });
    else if (r.scheme === void 0 || r === null)
      return 2;
    if (((g = o.options) == null ? void 0 : g.override) === Po.PICK) {
      const b = await this.doPickEditor(o);
      if (!b)
        return 1;
      o.options = b;
    }
    let { editor: a, conflictingDefault: d } = this.getEditor(r, (p = o.options) == null ? void 0 : p.override);
    if (!a && ((m = o.options) != null && m.override || sg(e)))
      return 2;
    if (!a) {
      const b = this.getEditor(r, Ke.id);
      if (a = b == null ? void 0 : b.editor, d = b == null ? void 0 : b.conflictingDefault, !a)
        return 2;
    }
    if (mr(o) && ((C = o.options) == null ? void 0 : C.override) === void 0) {
      let b = me.getCanonicalUri(o, { supportSideBySide: ie.SECONDARY });
      b || (b = A.from({ scheme: q.untitled }));
      const { editor: v } = this.getEditor(b, void 0);
      if (!v || a.editorInfo.id !== v.editorInfo.id) {
        const { editor: J, conflictingDefault: R } = this.getEditor(r, Ke.id);
        a = J, d = R;
      }
      if (!a)
        return 2;
    }
    if (o.options = { override: a.editorInfo.id, ...o.options }, a.editorFactoryObject.createDiffEditorInput === void 0 && mr(o))
      return 2;
    const h = await this.doResolveEditor(o, s, a);
    return d && h && await this.doHandleConflictingDefaults(r, a.editorInfo.label, o, h.editor, s), h ? (this.sendEditorResolutionTelemetry(h.editor), h.editor.editorId !== a.editorInfo.id && this.logService.warn(`Editor ID Mismatch: ${h.editor.editorId} !== ${a.editorInfo.id}. This will cause bugs. Please ensure editorInput.editorId matches the registered id`), { ...h, group: s }) : 1;
  }
  async doResolveSideBySideEditor(e, t) {
    const i = await this.resolveEditor(e.primary, t);
    if (!yl(i))
      return 2;
    const o = await this.resolveEditor(e.secondary, i.group ?? t);
    return yl(o) ? {
      group: i.group ?? o.group,
      editor: this.instantiationService.createInstance(li, e.label, e.description, o.editor, i.editor),
      options: e.options
    } : 2;
  }
  bufferChangeEvents(e) {
    this._onDidChangeEditorRegistrations.pause();
    try {
      e();
    } finally {
      this._onDidChangeEditorRegistrations.resume();
    }
  }
  registerEditor(e, t, i, o) {
    let s = this._editors.get(e);
    s === void 0 && (s = /* @__PURE__ */ new Map(), this._editors.set(e, s));
    let n = s.get(t.id);
    n === void 0 && (n = []);
    const r = Th(n, {
      globPattern: e,
      editorInfo: t,
      options: i,
      editorFactoryObject: o
    });
    return s.set(t.id, n), this._shouldReFlattenEditors = !0, this._onDidChangeEditorRegistrations.fire(), M(() => {
      r(), n && n.length === 0 && (s == null || s.delete(t.id)), this._shouldReFlattenEditors = !0, this._onDidChangeEditorRegistrations.fire();
    });
  }
  getAssociationsForResource(e) {
    const i = this.getAllUserAssociations().filter((s) => s.filenamePattern && br(s.filenamePattern, e)), o = this._registeredEditors;
    return i.filter((s) => o.find((n) => n.editorInfo.id === s.viewType));
  }
  getAllUserAssociations() {
    const e = this.configurationService.inspect(kl) || {}, t = e.workspaceValue ?? {}, i = e.userValue ?? {}, o = { ...t };
    for (const [n, r] of Object.entries(i))
      o[n] === void 0 && (o[n] = r);
    const s = [];
    for (const [n, r] of Object.entries(o)) {
      const a = {
        filenamePattern: n,
        viewType: r
      };
      s.push(a);
    }
    return s;
  }
  _flattenEditorsMap() {
    if (!this._shouldReFlattenEditors)
      return this._flattenedEditors;
    this._shouldReFlattenEditors = !1;
    const e = /* @__PURE__ */ new Map();
    for (const [t, i] of this._editors) {
      const o = [];
      for (const s of i.values()) {
        let n;
        for (const r of s)
          n || (n = {
            editorInfo: r.editorInfo,
            globPattern: r.globPattern,
            options: {},
            editorFactoryObject: {}
          }), n.options = { ...n.options, ...r.options }, n.editorFactoryObject = { ...n.editorFactoryObject, ...r.editorFactoryObject };
        n && o.push(n);
      }
      e.set(t, o);
    }
    return e;
  }
  get _registeredEditors() {
    return Tf(Array.from(this._flattenedEditors.values()));
  }
  updateUserAssociations(e, t) {
    const i = { viewType: t, filenamePattern: e }, o = this.getAllUserAssociations(), s = /* @__PURE__ */ Object.create(null);
    for (const n of [...o, i])
      n.filenamePattern && (s[n.filenamePattern] = n.viewType);
    this.configurationService.updateValue(kl, s);
  }
  findMatchingEditors(e) {
    const t = this.getAssociationsForResource(e), i = [];
    for (const [o, s] of this._flattenedEditors)
      for (const n of s)
        (t.find((a) => a.viewType === n.editorInfo.id) && n.editorInfo.priority !== xe.exclusive || br(o, e)) && i.push(n);
    return i.sort((o, s) => ai(s.editorInfo.priority) === ai(o.editorInfo.priority) && typeof s.globPattern == "string" && typeof o.globPattern == "string" ? s.globPattern.length - o.globPattern.length : ai(s.editorInfo.priority) - ai(o.editorInfo.priority));
  }
  getEditors(e) {
    if (this._flattenedEditors = this._flattenEditorsMap(), A.isUri(e)) {
      const t = this.findMatchingEditors(e);
      return t.find((i) => i.editorInfo.priority === xe.exclusive) ? [] : t.map((i) => i.editorInfo);
    }
    return oo(this._registeredEditors.map((t) => t.editorInfo), (t) => t.id);
  }
  getEditor(e, t) {
    var h;
    const i = (g, p) => g.find((m) => m.options && m.options.canSupportResource !== void 0 ? m.editorInfo.id === p && m.options.canSupportResource(e) : m.editorInfo.id === p);
    if (t && t !== Po.EXCLUSIVE_ONLY) {
      const g = this._registeredEditors;
      return {
        editor: i(g, t),
        conflictingDefault: !1
      };
    }
    const o = this.findMatchingEditors(e), s = this.getAssociationsForResource(e), n = t === Po.EXCLUSIVE_ONLY ? xe.exclusive : xe.builtin;
    let r = o.filter((g) => ai(g.editorInfo.priority) >= ai(n) && g.editorInfo.id !== Ke.id);
    if (r.length === 0)
      return {
        editor: s[0] && n !== xe.exclusive ? i(o, s[0].viewType) : void 0,
        conflictingDefault: !1
      };
    const a = r[0].editorInfo.priority === xe.exclusive ? r[0].editorInfo.id : ((h = s[0]) == null ? void 0 : h.viewType) || r[0].editorInfo.id;
    let d = !1;
    return r = r.filter((g) => g.editorInfo.priority !== xe.exclusive), s.length === 0 && r.length > 1 && (d = !0), {
      editor: i(o, a),
      conflictingDefault: d
    };
  }
  async doResolveEditor(e, t, i) {
    var d, h;
    let o = e.options;
    const s = me.getCanonicalUri(e, { supportSideBySide: ie.PRIMARY });
    if (o && typeof o.activation > "u" && (o = { ...o, activation: o.preserveFocus ? Zi.RESTORE : void 0 }), Lf(e)) {
      if (!i.editorFactoryObject.createMergeEditorInput)
        return;
      const g = await i.editorFactoryObject.createMergeEditorInput(e, t);
      return { editor: g.editor, options: g.options ?? o };
    }
    if (mr(e)) {
      if (!i.editorFactoryObject.createDiffEditorInput)
        return;
      const g = await i.editorFactoryObject.createDiffEditorInput(e, t);
      return { editor: g.editor, options: g.options ?? o };
    }
    if (wl(e))
      throw new Error("Untyped side by side editor input not supported here.");
    if (Ff(e)) {
      if (!i.editorFactoryObject.createUntitledEditorInput)
        return;
      const g = await i.editorFactoryObject.createUntitledEditorInput(e, t);
      return { editor: g.editor, options: g.options ?? o };
    }
    if (s === void 0)
      throw new Error("Undefined resource on non untitled editor input.");
    if (typeof ((d = i.options) == null ? void 0 : d.singlePerResource) == "function" ? i.options.singlePerResource() : (h = i.options) == null ? void 0 : h.singlePerResource) {
      const g = await this.moveExistingEditorForResource(s, i.editorInfo.id, t);
      if (g)
        return { editor: g, options: o };
    }
    if (!i.editorFactoryObject.createEditorInput)
      return;
    const r = await i.editorFactoryObject.createEditorInput(e, t);
    return o = r.options ?? o, { editor: r.editor, options: o };
  }
  async moveExistingEditorForResource(e, t, i) {
    const o = this.findExistingEditorsForResource(e, t);
    if (!o.length)
      return;
    const s = o[0];
    for (const { editor: n, group: r } of o)
      if (n !== s.editor && !await r.closeEditor(n))
        return;
    if (i.id !== s.group.id)
      return s.group.moveEditor(s.editor, i), s.editor;
  }
  findExistingEditorsForResource(e, t) {
    const i = [], o = oo([
      ...this.editorGroupService.groups
    ]);
    for (const s of o)
      for (const n of s.editors)
        Be(n.resource, e) && n.editorId === t && i.push({ editor: n, group: s });
    return i;
  }
  async doHandleConflictingDefaults(e, t, i, o, s) {
    const n = this.findMatchingEditors(e), r = JSON.parse(this.storageService.get(je.conflictingDefaultsStorageID, 0, "{}")), a = `*${Yt(e)}`, d = () => {
      r[a] = [], n.forEach((p) => r[a].push(p.editorInfo.id)), this.storageService.store(je.conflictingDefaultsStorageID, JSON.stringify(r), 0, 1);
    };
    if (r[a] && r[a].find((p) => p === o.editorId))
      return;
    const g = this.notificationService.prompt(xi.Warning, u(
      "editorResolver.conflictingDefaults",
      "There are multiple default editors available for the resource."
    ), [
      {
        label: u("editorResolver.configureDefault", "Configure Default"),
        run: async () => {
          const p = await this.doPickEditor(i, !0);
          if (!p)
            return;
          i.options = p;
          const m = await this.resolveEditor(i, s);
          m === 1 || m === 2 || s.replaceEditors([
            {
              editor: o,
              replacement: m.editor,
              options: m.options ?? p
            }
          ]);
        }
      },
      {
        label: u("editorResolver.keepDefault", "Keep {0}", t),
        run: d
      }
    ]).onDidClose(() => {
      d(), g.dispose();
    });
  }
  mapEditorsToQuickPickEntry(e, t) {
    var g, p, m;
    const i = td(this.editorGroupService.activeGroup.findEditors(e));
    let o = e.scheme === q.untitled ? this._registeredEditors.filter((C) => C.editorInfo.priority !== xe.exclusive) : this.findMatchingEditors(e);
    o = oo(o, (C) => C.editorInfo.id);
    const s = (g = this.getAssociationsForResource(e)[0]) == null ? void 0 : g.viewType;
    o = o.sort((C, b) => C.editorInfo.id === Ke.id ? -1 : b.editorInfo.id === Ke.id ? 1 : ai(b.editorInfo.priority) - ai(C.editorInfo.priority));
    const n = [], r = u("promptOpenWith.currentlyActive", "Active"), a = u("promptOpenWith.currentDefault", "Default"), d = u("promptOpenWith.currentDefaultAndActive", "Active and Default");
    let h = s;
    if (!h && o.length > 2 && ((p = o[1]) == null ? void 0 : p.editorInfo.priority) !== xe.option && (h = (m = o[1]) == null ? void 0 : m.editorInfo.id), h || (h = Ke.id), o.forEach((C) => {
      const b = (i == null ? void 0 : i.editorId) ?? Ke.id, v = i ? C.editorInfo.id === b : !1, J = C.editorInfo.id === h, R = {
        id: C.editorInfo.id,
        label: C.editorInfo.label,
        description: v && J ? d : v ? r : J ? a : void 0,
        detail: C.editorInfo.detail ?? C.editorInfo.priority
      };
      n.push(R);
    }), !t && Yt(e) !== "") {
      const C = { type: "separator" };
      n.push(C);
      const b = {
        id: je.configureDefaultID,
        label: u(
          "promptOpenWith.configureDefault",
          "Configure default editor for '{0}'...",
          `*${Yt(e)}`
        )
      };
      n.push(b);
    }
    return n;
  }
  async doPickEditor(e, t) {
    var d;
    let i = me.getOriginalUri(e, { supportSideBySide: ie.PRIMARY });
    i === void 0 && (i = A.from({ scheme: q.untitled }));
    const o = this.mapEditorsToQuickPickEntry(i, t), s = this.quickInputService.createQuickPick(), n = t ? u(
      "promptOpenWith.updateDefaultPlaceHolder",
      "Select new default editor for '{0}'",
      `*${Yt(i)}`
    ) : u(
      "promptOpenWith.placeHolder",
      "Select editor for '{0}'",
      Le(i)
    );
    s.placeholder = n, s.canAcceptInBackground = !0, s.items = o;
    const r = s.items.find((h) => h.type === "item");
    r && (s.selectedItems = [r]);
    const a = await new Promise((h) => {
      s.onDidAccept((g) => {
        let p;
        s.selectedItems.length === 1 && (p = {
          item: s.selectedItems[0],
          keyMods: s.keyMods,
          openInBackground: g.inBackground
        }), i && t && (p != null && p.item.id) && this.updateUserAssociations(`*${Yt(i)}`, p.item.id), h(p);
      }), s.onDidHide(() => h(void 0)), s.onDidTriggerItemButton((g) => {
        h({ item: g.item, openInBackground: !1 }), i && g.item && g.item.id && this.updateUserAssociations(`*${Yt(i)}`, g.item.id);
      }), s.show();
    });
    if (s.dispose(), a)
      return a.item.id === je.configureDefaultID ? this.doPickEditor(e, !0) : {
        ...e.options,
        override: a.item.id,
        preserveFocus: a.openInBackground || ((d = e.options) == null ? void 0 : d.preserveFocus)
      };
  }
  sendEditorResolutionTelemetry(e) {
    e.editorId && this.telemetryService.publicLog2("override.viewType", { viewType: e.editorId });
  }
  cacheEditors() {
    const e = /* @__PURE__ */ new Set();
    for (const [i, o] of this._flattenedEditors)
      o.find((n) => n.editorInfo.priority !== xe.option && n.editorInfo.id !== Ke.id) && (Xf(i) ? e.add(`${i.pattern}`) : e.add(i));
    const t = this.getAllUserAssociations();
    for (const i of t)
      i.filenamePattern && e.add(i.filenamePattern);
    this.storageService.store(je.cacheStorageID, JSON.stringify(Array.from(e)), 0, 1);
  }
  resourceMatchesCache(e) {
    if (!this.cache)
      return !1;
    for (const t of this.cache)
      if (br(t, e))
        return !0;
    return !1;
  }
}, je.configureDefaultID = "promptOpenWith.configureDefault", je.cacheStorageID = "editorOverrideService.cache", je.conflictingDefaultsStorageID = "editorOverrideService.conflictingDefaults", je);
bc = y([
  l(0, ce),
  l(1, W),
  l(2, x),
  l(3, Is),
  l(4, We),
  l(5, Xe),
  l(6, ee),
  l(7, ei),
  l(8, rt)
], bc);
var xk = '.monaco-workbench .part.statusbar{box-sizing:border-box;cursor:default;display:flex;font-size:12px;height:22px;overflow:hidden;width:100%}.monaco-workbench:not(.reduce-motion) .part.statusbar{transition:background-color .15s ease-out}.monaco-workbench .part.statusbar.status-border-top:after{background-color:var(--status-border-top-color);content:"";height:1px;left:0;pointer-events:none;position:absolute;top:0;width:100%;z-index:5}.monaco-workbench .part.statusbar>.left-items,.monaco-workbench .part.statusbar>.right-items{display:flex}.monaco-workbench .part.statusbar>.right-items{flex-direction:row-reverse;flex-wrap:wrap}.monaco-workbench .part.statusbar>.left-items{flex-grow:1}.monaco-workbench .part.statusbar>.items-container>.statusbar-item{display:inline-block;font-variant-numeric:tabular-nums;height:100%;line-height:22px;max-width:40vw;vertical-align:top}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.has-beak{position:relative}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.has-beak>.status-bar-item-beak-container{height:5px;left:calc(50% - 5px);position:absolute;top:-5px;width:10px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.has-beak>.status-bar-item-beak-container:before{border-bottom-style:solid;border-bottom-width:5px;border-left:5px solid transparent;border-right:5px solid transparent;content:"";position:fixed}.monaco-workbench .part.statusbar>.items-container>.statusbar-item>.statusbar-item-label{margin-left:3px;margin-right:3px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.compact-left>.statusbar-item-label{margin-left:0;margin-right:3px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.compact-right>.statusbar-item-label{margin-left:3px;margin-right:0}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.left.first-visible-item{padding-left:7px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.right.last-visible-item{margin-right:7px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.has-background-color.left.first-visible-item,.monaco-workbench .part.statusbar>.items-container>.statusbar-item.has-background-color.right.last-visible-item{padding-left:0;padding-right:0}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.has-background-color>.statusbar-item-label{margin-left:0;margin-right:0;padding-left:10px;padding-right:10px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.compact-left.has-background-color>.statusbar-item-label{padding-left:3px;padding-right:10px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.compact-right.has-background-color>.statusbar-item-label{padding-left:10px;padding-right:3px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item>.statusbar-item-label{align-items:center;cursor:pointer;display:flex;height:100%;outline-width:0;overflow:hidden;padding:0 5px;text-overflow:ellipsis;white-space:pre}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.compact-left>.statusbar-item-label,.monaco-workbench .part.statusbar>.items-container>.statusbar-item.compact-right>.statusbar-item-label{padding:0 3px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item>a:hover:not(.disabled){text-decoration:none}.monaco-workbench .part.statusbar>.items-container>.statusbar-item>a.disabled{cursor:default}.monaco-workbench .part.statusbar>.items-container>.statusbar-item span.codicon{color:inherit;font-size:14px;text-align:center}.monaco-workbench .part.statusbar>.items-container>.statusbar-item .status-bar-info{background-color:var(--vscode-statusBarItem-prominentBackground);color:var(--vscode-statusBarItem-prominentForeground)}.monaco-workbench .part.statusbar>.items-container>.statusbar-item a.status-bar-info:hover:not(.disabled){background-color:var(--vscode-statusBarItem-prominentHoverBackground)}.monaco-workbench .part.statusbar>.items-container>.statusbar-item a:active:not(.disabled){outline:1px solid var(--vscode-contrastActiveBorder)!important;outline-offset:-1px}.monaco-workbench:not(.hc-light):not(.hc-black) .part.statusbar>.items-container>.statusbar-item a:active:not(.disabled){background-color:var(--vscode-statusBarItem-activeBackground)!important}.monaco-workbench .part.statusbar>.items-container>.statusbar-item a:hover:not(.disabled){outline:1px dashed var(--vscode-contrastActiveBorder);outline-offset:-1px}.monaco-workbench:not(.hc-light):not(.hc-black) .part.statusbar>.items-container>.statusbar-item a:hover:not(.disabled){background-color:var(--vscode-statusBarItem-hoverBackground)}';
oe(xk, {});
class Dk extends j {
  constructor(e, t, i) {
    super(e, t, void 0, !0), this.model = i, this.checked = !i.isHidden(e);
  }
  async run() {
    this.model.isHidden(this.id) ? this.model.show(this.id) : this.model.hide(this.id);
  }
}
class Nk extends j {
  constructor(e, t, i) {
    super(e, u("hide", "Hide '{0}'", t), void 0, !0), this.model = i;
  }
  async run() {
    this.model.hide(this.id);
  }
}
V.registerCommandAndKeybindingRule({
  id: "workbench.statusBar.focusPrevious",
  weight: 200,
  primary: 15,
  secondary: [16],
  when: Ao,
  handler: (c) => {
    c.get(oi).focusPreviousEntry();
  }
});
V.registerCommandAndKeybindingRule({
  id: "workbench.statusBar.focusNext",
  weight: 200,
  primary: 17,
  secondary: [18],
  when: Ao,
  handler: (c) => {
    c.get(oi).focusNextEntry();
  }
});
V.registerCommandAndKeybindingRule({
  id: "workbench.statusBar.focusFirst",
  weight: 200,
  primary: 14,
  when: Ao,
  handler: (c) => {
    const e = c.get(oi);
    e.focus(!1), e.focusNextEntry();
  }
});
V.registerCommandAndKeybindingRule({
  id: "workbench.statusBar.focusLast",
  weight: 200,
  primary: 13,
  when: Ao,
  handler: (c) => {
    const e = c.get(oi);
    e.focus(!1), e.focusPreviousEntry();
  }
});
V.registerCommandAndKeybindingRule({
  id: "workbench.statusBar.clearFocus",
  weight: 200,
  primary: 9,
  when: Ao,
  handler: (c) => {
    const e = c.get(oi), t = c.get(D);
    e.isEntryFocused() ? e.focus(!1) : t.activeEditorPane && t.activeEditorPane.focus();
  }
});
class Qk extends ye {
  constructor() {
    super({
      id: "workbench.action.focusStatusBar",
      title: { value: u("focusStatusBar", "Focus Status Bar"), original: "Focus Status Bar" },
      category: Ce.View,
      f1: !0
    });
  }
  async run(e) {
    e.get(Pe).focusPart("workbench.parts.statusbar");
  }
}
P(Qk);
const Ii = class Ii extends E {
  get entries() {
    return this._entries.slice(0);
  }
  get lastFocusedEntry() {
    return this._lastFocusedEntry && !this.isHidden(this._lastFocusedEntry.id) ? this._lastFocusedEntry : void 0;
  }
  constructor(e) {
    super(), this.storageService = e, this._onDidChangeEntryVisibility = this._register(new w()), this.onDidChangeEntryVisibility = this._onDidChangeEntryVisibility.event, this._entries = [], this.hidden = /* @__PURE__ */ new Set(), this.restoreState(), this.registerListeners();
  }
  restoreState() {
    const e = this.storageService.get(Ii.HIDDEN_ENTRIES_KEY, 0);
    if (e)
      try {
        const t = JSON.parse(e);
        this.hidden = new Set(t);
      } catch {
      }
  }
  registerListeners() {
    this._register(this.storageService.onDidChangeValue((e) => this.onDidStorageValueChange(e)));
  }
  onDidStorageValueChange(e) {
    if (e.key === Ii.HIDDEN_ENTRIES_KEY && e.scope === 0) {
      const t = new Set(this.hidden);
      this.hidden.clear(), this.restoreState();
      const i = /* @__PURE__ */ new Set();
      for (const o of t)
        this.hidden.has(o) || i.add(o);
      for (const o of this.hidden)
        t.has(o) || i.add(o);
      if (i.size > 0)
        for (const o of this._entries)
          i.has(o.id) && (this.updateVisibility(o.id, !0), i.delete(o.id));
    }
  }
  add(e) {
    this._entries.push(e), this.updateVisibility(e, !1), this.sort(), this.markFirstLastVisibleEntry();
  }
  remove(e) {
    const t = this._entries.indexOf(e);
    t >= 0 && (this._entries.splice(t, 1), this._entries.some(
      (i) => zs(i.priority.primary) && i.priority.primary.id === e.id
    ) && this.sort(), this.markFirstLastVisibleEntry());
  }
  isHidden(e) {
    return this.hidden.has(e);
  }
  hide(e) {
    this.hidden.has(e) || (this.hidden.add(e), this.updateVisibility(e, !0), this.saveState());
  }
  show(e) {
    this.hidden.has(e) && (this.hidden.delete(e), this.updateVisibility(e, !0), this.saveState());
  }
  findEntry(e) {
    return this._entries.find((t) => t.container === e);
  }
  getEntries(e) {
    return this._entries.filter((t) => t.alignment === e);
  }
  focusNextEntry() {
    this.focusEntry(1, 0);
  }
  focusPreviousEntry() {
    this.focusEntry(-1, this.entries.length - 1);
  }
  isEntryFocused() {
    return !!this.getFocusedEntry();
  }
  getFocusedEntry() {
    return this._entries.find((e) => Nt(document.activeElement, e.container));
  }
  focusEntry(e, t) {
    const i = (n) => {
      let r = n, a = r >= 0 && r < this._entries.length ? this._entries[r] : void 0;
      for (; a && this.isHidden(a.id); )
        r += e, a = r >= 0 && r < this._entries.length ? this._entries[r] : void 0;
      return a;
    }, o = this.getFocusedEntry();
    if (o) {
      const n = i(this._entries.indexOf(o) + e);
      if (n) {
        this._lastFocusedEntry = n, n.labelContainer.focus();
        return;
      }
    }
    const s = i(t);
    s && (this._lastFocusedEntry = s, s.labelContainer.focus());
  }
  updateVisibility(e, t) {
    if (typeof e == "string") {
      const i = e;
      for (const o of this._entries)
        o.id === i && this.updateVisibility(o, t);
    } else {
      const i = e, o = this.isHidden(i.id);
      o ? gi(i.container) : hi(i.container), t && this._onDidChangeEntryVisibility.fire({ id: i.id, visible: !o }), this.markFirstLastVisibleEntry();
    }
  }
  saveState() {
    this.hidden.size > 0 ? this.storageService.store(Ii.HIDDEN_ENTRIES_KEY, JSON.stringify(Array.from(this.hidden.values())), 0, 0) : this.storageService.remove(Ii.HIDDEN_ENTRIES_KEY, 0);
  }
  sort() {
    const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
    for (let s = 0; s < this._entries.length; s++) {
      const n = this._entries[s];
      if (typeof n.priority.primary == "number")
        e.set(n, s);
      else {
        let r = t.get(n.priority.primary.id);
        r || (r = [], t.set(n.priority.primary.id, r)), r.push(n);
      }
    }
    const i = Array.from(e.keys());
    i.sort((s, n) => s.alignment === n.alignment ? s.priority.primary !== n.priority.primary ? Number(n.priority.primary) - Number(s.priority.primary) : s.priority.secondary !== n.priority.secondary ? n.priority.secondary - s.priority.secondary : e.get(s) - e.get(n) : s.alignment === 0 ? -1 : n.alignment === 0 ? 1 : 0);
    let o;
    if (t.size > 0) {
      o = [];
      for (const s of i) {
        const n = t.get(s.id);
        n && o.push(...n.filter((r) => zs(r.priority.primary) && r.priority.primary.alignment === 0)), o.push(s), n && o.push(...n.filter((r) => zs(r.priority.primary) && r.priority.primary.alignment === 1)), t.delete(s.id);
      }
      for (const [, s] of t)
        o.push(...s);
    } else
      o = i;
    this._entries = o;
  }
  markFirstLastVisibleEntry() {
    this.doMarkFirstLastVisibleStatusbarItem(this.getEntries(0)), this.doMarkFirstLastVisibleStatusbarItem(this.getEntries(1));
  }
  doMarkFirstLastVisibleStatusbarItem(e) {
    let t, i;
    for (const o of e)
      o.container.classList.remove("first-visible-item", "last-visible-item"), !this.isHidden(o.id) && (t || (t = o), i = o);
    t == null || t.container.classList.add("first-visible-item"), i == null || i.container.classList.add("last-visible-item");
  }
};
Ii.HIDDEN_ENTRIES_KEY = "workbench.statusbar.hidden";
let Cc = Ii, fc = class extends E {
  get name() {
    return L(this.entry).name;
  }
  get hasCommand() {
    var e;
    return typeof ((e = this.entry) == null ? void 0 : e.command) < "u";
  }
  constructor(e, t, i, o, s, n, r) {
    super(), this.container = e, this.hoverDelegate = i, this.commandService = o, this.notificationService = s, this.telemetryService = n, this.themeService = r, this.entry = void 0, this.foregroundListener = this._register(new Re()), this.backgroundListener = this._register(new Re()), this.commandMouseListener = this._register(new Re()), this.commandTouchListener = this._register(new Re()), this.commandKeyboardListener = this._register(new Re()), this.hover = void 0, this.labelContainer = document.createElement("a"), this.labelContainer.tabIndex = -1, this.labelContainer.setAttribute("role", "button"), this.labelContainer.className = "statusbar-item-label", this._register(zt.addTarget(this.labelContainer)), this.label = new Ak(this.labelContainer), this.container.appendChild(this.labelContainer), this.beakContainer = document.createElement("div"), this.beakContainer.className = "status-bar-item-beak-container", this.container.appendChild(this.beakContainer), this.update(t);
  }
  update(e) {
    if (this.label.showProgress = e.showProgress ?? !1, (!this.entry || e.text !== this.entry.text) && (this.label.text = e.text, e.text ? hi(this.labelContainer) : gi(this.labelContainer)), (!this.entry || e.ariaLabel !== this.entry.ariaLabel) && (this.container.setAttribute("aria-label", e.ariaLabel), this.labelContainer.setAttribute("aria-label", e.ariaLabel)), (!this.entry || e.role !== this.entry.role) && this.labelContainer.setAttribute("role", e.role || "button"), !this.entry || !this.isEqualTooltip(this.entry, e)) {
      const t = _i(e.tooltip) ? { markdown: e.tooltip, markdownNotSupportedFallback: void 0 } : e.tooltip;
      this.hover ? this.hover.update(t) : this.hover = this._register(Pu(this.hoverDelegate, this.container, t));
    }
    if (!this.entry || e.command !== this.entry.command) {
      this.commandMouseListener.clear(), this.commandTouchListener.clear(), this.commandKeyboardListener.clear();
      const t = e.command;
      t && (t !== Pr || this.hover) ? (this.commandMouseListener.value = S(this.labelContainer, I.CLICK, () => this.executeCommand(t)), this.commandTouchListener.value = S(this.labelContainer, Ne.Tap, () => this.executeCommand(t)), this.commandKeyboardListener.value = S(this.labelContainer, I.KEY_DOWN, (i) => {
        const o = new yt(i);
        (o.equals(10) || o.equals(3)) && (U.stop(i), this.executeCommand(t));
      }), this.labelContainer.classList.remove("disabled")) : this.labelContainer.classList.add("disabled");
    }
    (!this.entry || e.showBeak !== this.entry.showBeak) && (e.showBeak ? this.container.classList.add("has-beak") : this.container.classList.remove("has-beak")), (!this.entry || e.color !== this.entry.color) && this.applyColor(this.labelContainer, e.color), (!this.entry || e.backgroundColor !== this.entry.backgroundColor) && (this.container.classList.toggle("has-background-color", !!e.backgroundColor), this.applyColor(this.container, e.backgroundColor, !0)), this.entry = e;
  }
  isEqualTooltip({ tooltip: e }, { tooltip: t }) {
    return e === void 0 ? t === void 0 : _i(e) ? _i(t) && Kf(e, t) : e === t;
  }
  async executeCommand(e) {
    var t;
    if (e === Pr)
      (t = this.hover) == null || t.show(!0);
    else {
      const i = typeof e == "string" ? e : e.id, o = typeof e == "string" ? [] : e.arguments ?? [];
      this.telemetryService.publicLog2("workbenchActionExecuted", { id: i, from: "status bar" });
      try {
        await this.commandService.executeCommand(i, ...o);
      } catch (s) {
        this.notificationService.error(go(s));
      }
    }
  }
  applyColor(e, t, i) {
    var s;
    let o;
    if (i ? this.backgroundListener.clear() : this.foregroundListener.clear(), t)
      if (Yf(t)) {
        o = (s = this.themeService.getColorTheme().getColor(t.id)) == null ? void 0 : s.toString();
        const n = this.themeService.onDidColorThemeChange((r) => {
          var d;
          const a = (d = r.getColor(t.id)) == null ? void 0 : d.toString();
          i ? e.style.backgroundColor = a ?? "" : e.style.color = a ?? "";
        });
        i ? this.backgroundListener.value = n : this.foregroundListener.value = n;
      } else
        o = t;
    i ? e.style.backgroundColor = o ?? "" : e.style.color = o ?? "";
  }
};
fc = y([
  l(3, Bi),
  l(4, We),
  l(5, Xe),
  l(6, z)
], fc);
class Ak extends Sw {
  constructor(e) {
    super(e), this.container = e, this.progressCodicon = Sl(Il), this.currentText = "", this.currentShowProgress = !1;
  }
  set showProgress(e) {
    this.currentShowProgress !== e && (this.currentShowProgress = e, this.progressCodicon = Sl(e === "loading" ? Of : Il), this.text = this.currentText);
  }
  set text(e) {
    if (this.currentShowProgress) {
      this.container.firstChild !== this.progressCodicon && this.container.appendChild(this.progressCodicon);
      for (const i of Array.from(this.container.childNodes))
        i !== this.progressCodicon && i.remove();
      let t = e ?? "";
      t && (t = ` ${t}`), ae(this.container, ...Ms(t));
    } else
      super.text = e;
  }
}
let vc = class extends er {
  constructor(e, t, i, o, s, n, r, a, d) {
    super("workbench.parts.statusbar", { hasTitle: !1 }, t, o, s), this.instantiationService = e, this.contextService = i, this.storageService = o, this.contextMenuService = n, this.contextKeyService = r, this.hoverService = a, this.configurationService = d, this.minimumWidth = 0, this.maximumWidth = Number.POSITIVE_INFINITY, this.minimumHeight = 22, this.maximumHeight = 22, this.pendingEntries = [], this.viewModel = this._register(new Cc(this.storageService)), this.onDidChangeEntryVisibility = this.viewModel.onDidChangeEntryVisibility, this.hoverDelegate = new class {
      get delay() {
        return Date.now() - this.lastHoverHideTime < 200 ? 0 : this.configurationService.getValue("workbench.hover.delay");
      }
      constructor(h, g) {
        this.configurationService = h, this.hoverService = g, this.lastHoverHideTime = 0, this.placement = "element";
      }
      showHover(h, g) {
        return this.hoverService.showHover({
          ...h,
          hideOnKeyDown: !0
        }, g);
      }
      onDidHideHover() {
        this.lastHoverHideTime = Date.now();
      }
    }(this.configurationService, this.hoverService), this.compactEntriesDisposable = this._register(new Re()), this.styleOverrides = /* @__PURE__ */ new Set(), this.registerListeners();
  }
  registerListeners() {
    this._register(this.onDidChangeEntryVisibility(() => this.updateCompactEntries())), this._register(this.contextService.onDidChangeWorkbenchState(() => this.updateStyles()));
  }
  addEntry(e, t, i, o = 0) {
    let s;
    return Hf(o) ? s = o : s = {
      primary: o,
      secondary: Ws(t)
    }, this.element ? this.doAddEntry(e, t, i, s) : this.doAddPendingEntry(e, t, i, s);
  }
  doAddPendingEntry(e, t, i, o) {
    const s = { entry: e, id: t, alignment: i, priority: o };
    return this.pendingEntries.push(s), {
      update: (r) => {
        s.accessor ? s.accessor.update(r) : s.entry = r;
      },
      dispose: () => {
        s.accessor ? s.accessor.dispose() : this.pendingEntries = this.pendingEntries.filter((r) => r !== s);
      }
    };
  }
  doAddEntry(e, t, i, o) {
    const s = this.doCreateStatusItem(t, i, ...ti([e.showBeak ? "has-beak" : void 0])), n = this.instantiationService.createInstance(fc, s, e, this.hoverDelegate), r = new class {
      constructor() {
        this.id = t, this.alignment = i, this.priority = o, this.container = s, this.labelContainer = n.labelContainer;
      }
      get name() {
        return n.name;
      }
      get hasCommand() {
        return n.hasCommand;
      }
    }(), { needsFullRefresh: a } = this.doAddOrRemoveModelEntry(r, !0);
    return a ? this.appendStatusbarEntries() : this.appendStatusbarEntry(r), {
      update: (d) => {
        n.update(d);
      },
      dispose: () => {
        const { needsFullRefresh: d } = this.doAddOrRemoveModelEntry(r, !1);
        d ? this.appendStatusbarEntries() : s.remove(), le(n);
      }
    };
  }
  doCreateStatusItem(e, t, ...i) {
    const o = document.createElement("div");
    return o.id = e, o.classList.add("statusbar-item"), i && o.classList.add(...i), t === 1 ? o.classList.add("right") : o.classList.add("left"), o;
  }
  doAddOrRemoveModelEntry(e, t) {
    const i = this.viewModel.entries;
    t ? this.viewModel.add(e) : this.viewModel.remove(e);
    const o = this.viewModel.entries;
    return t ? i.splice(o.indexOf(e), 0, e) : i.splice(i.indexOf(e), 1), { needsFullRefresh: !bi(i, o) };
  }
  isEntryVisible(e) {
    return !this.viewModel.isHidden(e);
  }
  updateEntryVisibility(e, t) {
    t ? this.viewModel.show(e) : this.viewModel.hide(e);
  }
  focusNextEntry() {
    this.viewModel.focusNextEntry();
  }
  focusPreviousEntry() {
    this.viewModel.focusPreviousEntry();
  }
  isEntryFocused() {
    return this.viewModel.isEntryFocused();
  }
  focus(e = !0) {
    var i;
    (i = this.getContainer()) == null || i.focus();
    const t = this.viewModel.lastFocusedEntry;
    e && t && setTimeout(() => t.labelContainer.focus(), 0);
  }
  createContentArea(e) {
    this.element = e;
    const t = this.contextKeyService.createScoped(this.element);
    return Ao.bindTo(t).set(!0), this.leftItemsContainer = document.createElement("div"), this.leftItemsContainer.classList.add("left-items", "items-container"), this.element.appendChild(this.leftItemsContainer), this.element.tabIndex = 0, this.rightItemsContainer = document.createElement("div"), this.rightItemsContainer.classList.add("right-items", "items-container"), this.element.appendChild(this.rightItemsContainer), this._register(S(e, I.CONTEXT_MENU, (i) => this.showContextMenu(i))), this._register(zt.addTarget(e)), this._register(S(e, Ne.Contextmenu, (i) => this.showContextMenu(i))), this.createInitialStatusbarEntries(), this.element;
  }
  createInitialStatusbarEntries() {
    for (this.appendStatusbarEntries(); this.pendingEntries.length; ) {
      const e = this.pendingEntries.shift();
      e && (e.accessor = this.addEntry(e.entry, e.id, e.alignment, e.priority.primary));
    }
  }
  appendStatusbarEntries() {
    const e = L(this.leftItemsContainer), t = L(this.rightItemsContainer);
    Ut(e), Ut(t);
    for (const i of [
      ...this.viewModel.getEntries(0),
      ...this.viewModel.getEntries(1).reverse()
    ])
      (i.alignment === 0 ? e : t).appendChild(i.container);
    this.updateCompactEntries();
  }
  appendStatusbarEntry(e) {
    const t = this.viewModel.getEntries(e.alignment);
    e.alignment === 1 && t.reverse();
    const i = L(e.alignment === 0 ? this.leftItemsContainer : this.rightItemsContainer), o = t.indexOf(e);
    o + 1 === t.length ? i.appendChild(e.container) : i.insertBefore(e.container, t[o + 1].container), this.updateCompactEntries();
  }
  updateCompactEntries() {
    const e = this.viewModel.entries, t = /* @__PURE__ */ new Map();
    for (const n of e)
      this.viewModel.isHidden(n.id) || t.set(n.id, n), n.container.classList.remove("compact-left", "compact-right");
    const i = /* @__PURE__ */ new Map();
    for (const n of t.values())
      if (zs(n.priority.primary) && n.priority.primary.compact) {
        const r = n.priority.primary.id, a = t.get(r);
        if (!a)
          continue;
        let d = i.get(r);
        d ? d.add(n) : (d = /* @__PURE__ */ new Set([n, a]), i.set(r, d)), n.priority.primary.alignment === 0 ? (a.container.classList.add("compact-left"), n.container.classList.add("compact-right")) : (a.container.classList.add("compact-right"), n.container.classList.add("compact-left"));
      }
    const o = this.getColor(Pf), s = this.getColor(Mf);
    if (this.compactEntriesDisposable.value = new Z(), o && s && !qc(this.theme.type))
      for (const [, n] of i)
        for (const r of n)
          r.hasCommand && (this.compactEntriesDisposable.value.add(S(r.labelContainer, I.MOUSE_OVER, () => {
            n.forEach((a) => a.labelContainer.style.backgroundColor = o), r.labelContainer.style.backgroundColor = s;
          })), this.compactEntriesDisposable.value.add(S(r.labelContainer, I.MOUSE_OUT, () => {
            n.forEach((a) => a.labelContainer.style.backgroundColor = "");
          })));
  }
  showContextMenu(e) {
    U.stop(e, !0);
    const t = new kt(e);
    let i;
    this.contextMenuService.showContextMenu({
      getAnchor: () => t,
      getActions: () => (i = this.getContextMenuActions(t), i),
      onHide: () => {
        i && zf(i);
      }
    });
  }
  getContextMenuActions(e) {
    const t = [];
    t.push(we({ id: Bl.ID, label: u("hideStatusBar", "Hide Status Bar"), run: () => this.instantiationService.invokeFunction((s) => new Bl().run(s)) })), t.push(new Qe());
    const i = /* @__PURE__ */ new Set();
    for (const s of this.viewModel.entries)
      i.has(s.id) || (t.push(new Dk(s.id, s.name, this.viewModel)), i.add(s.id));
    let o;
    for (let s = e.target; s; s = s.parentElement) {
      const n = this.viewModel.findEntry(s);
      if (n) {
        o = n;
        break;
      }
    }
    return o && (t.push(new Qe()), t.push(new Nk(o.id, o.name, this.viewModel))), t;
  }
  updateStyles() {
    super.updateStyles();
    const e = L(this.getContainer()), t = [...this.styleOverrides].sort((a, d) => a.priority - d.priority)[0], i = this.getColor((t == null ? void 0 : t.background) ?? (this.contextService.getWorkbenchState() !== 1 ? Uf : jf)) || "";
    e.style.backgroundColor = i;
    const o = this.getColor((t == null ? void 0 : t.foreground) ?? (this.contextService.getWorkbenchState() !== 1 ? qf : $f)) || "";
    e.style.color = o;
    const s = this.getColor(ev), n = this.getColor((t == null ? void 0 : t.border) ?? (this.contextService.getWorkbenchState() !== 1 ? tv : iv)) || this.getColor(Oe);
    n ? (e.classList.add("status-border-top"), e.style.setProperty("--status-border-top-color", n)) : (e.classList.remove("status-border-top"), e.style.removeProperty("--status-border-top-color"));
    const r = this.getColor(ov);
    this.styleElement || (this.styleElement = Vh(e)), this.styleElement.textContent = `

				/* Status bar focus outline */
				.monaco-workbench .part.statusbar:focus {
					outline-color: ${r};
				}

				/* Status bar item focus outline */
				.monaco-workbench .part.statusbar > .items-container > .statusbar-item a:focus-visible:not(.disabled) {
					outline: 1px solid ${this.getColor(co) ?? s};
					outline-offset: ${n ? "-2px" : "-1px"};
				}

				/* Notification Beak */
				.monaco-workbench .part.statusbar > .items-container > .statusbar-item.has-beak > .status-bar-item-beak-container:before {
					border-bottom-color: ${i};
				}
			`;
  }
  layout(e, t, i, o) {
    super.layout(e, t, i, o), super.layoutContents(e, t);
  }
  overrideStyle(e) {
    return this.styleOverrides.add(e), this.updateStyles(), M(() => {
      this.styleOverrides.delete(e), this.updateStyles();
    });
  }
  toJSON() {
    return {
      type: "workbench.parts.statusbar"
    };
  }
};
vc = y([
  l(0, W),
  l(1, z),
  l(2, at),
  l(3, ee),
  l(4, Pe),
  l(5, Ie),
  l(6, F),
  l(7, Lt),
  l(8, x)
], vc);
var Ge;
let wc = (Ge = class extends E {
  constructor(e, t, i, o, s, n, r, a, d, h) {
    super(), this.editorService = e, this.editorGroupService = t, this.contextService = i, this.storageService = o, this.configurationService = s, this.fileService = n, this.workspacesService = r, this.instantiationService = a, this.layoutService = d, this.contextKeyService = h, this.activeEditorListeners = this._register(new Z()), this.lastActiveEditor = void 0, this.editorHelper = this.instantiationService.createInstance(Vn), this.canNavigateBackContextKey = new K("canNavigateBack", !1, u(
      "canNavigateBack",
      "Whether it is possible to navigate back in editor history"
    )).bindTo(this.contextKeyService), this.canNavigateForwardContextKey = new K("canNavigateForward", !1, u(
      "canNavigateForward",
      "Whether it is possible to navigate forward in editor history"
    )).bindTo(this.contextKeyService), this.canNavigateBackInNavigationsContextKey = new K("canNavigateBackInNavigationLocations", !1, u(
      "canNavigateBackInNavigationLocations",
      "Whether it is possible to navigate back in editor navigation locations history"
    )).bindTo(this.contextKeyService), this.canNavigateForwardInNavigationsContextKey = new K("canNavigateForwardInNavigationLocations", !1, u(
      "canNavigateForwardInNavigationLocations",
      "Whether it is possible to navigate forward in editor navigation locations history"
    )).bindTo(this.contextKeyService), this.canNavigateToLastNavigationLocationContextKey = new K("canNavigateToLastNavigationLocation", !1, u(
      "canNavigateToLastNavigationLocation",
      "Whether it is possible to navigate to the last editor navigation location"
    )).bindTo(this.contextKeyService), this.canNavigateBackInEditsContextKey = new K("canNavigateBackInEditLocations", !1, u(
      "canNavigateBackInEditLocations",
      "Whether it is possible to navigate back in editor edit locations history"
    )).bindTo(this.contextKeyService), this.canNavigateForwardInEditsContextKey = new K("canNavigateForwardInEditLocations", !1, u(
      "canNavigateForwardInEditLocations",
      "Whether it is possible to navigate forward in editor edit locations history"
    )).bindTo(this.contextKeyService), this.canNavigateToLastEditLocationContextKey = new K("canNavigateToLastEditLocation", !1, u(
      "canNavigateToLastEditLocation",
      "Whether it is possible to navigate to the last editor edit location"
    )).bindTo(this.contextKeyService), this.canReopenClosedEditorContextKey = new K("canReopenClosedEditor", !1, u(
      "canReopenClosedEditor",
      "Whether it is possible to reopen the last closed editor"
    )).bindTo(this.contextKeyService), this._onDidChangeEditorNavigationStack = this._register(new w()), this.onDidChangeEditorNavigationStack = this._onDidChangeEditorNavigationStack.event, this.defaultScopedEditorNavigationStack = void 0, this.editorGroupScopedNavigationStacks = /* @__PURE__ */ new Map(), this.editorScopedNavigationStacks = /* @__PURE__ */ new Map(), this.editorNavigationScope = 0, this.recentlyUsedEditorsStack = void 0, this.recentlyUsedEditorsStackIndex = 0, this.recentlyUsedEditorsInGroupStack = void 0, this.recentlyUsedEditorsInGroupStackIndex = 0, this.navigatingInRecentlyUsedEditorsStack = !1, this.navigatingInRecentlyUsedEditorsInGroupStack = !1, this.recentlyClosedEditors = [], this.ignoreEditorCloseEvent = !1, this.history = void 0, this.editorHistoryListeners = /* @__PURE__ */ new Map(), this.resourceExcludeMatcher = this._register(new Xu(() => {
      const g = this._register(this.instantiationService.createInstance(Ih, (p) => sv(p ? this.configurationService.getValue({ resource: p }) : this.configurationService.getValue()) || /* @__PURE__ */ Object.create(null), (p) => p.affectsConfiguration(nv) || p.affectsConfiguration(rv)));
      return this._register(g.onExpressionChange(() => this.removeExcludedFromHistory())), g;
    })), this.registerListeners(), this.editorService.activeEditorPane && this.onDidActiveEditorChange();
  }
  registerListeners() {
    this.registerMouseNavigationListener(), this._register(this.editorService.onDidActiveEditorChange(() => this.onDidActiveEditorChange())), this._register(this.editorService.onDidOpenEditorFail((e) => this.remove(e.editor))), this._register(this.editorService.onDidCloseEditor((e) => this.onDidCloseEditor(e))), this._register(this.editorService.onDidMostRecentlyActiveEditorsChange(() => this.handleEditorEventInRecentEditorsStack())), this._register(this.editorGroupService.onDidRemoveGroup((e) => this.onDidRemoveGroup(e))), this._register(this.fileService.onDidFilesChange((e) => this.onDidFilesChange(e))), this._register(this.fileService.onDidRunOperation((e) => this.onDidFilesChange(e))), this._register(this.storageService.onWillSaveState(() => this.saveState())), this.registerEditorNavigationScopeChangeListener(), this._register(this.onDidChangeEditorNavigationStack(() => this.updateContextKeys())), this._register(this.editorGroupService.onDidChangeActiveGroup(() => this.updateContextKeys()));
  }
  onDidCloseEditor(e) {
    this.handleEditorCloseEventInHistory(e), this.handleEditorCloseEventInReopen(e);
  }
  registerMouseNavigationListener() {
    const e = this._register(new Z()), t = () => {
      e.clear(), this.configurationService.getValue(Ge.MOUSE_NAVIGATION_SETTING) && (e.add(S(this.layoutService.container, I.MOUSE_DOWN, (i) => this.onMouseDownOrUp(i, !0))), e.add(S(this.layoutService.container, I.MOUSE_UP, (i) => this.onMouseDownOrUp(i, !1))));
    };
    this._register(this.configurationService.onDidChangeConfiguration((i) => {
      i.affectsConfiguration(Ge.MOUSE_NAVIGATION_SETTING) && t();
    })), t();
  }
  onMouseDownOrUp(e, t) {
    switch (e.button) {
      case 3:
        U.stop(e), t && this.goBack();
        break;
      case 4:
        U.stop(e), t && this.goForward();
        break;
    }
  }
  onDidRemoveGroup(e) {
    this.handleEditorGroupRemoveInNavigationStacks(e);
  }
  onDidActiveEditorChange() {
    const e = this.editorGroupService.activeGroup, t = e.activeEditorPane;
    this.lastActiveEditor && this.editorHelper.matchesEditorIdentifier(this.lastActiveEditor, t) || (this.lastActiveEditor = t != null && t.input && t.group ? { editor: t.input, groupId: t.group.id } : void 0, this.activeEditorListeners.clear(), this.handleActiveEditorChange(e, t), Mr(t) && this.activeEditorListeners.add(t.onDidChangeSelection((i) => this.handleActiveEditorSelectionChangeEvent(e, t, i))), this.updateContextKeys());
  }
  onDidFilesChange(e) {
    e instanceof Uo ? e.gotDeleted() && this.remove(e) : e.isOperation(1) ? this.remove(e) : e.isOperation(2) && e.target.isFile && this.move(e);
  }
  handleActiveEditorChange(e, t) {
    this.handleActiveEditorChangeInHistory(t), this.handleActiveEditorChangeInNavigationStacks(e, t);
  }
  handleActiveEditorSelectionChangeEvent(e, t, i) {
    this.handleActiveEditorSelectionChangeInNavigationStacks(e, t, i);
  }
  move(e) {
    this.moveInHistory(e), this.moveInEditorNavigationStacks(e);
  }
  remove(e) {
    this.removeFromHistory(e), this.removeFromEditorNavigationStacks(e), this.removeFromRecentlyClosedEditors(e), this.removeFromRecentlyOpened(e);
  }
  removeFromRecentlyOpened(e) {
    let t;
    De(e) ? t = me.getOriginalUri(e) : e instanceof Uo || (t = e.resource), t && this.workspacesService.removeRecentlyOpened([t]);
  }
  clear() {
    this.clearRecentlyOpened(), this.clearEditorNavigationStacks(), this.recentlyClosedEditors = [], this.updateContextKeys();
  }
  updateContextKeys() {
    this.contextKeyService.bufferChangeEvents(() => {
      const e = this.getStack();
      this.canNavigateBackContextKey.set(e.canGoBack(0)), this.canNavigateForwardContextKey.set(e.canGoForward(0)), this.canNavigateBackInNavigationsContextKey.set(e.canGoBack(2)), this.canNavigateForwardInNavigationsContextKey.set(e.canGoForward(2)), this.canNavigateToLastNavigationLocationContextKey.set(e.canGoLast(2)), this.canNavigateBackInEditsContextKey.set(e.canGoBack(1)), this.canNavigateForwardInEditsContextKey.set(e.canGoForward(1)), this.canNavigateToLastEditLocationContextKey.set(e.canGoLast(1)), this.canReopenClosedEditorContextKey.set(this.recentlyClosedEditors.length > 0);
    });
  }
  registerEditorNavigationScopeChangeListener() {
    const e = () => {
      this.disposeEditorNavigationStacks();
      const t = this.configurationService.getValue(Ge.NAVIGATION_SCOPE_SETTING);
      t === "editorGroup" ? this.editorNavigationScope = 1 : t === "editor" ? this.editorNavigationScope = 2 : this.editorNavigationScope = 0;
    };
    this._register(this.configurationService.onDidChangeConfiguration((t) => {
      t.affectsConfiguration(Ge.NAVIGATION_SCOPE_SETTING) && e();
    })), e();
  }
  getStack(e = this.editorGroupService.activeGroup, t = e.activeEditor) {
    var i, o;
    switch (this.editorNavigationScope) {
      case 2: {
        if (!t)
          return new Bk();
        let s = this.editorScopedNavigationStacks.get(e.id);
        s || (s = /* @__PURE__ */ new Map(), this.editorScopedNavigationStacks.set(e.id, s));
        let n = (i = s.get(t)) == null ? void 0 : i.stack;
        if (!n) {
          const r = new Z();
          n = r.add(this.instantiationService.createInstance($o, 2)), r.add(n.onDidChange(() => this._onDidChangeEditorNavigationStack.fire())), s.set(t, { stack: n, disposable: r });
        }
        return n;
      }
      case 1: {
        let s = (o = this.editorGroupScopedNavigationStacks.get(e.id)) == null ? void 0 : o.stack;
        if (!s) {
          const n = new Z();
          s = n.add(this.instantiationService.createInstance($o, 1)), n.add(s.onDidChange(() => this._onDidChangeEditorNavigationStack.fire())), this.editorGroupScopedNavigationStacks.set(e.id, { stack: s, disposable: n });
        }
        return s;
      }
      case 0:
        return this.defaultScopedEditorNavigationStack || (this.defaultScopedEditorNavigationStack = this._register(this.instantiationService.createInstance($o, 0)), this._register(this.defaultScopedEditorNavigationStack.onDidChange(() => this._onDidChangeEditorNavigationStack.fire()))), this.defaultScopedEditorNavigationStack;
    }
  }
  goForward(e) {
    return this.getStack().goForward(e);
  }
  goBack(e) {
    return this.getStack().goBack(e);
  }
  goPrevious(e) {
    return this.getStack().goPrevious(e);
  }
  goLast(e) {
    return this.getStack().goLast(e);
  }
  handleActiveEditorChangeInNavigationStacks(e, t) {
    this.getStack(e, t == null ? void 0 : t.input).handleActiveEditorChange(t);
  }
  handleActiveEditorSelectionChangeInNavigationStacks(e, t, i) {
    this.getStack(e, t.input).handleActiveEditorSelectionChange(t, i);
  }
  handleEditorCloseEventInHistory(e) {
    const t = this.editorScopedNavigationStacks.get(e.groupId);
    if (t) {
      const i = t.get(e.editor);
      i && (i.disposable.dispose(), t.delete(e.editor)), t.size === 0 && this.editorScopedNavigationStacks.delete(e.groupId);
    }
  }
  handleEditorGroupRemoveInNavigationStacks(e) {
    var i;
    (i = this.defaultScopedEditorNavigationStack) == null || i.remove(e.id);
    const t = this.editorGroupScopedNavigationStacks.get(e.id);
    t && (t.disposable.dispose(), this.editorGroupScopedNavigationStacks.delete(e.id));
  }
  clearEditorNavigationStacks() {
    this.withEachEditorNavigationStack((e) => e.clear());
  }
  removeFromEditorNavigationStacks(e) {
    this.withEachEditorNavigationStack((t) => t.remove(e));
  }
  moveInEditorNavigationStacks(e) {
    this.withEachEditorNavigationStack((t) => t.move(e));
  }
  withEachEditorNavigationStack(e) {
    this.defaultScopedEditorNavigationStack && e(this.defaultScopedEditorNavigationStack);
    for (const [, t] of this.editorGroupScopedNavigationStacks)
      e(t.stack);
    for (const [, t] of this.editorScopedNavigationStacks)
      for (const [, i] of t)
        e(i.stack);
  }
  disposeEditorNavigationStacks() {
    var e;
    (e = this.defaultScopedEditorNavigationStack) == null || e.dispose(), this.defaultScopedEditorNavigationStack = void 0;
    for (const [, t] of this.editorGroupScopedNavigationStacks)
      t.disposable.dispose();
    this.editorGroupScopedNavigationStacks.clear();
    for (const [, t] of this.editorScopedNavigationStacks)
      for (const [, i] of t)
        i.disposable.dispose();
    this.editorScopedNavigationStacks.clear();
  }
  openNextRecentlyUsedEditor(e) {
    const [t, i] = this.ensureRecentlyUsedStack((o) => o - 1, e);
    return this.doNavigateInRecentlyUsedEditorsStack(t[i], e);
  }
  openPreviouslyUsedEditor(e) {
    const [t, i] = this.ensureRecentlyUsedStack((o) => o + 1, e);
    return this.doNavigateInRecentlyUsedEditorsStack(t[i], e);
  }
  async doNavigateInRecentlyUsedEditorsStack(e, t) {
    if (e) {
      const i = typeof t != "number" || !this.editorGroupService.getGroup(t);
      i ? this.navigatingInRecentlyUsedEditorsStack = !0 : this.navigatingInRecentlyUsedEditorsInGroupStack = !0;
      const o = this.editorGroupService.getGroup(e.groupId) ?? this.editorGroupService.activeGroup;
      try {
        await o.openEditor(e.editor);
      } finally {
        i ? this.navigatingInRecentlyUsedEditorsStack = !1 : this.navigatingInRecentlyUsedEditorsInGroupStack = !1;
      }
    }
  }
  ensureRecentlyUsedStack(e, t) {
    let i, o;
    const s = typeof t == "number" ? this.editorGroupService.getGroup(t) : void 0;
    s ? (i = this.recentlyUsedEditorsInGroupStack || s.getEditors(0).map((r) => ({ groupId: s.id, editor: r })), o = this.recentlyUsedEditorsInGroupStackIndex) : (i = this.recentlyUsedEditorsStack || this.editorService.getEditors(0), o = this.recentlyUsedEditorsStackIndex);
    let n = e(o);
    return n < 0 ? n = 0 : n > i.length - 1 && (n = i.length - 1), s ? (this.recentlyUsedEditorsInGroupStack = i, this.recentlyUsedEditorsInGroupStackIndex = n) : (this.recentlyUsedEditorsStack = i, this.recentlyUsedEditorsStackIndex = n), [i, n];
  }
  handleEditorEventInRecentEditorsStack() {
    this.navigatingInRecentlyUsedEditorsStack || (this.recentlyUsedEditorsStack = void 0, this.recentlyUsedEditorsStackIndex = 0), this.navigatingInRecentlyUsedEditorsInGroupStack || (this.recentlyUsedEditorsInGroupStack = void 0, this.recentlyUsedEditorsInGroupStackIndex = 0);
  }
  handleEditorCloseEventInReopen(e) {
    if (this.ignoreEditorCloseEvent)
      return;
    const { editor: t, context: i } = e;
    if (i === Si.REPLACE || i === Si.MOVE)
      return;
    const o = t.toUntyped();
    if (!o)
      return;
    const s = [], n = me.getOriginalUri(t, { supportSideBySide: ie.BOTH });
    A.isUri(n) ? s.push(n) : n && s.push(...ti([n.primary, n.secondary])), this.removeFromRecentlyClosedEditors(t), this.recentlyClosedEditors.push({
      editorId: t.editorId,
      editor: o,
      resource: me.getOriginalUri(t),
      associatedResources: s,
      index: e.index,
      sticky: e.sticky
    }), this.recentlyClosedEditors.length > Ge.MAX_RECENTLY_CLOSED_EDITORS && this.recentlyClosedEditors.shift(), this.canReopenClosedEditorContextKey.set(!0);
  }
  async reopenLastClosedEditor() {
    const e = this.recentlyClosedEditors.pop();
    let t;
    return e && (t = this.doReopenLastClosedEditor(e)), this.canReopenClosedEditorContextKey.set(this.recentlyClosedEditors.length > 0), t;
  }
  async doReopenLastClosedEditor(e) {
    const t = { pinned: !0, sticky: e.sticky, index: e.index, ignoreError: !0 };
    (e.sticky && !this.editorGroupService.activeGroup.isSticky(e.index) || !e.sticky && this.editorGroupService.activeGroup.isSticky(e.index)) && (t.index = void 0);
    let i;
    if (!this.editorGroupService.activeGroup.contains(e.editor)) {
      this.ignoreEditorCloseEvent = !0;
      try {
        i = await this.editorService.openEditor({
          ...e.editor,
          options: {
            ...e.editor.options,
            ...t
          }
        });
      } finally {
        this.ignoreEditorCloseEvent = !1;
      }
    }
    i || (av(this.recentlyClosedEditors, e), this.reopenLastClosedEditor());
  }
  removeFromRecentlyClosedEditors(e) {
    this.recentlyClosedEditors = this.recentlyClosedEditors.filter((t) => De(e) && t.editorId !== e.editorId ? !0 : !(t.resource && this.editorHelper.matchesFile(t.resource, e) || t.associatedResources.some(
      (i) => this.editorHelper.matchesFile(i, e)
    ))), this.canReopenClosedEditorContextKey.set(this.recentlyClosedEditors.length > 0);
  }
  handleActiveEditorChangeInHistory(e) {
    const t = e == null ? void 0 : e.input;
    !t || t.isDisposed() || !this.includeInHistory(t) || (this.removeFromHistory(t), this.addToHistory(t));
  }
  addToHistory(e, t = !0) {
    this.ensureHistoryLoaded(this.history);
    const i = this.editorHelper.preferResourceEditorInput(e);
    i && (t ? this.history.unshift(i) : this.history.push(i), this.history.length > Ge.MAX_HISTORY_ITEMS && this.editorHelper.clearOnEditorDispose(this.history.pop(), this.editorHistoryListeners), De(i) && this.editorHelper.onEditorDispose(i, () => this.updateHistoryOnEditorDispose(i), this.editorHistoryListeners));
  }
  updateHistoryOnEditorDispose(e) {
    if (!cv(e))
      this.removeFromHistory(e);
    else {
      const t = [], i = e.primary.matches(e.secondary) ? [e.primary] : [e.primary, e.secondary];
      for (const o of i) {
        const s = this.editorHelper.preferResourceEditorInput(o);
        an(s) && t.push(s);
      }
      this.replaceInHistory(e, ...t);
    }
  }
  includeInHistory(e) {
    return De(e) ? !0 : !this.resourceExcludeMatcher.value.matches(e.resource);
  }
  removeExcludedFromHistory() {
    this.ensureHistoryLoaded(this.history), this.history = this.history.filter((e) => {
      const t = this.includeInHistory(e);
      return t || this.editorHelper.clearOnEditorDispose(e, this.editorHistoryListeners), t;
    });
  }
  moveInHistory(e) {
    e.isOperation(2) && this.removeFromHistory(e) && this.addToHistory({ resource: e.target.resource });
  }
  removeFromHistory(e) {
    let t = !1;
    return this.ensureHistoryLoaded(this.history), this.history = this.history.filter((i) => {
      const o = this.editorHelper.matchesEditor(e, i);
      return o && (this.editorHelper.clearOnEditorDispose(e, this.editorHistoryListeners), t = !0), !o;
    }), t;
  }
  replaceInHistory(e, ...t) {
    this.ensureHistoryLoaded(this.history);
    let i = !1;
    const o = [];
    for (const s of this.history)
      this.editorHelper.matchesEditor(e, s) ? (this.editorHelper.clearOnEditorDispose(e, this.editorHistoryListeners), i || (o.push(...t), i = !0)) : t.some((n) => this.editorHelper.matchesEditor(n, s)) || o.push(s);
    i || o.push(...t), this.history = o;
  }
  clearRecentlyOpened() {
    this.history = [];
    for (const [, e] of this.editorHistoryListeners)
      le(e);
    this.editorHistoryListeners.clear();
  }
  getHistory() {
    return this.ensureHistoryLoaded(this.history), this.history;
  }
  ensureHistoryLoaded(e) {
    this.history || (this.history = [], this.editorGroupService.isReady ? this.loadHistory() : (async () => (await this.editorGroupService.whenReady, this.loadHistory()))());
  }
  loadHistory() {
    var o;
    this.history = [];
    const e = this.loadHistoryFromStorage(), t = [...this.editorService.getEditors(0)].reverse(), i = /* @__PURE__ */ new Set();
    for (const { editor: s } of t)
      this.includeInHistory(s) && (this.addToHistory(s), s.resource && i.add(`${s.resource.toString()}/${s.editorId}`));
    for (const s of e)
      i.has(`${s.resource.toString()}/${(o = s.options) == null ? void 0 : o.override}`) || this.addToHistory(s, !1);
  }
  loadHistoryFromStorage() {
    const e = [], t = this.storageService.get(Ge.HISTORY_STORAGE_KEY, 1);
    if (t)
      try {
        const i = JSON.parse(t);
        for (const o of i)
          if (!(!o.editor || !o.editor.resource))
            try {
              e.push({
                ...o.editor,
                resource: typeof o.editor.resource == "string" ? A.parse(o.editor.resource) : A.from(o.editor.resource)
              });
            } catch (s) {
              ho(s);
            }
      } catch (i) {
        ho(i);
      }
    return e;
  }
  saveState() {
    if (!this.history)
      return;
    const e = [];
    for (const t of this.history)
      De(t) || !an(t) || e.push({
        editor: {
          ...t,
          resource: t.resource.toString()
        }
      });
    this.storageService.store(Ge.HISTORY_STORAGE_KEY, JSON.stringify(e), 1, 1);
  }
  getLastActiveWorkspaceRoot(e) {
    const t = this.contextService.getWorkspace().folders;
    if (t.length !== 0) {
      if (t.length === 1) {
        const i = t[0].uri;
        return !e || i.scheme === e ? i : void 0;
      }
      for (const i of this.getHistory()) {
        if (De(i) || e && i.resource.scheme !== e)
          continue;
        const o = this.contextService.getWorkspaceFolder(i.resource);
        if (o)
          return o.uri;
      }
      for (const i of t) {
        const o = i.uri;
        if (!e || o.scheme === e)
          return o;
      }
    }
  }
  getLastActiveFile(e) {
    for (const t of this.getHistory()) {
      let i;
      if (De(t) ? i = me.getOriginalUri(t, { filterByScheme: e }) : i = t.resource, (i == null ? void 0 : i.scheme) === e)
        return i;
    }
  }
}, Ge.MOUSE_NAVIGATION_SETTING = "workbench.editor.mouseBackForwardToNavigate", Ge.NAVIGATION_SCOPE_SETTING = "workbench.editor.navigationScope", Ge.MAX_RECENTLY_CLOSED_EDITORS = 20, Ge.MAX_HISTORY_ITEMS = 200, Ge.HISTORY_STORAGE_KEY = "history.entries", Ge);
wc = y([
  l(0, D),
  l(1, ce),
  l(2, at),
  l(3, ee),
  l(4, x),
  l(5, _e),
  l(6, Kc),
  l(7, W),
  l(8, Pe),
  l(9, F)
], wc);
class oh {
  constructor(e, t, i) {
    this.editorIdentifier = e, this.selection = t, this.reason = i;
  }
  justifiesNewNavigationEntry(e) {
    if (this.editorIdentifier.groupId !== e.editorIdentifier.groupId || !this.editorIdentifier.editor.matches(e.editorIdentifier.editor) || !this.selection || !e.selection)
      return !0;
    const t = this.selection.compare(e.selection);
    return t === 2 && (e.reason === 4 || e.reason === 5) ? !0 : t === 3;
  }
}
let $o = class extends E {
  constructor(e, t) {
    super(), this.scope = e, this.instantiationService = t, this.selectionsStack = this._register(this.instantiationService.createInstance(es, 0, this.scope)), this.editsStack = this._register(this.instantiationService.createInstance(es, 1, this.scope)), this.navigationsStack = this._register(this.instantiationService.createInstance(es, 2, this.scope)), this.stacks = [
      this.selectionsStack,
      this.editsStack,
      this.navigationsStack
    ], this.onDidChange = _.any(this.selectionsStack.onDidChange, this.editsStack.onDidChange, this.navigationsStack.onDidChange);
  }
  canGoForward(e) {
    return this.getStack(e).canGoForward();
  }
  goForward(e) {
    return this.getStack(e).goForward();
  }
  canGoBack(e) {
    return this.getStack(e).canGoBack();
  }
  goBack(e) {
    return this.getStack(e).goBack();
  }
  goPrevious(e) {
    return this.getStack(e).goPrevious();
  }
  canGoLast(e) {
    return this.getStack(e).canGoLast();
  }
  goLast(e) {
    return this.getStack(e).goLast();
  }
  getStack(e = 0) {
    switch (e) {
      case 0:
        return this.selectionsStack;
      case 1:
        return this.editsStack;
      case 2:
        return this.navigationsStack;
    }
  }
  handleActiveEditorChange(e) {
    this.selectionsStack.notifyNavigation(e);
  }
  handleActiveEditorSelectionChange(e, t) {
    const i = this.selectionsStack.current;
    this.selectionsStack.notifyNavigation(e, t), t.reason === 3 ? this.editsStack.notifyNavigation(e, t) : (t.reason === 4 || t.reason === 5) && !this.selectionsStack.isNavigating() && (t.reason === 5 && !this.navigationsStack.isNavigating() && i && this.navigationsStack.addOrReplace(i.groupId, i.editor, i.selection), this.navigationsStack.notifyNavigation(e, t));
  }
  clear() {
    for (const e of this.stacks)
      e.clear();
  }
  remove(e) {
    for (const t of this.stacks)
      t.remove(e);
  }
  move(e) {
    for (const t of this.stacks)
      t.move(e);
  }
};
$o = y([
  l(1, W)
], $o);
class Bk {
  constructor() {
    this.onDidChange = _.None;
  }
  canGoForward() {
    return !1;
  }
  async goForward() {
  }
  canGoBack() {
    return !1;
  }
  async goBack() {
  }
  async goPrevious() {
  }
  canGoLast() {
    return !1;
  }
  async goLast() {
  }
  handleActiveEditorChange() {
  }
  handleActiveEditorSelectionChange() {
  }
  clear() {
  }
  remove() {
  }
  move() {
  }
  dispose() {
  }
}
var _o;
let es = (_o = class extends E {
  get current() {
    return this.stack[this.index];
  }
  set current(e) {
    e && (this.stack[this.index] = e);
  }
  constructor(e, t, i, o, s, n) {
    super(), this.filter = e, this.scope = t, this.instantiationService = i, this.editorService = o, this.editorGroupService = s, this.logService = n, this._onDidChange = this._register(new w()), this.onDidChange = this._onDidChange.event, this.mapEditorToDisposable = /* @__PURE__ */ new Map(), this.mapGroupToDisposable = /* @__PURE__ */ new Map(), this.editorHelper = this.instantiationService.createInstance(Vn), this.stack = [], this.index = -1, this.previousIndex = -1, this.navigating = !1, this.currentSelectionState = void 0, this.registerListeners();
  }
  registerListeners() {
    this._register(this.onDidChange(() => this.traceStack())), this._register(this.logService.onDidChangeLogLevel(() => this.traceStack()));
  }
  traceStack() {
    var t, i, o;
    if (this.logService.getLevel() !== Jl.Trace)
      return;
    const e = [];
    for (const s of this.stack)
      typeof ((t = s.selection) == null ? void 0 : t.log) == "function" ? e.push(`- group: ${s.groupId}, editor: ${(i = s.editor.resource) == null ? void 0 : i.toString()}, selection: ${s.selection.log()}`) : e.push(`- group: ${s.groupId}, editor: ${(o = s.editor.resource) == null ? void 0 : o.toString()}, selection: <none>`);
    e.length === 0 ? this.trace(`index: ${this.index}, navigating: ${this.isNavigating()}: <empty>`) : this.trace(`index: ${this.index}, navigating: ${this.isNavigating()}
${e.join(`
`)}
			`);
  }
  trace(e, t = null, i) {
    var n;
    if (this.logService.getLevel() !== Jl.Trace)
      return;
    let o;
    switch (this.filter) {
      case 0:
        o = "global";
        break;
      case 1:
        o = "edits";
        break;
      case 2:
        o = "navigation";
        break;
    }
    let s;
    switch (this.scope) {
      case 0:
        s = "default";
        break;
      case 1:
        s = "editorGroup";
        break;
      case 2:
        s = "editor";
        break;
    }
    t !== null ? this.logService.trace(`[History stack ${o}-${s}]: ${e} (editor: ${(n = t == null ? void 0 : t.resource) == null ? void 0 : n.toString()}, event: ${this.traceEvent(i)})`) : this.logService.trace(`[History stack ${o}-${s}]: ${e}`);
  }
  traceEvent(e) {
    if (!e)
      return "<none>";
    switch (e.reason) {
      case 3:
        return "edit";
      case 4:
        return "navigation";
      case 5:
        return "jump";
      case 1:
        return "programmatic";
      case 2:
        return "user";
    }
  }
  registerGroupListeners(e) {
    if (!this.mapGroupToDisposable.has(e)) {
      const t = this.editorGroupService.getGroup(e);
      t && this.mapGroupToDisposable.set(e, t.onWillMoveEditor((i) => this.onWillMoveEditor(i)));
    }
  }
  onWillMoveEditor(e) {
    if (this.trace("onWillMoveEditor()", e.editor), this.scope !== 1)
      for (const t of this.stack)
        t.groupId === e.groupId && this.editorHelper.matchesEditor(e.editor, t.editor) && (t.groupId = e.target);
  }
  notifyNavigation(e, t) {
    this.trace("notifyNavigation()", e == null ? void 0 : e.input, t);
    const i = Mr(e), o = (e == null ? void 0 : e.group) && e.input && !e.input.isDisposed();
    this.navigating ? (this.trace("notifyNavigation() ignoring (navigating)", e == null ? void 0 : e.input, t), i && o ? (this.trace("notifyNavigation() updating current selection state", e == null ? void 0 : e.input, t), this.currentSelectionState = new oh(
      { groupId: e.group.id, editor: e.input },
      e.getSelection(),
      t == null ? void 0 : t.reason
    )) : (this.trace("notifyNavigation() dropping current selection state", e == null ? void 0 : e.input, t), this.currentSelectionState = void 0)) : (this.trace("notifyNavigation() not ignoring", e == null ? void 0 : e.input, t), i && o ? this.onSelectionAwareEditorNavigation(e.group.id, e.input, e.getSelection(), t) : (this.currentSelectionState = void 0, o && this.onNonSelectionAwareEditorNavigation(e.group.id, e.input)));
  }
  onSelectionAwareEditorNavigation(e, t, i, o) {
    var n;
    if (((n = this.current) == null ? void 0 : n.groupId) === e && !i && this.editorHelper.matchesEditor(this.current.editor, t))
      return;
    this.trace("onSelectionAwareEditorNavigation()", t, o);
    const s = new oh({ groupId: e, editor: t }, i, o == null ? void 0 : o.reason);
    !this.currentSelectionState || this.currentSelectionState.justifiesNewNavigationEntry(s) ? this.doAdd(e, t, s.selection) : this.doReplace(e, t, s.selection), this.currentSelectionState = s;
  }
  onNonSelectionAwareEditorNavigation(e, t) {
    var i;
    ((i = this.current) == null ? void 0 : i.groupId) === e && this.editorHelper.matchesEditor(this.current.editor, t) || (this.trace("onNonSelectionAwareEditorNavigation()", t), this.doAdd(e, t));
  }
  doAdd(e, t, i) {
    this.navigating || this.addOrReplace(e, t, i);
  }
  doReplace(e, t, i) {
    this.navigating || this.addOrReplace(e, t, i, !0);
  }
  addOrReplace(e, t, i, o) {
    this.registerGroupListeners(e);
    let s = !1;
    this.current && (o || this.shouldReplaceStackEntry(this.current, { groupId: e, editor: t, selection: i })) && (s = !0);
    const n = this.editorHelper.preferResourceEditorInput(t);
    if (!n)
      return;
    s ? this.trace("replace()", n) : this.trace("add()", n);
    const r = { groupId: e, editor: n, selection: i }, a = [];
    if (s)
      this.current && a.push(this.current), this.current = r;
    else {
      if (this.stack.length > this.index + 1) {
        for (let d = this.index + 1; d < this.stack.length; d++)
          a.push(this.stack[d]);
        this.stack = this.stack.slice(0, this.index + 1);
      }
      this.stack.splice(this.index + 1, 0, r), this.stack.length > _o.MAX_STACK_SIZE ? (a.push(this.stack.shift()), this.previousIndex >= 0 && this.previousIndex--) : this.setIndex(this.index + 1, !0);
    }
    for (const d of a)
      this.editorHelper.clearOnEditorDispose(d.editor, this.mapEditorToDisposable);
    De(n) && this.editorHelper.onEditorDispose(n, () => this.remove(n), this.mapEditorToDisposable), this._onDidChange.fire();
  }
  shouldReplaceStackEntry(e, t) {
    return e.groupId !== t.groupId || !this.editorHelper.matchesEditor(e.editor, t.editor) ? !1 : e.selection ? t.selection ? e.selection.compare(t.selection) === 1 : !1 : !0;
  }
  move(e) {
    if (e.isOperation(2))
      for (const t of this.stack)
        this.editorHelper.matchesEditor(e, t.editor) && (t.editor = { resource: e.target.resource });
  }
  remove(e) {
    var t;
    this.stack = this.stack.filter((i) => {
      const o = typeof e == "number" ? i.groupId === e : this.editorHelper.matchesEditor(e, i.editor);
      return o && this.editorHelper.clearOnEditorDispose(i.editor, this.mapEditorToDisposable), !o;
    }), this.flatten(), this.index = this.stack.length - 1, this.previousIndex = -1, typeof e == "number" && ((t = this.mapGroupToDisposable.get(e)) == null || t.dispose(), this.mapGroupToDisposable.delete(e)), this._onDidChange.fire();
  }
  flatten() {
    const e = [];
    let t;
    for (const i of this.stack)
      t && this.shouldReplaceStackEntry(i, t) || (t = i, e.push(i));
    this.stack = e;
  }
  clear() {
    this.index = -1, this.previousIndex = -1, this.stack.splice(0);
    for (const [, e] of this.mapEditorToDisposable)
      le(e);
    this.mapEditorToDisposable.clear();
    for (const [, e] of this.mapGroupToDisposable)
      le(e);
    this.mapGroupToDisposable.clear();
  }
  dispose() {
    super.dispose(), this.clear();
  }
  canGoForward() {
    return this.stack.length > this.index + 1;
  }
  async goForward() {
    if (!await this.maybeGoCurrent() && this.canGoForward())
      return this.setIndex(this.index + 1), this.navigate();
  }
  canGoBack() {
    return this.index > 0;
  }
  async goBack() {
    if (!await this.maybeGoCurrent() && this.canGoBack())
      return this.setIndex(this.index - 1), this.navigate();
  }
  async goPrevious() {
    if (!await this.maybeGoCurrent())
      return this.previousIndex === -1 ? this.goBack() : (this.setIndex(this.previousIndex), this.navigate());
  }
  canGoLast() {
    return this.stack.length > 0;
  }
  async goLast() {
    if (this.canGoLast())
      return this.setIndex(this.stack.length - 1), this.navigate();
  }
  async maybeGoCurrent() {
    return this.filter === 0 || this.isCurrentSelectionActive() ? !1 : (await this.navigate(), !0);
  }
  isCurrentSelectionActive() {
    var i, o;
    if (!((i = this.current) != null && i.selection))
      return !1;
    const e = this.editorService.activeEditorPane;
    if (!Mr(e) || ((o = e.group) == null ? void 0 : o.id) !== this.current.groupId || !e.input || !this.editorHelper.matchesEditor(e.input, this.current.editor))
      return !1;
    const t = e.getSelection();
    return t ? t.compare(this.current.selection) === 1 : !1;
  }
  setIndex(e, t) {
    this.previousIndex = this.index, this.index = e, t || this._onDidChange.fire();
  }
  async navigate() {
    this.navigating = !0;
    try {
      this.current && await this.doNavigate(this.current);
    } finally {
      this.navigating = !1;
    }
  }
  doNavigate(e) {
    let t = /* @__PURE__ */ Object.create(null);
    return e.selection && (t = e.selection.restore(t)), De(e.editor) ? this.editorService.openEditor(e.editor, t, e.groupId) : this.editorService.openEditor({
      ...e.editor,
      options: {
        ...e.editor.options,
        ...t
      }
    }, e.groupId);
  }
  isNavigating() {
    return this.navigating;
  }
}, _o.MAX_STACK_SIZE = 50, _o);
es = y([
  l(2, W),
  l(3, D),
  l(4, ce),
  l(5, rt)
], es);
let Vn = class {
  constructor(e, t, i, o) {
    this.uriIdentityService = e, this.lifecycleService = t, this.fileService = i, this.pathService = o;
  }
  preferResourceEditorInput(e) {
    const t = me.getOriginalUri(e);
    if ((t == null ? void 0 : t.scheme) === q.file || (t == null ? void 0 : t.scheme) === q.vscodeRemote || (t == null ? void 0 : t.scheme) === q.vscodeUserData || (t == null ? void 0 : t.scheme) === this.pathService.defaultUriScheme) {
      if (De(e)) {
        const o = e.toUntyped();
        if (an(o))
          return o;
      }
      return e;
    } else
      return De(e) ? e : void 0;
  }
  matchesEditor(e, t) {
    return e instanceof Uo || e instanceof Vl ? De(t) ? !1 : e instanceof Uo ? e.contains(t.resource, 2) : this.matchesFile(t.resource, e) : De(e) ? De(t) ? e.matches(t) : this.matchesFile(t.resource, e) : De(t) ? this.matchesFile(e.resource, t) : e && t && this.uriIdentityService.extUri.isEqual(e.resource, t.resource);
  }
  matchesFile(e, t) {
    if (t instanceof Uo)
      return t.contains(e, 2);
    if (t instanceof Vl)
      return this.uriIdentityService.extUri.isEqualOrParent(e, t.resource);
    if (De(t)) {
      const i = t.resource;
      return !i || this.lifecycleService.phase >= 3 && !this.fileService.hasProvider(i) ? !1 : this.uriIdentityService.extUri.isEqual(i, e);
    }
    return this.uriIdentityService.extUri.isEqual(t == null ? void 0 : t.resource, e);
  }
  matchesEditorIdentifier(e, t) {
    return !(t != null && t.group) || e.groupId !== t.group.id ? !1 : t.input ? e.editor.matches(t.input) : !1;
  }
  onEditorDispose(e, t, i) {
    const o = _.once(e.onWillDispose)(() => t());
    let s = i.get(e);
    s || (s = new Z(), i.set(e, s)), s.add(o);
  }
  clearOnEditorDispose(e, t) {
    if (!De(e))
      return;
    const i = t.get(e);
    i && (le(i), t.delete(e));
  }
};
Vn = y([
  l(0, Li),
  l(1, xo),
  l(2, _e),
  l(3, Pn)
], Vn);
class Tk {
  constructor() {
    this._factories = new lg(), this._onDidChange = new w(), this.onDidChange = this._onDidChange.event;
  }
  canCreateOutline(e) {
    for (const t of this._factories)
      if (t.matches(e))
        return !0;
    return !1;
  }
  async createOutline(e, t, i) {
    for (const o of this._factories)
      if (o.matches(e))
        return await o.createOutline(e, t, i);
  }
  registerOutlineCreator(e) {
    const t = this._factories.push(e);
    return this._onDidChange.fire(), M(() => {
      t(), this._onDidChange.fire();
    });
  }
}
var Lk = ".webview.modified{box-shadow:-6px 0 5px -5px var(--vscode-scrollbar-shadow)}";
oe(Lk, {});
class Fk {
  constructor() {
    this._references = /* @__PURE__ */ new Map();
  }
  async getAllModels(e) {
    const t = `${e.toString()}@@@`, i = [];
    for (const [o, s] of this._references)
      o.startsWith(t) && s.model && i.push(await s.model);
    return i;
  }
  async get(e, t) {
    const i = this.key(e, t), o = this._references.get(i);
    return o == null ? void 0 : o.model;
  }
  tryRetain(e, t) {
    const i = this.key(e, t), o = this._references.get(i);
    if (o)
      return o.counter++, o.model.then((s) => ({
        object: s,
        dispose: dv(() => {
          --o.counter <= 0 && (o.model.then((n) => n.dispose()), this._references.delete(i));
        })
      }));
  }
  add(e, t, i) {
    const o = this.key(e, t);
    if (this._references.get(o))
      throw new Error("Model already exists");
    return this._references.set(o, { viewType: t, model: i, counter: 0 }), this.tryRetain(e, t);
  }
  disposeAllModelsForView(e) {
    for (const [t, i] of this._references)
      i.viewType === e && (i.model.then((o) => o.dispose()), this._references.delete(t));
  }
  key(e, t) {
    return `${e.toString()}@@@${t}`;
  }
}
const bt = Object.freeze({
  viewType: "viewType",
  displayName: "displayName",
  selector: "selector",
  priority: "priority"
}), Xk = {
  description: u("contributes.customEditors", "Contributed custom editors."),
  type: "array",
  defaultSnippets: [{
    body: [{
      [bt.viewType]: "$1",
      [bt.displayName]: "$2",
      [bt.selector]: [{
        filenamePattern: "$3"
      }]
    }]
  }],
  items: {
    type: "object",
    required: [
      bt.viewType,
      bt.displayName,
      bt.selector
    ],
    properties: {
      [bt.viewType]: {
        type: "string",
        markdownDescription: u(
          "contributes.viewType",
          "Identifier for the custom editor. This must be unique across all custom editors, so we recommend including your extension id as part of `viewType`. The `viewType` is used when registering custom editors with `vscode.registerCustomEditorProvider` and in the `onCustomEditor:${id}` [activation event](https://code.visualstudio.com/api/references/activation-events)."
        )
      },
      [bt.displayName]: {
        type: "string",
        description: u(
          "contributes.displayName",
          "Human readable name of the custom editor. This is displayed to users when selecting which editor to use."
        )
      },
      [bt.selector]: {
        type: "array",
        description: u(
          "contributes.selector",
          "Set of globs that the custom editor is enabled for."
        ),
        items: {
          type: "object",
          defaultSnippets: [{
            body: {
              filenamePattern: "$1"
            }
          }],
          properties: {
            filenamePattern: {
              type: "string",
              description: u(
                "contributes.selector.filenamePattern",
                "Glob that the custom editor is enabled for."
              )
            }
          }
        }
      },
      [bt.priority]: {
        type: "string",
        markdownDeprecationMessage: u(
          "contributes.priority",
          "Controls if the custom editor is enabled automatically when the user opens a file. This may be overridden by users using the `workbench.editorAssociations` setting."
        ),
        enum: [
          "default",
          "option"
        ],
        markdownEnumDescriptions: [
          u(
            "contributes.priority.default",
            "The editor is automatically used when the user opens a resource, provided that no other default custom editors are registered for that resource."
          ),
          u(
            "contributes.priority.option",
            "The editor is not automatically used when the user opens a resource, but a user can switch to the editor using the `Reopen With` command."
          )
        ],
        default: "default"
      }
    }
  }
}, Kk = yd.registerExtensionPoint({
  extensionPoint: "customEditors",
  deps: [lv],
  jsonSchema: Xk,
  activationEventsGenerator: (c, e) => {
    for (const t of c) {
      const i = t[bt.viewType];
      i && e.push(`onCustomEditor:${i}`);
    }
  }
}), Ji = class Ji extends E {
  constructor(e) {
    super(), this._editors = /* @__PURE__ */ new Map(), this._onChange = this._register(new w()), this.onChange = this._onChange.event, this._memento = new Uu(Ji.CUSTOM_EDITORS_STORAGE_ID, e);
    const t = this._memento.getMemento(0, 1);
    for (const i of t[Ji.CUSTOM_EDITORS_ENTRY_ID] || [])
      this.add(new Zl(i));
    Kk.setHandler((i) => {
      this.update(i);
    });
  }
  update(e) {
    this._editors.clear();
    for (const i of e)
      for (const o of i.value)
        this.add(new Zl({
          id: o.viewType,
          displayName: o.displayName,
          providerDisplayName: i.description.isBuiltin ? u("builtinProviderDisplayName", "Built-in") : i.description.displayName || i.description.identifier.value,
          selector: o.selector || [],
          priority: Yk(o, i.description)
        }));
    const t = this._memento.getMemento(0, 1);
    t[Ji.CUSTOM_EDITORS_ENTRY_ID] = Array.from(this._editors.values()), this._memento.saveMemento(), this._onChange.fire();
  }
  [Symbol.iterator]() {
    return this._editors.values();
  }
  get(e) {
    return this._editors.get(e);
  }
  getContributedEditors(e) {
    return Array.from(this._editors.values()).filter((t) => t.matches(e));
  }
  add(e) {
    if (this._editors.has(e.id)) {
      console.error(`Custom editor with id '${e.id}' already registered`);
      return;
    }
    this._editors.set(e.id, e);
  }
};
Ji.CUSTOM_EDITORS_STORAGE_ID = "customEditors", Ji.CUSTOM_EDITORS_ENTRY_ID = "editors";
let yc = Ji;
function Yk(c, e) {
  switch (c.priority) {
    case xe.default:
    case xe.option:
      return c.priority;
    case xe.builtin:
      return e.isBuiltin ? xe.builtin : xe.default;
    default:
      return xe.default;
  }
}
let kc = class extends E {
  constructor(e, t, i, o, s, n, r, a) {
    super(), this.editorService = o, this.editorGroupService = s, this.instantiationService = n, this.uriIdentityService = r, this.editorResolverService = a, this._untitledCounter = 0, this._editorResolverDisposables = this._register(new Z()), this._editorCapabilities = /* @__PURE__ */ new Map(), this._models = new Fk(), this._onDidChangeEditorTypes = this._register(new w()), this.onDidChangeEditorTypes = this._onDidChangeEditorTypes.event, this._fileEditorFactory = N.as(Ci.EditorFactory).getFileEditorFactory(), this._activeCustomEditorId = hv.bindTo(e), this._focusedCustomEditorIsEditable = uv.bindTo(e), this._contributedEditors = this._register(new yc(i)), this.editorResolverService.bufferChangeEvents(this.registerContributionPoints.bind(this)), this._register(this._contributedEditors.onChange(() => {
      this.editorResolverService.bufferChangeEvents(this.registerContributionPoints.bind(this)), this.updateContexts(), this._onDidChangeEditorTypes.fire();
    })), this._register(this.editorService.onDidActiveEditorChange(() => this.updateContexts())), this._register(t.onDidRunOperation((h) => {
      h.isOperation(2) && this.handleMovedFileInOpenedFileEditors(h.resource, this.uriIdentityService.asCanonicalUri(h.target.resource));
    }));
    const d = 105;
    this._register(cg.addImplementation(d, "custom-editor", () => this.withActiveCustomEditor((h) => h.undo()))), this._register(dg.addImplementation(d, "custom-editor", () => this.withActiveCustomEditor((h) => h.redo()))), this.updateContexts();
  }
  getEditorTypes() {
    return [...this._contributedEditors];
  }
  withActiveCustomEditor(e) {
    const t = this.editorService.activeEditor;
    if (t instanceof qe) {
      const i = e(t);
      return i || !0;
    }
    return !1;
  }
  registerContributionPoints() {
    this._editorResolverDisposables.clear();
    for (const e of this._contributedEditors)
      for (const t of e.selector)
        t.filenamePattern && this._editorResolverDisposables.add(this.editorResolverService.registerEditor(t.filenamePattern, {
          id: e.id,
          label: e.displayName,
          detail: e.providerDisplayName,
          priority: e.priority
        }, {
          singlePerResource: () => {
            var i;
            return !((i = this.getCustomEditorCapabilities(e.id)) != null && i.supportsMultipleEditorsPerDocument);
          }
        }, {
          createEditorInput: ({ resource: i }, o) => ({ editor: qe.create(this.instantiationService, i, e.id, o.id) }),
          createUntitledEditorInput: ({ resource: i }, o) => ({ editor: qe.create(this.instantiationService, i ?? A.from(
            { scheme: q.untitled, authority: `Untitled-${this._untitledCounter++}` }
          ), e.id, o.id) }),
          createDiffEditorInput: (i, o) => ({ editor: this.createDiffEditorInput(i, e.id, o) })
        }));
  }
  createDiffEditorInput(e, t, i) {
    const o = qe.create(this.instantiationService, L(e.modified.resource), t, i.id, { customClasses: "modified" }), s = qe.create(this.instantiationService, L(e.original.resource), t, i.id, { customClasses: "original" });
    return this.instantiationService.createInstance(ld, e.label, e.description, s, o, !0);
  }
  get models() {
    return this._models;
  }
  getCustomEditor(e) {
    return this._contributedEditors.get(e);
  }
  getContributedCustomEditors(e) {
    return new Cr(this._contributedEditors.getContributedEditors(e));
  }
  getUserConfiguredCustomEditors(e) {
    const t = this.editorResolverService.getAssociationsForResource(e);
    return new Cr(ti(t.map((i) => this._contributedEditors.get(i.viewType))));
  }
  getAllCustomEditors(e) {
    return new Cr([
      ...this.getUserConfiguredCustomEditors(e).allEditors,
      ...this.getContributedCustomEditors(e).allEditors
    ]);
  }
  registerCustomEditorCapabilities(e, t) {
    if (this._editorCapabilities.has(e))
      throw new Error(`Capabilities for ${e} already set`);
    return this._editorCapabilities.set(e, t), M(() => {
      this._editorCapabilities.delete(e);
    });
  }
  getCustomEditorCapabilities(e) {
    return this._editorCapabilities.get(e);
  }
  updateContexts() {
    var i;
    const e = this.editorService.activeEditorPane;
    if (!((i = e == null ? void 0 : e.input) == null ? void 0 : i.resource)) {
      this._activeCustomEditorId.reset(), this._focusedCustomEditorIsEditable.reset();
      return;
    }
    this._activeCustomEditorId.set((e == null ? void 0 : e.input) instanceof qe ? e.input.viewType : ""), this._focusedCustomEditorIsEditable.set((e == null ? void 0 : e.input) instanceof qe);
  }
  async handleMovedFileInOpenedFileEditors(e, t) {
    if (Yt(e).toLowerCase() === Yt(t).toLowerCase())
      return;
    const i = this.getAllCustomEditors(t);
    if (!i.allEditors.some((s) => s.priority !== xe.option))
      return;
    const o = /* @__PURE__ */ new Map();
    for (const s of this.editorGroupService.groups)
      for (const n of s.editors)
        if (this._fileEditorFactory.isFileEditor(n) && !(n instanceof qe) && Be(n.resource, t)) {
          let r = o.get(s.id);
          r || (r = [], o.set(s.id, r)), r.push(n);
        }
    if (o.size)
      for (const [s, n] of o)
        this.editorService.replaceEditors(n.map((r) => {
          let a;
          if (i.defaultEditor) {
            const d = i.defaultEditor.id;
            a = qe.create(this.instantiationService, t, d, s);
          } else
            a = { resource: t, options: { override: Ke.id } };
          return {
            editor: r,
            replacement: a,
            options: {
              preserveFocus: !0
            }
          };
        }), s);
  }
};
kc = y([
  l(0, F),
  l(1, _e),
  l(2, ee),
  l(3, D),
  l(4, ce),
  l(5, W),
  l(6, Li),
  l(7, Zs)
], kc);
let Sc = class extends E {
  constructor(e, t) {
    super(), this._themeService = e, this._configurationService = t, this._cachedWebViewThemeData = void 0, this._onThemeDataChanged = this._register(new w()), this.onThemeDataChanged = this._onThemeDataChanged.event, this._register(this._themeService.onDidColorThemeChange(() => {
      this._reset();
    }));
    const i = ["editor.fontFamily", "editor.fontWeight", "editor.fontSize"];
    this._register(this._configurationService.onDidChangeConfiguration((o) => {
      i.some((s) => o.affectsConfiguration(s)) && this._reset();
    }));
  }
  getTheme() {
    return this._themeService.getColorTheme();
  }
  getWebviewThemeData() {
    if (!this._cachedWebViewThemeData) {
      const e = this._configurationService.getValue("editor"), t = e.fontFamily || Ps.fontFamily, i = e.fontWeight || Ps.fontWeight, o = e.fontSize || Ps.fontSize, s = this._themeService.getColorTheme(), n = pv().getColors().reduce((d, h) => {
        const g = s.getColor(h.id);
        return g && (d["vscode-" + h.id.replace(".", "-")] = g.toString()), d;
      }, {}), r = {
        "vscode-font-family": Iw,
        "vscode-font-weight": "normal",
        "vscode-font-size": "13px",
        "vscode-editor-font-family": t,
        "vscode-editor-font-weight": i,
        "vscode-editor-font-size": o + "px",
        ...n
      }, a = bs.fromTheme(s);
      this._cachedWebViewThemeData = { styles: r, activeTheme: a, themeLabel: s.label, themeId: s.settingsId };
    }
    return this._cachedWebViewThemeData;
  }
  _reset() {
    this._cachedWebViewThemeData = void 0, this._onThemeDataChanged.fire();
  }
};
Sc = y([
  l(0, gv),
  l(1, x)
], Sc);
var bs;
(function(c) {
  c.light = "vscode-light", c.dark = "vscode-dark", c.highContrast = "vscode-high-contrast", c.highContrastLight = "vscode-high-contrast-light";
})(bs || (bs = {}));
(function(c) {
  function e(t) {
    switch (t.type) {
      case Hi.LIGHT:
        return c.light;
      case Hi.DARK:
        return c.dark;
      case Hi.HIGH_CONTRAST_DARK:
        return c.highContrast;
      case Hi.HIGH_CONTRAST_LIGHT:
        return c.highContrastLight;
    }
  }
  c.fromTheme = e;
})(bs || (bs = {}));
class Ok {
  constructor(e, t, i) {
    this._getExtensionLocation = e, this._getMappings = t, this.tunnelService = i, this._tunnels = /* @__PURE__ */ new Map();
  }
  async getRedirect(e, t) {
    const i = A.parse(t), o = mv(i);
    if (o) {
      for (const s of this._getMappings())
        if (s.webviewPort === o.port) {
          const n = this._getExtensionLocation();
          if (n && n.scheme === q.vscodeRemote) {
            const r = e && await this.getOrCreateTunnel(e, s.extensionHostPort);
            if (r)
              return r.tunnelLocalPort === s.webviewPort ? void 0 : encodeURI(i.with({
                authority: `127.0.0.1:${r.tunnelLocalPort}`
              }).toString(!0));
          }
          if (s.webviewPort !== s.extensionHostPort)
            return encodeURI(i.with({
              authority: `${o.address}:${s.extensionHostPort}`
            }).toString(!0));
        }
    }
  }
  async dispose() {
    for (const e of this._tunnels.values())
      await e.dispose();
    this._tunnels.clear();
  }
  async getOrCreateTunnel(e, t) {
    const i = this._tunnels.get(t);
    if (i)
      return i;
    const o = await this.tunnelService.openTunnel({ getAddress: async () => e }, void 0, t);
    return o && this._tunnels.set(t, o), o;
  }
}
const Hk = /* @__PURE__ */ new Map([
  [".svg", "image/svg+xml"],
  [".txt", Mo.text],
  [".css", "text/css"],
  [".js", "application/javascript"],
  [".cjs", "application/javascript"],
  [".mjs", "application/javascript"],
  [".json", "application/json"],
  [".html", "text/html"],
  [".htm", "text/html"],
  [".xhtml", "application/xhtml+xml"],
  [".oft", "font/otf"],
  [".xml", "application/xml"],
  [".wasm", "application/wasm"]
]);
function Pk(c) {
  const e = bv(c.fsPath).toLowerCase();
  return Hk.get(e) || Cv(c.fsPath) || Mo.unknown;
}
var Ot;
(function(c) {
  let e;
  (function(o) {
    o[o.Success = 0] = "Success", o[o.Failed = 1] = "Failed", o[o.AccessDenied = 2] = "AccessDenied", o[o.NotModified = 3] = "NotModified";
  })(e = c.Type || (c.Type = {}));
  class t {
    constructor(s, n, r, a) {
      this.stream = s, this.etag = n, this.mtime = r, this.mimeType = a, this.type = e.Success;
    }
  }
  c.StreamSuccess = t, c.Failed = { type: e.Failed }, c.AccessDenied = { type: e.AccessDenied };
  class i {
    constructor(s, n) {
      this.mimeType = s, this.mtime = n, this.type = e.NotModified;
    }
  }
  c.NotModified = i;
})(Ot || (Ot = {}));
async function Mk(c, e, t, i, o) {
  var r;
  i.debug(`loadLocalResource - begin. requestUri=${c}`);
  const s = zk(c, e.roots);
  if (i.debug(`loadLocalResource - found resource to load. requestUri=${c}, resourceToLoad=${s}`), !s)
    return Ot.AccessDenied;
  const n = Pk(c);
  try {
    const a = await t.readFileStream(s, { etag: e.ifNoneMatch }, o);
    return new Ot.StreamSuccess(a.value, a.etag, a.mtime, n);
  } catch (a) {
    return a instanceof ag && a.fileOperationResult === 2 ? new Ot.NotModified(n, (r = a.options) == null ? void 0 : r.mtime) : (i.debug(`loadLocalResource - Error using fileReader. requestUri=${c}`), console.log(a), Ot.Failed);
  }
}
function zk(c, e) {
  for (const t of e)
    if (Uk(t, c))
      return jk(c);
}
function Uk(c, e) {
  if (c.scheme !== e.scheme)
    return !1;
  let t = Wl(e.fsPath), i = Wl(c.fsPath + (c.fsPath.endsWith(zo) ? "" : zo));
  return _l(c.fsPath) && _l(e.fsPath) && (i = i.toLowerCase(), t = t.toLowerCase()), t.startsWith(i);
}
function jk(c) {
  return c.scheme === q.vscodeRemote ? A.from({
    scheme: q.vscodeRemote,
    authority: c.authority,
    path: "/vscode-resource",
    query: JSON.stringify({
      requestResourcePath: c.path
    })
  }) : c;
}
var qk = ".monaco-workbench .simple-find-part-wrapper{max-width:calc(100% - 64px);overflow:hidden;padding:0 10px 10px;pointer-events:none;position:absolute;right:18px;top:0;z-index:10}.simple-find-part .monaco-inputbox>.ibwrapper>input{text-overflow:clip}.monaco-workbench .simple-find-part{align-items:center;background-color:var(--vscode-editorWidget-background)!important;border:1px solid var(--vscode-contrastBorder);border-bottom-left-radius:4px;border-bottom-right-radius:4px;box-shadow:0 0 8px 2px var(--vscode-widget-shadow);color:var(--vscode-editorWidget-foreground);display:flex;font-size:12px;padding:4px;pointer-events:all;position:relative;top:-45px;transition:top .2s linear;visibility:hidden;z-index:10}.monaco-workbench.reduce-motion .monaco-editor .find-widget{transition:top 0ms linear}.monaco-workbench .simple-find-part.visible{visibility:visible}.monaco-workbench .simple-find-part.suppress-transition{transition:none}.monaco-workbench .simple-find-part.visible-transition{top:0}.monaco-workbench .simple-find-part .monaco-findInput{flex:1}.monaco-workbench .simple-find-part .matchesCount{max-width:73px;min-width:73px;padding-left:5px;width:73px}.monaco-workbench .simple-find-part.reduced-find-widget .matchesCount{display:none}.monaco-workbench .simple-find-part .button{background-position:50%;background-repeat:no-repeat;cursor:pointer;display:flex;flex:initial;height:20px;justify-content:center;line-height:20px;margin-left:3px;min-width:20px;width:20px}.monaco-workbench div.simple-find-part div.button.disabled{cursor:default;opacity:.3!important}div.simple-find-part-wrapper div.button{border-radius:5px}.no-results.matchesCount{color:var(--vscode-errorForeground)}div.simple-find-part-wrapper div.button:hover:not(.disabled){background-color:var(--vscode-toolbar-hoverBackground);outline:1px dashed var(--vscode-toolbar-hoverOutline);outline-offset:-1px}";
oe(qk, {});
const $k = u("label.find", "Find"), eS = u("placeholder.find", "Find ( for history)"), tS = u("label.previousMatchButton", "Previous Match"), iS = u("label.nextMatchButton", "Next Match"), oS = u("label.closeButton", "Close"), sS = 310, nS = 73;
class rS extends Bn {
  constructor(e, t, i, o) {
    super(), this._keybindingService = o, this._isVisible = !1, this._foundMatch = !1, this._width = 0, this.state = new fv(), this._matchesLimit = e.matchesLimit ?? Number.MAX_SAFE_INTEGER, this._findInput = this._register(new vv(null, t, {
      label: $k,
      placeholder: eS,
      validation: (n) => {
        if (n.length === 0 || !this._findInput.getRegex())
          return null;
        try {
          return null;
        } catch (r) {
          return this._foundMatch = !1, this.updateButtons(this._foundMatch), { content: r.message };
        }
      },
      showCommonFindToggles: e.showCommonFindToggles,
      appendCaseSensitiveLabel: e.appendCaseSensitiveActionId ? this._getKeybinding(e.appendCaseSensitiveActionId) : void 0,
      appendRegexLabel: e.appendRegexActionId ? this._getKeybinding(e.appendRegexActionId) : void 0,
      appendWholeWordsLabel: e.appendWholeWordsActionId ? this._getKeybinding(e.appendWholeWordsActionId) : void 0,
      showHistoryHint: () => wv(o),
      inputBoxStyles: yv,
      toggleStyles: Hu
    }, i)), this._updateHistoryDelayer = new kv(500), this._register(this._findInput.onInput(async (n) => {
      (!e.checkImeCompletionState || !this._findInput.isImeSessionInProgress) && (this._foundMatch = this._onInputChanged(), e.showResultCount && await this.updateResultCount(), this.updateButtons(this._foundMatch), this.focusFindBox(), this._delayedUpdateHistory());
    })), this._findInput.setRegex(!!this.state.isRegex), this._findInput.setCaseSensitive(!!this.state.matchCase), this._findInput.setWholeWords(!!this.state.wholeWord), this._register(this._findInput.onDidOptionChange(() => {
      this.state.change({
        isRegex: this._findInput.getRegex(),
        wholeWord: this._findInput.getWholeWords(),
        matchCase: this._findInput.getCaseSensitive()
      }, !0);
    })), this._register(this.state.onFindReplaceStateChange(() => {
      this._findInput.setRegex(this.state.isRegex), this._findInput.setWholeWords(this.state.wholeWord), this._findInput.setCaseSensitive(this.state.matchCase), this.findFirst();
    })), this.prevBtn = this._register(new fr({
      label: tS + (e.previousMatchActionId ? this._getKeybinding(e.previousMatchActionId) : ""),
      icon: Sv,
      onTrigger: () => {
        this.find(!0);
      }
    })), this.nextBtn = this._register(new fr({
      label: iS + (e.nextMatchActionId ? this._getKeybinding(e.nextMatchActionId) : ""),
      icon: Iv,
      onTrigger: () => {
        this.find(!1);
      }
    }));
    const s = this._register(new fr({
      label: oS + (e.closeWidgetActionId ? this._getKeybinding(e.closeWidgetActionId) : ""),
      icon: Jv,
      onTrigger: () => {
        this.hide();
      }
    }));
    this._innerDomNode = document.createElement("div"), this._innerDomNode.classList.add("simple-find-part"), this._innerDomNode.appendChild(this._findInput.domNode), this._innerDomNode.appendChild(this.prevBtn.domNode), this._innerDomNode.appendChild(this.nextBtn.domNode), this._innerDomNode.appendChild(s.domNode), this._domNode = document.createElement("div"), this._domNode.classList.add("simple-find-part-wrapper"), this._domNode.appendChild(this._innerDomNode), this.onkeyup(this._innerDomNode, (n) => {
      if (n.equals(9)) {
        this.hide(), n.preventDefault();
        return;
      }
    }), this._focusTracker = this._register(pi(this._innerDomNode)), this._register(this._focusTracker.onDidFocus(this._onFocusTrackerFocus.bind(this))), this._register(this._focusTracker.onDidBlur(this._onFocusTrackerBlur.bind(this))), this._findInputFocusTracker = this._register(pi(this._findInput.domNode)), this._register(this._findInputFocusTracker.onDidFocus(this._onFindInputFocusTrackerFocus.bind(this))), this._register(this._findInputFocusTracker.onDidBlur(this._onFindInputFocusTrackerBlur.bind(this))), this._register(S(this._innerDomNode, "click", (n) => {
      n.stopPropagation();
    })), e != null && e.showResultCount && (this._domNode.classList.add("result-count"), this._matchesCount = document.createElement("div"), this._matchesCount.className = "matchesCount", this._findInput.domNode.insertAdjacentElement("afterend", this._matchesCount), this._register(this._findInput.onDidChange(async () => {
      await this.updateResultCount();
    })), this._register(this._findInput.onDidOptionChange(async () => {
      this._foundMatch = this._onInputChanged(), await this.updateResultCount(), this.focusFindBox(), this._delayedUpdateHistory();
    })));
  }
  get inputValue() {
    return this._findInput.getValue();
  }
  get focusTracker() {
    return this._focusTracker;
  }
  _getKeybinding(e) {
    var i;
    const t = (i = this._keybindingService) == null ? void 0 : i.lookupKeybinding(e);
    return t ? ` (${t.getLabel()})` : "";
  }
  dispose() {
    super.dispose(), this._domNode && this._domNode.parentElement && this._domNode.parentElement.removeChild(this._domNode);
  }
  isVisible() {
    return this._isVisible;
  }
  getDomNode() {
    return this._domNode;
  }
  reveal(e, t = !0) {
    if (e && this._findInput.setValue(e), this._isVisible) {
      this._findInput.select();
      return;
    }
    this._isVisible = !0, this.updateResultCount(), this.layout(), setTimeout(() => {
      this._innerDomNode.classList.toggle("suppress-transition", !t), this._innerDomNode.classList.add("visible", "visible-transition"), this._innerDomNode.setAttribute("aria-hidden", "false"), this._findInput.select(), t || setTimeout(() => {
        this._innerDomNode.classList.remove("suppress-transition");
      }, 0);
    }, 0);
  }
  show(e) {
    e && !this._isVisible && this._findInput.setValue(e), this._isVisible = !0, this.layout(), setTimeout(() => {
      this._innerDomNode.classList.add("visible", "visible-transition"), this._innerDomNode.setAttribute("aria-hidden", "false");
    }, 0);
  }
  hide(e = !0) {
    this._isVisible && (this._innerDomNode.classList.toggle("suppress-transition", !e), this._innerDomNode.classList.remove("visible-transition"), this._innerDomNode.setAttribute("aria-hidden", "true"), setTimeout(() => {
      this._isVisible = !1, this.updateButtons(this._foundMatch), this._innerDomNode.classList.remove("visible", "suppress-transition");
    }, e ? 200 : 0));
  }
  layout(e = this._width) {
    if (this._width = e, !!this._isVisible && this._matchesCount) {
      let t = !1;
      sS + nS + 28 >= e && (t = !0), this._innerDomNode.classList.toggle("reduced-find-widget", t);
    }
  }
  _delayedUpdateHistory() {
    this._updateHistoryDelayer.trigger(this._updateHistory.bind(this));
  }
  _updateHistory() {
    this._findInput.inputBox.addToHistory();
  }
  _getRegexValue() {
    return this._findInput.getRegex();
  }
  _getWholeWordValue() {
    return this._findInput.getWholeWords();
  }
  _getCaseSensitiveValue() {
    return this._findInput.getCaseSensitive();
  }
  updateButtons(e) {
    const t = this.inputValue.length > 0;
    this.prevBtn.setEnabled(this._isVisible && t && e), this.nextBtn.setEnabled(this._isVisible && t && e);
  }
  focusFindBox() {
    this.nextBtn.focus(), this._findInput.inputBox.focus();
  }
  async updateResultCount() {
    if (!this._matchesCount) {
      this.updateButtons(this._foundMatch);
      return;
    }
    const e = await this._getResultCount();
    this._matchesCount.innerText = "";
    const t = this.inputValue.length > 0 && (e == null ? void 0 : e.resultCount) === 0;
    this._matchesCount.classList.toggle("no-results", t);
    let i = "";
    if (e != null && e.resultCount) {
      let o = String(e.resultCount);
      e.resultCount >= this._matchesLimit && (o += "+");
      let s = String(e.resultIndex + 1);
      s === "0" && (s = "?"), i = Vv(Zv, s, o);
    } else
      i = El;
    Wv(this._announceSearchResults(i, this.inputValue)), this._matchesCount.appendChild(document.createTextNode(i)), this._foundMatch = !!e && e.resultCount > 0, this.updateButtons(this._foundMatch);
  }
  changeState(e) {
    this.state.change(e, !1);
  }
  _announceSearchResults(e, t) {
    return t ? e === El ? t === "" ? u("ariaSearchNoResultEmpty", "{0} found", e) : u("ariaSearchNoResult", "{0} found for '{1}'", e, t) : u(
      "ariaSearchNoResultWithLineNumNoCurrentMatch",
      "{0} found for '{1}'",
      e,
      t
    ) : u("ariaSearchNoInput", "Enter search input");
  }
}
let Ic = class extends rS {
  async _getResultCount(e) {
  }
  constructor(e, t, i, o) {
    super({ showCommonFindToggles: !1, checkImeCompletionState: e.checkImeCompletionState }, t, i, o), this._delegate = e, this._findWidgetFocused = Sd.bindTo(i), this._register(e.hasFindResult((s) => {
      this.updateButtons(s), this.focusFindBox();
    })), this._register(e.onDidStopFind(() => {
      this.updateButtons(!1);
    }));
  }
  find(e) {
    const t = this.inputValue;
    t && this._delegate.find(t, e);
  }
  hide(e = !0) {
    super.hide(e), this._delegate.stopFind(!0), this._delegate.focus();
  }
  _onInputChanged() {
    const e = this.inputValue;
    return e ? this._delegate.updateFind(e) : this._delegate.stopFind(!1), !1;
  }
  _onFocusTrackerFocus() {
    this._findWidgetFocused.set(!0);
  }
  _onFocusTrackerBlur() {
    this._findWidgetFocused.reset();
  }
  _onFindInputFocusTrackerFocus() {
  }
  _onFindInputFocusTrackerBlur() {
  }
  findFirst() {
  }
};
Ic = y([
  l(1, Fn),
  l(2, F),
  l(3, be)
], Ic);
var Zn;
(function(c) {
  (function(t) {
    t[t.Initializing = 0] = "Initializing", t[t.Ready = 1] = "Ready";
  })(c.Type || (c.Type = {}));
  class e {
    constructor(i) {
      this.pendingMessages = i, this.type = 0;
    }
  }
  c.Initializing = e, c.Ready = { type: 1 };
})(Zn || (Zn = {}));
const aS = "webviewId";
let Jc = class extends E {
  get platform() {
    return "browser";
  }
  get element() {
    return this._element;
  }
  get isFocused() {
    return !(!this._focused || document.activeElement && document.activeElement !== this.element);
  }
  constructor(e, t, i, o, s, n, r, a, d, h, g, p, m) {
    super(), this.webviewThemeDataProvider = t, this._environmentService = n, this._fileService = r, this._logService = a, this._remoteAuthorityResolverService = d, this._telemetryService = h, this._tunnelService = g, this._accessibilityService = m, this.id = An(), this._expectedServiceWorkerVersion = 4, this._state = new Zn.Initializing([]), this._resourceLoadingCts = this._register(new $e()), this._focusDelayer = this._register(new ig(50)), this._onDidHtmlChange = this._register(new w()), this.onDidHtmlChange = this._onDidHtmlChange.event, this._messageHandlers = /* @__PURE__ */ new Map(), this.checkImeCompletionState = !0, this._disposed = !1, this._onMissingCsp = this._register(new w()), this.onMissingCsp = this._onMissingCsp.event, this._onDidClickLink = this._register(new w()), this.onDidClickLink = this._onDidClickLink.event, this._onDidReload = this._register(new w()), this.onDidReload = this._onDidReload.event, this._onMessage = this._register(new w()), this.onMessage = this._onMessage.event, this._onDidScroll = this._register(new w()), this.onDidScroll = this._onDidScroll.event, this._onDidWheel = this._register(new w()), this.onDidWheel = this._onDidWheel.event, this._onDidUpdateState = this._register(new w()), this.onDidUpdateState = this._onDidUpdateState.event, this._onDidFocus = this._register(new w()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new w()), this.onDidBlur = this._onDidBlur.event, this._onFatalError = this._register(new w()), this.onFatalError = this._onFatalError.event, this._onDidDispose = this._register(new w()), this.onDidDispose = this._onDidDispose.event, this._hasAlertedAboutMissingCsp = !1, this._hasFindResult = this._register(new w()), this.hasFindResult = this._hasFindResult.event, this._onDidStopFind = this._register(new w()), this.onDidStopFind = this._onDidStopFind.event, this.providedViewType = e.providedViewType, this.origin = e.origin ?? this.id, this._encodedWebviewOriginPromise = Rv(window.origin, this.origin).then((b) => this._encodedWebviewOrigin = b), this._options = e.options, this.extension = e.extension, this._content = {
      html: "",
      title: e.title,
      options: e.contentOptions,
      state: void 0
    }, this._portMappingManager = this._register(new Ok(
      () => {
        var b;
        return (b = this.extension) == null ? void 0 : b.location;
      },
      () => this._content.options.portMapping || [],
      this._tunnelService
    )), this._element = this._createElement(e.options, e.contentOptions);
    const C = this._register(S(window, "message", (b) => {
      var v, J;
      if (!(!this._encodedWebviewOrigin || ((v = b == null ? void 0 : b.data) == null ? void 0 : v.target) !== this.id) && b.data.channel === "webview-ready") {
        if (this._messagePort)
          return;
        this._logService.debug(`Webview(${this.id}): webview ready`), this._messagePort = b.ports[0], this._messagePort.onmessage = (R) => {
          const O = this._messageHandlers.get(R.data.channel);
          if (!O) {
            console.log(`No handlers found for '${R.data.channel}'`);
            return;
          }
          O == null || O.forEach((Je) => Je(R.data.data, R));
        }, (J = this.element) == null || J.classList.add("ready"), this._state.type === 0 && this._state.pendingMessages.forEach(({ channel: R, data: O }) => this.doPostMessage(R, O)), this._state = Zn.Ready, C.dispose();
      }
    }));
    this._register(this.on("no-csp-found", () => {
      this.handleNoCspFound();
    })), this._register(this.on("did-click-link", ({ uri: b }) => {
      this._onDidClickLink.fire(b);
    })), this._register(this.on("onmessage", ({ message: b, transfer: v }) => {
      this._onMessage.fire({ message: b, transfer: v });
    })), this._register(this.on("did-scroll", ({ scrollYPercentage: b }) => {
      this._onDidScroll.fire({ scrollYPercentage: b });
    })), this._register(this.on("do-reload", () => {
      this.reload();
    })), this._register(this.on("do-update-state", (b) => {
      this.state = b, this._onDidUpdateState.fire(b);
    })), this._register(this.on("did-focus", () => {
      this.handleFocusChange(!0);
    })), this._register(this.on("did-blur", () => {
      this.handleFocusChange(!1);
    })), this._register(this.on("did-scroll-wheel", (b) => {
      this._onDidWheel.fire(b);
    })), this._register(this.on("did-find", ({ didFind: b }) => {
      this._hasFindResult.fire(b);
    })), this._register(this.on("fatal-error", (b) => {
      s.error(u("fatalErrorMessage", "Error loading webview: {0}", b.message)), this._onFatalError.fire({ message: b.message });
    })), this._register(this.on("did-keydown", (b) => {
      this.handleKeyEvent("keydown", b);
    })), this._register(this.on("did-keyup", (b) => {
      this.handleKeyEvent("keyup", b);
    })), this._register(this.on("did-context-menu", (b) => {
      if (!this.element || !this._contextKeyService)
        return;
      const v = this.element.getBoundingClientRect(), J = this._contextKeyService.createOverlay([
        ...Object.entries(b.context),
        [aS, this.providedViewType]
      ]);
      o.showContextMenu({
        menuId: k.WebviewContext,
        menuActionOptions: { shouldForwardArgs: !0 },
        contextKeyService: J,
        getActionsContext: () => ({ ...b.context, webview: this.providedViewType }),
        getAnchor: () => ({
          x: v.x + b.clientX,
          y: v.y + b.clientY
        })
      });
    })), this._register(this.on("load-resource", async (b) => {
      try {
        const v = Gv(b.authority), J = A.from({
          scheme: b.scheme,
          authority: v,
          path: decodeURIComponent(b.path),
          query: b.query ? decodeURIComponent(b.query) : b.query
        });
        this.loadResource(b.id, J, b.ifNoneMatch);
      } catch {
        this._send("did-load-resource", {
          id: b.id,
          status: 404,
          path: b.path
        });
      }
    })), this._register(this.on("load-localhost", (b) => {
      this.localLocalhost(b.id, b.origin);
    })), this._register(_.runAndSubscribe(t.onThemeDataChanged, () => this.style())), this._register(m.onDidChangeReducedMotion(() => this.style())), this._register(m.onDidChangeScreenReaderOptimized(() => this.style())), this._register(o.onDidShowContextMenu(() => this._send("set-context-menu-visible", { visible: !0 }))), this._register(o.onDidHideContextMenu(() => this._send("set-context-menu-visible", { visible: !1 }))), this._confirmBeforeClose = i.getValue("window.confirmBeforeClose"), this._register(i.onDidChangeConfiguration((b) => {
      b.affectsConfiguration("window.confirmBeforeClose") && (this._confirmBeforeClose = i.getValue("window.confirmBeforeClose"), this._send("set-confirm-before-close", this._confirmBeforeClose));
    })), this._register(this.on("drag-start", () => {
      this._startBlockingIframeDragEvents();
    })), e.options.enableFindWidget && (this._webviewFindWidget = this._register(p.createInstance(Ic, this))), this._encodedWebviewOriginPromise.then((b) => {
      this._disposed || this._initElement(b, this.extension, this._options);
    });
  }
  dispose() {
    var e;
    if (this._disposed = !0, (e = this.element) == null || e.remove(), this._element = void 0, this._messagePort = void 0, this._state.type === 0) {
      for (const t of this._state.pendingMessages)
        t.resolve(!1);
      this._state.pendingMessages = [];
    }
    this._onDidDispose.fire(), this._resourceLoadingCts.dispose(!0), super.dispose();
  }
  setContextKeyService(e) {
    this._contextKeyService = e;
  }
  postMessage(e, t) {
    return this._send("message", { message: e, transfer: t });
  }
  async _send(e, t, i = []) {
    if (this._state.type === 0) {
      let o;
      const s = new Promise((n) => o = n);
      return this._state.pendingMessages.push({ channel: e, data: t, transferable: i, resolve: o }), s;
    } else
      return this.doPostMessage(e, t, i);
  }
  _createElement(e, t) {
    const i = document.createElement("iframe");
    i.name = this.id, i.className = `webview ${e.customClasses || ""}`, i.sandbox.add("allow-scripts", "allow-same-origin", "allow-forms", "allow-pointer-lock", "allow-downloads");
    const o = ["cross-origin-isolated", "autoplay"];
    return Dr || o.push("clipboard-read", "clipboard-write"), i.setAttribute("allow", o.join("; ")), i.style.border = "none", i.style.width = "100%", i.style.height = "100%", i.focus = () => {
      this._doFocus();
    }, i;
  }
  _initElement(e, t, i) {
    const o = {
      id: this.id,
      origin: this.origin,
      swVersion: String(this._expectedServiceWorkerVersion),
      extensionId: (t == null ? void 0 : t.id.value) ?? "",
      platform: this.platform,
      "vscode-resource-base-authority": xv,
      parentOrigin: window.origin
    };
    this._options.disableServiceWorker && (o.disableServiceWorker = "true"), this._environmentService.remoteAuthority && (o.remoteAuthority = this._environmentService.remoteAuthority), i.purpose && (o.purpose = i.purpose), o.serviceWorkerUri = vr.asBrowserUri("vs/workbench/contrib/webview/browser/pre/service-worker.js").toString(!0), o.fakeHtmlUri = vr.asBrowserUri("vs/workbench/contrib/webview/browser/pre/fake.html").toString(!0), Dv.addSearchParam(o, !0, !0);
    const s = new URLSearchParams(o).toString(), n = Dr ? "index-no-csp.html" : "index.html", r = vr.asBrowserUri(`vs/workbench/contrib/webview/browser/pre/${n}`);
    this.element.setAttribute("src", `${r.toString(!0)}?${s}`);
  }
  mountTo(e) {
    if (this.element) {
      this._webviewFindWidget && e.appendChild(this._webviewFindWidget.getDomNode());
      for (const t of [I.MOUSE_DOWN, I.MOUSE_MOVE, I.DROP])
        this._register(S(e, t, () => {
          this._stopBlockingIframeDragEvents();
        }));
      for (const t of [e, window])
        this._register(S(t, I.DRAG_END, () => {
          this._stopBlockingIframeDragEvents();
        }));
      e.id = this.id, e.appendChild(this.element);
    }
  }
  _startBlockingIframeDragEvents() {
    this.element && (this.element.style.pointerEvents = "none");
  }
  _stopBlockingIframeDragEvents() {
    this.element && (this.element.style.pointerEvents = "auto");
  }
  webviewContentEndpoint(e) {
    const t = this._environmentService.webviewExternalEndpoint;
    if (!t)
      throw new Error("'webviewExternalEndpoint' has not been configured. Webviews will not work!");
    const i = t.replace("{{uuid}}", e);
    return i[i.length - 1] === "/" ? i.slice(0, i.length - 1) : i;
  }
  doPostMessage(e, t, i = []) {
    return this.element && this._messagePort ? (this._messagePort.postMessage({ channel: e, args: t }, i), !0) : !1;
  }
  on(e, t) {
    let i = this._messageHandlers.get(e);
    return i || (i = /* @__PURE__ */ new Set(), this._messageHandlers.set(e, i)), i.add(t), M(() => {
      var o;
      (o = this._messageHandlers.get(e)) == null || o.delete(t);
    });
  }
  handleNoCspFound() {
    var e;
    if (!this._hasAlertedAboutMissingCsp && (this._hasAlertedAboutMissingCsp = !0, (e = this.extension) != null && e.id)) {
      this._environmentService.isExtensionDevelopment && this._onMissingCsp.fire(this.extension.id);
      const t = {
        extension: this.extension.id.value
      };
      this._telemetryService.publicLog2("webviewMissingCsp", t);
    }
  }
  reload() {
    this.doUpdateContent(this._content);
    const e = this._register(this.on("did-load", () => {
      this._onDidReload.fire(), e.dispose();
    }));
  }
  setHtml(e) {
    this.doUpdateContent({ ...this._content, html: e }), this._onDidHtmlChange.fire(e);
  }
  setTitle(e) {
    this._content = { ...this._content, title: e }, this._send("set-title", e);
  }
  set contentOptions(e) {
    if (this._logService.debug(`Webview(${this.id}): will update content options`), Nv(e, this._content.options)) {
      this._logService.debug(`Webview(${this.id}): skipping content options update`);
      return;
    }
    this.doUpdateContent({ ...this._content, options: e });
  }
  set localResourcesRoot(e) {
    this._content = {
      ...this._content,
      options: { ...this._content.options, localResourceRoots: e }
    };
  }
  set state(e) {
    this._content = { ...this._content, state: e };
  }
  set initialScrollProgress(e) {
    this._send("initial-scroll-position", e);
  }
  doUpdateContent(e) {
    this._logService.debug(`Webview(${this.id}): will update content`), this._content = e;
    const t = !!this._content.options.allowScripts;
    this._send("content", {
      contents: this._content.html,
      title: this._content.title,
      options: {
        allowMultipleAPIAcquire: !!this._content.options.allowMultipleAPIAcquire,
        allowScripts: t,
        allowForms: this._content.options.allowForms ?? t
      },
      state: this._content.state,
      cspSource: Qv,
      confirmBeforeClose: this._confirmBeforeClose
    });
  }
  style() {
    let { styles: e, activeTheme: t, themeLabel: i, themeId: o } = this.webviewThemeDataProvider.getWebviewThemeData();
    this._options.transformCssVariables && (e = this._options.transformCssVariables(e));
    const s = this._accessibilityService.isMotionReduced(), n = this._accessibilityService.isScreenReaderOptimized();
    this._send("styles", { styles: e, activeTheme: t, themeId: o, themeLabel: i, reduceMotion: s, screenReader: n });
  }
  handleFocusChange(e) {
    this._focused = e, e ? this._onDidFocus.fire() : this._onDidBlur.fire();
  }
  handleKeyEvent(e, t) {
    const i = new KeyboardEvent(e, t);
    Object.defineProperty(i, "target", {
      get: () => this.element
    }), window.dispatchEvent(i);
  }
  windowDidDragStart() {
    this._startBlockingIframeDragEvents();
  }
  windowDidDragEnd() {
    this._stopBlockingIframeDragEvents();
  }
  selectAll() {
    this.execCommand("selectAll");
  }
  copy() {
    this.execCommand("copy");
  }
  paste() {
    this.execCommand("paste");
  }
  cut() {
    this.execCommand("cut");
  }
  undo() {
    this.execCommand("undo");
  }
  redo() {
    this.execCommand("redo");
  }
  execCommand(e) {
    this.element && this._send("execCommand", e);
  }
  async loadResource(e, t, i) {
    try {
      const o = await Mk(t, {
        ifNoneMatch: i,
        roots: this._content.options.localResourceRoots || []
      }, this._fileService, this._logService, this._resourceLoadingCts.token);
      switch (o.type) {
        case Ot.Type.Success: {
          const s = await this.streamToBuffer(o.stream);
          return this._send("did-load-resource", {
            id: e,
            status: 200,
            path: t.path,
            mime: o.mimeType,
            data: s,
            etag: o.etag,
            mtime: o.mtime
          }, [s]);
        }
        case Ot.Type.NotModified:
          return this._send("did-load-resource", {
            id: e,
            status: 304,
            path: t.path,
            mime: o.mimeType,
            mtime: o.mtime
          });
        case Ot.Type.AccessDenied:
          return this._send("did-load-resource", {
            id: e,
            status: 401,
            path: t.path
          });
      }
    } catch {
    }
    return this._send("did-load-resource", {
      id: e,
      status: 404,
      path: t.path
    });
  }
  async streamToBuffer(e) {
    return (await Av(e)).buffer.buffer;
  }
  async localLocalhost(e, t) {
    const i = this._environmentService.remoteAuthority, o = i ? await this._remoteAuthorityResolverService.resolveAuthority(i) : void 0, s = o ? await this._portMappingManager.getRedirect(o.authority, t) : void 0;
    return this._send("did-load-localhost", {
      id: e,
      origin: t,
      location: s
    });
  }
  focus() {
    this._doFocus(), this.handleFocusChange(!0);
  }
  _doFocus() {
    var e;
    if (this.element) {
      try {
        (e = this.element.contentWindow) == null || e.focus();
      } catch {
      }
      this._focusDelayer.trigger(async () => {
        var t;
        !this.isFocused || !this.element || document.activeElement && document.activeElement !== this.element && ((t = document.activeElement) == null ? void 0 : t.tagName) !== "BODY" || this._send("focus", void 0);
      });
    }
  }
  find(e, t) {
    this.element && this._send("find", { value: e, previous: t });
  }
  updateFind(e) {
    !e || !this.element || this._send("find", { value: e });
  }
  stopFind(e) {
    this.element && (this._send("find-stop", { clearSelection: !e }), this._onDidStopFind.fire());
  }
  showFind(e = !0) {
    var t;
    (t = this._webviewFindWidget) == null || t.reveal(void 0, e);
  }
  hideFind(e = !0) {
    var t;
    (t = this._webviewFindWidget) == null || t.hide(e);
  }
  runFindAction(e) {
    var t;
    (t = this._webviewFindWidget) == null || t.find(e);
  }
};
Jc = y([
  l(2, x),
  l(3, Ie),
  l(4, We),
  l(5, Tt),
  l(6, _e),
  l(7, rt),
  l(8, _v),
  l(9, Xe),
  l(10, Ev),
  l(11, W),
  l(12, Pc)
], Jc);
let Vc = class extends E {
  constructor(e, t, i, o) {
    super(), this._layoutService = t, this._webviewService = i, this._baseContextKeyService = o, this._isFirstLoad = !0, this._firstLoadPendingMessages = /* @__PURE__ */ new Set(), this._webview = this._register(new Re()), this._webviewEvents = this._register(new Z()), this._html = "", this._initialScrollProgress = 0, this._state = void 0, this._owner = void 0, this._scopedContextKeyService = this._register(new Re()), this._shouldShowFindWidgetOnRestore = !1, this._isDisposed = !1, this._onDidDispose = this._register(new w()), this.onDidDispose = this._onDidDispose.event, this._onDidFocus = this._register(new w()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new w()), this.onDidBlur = this._onDidBlur.event, this._onDidClickLink = this._register(new w()), this.onDidClickLink = this._onDidClickLink.event, this._onDidReload = this._register(new w()), this.onDidReload = this._onDidReload.event, this._onDidScroll = this._register(new w()), this.onDidScroll = this._onDidScroll.event, this._onDidUpdateState = this._register(new w()), this.onDidUpdateState = this._onDidUpdateState.event, this._onMessage = this._register(new w()), this.onMessage = this._onMessage.event, this._onMissingCsp = this._register(new w()), this.onMissingCsp = this._onMissingCsp.event, this._onDidWheel = this._register(new w()), this.onDidWheel = this._onDidWheel.event, this._onFatalError = this._register(new w()), this.onFatalError = this._onFatalError.event, this.providedViewType = e.providedViewType, this.origin = e.origin ?? An(), this._title = e.title, this._extension = e.extension, this._options = e.options, this._contentOptions = e.contentOptions;
  }
  get isFocused() {
    var e;
    return !!((e = this._webview.value) != null && e.isFocused);
  }
  dispose() {
    var e;
    this._isDisposed = !0, (e = this._container) == null || e.domNode.remove(), this._container = void 0;
    for (const t of this._firstLoadPendingMessages)
      t.resolve(!1);
    this._firstLoadPendingMessages.clear(), this._onDidDispose.fire(), super.dispose();
  }
  get container() {
    if (this._isDisposed)
      throw new Error("OverlayWebview has been disposed");
    if (!this._container) {
      const e = document.createElement("div");
      e.style.position = "absolute", e.style.overflow = "hidden", this._container = new Bv(e), this._container.setVisibility("hidden"), this._layoutService.container.appendChild(e);
    }
    return this._container.domNode;
  }
  claim(e, t) {
    var o, s, n, r;
    if (this._isDisposed)
      return;
    const i = this._owner;
    if (this._owner = e, this._show(), i !== e) {
      const a = t || this._baseContextKeyService;
      this._scopedContextKeyService.clear(), this._scopedContextKeyService.value = a.createScoped(this.container);
      const d = (o = this._findWidgetVisible) == null ? void 0 : o.get();
      (s = this._findWidgetVisible) == null || s.reset(), this._findWidgetVisible = tg.bindTo(a), this._findWidgetVisible.set(!!d), (n = this._findWidgetEnabled) == null || n.reset(), this._findWidgetEnabled = eg.bindTo(a), this._findWidgetEnabled.set(!!this.options.enableFindWidget), (r = this._webview.value) == null || r.setContextKeyService(this._scopedContextKeyService.value);
    }
  }
  release(e) {
    var t;
    this._owner === e && (this._scopedContextKeyService.clear(), this._owner = void 0, this._container && this._container.setVisibility("hidden"), this._options.retainContextWhenHidden ? (this._shouldShowFindWidgetOnRestore = !!((t = this._findWidgetVisible) != null && t.get()), this.hideFind(!1)) : (this._webview.clear(), this._webviewEvents.clear()));
  }
  layoutWebviewOverElement(e, t, i) {
    if (!this._container || !this._container.domNode.parentElement)
      return;
    const o = e.getBoundingClientRect(), s = this._container.domNode.parentElement.getBoundingClientRect(), n = (s.height - this._container.domNode.parentElement.clientHeight) / 2, r = (s.width - this._container.domNode.parentElement.clientWidth) / 2;
    if (this._container.setTop(o.top - s.top - n), this._container.setLeft(o.left - s.left - r), this._container.setWidth(t ? t.width : o.width), this._container.setHeight(t ? t.height : o.height), i) {
      const { top: a, left: d, right: h, bottom: g } = cS(o, i);
      this._container.domNode.style.clipPath = `polygon(${d}px ${a}px, ${h}px ${a}px, ${h}px ${g}px, ${d}px ${g}px)`;
    }
  }
  _show() {
    var e, t;
    if (this._isDisposed)
      throw new Error("OverlayWebview is disposed");
    if (!this._webview.value) {
      const i = this._webviewService.createWebviewElement({
        providedViewType: this.providedViewType,
        origin: this.origin,
        title: this._title,
        options: this._options,
        contentOptions: this._contentOptions,
        extension: this.extension
      });
      this._webview.value = i, i.state = this._state, this._scopedContextKeyService.value && this._webview.value.setContextKeyService(this._scopedContextKeyService.value), this._html && i.setHtml(this._html), this._options.tryRestoreScrollPosition && (i.initialScrollProgress = this._initialScrollProgress), (e = this._findWidgetEnabled) == null || e.set(!!this.options.enableFindWidget), i.mountTo(this.container), this._webviewEvents.clear(), this._webviewEvents.add(i.onDidFocus(() => {
        this._onDidFocus.fire();
      })), this._webviewEvents.add(i.onDidBlur(() => {
        this._onDidBlur.fire();
      })), this._webviewEvents.add(i.onDidClickLink((o) => {
        this._onDidClickLink.fire(o);
      })), this._webviewEvents.add(i.onMessage((o) => {
        this._onMessage.fire(o);
      })), this._webviewEvents.add(i.onMissingCsp((o) => {
        this._onMissingCsp.fire(o);
      })), this._webviewEvents.add(i.onDidWheel((o) => {
        this._onDidWheel.fire(o);
      })), this._webviewEvents.add(i.onDidReload(() => {
        this._onDidReload.fire();
      })), this._webviewEvents.add(i.onFatalError((o) => {
        this._onFatalError.fire(o);
      })), this._webviewEvents.add(i.onDidScroll((o) => {
        this._initialScrollProgress = o.scrollYPercentage, this._onDidScroll.fire(o);
      })), this._webviewEvents.add(i.onDidUpdateState((o) => {
        this._state = o, this._onDidUpdateState.fire(o);
      })), this._isFirstLoad && this._firstLoadPendingMessages.forEach(async (o) => {
        o.resolve(await i.postMessage(o.message, o.transfer));
      }), this._isFirstLoad = !1, this._firstLoadPendingMessages.clear();
    }
    this.options.retainContextWhenHidden && this._shouldShowFindWidgetOnRestore && (this.showFind(!1), this._shouldShowFindWidgetOnRestore = !1), (t = this._container) == null || t.setVisibility("visible");
  }
  setHtml(e) {
    this._html = e, this._withWebview((t) => t.setHtml(e));
  }
  setTitle(e) {
    this._title = e, this._withWebview((t) => t.setTitle(e));
  }
  get initialScrollProgress() {
    return this._initialScrollProgress;
  }
  set initialScrollProgress(e) {
    this._initialScrollProgress = e, this._withWebview((t) => t.initialScrollProgress = e);
  }
  get state() {
    return this._state;
  }
  set state(e) {
    this._state = e, this._withWebview((t) => t.state = e);
  }
  get extension() {
    return this._extension;
  }
  set extension(e) {
    this._extension = e, this._withWebview((t) => t.extension = e);
  }
  get options() {
    return this._options;
  }
  set options(e) {
    this._options = { customClasses: this._options.customClasses, ...e };
  }
  get contentOptions() {
    return this._contentOptions;
  }
  set contentOptions(e) {
    this._contentOptions = e, this._withWebview((t) => t.contentOptions = e);
  }
  set localResourcesRoot(e) {
    this._withWebview((t) => t.localResourcesRoot = e);
  }
  async postMessage(e, t) {
    if (this._webview.value)
      return this._webview.value.postMessage(e, t);
    if (this._isFirstLoad) {
      let i;
      const o = new Promise((s) => i = s);
      return this._firstLoadPendingMessages.add({ message: e, transfer: t, resolve: i }), o;
    }
    return !1;
  }
  focus() {
    var e;
    (e = this._webview.value) == null || e.focus();
  }
  reload() {
    var e;
    (e = this._webview.value) == null || e.reload();
  }
  selectAll() {
    var e;
    (e = this._webview.value) == null || e.selectAll();
  }
  copy() {
    var e;
    (e = this._webview.value) == null || e.copy();
  }
  paste() {
    var e;
    (e = this._webview.value) == null || e.paste();
  }
  cut() {
    var e;
    (e = this._webview.value) == null || e.cut();
  }
  undo() {
    var e;
    (e = this._webview.value) == null || e.undo();
  }
  redo() {
    var e;
    (e = this._webview.value) == null || e.redo();
  }
  showFind(e = !0) {
    var t;
    this._webview.value && (this._webview.value.showFind(e), (t = this._findWidgetVisible) == null || t.set(!0));
  }
  hideFind(e = !0) {
    var t, i;
    (t = this._findWidgetVisible) == null || t.reset(), (i = this._webview.value) == null || i.hideFind(e);
  }
  runFindAction(e) {
    var t;
    (t = this._webview.value) == null || t.runFindAction(e);
  }
  _withWebview(e) {
    this._webview.value && e(this._webview.value);
  }
  windowDidDragStart() {
    var e;
    (e = this._webview.value) == null || e.windowDidDragStart();
  }
  windowDidDragEnd() {
    var e;
    (e = this._webview.value) == null || e.windowDidDragEnd();
  }
  setContextKeyService(e) {
    var t;
    (t = this._webview.value) == null || t.setContextKeyService(e);
  }
};
Vc = y([
  l(1, Vd),
  l(2, As),
  l(3, F)
], Vc);
function cS(c, e) {
  const t = e.getBoundingClientRect(), i = Math.max(t.top - c.top, 0), o = Math.max(c.width - (c.right - t.right), 0), s = Math.max(c.height - (c.bottom - t.bottom), 0), n = Math.max(t.left - c.left, 0);
  return { top: i, right: o, bottom: s, left: n };
}
let Zc = class extends E {
  constructor(e) {
    super(), this._instantiationService = e, this._webviews = /* @__PURE__ */ new Set(), this._onDidChangeActiveWebview = this._register(new w()), this.onDidChangeActiveWebview = this._onDidChangeActiveWebview.event, this._webviewThemeDataProvider = this._instantiationService.createInstance(Sc);
  }
  get activeWebview() {
    return this._activeWebview;
  }
  _updateActiveWebview(e) {
    e !== this._activeWebview && (this._activeWebview = e, this._onDidChangeActiveWebview.fire(e));
  }
  get webviews() {
    return this._webviews.values();
  }
  createWebviewElement(e) {
    const t = this._instantiationService.createInstance(Jc, e, this._webviewThemeDataProvider);
    return this.registerNewWebview(t), t;
  }
  createWebviewOverlay(e) {
    const t = this._instantiationService.createInstance(Vc, e);
    return this.registerNewWebview(t), t;
  }
  registerNewWebview(e) {
    this._webviews.add(e), e.onDidFocus(() => {
      this._updateActiveWebview(e);
    });
    const t = () => {
      this._activeWebview === e && this._updateActiveWebview(void 0);
    };
    e.onDidBlur(t), e.onDidDispose(() => {
      t(), this._webviews.delete(e);
    });
  }
};
Zc = y([
  l(0, W)
], Zc);
class Cs {
  constructor() {
    this.uris = [];
  }
  async perform() {
    return this;
  }
  toString() {
    return "(noop)";
  }
}
class ap {
  constructor(e, t, i) {
    this.newUri = e, this.oldUri = t, this.options = i, this.type = "rename";
  }
}
let Wc = class cp {
  constructor(e, t, i, o) {
    this._edits = e, this._undoRedoInfo = t, this._workingCopyFileService = i, this._fileService = o;
  }
  get uris() {
    return this._edits.map((e) => [e.newUri, e.oldUri]).flat();
  }
  async perform(e) {
    const t = [], i = [];
    for (const o of this._edits)
      o.options.overwrite === void 0 && o.options.ignoreIfExists && await this._fileService.exists(o.newUri) || (t.push({
        file: { source: o.oldUri, target: o.newUri },
        overwrite: o.options.overwrite
      }), i.push(new ap(o.oldUri, o.newUri, o.options)));
    return t.length === 0 ? new Cs() : (await this._workingCopyFileService.move(t, e, this._undoRedoInfo), new cp(
      i,
      { isUndoing: !0 },
      this._workingCopyFileService,
      this._fileService
    ));
  }
  toString() {
    return `(rename ${this._edits.map((e) => `${e.oldUri} to ${e.newUri}`).join(", ")})`;
  }
};
Wc = y([
  l(2, $n),
  l(3, _e)
], Wc);
class dS {
  constructor(e, t, i) {
    this.newUri = e, this.oldUri = t, this.options = i, this.type = "copy";
  }
}
let _c = class {
  constructor(e, t, i, o, s) {
    this._edits = e, this._undoRedoInfo = t, this._workingCopyFileService = i, this._fileService = o, this._instaService = s;
  }
  get uris() {
    return this._edits.map((e) => [e.newUri, e.oldUri]).flat();
  }
  async perform(e) {
    const t = [];
    for (const s of this._edits)
      s.options.overwrite === void 0 && s.options.ignoreIfExists && await this._fileService.exists(s.newUri) || t.push({ file: { source: s.oldUri, target: s.newUri }, overwrite: s.options.overwrite });
    if (t.length === 0)
      return new Cs();
    const i = await this._workingCopyFileService.copy(t, e, this._undoRedoInfo), o = [];
    for (let s = 0; s < i.length; s++) {
      const n = i[s], r = this._edits[s];
      o.push(new Kd(
        n.resource,
        { recursive: !0, folder: this._edits[s].options.folder || n.isDirectory, ...r.options },
        !1
      ));
    }
    return this._instaService.createInstance(fs, o, { isUndoing: !0 });
  }
  toString() {
    return `(copy ${this._edits.map((e) => `${e.oldUri} to ${e.newUri}`).join(", ")})`;
  }
};
_c = y([
  l(2, $n),
  l(3, _e),
  l(4, W)
], _c);
class dp {
  constructor(e, t, i) {
    this.newUri = e, this.options = t, this.contents = i, this.type = "create";
  }
}
let Wn = class {
  constructor(e, t, i, o, s, n) {
    this._edits = e, this._undoRedoInfo = t, this._fileService = i, this._workingCopyFileService = o, this._instaService = s, this._textFileService = n;
  }
  get uris() {
    return this._edits.map((e) => e.newUri);
  }
  async perform(e) {
    const t = [], i = [], o = [];
    for (const s of this._edits)
      if (!(s.options.overwrite === void 0 && s.options.ignoreIfExists && await this._fileService.exists(s.newUri))) {
        if (s.options.folder)
          t.push({ resource: s.newUri });
        else {
          const n = typeof s.contents < "u" ? s.contents : await this._textFileService.getEncodedReadable(s.newUri);
          i.push({ resource: s.newUri, contents: n, overwrite: s.options.overwrite });
        }
        o.push(new Kd(s.newUri, s.options, !s.options.folder && !s.contents));
      }
    return t.length === 0 && i.length === 0 ? new Cs() : (await this._workingCopyFileService.createFolder(t, e, this._undoRedoInfo), await this._workingCopyFileService.create(i, e, this._undoRedoInfo), this._instaService.createInstance(fs, o, { isUndoing: !0 }));
  }
  toString() {
    return `(create ${this._edits.map(
      (e) => {
        var t;
        return e.options.folder ? `folder ${e.newUri}` : `file ${e.newUri} with ${((t = e.contents) == null ? void 0 : t.byteLength) || 0} bytes`;
      }
    ).join(", ")})`;
  }
};
Wn = y([
  l(2, _e),
  l(3, $n),
  l(4, W),
  l(5, Qo)
], Wn);
class Kd {
  constructor(e, t, i) {
    this.oldUri = e, this.options = t, this.undoesCreate = i, this.type = "delete";
  }
}
let fs = class {
  constructor(e, t, i, o, s, n, r) {
    this._edits = e, this._undoRedoInfo = t, this._workingCopyFileService = i, this._fileService = o, this._configurationService = s, this._instaService = n, this._logService = r;
  }
  get uris() {
    return this._edits.map((e) => e.oldUri);
  }
  async perform(e) {
    const t = [], i = [];
    for (const o of this._edits) {
      let s;
      try {
        s = await this._fileService.resolve(o.oldUri, { resolveMetadata: !0 });
      } catch {
        if (!o.options.ignoreIfNotExists)
          throw new Error(`${o.oldUri} does not exist and can not be deleted`);
        continue;
      }
      t.push({
        resource: o.oldUri,
        recursive: o.options.recursive,
        useTrash: !o.options.skipTrashBin && this._fileService.hasCapability(o.oldUri, 4096) && this._configurationService.getValue("files.enableTrash")
      });
      let n;
      if (!o.undoesCreate && !o.options.folder && !(typeof o.options.maxSize == "number" && s.size > o.options.maxSize))
        try {
          n = await this._fileService.readFile(o.oldUri);
        } catch (r) {
          this._logService.error(r);
        }
      n !== void 0 && i.push(new dp(o.oldUri, o.options, n.value));
    }
    return t.length === 0 ? new Cs() : (await this._workingCopyFileService.delete(t, e, this._undoRedoInfo), i.length === 0 ? new Cs() : this._instaService.createInstance(Wn, i, { isUndoing: !0 }));
  }
  toString() {
    return `(delete ${this._edits.map((e) => e.oldUri).join(", ")})`;
  }
};
fs = y([
  l(2, $n),
  l(3, _e),
  l(4, x),
  l(5, W),
  l(6, rt)
], fs);
class lS {
  constructor(e, t, i, o) {
    this.label = e, this.code = t, this.operations = i, this.confirmBeforeUndo = o, this.type = 1, this.resources = i.map((s) => s.uris).flat();
  }
  async undo() {
    await this._reverse();
  }
  async redo() {
    await this._reverse();
  }
  async _reverse() {
    for (let e = 0; e < this.operations.length; e++) {
      const i = await this.operations[e].perform(Ni.None);
      this.operations[e] = i;
    }
  }
  toString() {
    return this.operations.map((e) => String(e)).join(", ");
  }
}
let Ec = class {
  constructor(e, t, i, o, s, n, r, a, d, h) {
    this._label = e, this._code = t, this._undoRedoGroup = i, this._undoRedoSource = o, this._confirmBeforeUndo = s, this._progress = n, this._token = r, this._edits = a, this._instaService = d, this._undoRedoService = h;
  }
  async apply() {
    var n, r;
    const e = [], t = { undoRedoGroupId: this._undoRedoGroup.id }, i = [];
    for (const a of this._edits)
      a.newResource && a.oldResource && !((n = a.options) != null && n.copy) ? i.push(new ap(a.newResource, a.oldResource, a.options ?? {})) : a.newResource && a.oldResource && ((r = a.options) != null && r.copy) ? i.push(new dS(a.newResource, a.oldResource, a.options ?? {})) : !a.newResource && a.oldResource ? i.push(new Kd(a.oldResource, a.options ?? {}, !1)) : a.newResource && !a.oldResource && i.push(new dp(a.newResource, a.options ?? {}, await a.options.contents));
    if (i.length === 0)
      return [];
    const o = [];
    o[0] = [i[0]];
    for (let a = 1; a < i.length; a++) {
      const d = i[a], h = Eh(o);
      h[0].type === d.type ? h.push(d) : o.push([d]);
    }
    for (const a of o) {
      if (this._token.isCancellationRequested)
        break;
      let d;
      switch (a[0].type) {
        case "rename":
          d = this._instaService.createInstance(Wc, a, t);
          break;
        case "copy":
          d = this._instaService.createInstance(_c, a, t);
          break;
        case "delete":
          d = this._instaService.createInstance(fs, a, t);
          break;
        case "create":
          d = this._instaService.createInstance(Wn, a, t);
          break;
      }
      if (d) {
        const h = await d.perform(this._token);
        e.push(h);
      }
      this._progress.report(void 0);
    }
    const s = new lS(this._label, this._code, e, this._confirmBeforeUndo);
    return this._undoRedoService.pushElement(s, this._undoRedoGroup, this._undoRedoSource), s.resources;
  }
};
Ec = y([
  l(8, W),
  l(9, qn)
], Ec);
class lp {
  constructor(e) {
    this._modelReference = e, this.model = this._modelReference.object.textEditorModel, this._edits = [];
  }
  dispose() {
    this._modelReference.dispose();
  }
  isNoOp() {
    return !(this._edits.length > 0 || this._newEol !== void 0 && this._newEol !== this.model.getEndOfLineSequence());
  }
  addEdit(e) {
    this._expectedModelVersionId = e.versionId;
    const { textEdit: t } = e;
    if (typeof t.eol == "number" && (this._newEol = t.eol), !t.range && !t.text || Fe.isEmpty(t.range) && !t.text)
      return;
    let i;
    t.range ? i = Fe.lift(t.range) : i = this.model.getFullModelRange(), this._edits.push({ ...Fv.replaceMove(i, t.text), insertAsSnippet: t.insertAsSnippet });
  }
  validate() {
    return typeof this._expectedModelVersionId > "u" || this.model.getVersionId() === this._expectedModelVersionId ? { canApply: !0 } : { canApply: !1, reason: this.model.uri };
  }
  getBeforeCursorState() {
    return null;
  }
  apply() {
    this._edits.length > 0 && (this._edits = this._edits.map(this._transformSnippetStringToInsertText, this).sort((e, t) => Fe.compareRangesUsingStarts(e.range, t.range)), this.model.pushEditOperations(null, this._edits, () => null)), this._newEol !== void 0 && this.model.pushEOL(this._newEol);
  }
  _transformSnippetStringToInsertText(e) {
    if (!e.insertAsSnippet || !e.text)
      return e;
    const t = hg.asInsertText(e.text);
    return { ...e, insertAsSnippet: !1, text: t };
  }
}
class hS extends lp {
  constructor(e, t) {
    super(e), this._editor = t;
  }
  getBeforeCursorState() {
    return this._canUseEditor() ? this._editor.getSelections() : null;
  }
  apply() {
    if (!this._canUseEditor()) {
      super.apply();
      return;
    }
    if (this._edits.length > 0) {
      const e = Xv.get(this._editor);
      if (e && this._edits.some((t) => t.insertAsSnippet)) {
        const t = [];
        for (const i of this._edits)
          i.range && i.text !== null && t.push({
            range: Fe.lift(i.range),
            template: i.insertAsSnippet ? i.text : hg.escape(i.text)
          });
        e.apply(t, { undoStopBefore: !1, undoStopAfter: !1 });
      } else
        this._edits = this._edits.map(this._transformSnippetStringToInsertText, this).sort((t, i) => Fe.compareRangesUsingStarts(t.range, i.range)), this._editor.executeEdits("", this._edits);
    }
    this._newEol !== void 0 && this._editor.hasModel() && this._editor.getModel().pushEOL(this._newEol);
  }
  _canUseEditor() {
    var e, t;
    return ((t = (e = this._editor) == null ? void 0 : e.getModel()) == null ? void 0 : t.uri.toString()) === this.model.uri.toString();
  }
}
let Rc = class {
  constructor(e, t, i, o, s, n, r, a, d, h, g, p) {
    this._label = e, this._code = t, this._editor = i, this._undoRedoGroup = o, this._undoRedoSource = s, this._progress = n, this._token = r, this._editorWorker = d, this._modelService = h, this._textModelResolverService = g, this._undoRedoService = p, this._edits = new Et();
    for (const m of a) {
      let C = this._edits.get(m.resource);
      C || (C = [], this._edits.set(m.resource, C)), C.push(m);
    }
  }
  _validateBeforePrepare() {
    for (const e of this._edits.values())
      for (const t of e)
        if (typeof t.versionId == "number") {
          const i = this._modelService.getModel(t.resource);
          if (i && i.getVersionId() !== t.versionId)
            throw new Error(`${i.uri.toString()} has changed in the meantime`);
        }
  }
  async _createEditsTasks() {
    const e = [], t = [];
    for (const [i, o] of this._edits) {
      const s = this._textModelResolverService.createModelReference(i).then(async (n) => {
        var d, h;
        let r, a = !1;
        ((h = (d = this._editor) == null ? void 0 : d.getModel()) == null ? void 0 : h.uri.toString()) === n.object.textEditorModel.uri.toString() ? (r = new hS(n, this._editor), a = !0) : r = new lp(n);
        for (const g of o)
          if (a && !g.textEdit.insertAsSnippet) {
            const p = await this._editorWorker.computeMoreMinimalEdits(g.resource, [g.textEdit]);
            if (!p)
              r.addEdit(g);
            else
              for (const m of p)
                r.addEdit(new as(g.resource, m, g.versionId, g.metadata));
          } else
            r.addEdit(g);
        e.push(r);
      });
      t.push(s);
    }
    return await Promise.all(t), e;
  }
  _validateTasks(e) {
    for (const t of e) {
      const i = t.validate();
      if (!i.canApply)
        return i;
    }
    return { canApply: !0 };
  }
  async apply() {
    this._validateBeforePrepare();
    const e = await this._createEditsTasks();
    try {
      if (this._token.isCancellationRequested)
        return [];
      const t = [], i = this._validateTasks(e);
      if (!i.canApply)
        throw new Error(`${i.reason.toString()} has changed in the meantime`);
      if (e.length === 1) {
        const o = e[0];
        if (!o.isNoOp()) {
          const s = new Rl(this._label, this._code, o.model, o.getBeforeCursorState());
          this._undoRedoService.pushElement(s, this._undoRedoGroup, this._undoRedoSource), o.apply(), s.close(), t.push(o.model.uri);
        }
        this._progress.report(void 0);
      } else {
        const o = new Lv(this._label, this._code, e.map((s) => new Rl(this._label, this._code, s.model, s.getBeforeCursorState())));
        this._undoRedoService.pushElement(o, this._undoRedoGroup, this._undoRedoSource);
        for (const s of e)
          s.apply(), this._progress.report(void 0), t.push(s.model.uri);
        o.close();
      }
      return t;
    } finally {
      le(e);
    }
  }
};
Rc = y([
  l(8, Tv),
  l(9, Ch),
  l(10, Do),
  l(11, qn)
], Rc);
function uS(c) {
  return c.map((e) => {
    if (as.is(e))
      return as.lift(e);
    if (dn.is(e))
      return dn.lift(e);
    if (zr.is(e))
      return zr.lift(e);
    throw new Error("Unsupported edit");
  });
}
let Gc = class {
  constructor(e, t, i, o, s, n, r, a, d, h, g) {
    this._label = e, this._code = t, this._editor = i, this._progress = o, this._token = s, this._edits = n, this._undoRedoGroup = r, this._undoRedoSource = a, this._confirmBeforeUndo = d, this._instaService = h, this._logService = g;
  }
  ariaMessage() {
    const e = new Et(), t = new Et();
    let i = 0;
    for (const o of this._edits)
      o instanceof as ? (i += 1, t.set(o.resource, !0)) : o instanceof dn && e.set(o.oldResource ?? o.newResource, !0);
    return this._edits.length === 0 ? u("summary.0", "Made no edits") : e.size === 0 ? i > 1 && t.size > 1 ? u(
      "summary.nm",
      "Made {0} text edits in {1} files",
      i,
      t.size
    ) : u("summary.n0", "Made {0} text edits in one file", i) : u(
      "summary.textFiles",
      "Made {0} text edits in {1} files, also created or deleted {2} files",
      i,
      t.size,
      e.size
    );
  }
  async perform() {
    if (this._edits.length === 0)
      return [];
    const e = [1];
    for (let n = 1; n < this._edits.length; n++)
      Object.getPrototypeOf(this._edits[n - 1]) === Object.getPrototypeOf(this._edits[n]) ? e[e.length - 1]++ : e.push(1);
    const t = this._edits.length > 1 ? 0 : void 0;
    this._progress.report({ increment: t, total: 100 });
    const i = { report: (n) => this._progress.report({ increment: 100 / this._edits.length }) }, o = [];
    let s = 0;
    for (const n of e) {
      if (this._token.isCancellationRequested)
        break;
      const r = this._edits.slice(s, s + n);
      r[0] instanceof dn ? o.push(await this._performFileEdits(r, this._undoRedoGroup, this._undoRedoSource, this._confirmBeforeUndo, i)) : r[0] instanceof as ? o.push(await this._performTextEdits(r, this._undoRedoGroup, this._undoRedoSource, i)) : r[0] instanceof zr ? o.push(await this._performCellEdits(r, this._undoRedoGroup, this._undoRedoSource, i)) : console.log("UNKNOWN EDIT"), s = s + n;
    }
    return o.flat();
  }
  async _performFileEdits(e, t, i, o, s) {
    return this._logService.debug("_performFileEdits", JSON.stringify(e)), await this._instaService.createInstance(Ec, this._label || u("workspaceEdit", "Workspace Edit"), this._code || "undoredo.workspaceEdit", t, i, o, s, this._token, e).apply();
  }
  async _performTextEdits(e, t, i, o) {
    return this._logService.debug("_performTextEdits", JSON.stringify(e)), await this._instaService.createInstance(Rc, this._label || u("workspaceEdit", "Workspace Edit"), this._code || "undoredo.workspaceEdit", this._editor, t, i, o, this._token, e).apply();
  }
  async _performCellEdits(e, t, i, o) {
    return this._logService.debug("_performCellEdits", JSON.stringify(e)), await this._instaService.createInstance(Kv, t, i, o, this._token, e).apply();
  }
};
Gc = y([
  l(9, W),
  l(10, rt)
], Gc);
let xc = class {
  constructor(e, t, i, o, s, n, r) {
    this._instaService = e, this._logService = t, this._editorService = i, this._lifecycleService = o, this._dialogService = s, this._workingCopyService = n, this._configService = r, this._activeUndoRedoGroups = new lg();
  }
  setPreviewHandler(e) {
    return this._previewHandler = e, M(() => {
      this._previewHandler === e && (this._previewHandler = void 0);
    });
  }
  hasPreviewHandler() {
    return !!this._previewHandler;
  }
  async apply(e, t) {
    let i = uS(Array.isArray(e) ? e : e.edits);
    if (i.length === 0)
      return { ariaSummary: u("nothing", "Made no edits"), isApplied: !1 };
    this._previewHandler && (t != null && t.showPreview || i.some((h) => {
      var g;
      return (g = h.metadata) == null ? void 0 : g.needsConfirmation;
    })) && (i = await this._previewHandler(i, t));
    let o = t == null ? void 0 : t.editor;
    if (!o) {
      const h = this._editorService.activeTextEditorControl;
      Yr(h) && (o = h);
    }
    o && o.getOption(89) && (o = void 0);
    let s, n = () => {
    };
    if (typeof (t == null ? void 0 : t.undoRedoGroupId) == "number") {
      for (const h of this._activeUndoRedoGroups)
        if (h.id === t.undoRedoGroupId) {
          s = h;
          break;
        }
    }
    s || (s = new Yv(), n = this._activeUndoRedoGroups.push(s));
    const r = (t == null ? void 0 : t.quotableLabel) || (t == null ? void 0 : t.label), a = this._instaService.createInstance(Gc, r, t == null ? void 0 : t.code, o, (t == null ? void 0 : t.progress) ?? Ov.None, (t == null ? void 0 : t.token) ?? Ni.None, i, s, t == null ? void 0 : t.undoRedoSource, !!(t != null && t.confirmBeforeUndo));
    let d;
    try {
      d = this._lifecycleService.onBeforeShutdown((g) => g.veto(this._shouldVeto(r, g.reason), "veto.blukEditService"));
      const h = await a.perform();
      return t != null && t.respectAutoSaveConfig && this._configService.getValue(hp) === !0 && h.length > 1 && await this._saveAll(h), { ariaSummary: a.ariaMessage(), isApplied: i.length > 0 };
    } catch (h) {
      throw this._logService.error(h), h;
    } finally {
      d == null || d.dispose(), n();
    }
  }
  async _saveAll(e) {
    const t = new Hv(e), i = this._workingCopyService.dirtyWorkingCopies.map(async (s) => {
      t.has(s.resource) && await s.save();
    }), o = await Promise.allSettled(i);
    for (const s of o)
      s.status === "rejected" && this._logService.warn(s.reason);
  }
  async _shouldVeto(e, t) {
    let i, o;
    switch (t) {
      case 1:
        i = u("closeTheWindow.message", "Are you sure you want to close the window?"), o = u(
          { key: "closeTheWindow", comment: ["&& denotes a mnemonic"] },
          "&&Close Window"
        );
        break;
      case 4:
        i = u(
          "changeWorkspace.message",
          "Are you sure you want to change the workspace?"
        ), o = u(
          { key: "changeWorkspace", comment: ["&& denotes a mnemonic"] },
          "Change &&Workspace"
        );
        break;
      case 3:
        i = u("reloadTheWindow.message", "Are you sure you want to reload the window?"), o = u(
          { key: "reloadTheWindow", comment: ["&& denotes a mnemonic"] },
          "&&Reload Window"
        );
        break;
      default:
        i = u("quit.message", "Are you sure you want to quit?"), o = u({ key: "quit", comment: ["&& denotes a mnemonic"] }, "&&Quit");
        break;
    }
    return !(await this._dialogService.confirm({
      message: i,
      detail: u(
        "areYouSureQuiteBulkEdit.detail",
        "'{0}' is in progress.",
        e || u("fileOperation", "File operation")
      ),
      primaryButton: o
    })).confirmed;
  }
};
xc = y([
  l(0, W),
  l(1, rt),
  l(2, D),
  l(3, xo),
  l(4, Yc),
  l(5, ng),
  l(6, x)
], xc);
const hp = "files.refactoring.autoSave";
N.as(Cd.Configuration).registerConfiguration({
  id: "files",
  properties: {
    [hp]: {
      description: u(
        "refactoring.autoSave",
        "Controls if files that were part of a refactoring are saved automatically"
      ),
      default: !0,
      type: "boolean"
    }
  }
});
function gS() {
  return {
    [Jh.toString()]: new T(xc, [], !0)
  };
}
function pS(c, e, t) {
  const i = document.createElement(e === "status" ? "footer" : "div");
  return i.classList.add("part", ...t), i.id = c, i.setAttribute("role", e), e === "status" && i.setAttribute("aria-live", "off"), i;
}
function up(c) {
  var t;
  const e = (t = c.getContainer()) == null ? void 0 : t.parentNode;
  e != null && c.layout(Math.max(c.minimumWidth, Math.min(c.maximumWidth, e.offsetWidth)), Math.max(c.minimumHeight, Math.min(c.maximumHeight, e.offsetHeight)), 0, 0);
}
function mS(c, e) {
  c.oncontextmenu = () => !1;
  function t() {
    up(e);
  }
  e.onDidVisibilityChange((i) => {
    i && t();
  }), t();
}
function gp(c) {
  return po.get(Vd).getPart(c);
}
function bS(c, e) {
  e.append(c.getContainer());
  const t = new ResizeObserver(() => up(c));
  return t.observe(e), {
    dispose() {
      return t.disconnect();
    }
  };
}
function Bo(c, e) {
  return bS(gp(c), e);
}
function MI(c, e) {
  return gp(c).onDidVisibilityChange(e);
}
function zI(c) {
  return po.get(Pe).isVisible(c);
}
function UI(c, e) {
  po.get(Pe).setPartHidden(!e, c);
}
function jI(c) {
  return Bo("workbench.parts.activitybar", c);
}
function qI(c) {
  return Bo("workbench.parts.sidebar", c);
}
function $I(c) {
  return Bo("workbench.parts.panel", c);
}
function eJ(c) {
  return Bo("workbench.parts.auxiliarybar", c);
}
function tJ(c) {
  return Bo("workbench.parts.editor", c);
}
function iJ(c) {
  return Bo("workbench.parts.statusbar", c);
}
function sJ(c) {
  let e = class extends xr {
    constructor(s, n, r) {
      super(c.id, s, n, r);
    }
    createEditor(s) {
      this.content = Y(".editor-pane-content"), this.content.style.display = "flex", this.content.style.alignItems = "stretch", ae(s, this.content), this._register(c.renderBody(this.content));
    }
    layout(s) {
      this.content.style.height = `${s.height}px`, this.content.style.width = `${s.width}px`;
    }
  };
  e = y([
    l(0, Xe),
    l(1, z),
    l(2, ee)
  ], e);
  class t extends cw {
    constructor(s) {
      super(), this.closeHandler = s, this.name = c.name, this.title = c.name, this.description = c.name, this.dirty = !1;
    }
    get typeId() {
      return t.ID;
    }
    get resource() {
    }
    setName(s) {
      this.name = s, this._onDidChangeLabel.fire();
    }
    setTitle(s) {
      this.title = s, this._onDidChangeLabel.fire();
    }
    setDescription(s) {
      this.description = s, this._onDidChangeLabel.fire();
    }
    getLabelValue(s, n) {
      if (typeof s == "string")
        return s;
      switch (n) {
        case 0:
          return s.short;
        case 2:
          return s.long;
        case 1:
        default:
          return s.medium;
      }
    }
    getName() {
      return this.name;
    }
    getTitle(s) {
      return this.getLabelValue(this.title, s);
    }
    getDescription(s) {
      return this.getLabelValue(this.description, s);
    }
    isDirty() {
      return this.dirty;
    }
    setDirty(s) {
      this.dirty = s, this._onDidChangeDirty.fire();
    }
  }
  return t.ID = `workbench.editors.${c.id}Input`, {
    disposable: N.as(Ci.EditorPane).registerEditorPane(Bs.create(e, c.id, c.name), [new T(t)]),
    CustomEditorInput: t
  };
}
function nJ(c) {
  const e = c.icon != null ? A.parse(c.icon) : void 0, t = N.as(nt.ViewContainersRegistry).registerViewContainer({
    id: c.id,
    title: c.name,
    order: c.order,
    ctorDescriptor: new T(Fc, [c.id, { mergeViewWithContainerWhenSingleView: !0 }]),
    hideIfEmpty: !0,
    icon: e
  }, c.location), i = [{
    id: c.id,
    name: c.name,
    canToggleVisibility: !1,
    ctorDescriptor: new T(class extends jn {
      renderBody(s) {
        super.renderBody(s), this.content = Y(".view-pane-content"), this.content.style.display = "flex", this.content.style.alignItems = "stretch", ae(s, this.content), this._register(c.renderBody(this.content));
      }
      getActionViewItem(s, n) {
        const r = (c.actions ?? []).find((a) => a.id === s.id);
        return (r == null ? void 0 : r.render) != null ? new class extends Pv {
          constructor() {
            super(null, s), this.render = r.render;
          }
        }() : super.getActionViewItem(s, n);
      }
      layoutBody(s, n) {
        this.content.style.height = `${s}px`, this.content.style.width = `${n}px`;
      }
    }),
    canMoveView: c.canMoveView ?? !0,
    containerIcon: e
  }];
  N.as(nt.ViewsRegistry).registerViews(i, t), (c.default ?? !1) && po.get(xo).when(4).then(() => {
    po.get(Mn).openViewContainer(c.id);
  });
  const o = new Z();
  o.add({
    dispose() {
      N.as(nt.ViewsRegistry).deregisterViews(i, t), N.as(nt.ViewContainersRegistry).deregisterViewContainer(t);
    }
  });
  for (const s of c.actions ?? [])
    o.add(P(class extends ye {
      constructor() {
        super({
          id: s.id,
          title: { value: s.title, original: s.title },
          category: Ce.View,
          menu: [{
            id: k.ViewTitle,
            when: f.equals("view", c.id),
            group: "navigation",
            order: s.order
          }, {
            id: k.CommandPalette
          }],
          tooltip: s.tooltip,
          icon: s.icon != null ? he[s.icon] : void 0
        }), this.run = s.run ?? (async () => {
        });
      }
    }));
  return o;
}
let Dc = class {
  constructor(e) {
    this.editorPart = e;
  }
  createEditorDropTarget(e, t) {
    return this.editorPart.createEditorDropTarget(e, t);
  }
};
Dc = y([
  l(0, ce)
], Dc);
function CS(c) {
  return c.isConnected ? c.checkVisibility != null ? c.checkVisibility({
    checkOpacity: !0,
    checkVisibilityCSS: !0
  }) : c.offsetHeight > 0 && c.offsetWidth > 0 : !1;
}
function Vr() {
  const c = po.get(ce).getContainer();
  return c != null && CS(c);
}
let Nc = class extends yw {
  constructor(e) {
    super(e.createInstance(Ea), e), this.onDidChangeSizeConstraints = this.delegate.onDidChangeSizeConstraints, this.restoreGroup = (...t) => this.delegate.restoreGroup(...t), this.isGroupMaximized = (...t) => this.delegate.isGroupMaximized(...t), this.createEditorDropTarget = (...t) => this.delegate.createEditorDropTarget(...t), this.updateStyles = (...t) => this.delegate.updateStyles(...t), this.setBoundarySashes = (...t) => this.delegate.setBoundarySashes(...t), this.layout = (...t) => this.delegate.layout(...t), this.toJSON = (...t) => this.delegate.toJSON(...t), this.onDidVisibilityChange = this.delegate.onDidVisibilityChange, this.create = (...t) => this.delegate.create(...t), this.getContainer = (...t) => this.delegate.getContainer(...t), this.setVisible = (...t) => this.delegate.setVisible(...t), this.getId = (...t) => this.delegate.getId(...t);
  }
  get minimumWidth() {
    return this.delegate.minimumWidth;
  }
  get maximumWidth() {
    return this.delegate.maximumWidth;
  }
  get minimumHeight() {
    return this.delegate.minimumHeight;
  }
  get maximumHeight() {
    return this.delegate.maximumHeight;
  }
  get snap() {
    return this.delegate.snap;
  }
  get onDidChange() {
    return this.delegate.onDidChange;
  }
  get priority() {
    return this.delegate.priority;
  }
  get dimension() {
    return this.delegate.dimension;
  }
  get element() {
    return this.delegate.element;
  }
};
Nc = y([
  l(0, W)
], Nc);
let Oo;
Mv({
  "vs/workbench/contrib/webview/browser/pre/service-worker.js": () => Os(new URL("data:application/javascript;base64,LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi4KICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovCi8vIEB0cy1jaGVjawoKLy8vIDxyZWZlcmVuY2Ugbm8tZGVmYXVsdC1saWI9InRydWUiLz4KLy8vIDxyZWZlcmVuY2UgbGliPSJ3ZWJ3b3JrZXIiIC8+Cgpjb25zdCBzdyA9IC8qKiBAdHlwZSB7U2VydmljZVdvcmtlckdsb2JhbFNjb3BlfSAqLyAoLyoqIEB0eXBlIHthbnl9ICovIChzZWxmKSk7Cgpjb25zdCBWRVJTSU9OID0gNDsKCmNvbnN0IHJlc291cmNlQ2FjaGVOYW1lID0gYHZzY29kZS1yZXNvdXJjZS1jYWNoZS0ke1ZFUlNJT059YDsKCmNvbnN0IHJvb3RQYXRoID0gc3cubG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXC9zZXJ2aWNlLXdvcmtlci5qcyQvLCAnJyk7Cgpjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMKGxvY2F0aW9uLnRvU3RyaW5nKCkpLnNlYXJjaFBhcmFtczsKCmNvbnN0IHJlbW90ZUF1dGhvcml0eSA9IHNlYXJjaFBhcmFtcy5nZXQoJ3JlbW90ZUF1dGhvcml0eScpOwoKLyoqCiAqIE9yaWdpbiB1c2VkIGZvciByZXNvdXJjZXMKICovCmNvbnN0IHJlc291cmNlQmFzZUF1dGhvcml0eSA9IHNlYXJjaFBhcmFtcy5nZXQoJ3ZzY29kZS1yZXNvdXJjZS1iYXNlLWF1dGhvcml0eScpOwoKY29uc3QgcmVzb2x2ZVRpbWVvdXQgPSAzMF8wMDA7CgovKioKICogQHRlbXBsYXRlIFQKICogQHR5cGVkZWYge3sgc3RhdHVzOiAnb2snOyB2YWx1ZTogVCB9IHwgeyBzdGF0dXM6ICd0aW1lb3V0JyB9fSBSZXF1ZXN0U3RvcmVSZXN1bHQKICovCgovKioKICogQHRlbXBsYXRlIFQKICogQHR5cGVkZWYge3sKICogICAgIHJlc29sdmU6ICh4OiBSZXF1ZXN0U3RvcmVSZXN1bHQ8VD4pID0+IHZvaWQsCiAqICAgICBwcm9taXNlOiBQcm9taXNlPFJlcXVlc3RTdG9yZVJlc3VsdDxUPj4KICogfX0gUmVxdWVzdFN0b3JlRW50cnkKICovCgovKioKICogQ2FjaGVzCiAqIEB0ZW1wbGF0ZSBUCiAqLwpjbGFzcyBSZXF1ZXN0U3RvcmUgewoJY29uc3RydWN0b3IoKSB7CgkJLyoqIEB0eXBlIHtNYXA8bnVtYmVyLCBSZXF1ZXN0U3RvcmVFbnRyeTxUPj59ICovCgkJdGhpcy5tYXAgPSBuZXcgTWFwKCk7CgoJCXRoaXMucmVxdWVzdFBvb2wgPSAwOwoJfQoKCS8qKgoJICogQHJldHVybnMge3sgcmVxdWVzdElkOiBudW1iZXIsIHByb21pc2U6IFByb21pc2U8UmVxdWVzdFN0b3JlUmVzdWx0PFQ+PiB9fQoJICovCgljcmVhdGUoKSB7CgkJY29uc3QgcmVxdWVzdElkID0gKyt0aGlzLnJlcXVlc3RQb29sOwoKCQkvKiogQHR5cGUge3VuZGVmaW5lZCB8ICgoeDogUmVxdWVzdFN0b3JlUmVzdWx0PFQ+KSA9PiB2b2lkKX0gKi8KCQlsZXQgcmVzb2x2ZTsKCgkJLyoqIEB0eXBlIHtQcm9taXNlPFJlcXVlc3RTdG9yZVJlc3VsdDxUPj59ICovCgkJY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHIgPT4gcmVzb2x2ZSA9IHIpOwoKCQkvKiogQHR5cGUge1JlcXVlc3RTdG9yZUVudHJ5PFQ+fSAqLwoJCWNvbnN0IGVudHJ5ID0geyByZXNvbHZlOiAvKiogQHR5cGUgeyh4OiBSZXF1ZXN0U3RvcmVSZXN1bHQ8VD4pID0+IHZvaWR9ICovIChyZXNvbHZlKSwgcHJvbWlzZSB9OwoKCQl0aGlzLm1hcC5zZXQocmVxdWVzdElkLCBlbnRyeSk7CgoJCWNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7CgkJCWNsZWFyVGltZW91dCh0aW1lb3V0KTsKCQkJY29uc3QgZXhpc3RpbmdFbnRyeSA9IHRoaXMubWFwLmdldChyZXF1ZXN0SWQpOwoJCQlpZiAoZXhpc3RpbmdFbnRyeSA9PT0gZW50cnkpIHsKCQkJCWV4aXN0aW5nRW50cnkucmVzb2x2ZSh7IHN0YXR1czogJ3RpbWVvdXQnIH0pOwoJCQkJdGhpcy5tYXAuZGVsZXRlKHJlcXVlc3RJZCk7CgkJCQlyZXR1cm47CgkJCX0KCQl9OwoJCWNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRpc3Bvc2UsIHJlc29sdmVUaW1lb3V0KTsKCQlyZXR1cm4geyByZXF1ZXN0SWQsIHByb21pc2UgfTsKCX0KCgkvKioKCSAqIEBwYXJhbSB7bnVtYmVyfSByZXF1ZXN0SWQKCSAqIEBwYXJhbSB7VH0gcmVzdWx0CgkgKiBAcmV0dXJuIHtib29sZWFufQoJICovCglyZXNvbHZlKHJlcXVlc3RJZCwgcmVzdWx0KSB7CgkJY29uc3QgZW50cnkgPSB0aGlzLm1hcC5nZXQocmVxdWVzdElkKTsKCQlpZiAoIWVudHJ5KSB7CgkJCXJldHVybiBmYWxzZTsKCQl9CgkJZW50cnkucmVzb2x2ZSh7IHN0YXR1czogJ29rJywgdmFsdWU6IHJlc3VsdCB9KTsKCQl0aGlzLm1hcC5kZWxldGUocmVxdWVzdElkKTsKCQlyZXR1cm4gdHJ1ZTsKCX0KfQoKLyoqCiAqIEB0eXBlZGVmIHt7IHJlYWRvbmx5IHN0YXR1czogMjAwOyBpZDogbnVtYmVyOyBwYXRoOiBzdHJpbmc7IG1pbWU6IHN0cmluZzsgZGF0YTogVWludDhBcnJheTsgZXRhZzogc3RyaW5nIHwgdW5kZWZpbmVkOyBtdGltZTogbnVtYmVyIHwgdW5kZWZpbmVkOyB9CiAqIAkJfCB7IHJlYWRvbmx5IHN0YXR1czogMzA0OyBpZDogbnVtYmVyOyBwYXRoOiBzdHJpbmc7IG1pbWU6IHN0cmluZzsgbXRpbWU6IG51bWJlciB8IHVuZGVmaW5lZCB9CiAqCQl8IHsgcmVhZG9ubHkgc3RhdHVzOiA0MDE7IGlkOiBudW1iZXI7IHBhdGg6IHN0cmluZyB9CiAqCQl8IHsgcmVhZG9ubHkgc3RhdHVzOiA0MDQ7IGlkOiBudW1iZXI7IHBhdGg6IHN0cmluZyB9fSBSZXNvdXJjZVJlc3BvbnNlCiAqLwoKLyoqCiAqIE1hcCBvZiByZXF1ZXN0ZWQgcGF0aHMgdG8gcmVzcG9uc2VzLgogKgogKiBAdHlwZSB7UmVxdWVzdFN0b3JlPFJlc291cmNlUmVzcG9uc2U+fQogKi8KY29uc3QgcmVzb3VyY2VSZXF1ZXN0U3RvcmUgPSBuZXcgUmVxdWVzdFN0b3JlKCk7CgovKioKICogTWFwIG9mIHJlcXVlc3RlZCBsb2NhbGhvc3Qgb3JpZ2lucyB0byBvcHRpb25hbCByZWRpcmVjdHMuCiAqCiAqIEB0eXBlIHtSZXF1ZXN0U3RvcmU8c3RyaW5nIHwgdW5kZWZpbmVkPn0KICovCmNvbnN0IGxvY2FsaG9zdFJlcXVlc3RTdG9yZSA9IG5ldyBSZXF1ZXN0U3RvcmUoKTsKCmNvbnN0IHVuYXV0aG9yaXplZCA9ICgpID0+CgluZXcgUmVzcG9uc2UoJ1VuYXV0aG9yaXplZCcsIHsgc3RhdHVzOiA0MDEsIH0pOwoKY29uc3Qgbm90Rm91bmQgPSAoKSA9PgoJbmV3IFJlc3BvbnNlKCdOb3QgRm91bmQnLCB7IHN0YXR1czogNDA0LCB9KTsKCmNvbnN0IG1ldGhvZE5vdEFsbG93ZWQgPSAoKSA9PgoJbmV3IFJlc3BvbnNlKCdNZXRob2QgTm90IEFsbG93ZWQnLCB7IHN0YXR1czogNDA1LCB9KTsKCmNvbnN0IHJlcXVlc3RUaW1lb3V0ID0gKCkgPT4KCW5ldyBSZXNwb25zZSgnUmVxdWVzdCBUaW1lb3V0JywgeyBzdGF0dXM6IDQwOCwgfSk7Cgpzdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgYXN5bmMgKGV2ZW50KSA9PiB7Cglzd2l0Y2ggKGV2ZW50LmRhdGEuY2hhbm5lbCkgewoJCWNhc2UgJ3ZlcnNpb24nOiB7CgkJCWNvbnN0IHNvdXJjZSA9IC8qKiBAdHlwZSB7Q2xpZW50fSAqLyAoZXZlbnQuc291cmNlKTsKCQkJc3cuY2xpZW50cy5nZXQoc291cmNlLmlkKS50aGVuKGNsaWVudCA9PiB7CgkJCQlpZiAoY2xpZW50KSB7CgkJCQkJY2xpZW50LnBvc3RNZXNzYWdlKHsKCQkJCQkJY2hhbm5lbDogJ3ZlcnNpb24nLAoJCQkJCQl2ZXJzaW9uOiBWRVJTSU9OCgkJCQkJfSk7CgkJCQl9CgkJCX0pOwoJCQlyZXR1cm47CgkJfQoJCWNhc2UgJ2RpZC1sb2FkLXJlc291cmNlJzogewoJCQkvKiogQHR5cGUge1Jlc291cmNlUmVzcG9uc2V9ICovCgkJCWNvbnN0IHJlc3BvbnNlID0gZXZlbnQuZGF0YS5kYXRhOwoJCQlpZiAoIXJlc291cmNlUmVxdWVzdFN0b3JlLnJlc29sdmUocmVzcG9uc2UuaWQsIHJlc3BvbnNlKSkgewoJCQkJY29uc29sZS5sb2coJ0NvdWxkIG5vdCByZXNvbHZlIHVua25vd24gcmVzb3VyY2UnLCByZXNwb25zZS5wYXRoKTsKCQkJfQoJCQlyZXR1cm47CgkJfQoJCWNhc2UgJ2RpZC1sb2FkLWxvY2FsaG9zdCc6IHsKCQkJY29uc3QgZGF0YSA9IGV2ZW50LmRhdGEuZGF0YTsKCQkJaWYgKCFsb2NhbGhvc3RSZXF1ZXN0U3RvcmUucmVzb2x2ZShkYXRhLmlkLCBkYXRhLmxvY2F0aW9uKSkgewoJCQkJY29uc29sZS5sb2coJ0NvdWxkIG5vdCByZXNvbHZlIHVua25vd24gbG9jYWxob3N0JywgZGF0YS5vcmlnaW4pOwoJCQl9CgkJCXJldHVybjsKCQl9CgkJZGVmYXVsdDogewoJCQljb25zb2xlLmxvZygnVW5rbm93biBtZXNzYWdlJyk7CgkJCXJldHVybjsKCQl9Cgl9Cn0pOwoKc3cuYWRkRXZlbnRMaXN0ZW5lcignZmV0Y2gnLCAoZXZlbnQpID0+IHsKCWNvbnN0IHJlcXVlc3RVcmwgPSBuZXcgVVJMKGV2ZW50LnJlcXVlc3QudXJsKTsKCWlmIChyZXF1ZXN0VXJsLnByb3RvY29sID09PSAnaHR0cHM6JyAmJiByZXF1ZXN0VXJsLmhvc3RuYW1lLmVuZHNXaXRoKCcuJyArIHJlc291cmNlQmFzZUF1dGhvcml0eSkpIHsKCQlzd2l0Y2ggKGV2ZW50LnJlcXVlc3QubWV0aG9kKSB7CgkJCWNhc2UgJ0dFVCc6CgkJCWNhc2UgJ0hFQUQnOiB7CgkJCQljb25zdCBmaXJzdEhvc3RTZWdtZW50ID0gcmVxdWVzdFVybC5ob3N0bmFtZS5zbGljZSgwLCByZXF1ZXN0VXJsLmhvc3RuYW1lLmxlbmd0aCAtIChyZXNvdXJjZUJhc2VBdXRob3JpdHkubGVuZ3RoICsgMSkpOwoJCQkJY29uc3Qgc2NoZW1lID0gZmlyc3RIb3N0U2VnbWVudC5zcGxpdCgnKycsIDEpWzBdOwoJCQkJY29uc3QgYXV0aG9yaXR5ID0gZmlyc3RIb3N0U2VnbWVudC5zbGljZShzY2hlbWUubGVuZ3RoICsgMSk7IC8vIG1heSBiZSBlbXB0eQoJCQkJcmV0dXJuIGV2ZW50LnJlc3BvbmRXaXRoKHByb2Nlc3NSZXNvdXJjZVJlcXVlc3QoZXZlbnQsIHsKCQkJCQlzY2hlbWUsCgkJCQkJYXV0aG9yaXR5LAoJCQkJCXBhdGg6IHJlcXVlc3RVcmwucGF0aG5hbWUsCgkJCQkJcXVlcnk6IHJlcXVlc3RVcmwuc2VhcmNoLnJlcGxhY2UoL15cPy8sICcnKSwKCQkJCX0pKTsKCQkJfQoJCQlkZWZhdWx0OiB7CgkJCQlyZXR1cm4gZXZlbnQucmVzcG9uZFdpdGgobWV0aG9kTm90QWxsb3dlZCgpKTsKCQkJfQoJCX0KCX0KCgkvLyBJZiB3ZSdyZSBtYWtpbmcgYSByZXF1ZXN0IGFnYWluc3QgdGhlIHJlbW90ZSBhdXRob3JpdHksIHdlIHdhbnQgdG8gZ28KCS8vIHRocm91Z2ggVlMgQ29kZSBpdHNlbGYgc28gdGhhdCB3ZSBhcmUgYXV0aGVudGljYXRlZCBwcm9wZXJseS4gIElmIHRoZQoJLy8gc2VydmljZSB3b3JrZXIgaXMgaG9zdGVkIG9uIHRoZSBzYW1lIG9yaWdpbiB3ZSB3aWxsIGhhdmUgY29va2llcyBhbmQKCS8vIGF1dGhlbnRpY2F0aW9uIHdpbGwgbm90IGJlIGFuIGlzc3VlLgoJaWYgKHJlcXVlc3RVcmwub3JpZ2luICE9PSBzdy5vcmlnaW4gJiYgcmVxdWVzdFVybC5ob3N0ID09PSByZW1vdGVBdXRob3JpdHkpIHsKCQlzd2l0Y2ggKGV2ZW50LnJlcXVlc3QubWV0aG9kKSB7CgkJCWNhc2UgJ0dFVCc6CgkJCWNhc2UgJ0hFQUQnOiB7CgkJCQlyZXR1cm4gZXZlbnQucmVzcG9uZFdpdGgocHJvY2Vzc1Jlc291cmNlUmVxdWVzdChldmVudCwgewoJCQkJCXBhdGg6IHJlcXVlc3RVcmwucGF0aG5hbWUsCgkJCQkJc2NoZW1lOiByZXF1ZXN0VXJsLnByb3RvY29sLnNsaWNlKDAsIHJlcXVlc3RVcmwucHJvdG9jb2wubGVuZ3RoIC0gMSksCgkJCQkJYXV0aG9yaXR5OiByZXF1ZXN0VXJsLmhvc3QsCgkJCQkJcXVlcnk6IHJlcXVlc3RVcmwuc2VhcmNoLnJlcGxhY2UoL15cPy8sICcnKSwKCQkJCX0pKTsKCQkJfQoJCQlkZWZhdWx0OiB7CgkJCQlyZXR1cm4gZXZlbnQucmVzcG9uZFdpdGgobWV0aG9kTm90QWxsb3dlZCgpKTsKCQkJfQoJCX0KCX0KCgkvLyBTZWUgaWYgaXQncyBhIGxvY2FsaG9zdCByZXF1ZXN0CglpZiAocmVxdWVzdFVybC5vcmlnaW4gIT09IHN3Lm9yaWdpbiAmJiByZXF1ZXN0VXJsLmhvc3QubWF0Y2goL14obG9jYWxob3N0fDEyNy4wLjAuMXwwLjAuMC4wKTooXGQrKSQvKSkgewoJCXJldHVybiBldmVudC5yZXNwb25kV2l0aChwcm9jZXNzTG9jYWxob3N0UmVxdWVzdChldmVudCwgcmVxdWVzdFVybCkpOwoJfQp9KTsKCnN3LmFkZEV2ZW50TGlzdGVuZXIoJ2luc3RhbGwnLCAoZXZlbnQpID0+IHsKCWV2ZW50LndhaXRVbnRpbChzdy5za2lwV2FpdGluZygpKTsgLy8gQWN0aXZhdGUgd29ya2VyIGltbWVkaWF0ZWx5Cn0pOwoKc3cuYWRkRXZlbnRMaXN0ZW5lcignYWN0aXZhdGUnLCAoZXZlbnQpID0+IHsKCWV2ZW50LndhaXRVbnRpbChzdy5jbGllbnRzLmNsYWltKCkpOyAvLyBCZWNvbWUgYXZhaWxhYmxlIHRvIGFsbCBwYWdlcwp9KTsKCi8qKgogKiBAcGFyYW0ge0ZldGNoRXZlbnR9IGV2ZW50CiAqIEBwYXJhbSB7ewogKiAJCXNjaGVtZTogc3RyaW5nOwogKiAJCWF1dGhvcml0eTogc3RyaW5nOwogKiAJCXBhdGg6IHN0cmluZzsKICogCQlxdWVyeTogc3RyaW5nOwogKiB9fSByZXF1ZXN0VXJsQ29tcG9uZW50cwogKi8KYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1Jlc291cmNlUmVxdWVzdChldmVudCwgcmVxdWVzdFVybENvbXBvbmVudHMpIHsKCWNvbnN0IGNsaWVudCA9IGF3YWl0IHN3LmNsaWVudHMuZ2V0KGV2ZW50LmNsaWVudElkKTsKCWlmICghY2xpZW50KSB7CgkJY29uc29sZS5lcnJvcignQ291bGQgbm90IGZpbmQgaW5uZXIgY2xpZW50IGZvciByZXF1ZXN0Jyk7CgkJcmV0dXJuIG5vdEZvdW5kKCk7Cgl9CgoJY29uc3Qgd2Vidmlld0lkID0gZ2V0V2Vidmlld0lkRm9yQ2xpZW50KGNsaWVudCk7CglpZiAoIXdlYnZpZXdJZCkgewoJCWNvbnNvbGUuZXJyb3IoJ0NvdWxkIG5vdCByZXNvbHZlIHdlYnZpZXcgaWQnKTsKCQlyZXR1cm4gbm90Rm91bmQoKTsKCX0KCgljb25zdCBzaG91bGRUcnlDYWNoaW5nID0gKGV2ZW50LnJlcXVlc3QubWV0aG9kID09PSAnR0VUJyk7CgoJLyoqCgkgKiBAcGFyYW0ge1JlcXVlc3RTdG9yZVJlc3VsdDxSZXNvdXJjZVJlc3BvbnNlPn0gcmVzdWx0CgkgKiBAcGFyYW0ge1Jlc3BvbnNlIHwgdW5kZWZpbmVkfSBjYWNoZWRSZXNwb25zZQoJICovCgljb25zdCByZXNvbHZlUmVzb3VyY2VFbnRyeSA9IChyZXN1bHQsIGNhY2hlZFJlc3BvbnNlKSA9PiB7CgkJaWYgKHJlc3VsdC5zdGF0dXMgPT09ICd0aW1lb3V0JykgewoJCQlyZXR1cm4gcmVxdWVzdFRpbWVvdXQoKTsKCQl9CgoJCWNvbnN0IGVudHJ5ID0gcmVzdWx0LnZhbHVlOwoJCWlmIChlbnRyeS5zdGF0dXMgPT09IDMwNCkgeyAvLyBOb3QgbW9kaWZpZWQKCQkJaWYgKGNhY2hlZFJlc3BvbnNlKSB7CgkJCQlyZXR1cm4gY2FjaGVkUmVzcG9uc2UuY2xvbmUoKTsKCQkJfSBlbHNlIHsKCQkJCXRocm93IG5ldyBFcnJvcignTm8gY2FjaGUgZm91bmQnKTsKCQkJfQoJCX0KCgkJaWYgKGVudHJ5LnN0YXR1cyA9PT0gNDAxKSB7CgkJCXJldHVybiB1bmF1dGhvcml6ZWQoKTsKCQl9CgoJCWlmIChlbnRyeS5zdGF0dXMgIT09IDIwMCkgewoJCQlyZXR1cm4gbm90Rm91bmQoKTsKCQl9CgoJCS8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gKi8KCQljb25zdCBjb21tb25IZWFkZXJzID0gewoJCQknQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonLAoJCX07CgoJCWNvbnN0IGJ5dGVMZW5ndGggPSBlbnRyeS5kYXRhLmJ5dGVMZW5ndGg7CgoJCWNvbnN0IHJhbmdlID0gZXZlbnQucmVxdWVzdC5oZWFkZXJzLmdldCgncmFuZ2UnKTsKCQlpZiAocmFuZ2UpIHsKCQkJLy8gVG8gc3VwcG9ydCBzZWVraW5nIGZvciB2aWRlb3MsIHdlIG5lZWQgdG8gaGFuZGxlIHJhbmdlIHJlcXVlc3RzCgkJCWNvbnN0IGJ5dGVzID0gcmFuZ2UubWF0Y2goL15ieXRlc1w9KFxkKylcLShcZCspPyQvZyk7CgkJCWlmIChieXRlcykgewoJCQkJLy8gVE9ETzogUmlnaHQgbm93IHdlIGFyZSBhbHdheXMgcmVhZGluZyB0aGUgZnVsbCBmaWxlIGNvbnRlbnQuIFRoaXMgaXMgYSBiYWQgaWRlYQoJCQkJLy8gZm9yIGxhcmdlIHZpZGVvIGZpbGVzIDopCgoJCQkJY29uc3Qgc3RhcnQgPSBOdW1iZXIoYnl0ZXNbMV0pOwoJCQkJY29uc3QgZW5kID0gTnVtYmVyKGJ5dGVzWzJdKSB8fCBieXRlTGVuZ3RoIC0gMTsKCQkJCXJldHVybiBuZXcgUmVzcG9uc2UoZW50cnkuZGF0YS5zbGljZShzdGFydCwgZW5kICsgMSksIHsKCQkJCQlzdGF0dXM6IDIwNiwKCQkJCQloZWFkZXJzOiB7CgkJCQkJCS4uLmNvbW1vbkhlYWRlcnMsCgkJCQkJCSdDb250ZW50LXJhbmdlJzogYGJ5dGVzIDAtJHtlbmR9LyR7Ynl0ZUxlbmd0aH1gLAoJCQkJCX0KCQkJCX0pOwoJCQl9IGVsc2UgewoJCQkJLy8gV2UgZG9uJ3QgdW5kZXJzdGFuZCB0aGUgcmVxdWVzdGVkIGJ5dGVzCgkJCQlyZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsKCQkJCQlzdGF0dXM6IDQxNiwKCQkJCQloZWFkZXJzOiB7CgkJCQkJCS4uLmNvbW1vbkhlYWRlcnMsCgkJCQkJCSdDb250ZW50LXJhbmdlJzogYCovJHtieXRlTGVuZ3RofWAKCQkJCQl9CgkJCQl9KTsKCQkJfQoJCX0KCgkJLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSAqLwoJCWNvbnN0IGhlYWRlcnMgPSB7CgkJCS4uLmNvbW1vbkhlYWRlcnMsCgkJCSdDb250ZW50LVR5cGUnOiBlbnRyeS5taW1lLAoJCQknQ29udGVudC1MZW5ndGgnOiBieXRlTGVuZ3RoLnRvU3RyaW5nKCksCgkJfTsKCgkJaWYgKGVudHJ5LmV0YWcpIHsKCQkJaGVhZGVyc1snRVRhZyddID0gZW50cnkuZXRhZzsKCQkJaGVhZGVyc1snQ2FjaGUtQ29udHJvbCddID0gJ25vLWNhY2hlJzsKCQl9CgkJaWYgKGVudHJ5Lm10aW1lKSB7CgkJCWhlYWRlcnNbJ0xhc3QtTW9kaWZpZWQnXSA9IG5ldyBEYXRlKGVudHJ5Lm10aW1lKS50b1VUQ1N0cmluZygpOwoJCX0KCgkJLy8gc3VwcG9ydCBDT0kgcmVxdWVzdHMsIHNlZSBuZXR3b3JrLnRzI0NPSS5nZXRIZWFkZXJzRnJvbVF1ZXJ5KC4uLikKCQljb25zdCBjb2lSZXF1ZXN0ID0gbmV3IFVSTChldmVudC5yZXF1ZXN0LnVybCkuc2VhcmNoUGFyYW1zLmdldCgndnNjb2RlLWNvaScpOwoJCWlmIChjb2lSZXF1ZXN0ID09PSAnMycpIHsKCQkJaGVhZGVyc1snQ3Jvc3MtT3JpZ2luLU9wZW5lci1Qb2xpY3knXSA9ICdzYW1lLW9yaWdpbic7CgkJCWhlYWRlcnNbJ0Nyb3NzLU9yaWdpbi1FbWJlZGRlci1Qb2xpY3knXSA9ICdyZXF1aXJlLWNvcnAnOwoJCX0gZWxzZSBpZiAoY29pUmVxdWVzdCA9PT0gJzInKSB7CgkJCWhlYWRlcnNbJ0Nyb3NzLU9yaWdpbi1FbWJlZGRlci1Qb2xpY3knXSA9ICdyZXF1aXJlLWNvcnAnOwoJCX0gZWxzZSBpZiAoY29pUmVxdWVzdCA9PT0gJzEnKSB7CgkJCWhlYWRlcnNbJ0Nyb3NzLU9yaWdpbi1PcGVuZXItUG9saWN5J10gPSAnc2FtZS1vcmlnaW4nOwoJCX0KCgkJY29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoZW50cnkuZGF0YSwgewoJCQlzdGF0dXM6IDIwMCwKCQkJaGVhZGVycwoJCX0pOwoKCQlpZiAoc2hvdWxkVHJ5Q2FjaGluZyAmJiBlbnRyeS5ldGFnKSB7CgkJCWNhY2hlcy5vcGVuKHJlc291cmNlQ2FjaGVOYW1lKS50aGVuKGNhY2hlID0+IHsKCQkJCXJldHVybiBjYWNoZS5wdXQoZXZlbnQucmVxdWVzdCwgcmVzcG9uc2UpOwoJCQl9KTsKCQl9CgkJcmV0dXJuIHJlc3BvbnNlLmNsb25lKCk7Cgl9OwoKCWNvbnN0IHBhcmVudENsaWVudHMgPSBhd2FpdCBnZXRPdXRlcklmcmFtZUNsaWVudCh3ZWJ2aWV3SWQpOwoJaWYgKCFwYXJlbnRDbGllbnRzLmxlbmd0aCkgewoJCWNvbnNvbGUubG9nKCdDb3VsZCBub3QgZmluZCBwYXJlbnQgY2xpZW50IGZvciByZXF1ZXN0Jyk7CgkJcmV0dXJuIG5vdEZvdW5kKCk7Cgl9CgoJLyoqIEB0eXBlIHtSZXNwb25zZSB8IHVuZGVmaW5lZH0gKi8KCWxldCBjYWNoZWQ7CglpZiAoc2hvdWxkVHJ5Q2FjaGluZykgewoJCWNvbnN0IGNhY2hlID0gYXdhaXQgY2FjaGVzLm9wZW4ocmVzb3VyY2VDYWNoZU5hbWUpOwoJCWNhY2hlZCA9IGF3YWl0IGNhY2hlLm1hdGNoKGV2ZW50LnJlcXVlc3QpOwoJfQoKCWNvbnN0IHsgcmVxdWVzdElkLCBwcm9taXNlIH0gPSByZXNvdXJjZVJlcXVlc3RTdG9yZS5jcmVhdGUoKTsKCglmb3IgKGNvbnN0IHBhcmVudENsaWVudCBvZiBwYXJlbnRDbGllbnRzKSB7CgkJcGFyZW50Q2xpZW50LnBvc3RNZXNzYWdlKHsKCQkJY2hhbm5lbDogJ2xvYWQtcmVzb3VyY2UnLAoJCQlpZDogcmVxdWVzdElkLAoJCQlzY2hlbWU6IHJlcXVlc3RVcmxDb21wb25lbnRzLnNjaGVtZSwKCQkJYXV0aG9yaXR5OiByZXF1ZXN0VXJsQ29tcG9uZW50cy5hdXRob3JpdHksCgkJCXBhdGg6IHJlcXVlc3RVcmxDb21wb25lbnRzLnBhdGgsCgkJCXF1ZXJ5OiByZXF1ZXN0VXJsQ29tcG9uZW50cy5xdWVyeSwKCQkJaWZOb25lTWF0Y2g6IGNhY2hlZD8uaGVhZGVycy5nZXQoJ0VUYWcnKSwKCQl9KTsKCX0KCglyZXR1cm4gcHJvbWlzZS50aGVuKGVudHJ5ID0+IHJlc29sdmVSZXNvdXJjZUVudHJ5KGVudHJ5LCBjYWNoZWQpKTsKfQoKLyoqCiAqIEBwYXJhbSB7RmV0Y2hFdmVudH0gZXZlbnQKICogQHBhcmFtIHtVUkx9IHJlcXVlc3RVcmwKICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZT59CiAqLwphc3luYyBmdW5jdGlvbiBwcm9jZXNzTG9jYWxob3N0UmVxdWVzdChldmVudCwgcmVxdWVzdFVybCkgewoJY29uc3QgY2xpZW50ID0gYXdhaXQgc3cuY2xpZW50cy5nZXQoZXZlbnQuY2xpZW50SWQpOwoJaWYgKCFjbGllbnQpIHsKCQkvLyBUaGlzIGlzIGV4cGVjdGVkIHdoZW4gcmVxdWVzdGluZyByZXNvdXJjZXMgb24gb3RoZXIgbG9jYWxob3N0IHBvcnRzCgkJLy8gdGhhdCBhcmUgbm90IHNwYXduZWQgYnkgdnMgY29kZQoJCXJldHVybiBmZXRjaChldmVudC5yZXF1ZXN0KTsKCX0KCWNvbnN0IHdlYnZpZXdJZCA9IGdldFdlYnZpZXdJZEZvckNsaWVudChjbGllbnQpOwoJaWYgKCF3ZWJ2aWV3SWQpIHsKCQljb25zb2xlLmVycm9yKCdDb3VsZCBub3QgcmVzb2x2ZSB3ZWJ2aWV3IGlkJyk7CgkJcmV0dXJuIGZldGNoKGV2ZW50LnJlcXVlc3QpOwoJfQoKCWNvbnN0IG9yaWdpbiA9IHJlcXVlc3RVcmwub3JpZ2luOwoKCS8qKgoJICogQHBhcmFtIHtSZXF1ZXN0U3RvcmVSZXN1bHQ8c3RyaW5nIHwgdW5kZWZpbmVkPn0gcmVzdWx0CgkgKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlPn0KCSAqLwoJY29uc3QgcmVzb2x2ZVJlZGlyZWN0ID0gYXN5bmMgKHJlc3VsdCkgPT4gewoJCWlmIChyZXN1bHQuc3RhdHVzICE9PSAnb2snIHx8ICFyZXN1bHQudmFsdWUpIHsKCQkJcmV0dXJuIGZldGNoKGV2ZW50LnJlcXVlc3QpOwoJCX0KCgkJY29uc3QgcmVkaXJlY3RPcmlnaW4gPSByZXN1bHQudmFsdWU7CgkJY29uc3QgbG9jYXRpb24gPSBldmVudC5yZXF1ZXN0LnVybC5yZXBsYWNlKG5ldyBSZWdFeHAoYF4ke3JlcXVlc3RVcmwub3JpZ2lufSgvfCQpYCksIGAke3JlZGlyZWN0T3JpZ2lufSQxYCk7CgkJcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7CgkJCXN0YXR1czogMzAyLAoJCQloZWFkZXJzOiB7CgkJCQlMb2NhdGlvbjogbG9jYXRpb24KCQkJfQoJCX0pOwoJfTsKCgljb25zdCBwYXJlbnRDbGllbnRzID0gYXdhaXQgZ2V0T3V0ZXJJZnJhbWVDbGllbnQod2Vidmlld0lkKTsKCWlmICghcGFyZW50Q2xpZW50cy5sZW5ndGgpIHsKCQljb25zb2xlLmxvZygnQ291bGQgbm90IGZpbmQgcGFyZW50IGNsaWVudCBmb3IgcmVxdWVzdCcpOwoJCXJldHVybiBub3RGb3VuZCgpOwoJfQoKCWNvbnN0IHsgcmVxdWVzdElkLCBwcm9taXNlIH0gPSBsb2NhbGhvc3RSZXF1ZXN0U3RvcmUuY3JlYXRlKCk7Cglmb3IgKGNvbnN0IHBhcmVudENsaWVudCBvZiBwYXJlbnRDbGllbnRzKSB7CgkJcGFyZW50Q2xpZW50LnBvc3RNZXNzYWdlKHsKCQkJY2hhbm5lbDogJ2xvYWQtbG9jYWxob3N0JywKCQkJb3JpZ2luOiBvcmlnaW4sCgkJCWlkOiByZXF1ZXN0SWQsCgkJfSk7Cgl9CgoJcmV0dXJuIHByb21pc2UudGhlbihyZXNvbHZlUmVkaXJlY3QpOwp9CgovKioKICogQHBhcmFtIHtDbGllbnR9IGNsaWVudAogKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH0KICovCmZ1bmN0aW9uIGdldFdlYnZpZXdJZEZvckNsaWVudChjbGllbnQpIHsKCWNvbnN0IHJlcXVlc3RlckNsaWVudFVybCA9IG5ldyBVUkwoY2xpZW50LnVybCk7CglyZXR1cm4gcmVxdWVzdGVyQ2xpZW50VXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2lkJyk7Cn0KCi8qKgogKiBAcGFyYW0ge3N0cmluZ30gd2Vidmlld0lkCiAqIEByZXR1cm5zIHtQcm9taXNlPENsaWVudFtdPn0KICovCmFzeW5jIGZ1bmN0aW9uIGdldE91dGVySWZyYW1lQ2xpZW50KHdlYnZpZXdJZCkgewoJY29uc3QgYWxsQ2xpZW50cyA9IGF3YWl0IHN3LmNsaWVudHMubWF0Y2hBbGwoeyBpbmNsdWRlVW5jb250cm9sbGVkOiB0cnVlIH0pOwoJcmV0dXJuIGFsbENsaWVudHMuZmlsdGVyKGNsaWVudCA9PiB7CgkJY29uc3QgY2xpZW50VXJsID0gbmV3IFVSTChjbGllbnQudXJsKTsKCQlyZXR1cm4gY2xpZW50VXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2lkJykgPT09IHdlYnZpZXdJZDsKCX0pOwp9Cg==", self.location).href, Oo),
  "vs/workbench/contrib/webview/browser/pre/index.html": () => Os(new URL("data:text/html;base64,PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIiBzdHlsZT0id2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsiPgoKPGhlYWQ+Cgk8bWV0YSBjaGFyc2V0PSJVVEYtOCI+CgoJPG1ldGEgaHR0cC1lcXVpdj0iQ29udGVudC1TZWN1cml0eS1Qb2xpY3kiCgkJY29udGVudD0iZGVmYXVsdC1zcmMgJ25vbmUnOyBzY3JpcHQtc3JjICdzaGEyNTYtWXBFNmJjSUZhZzUyemVscTQwdVN0YkJoQXpFMExNYW5nTUMzTGVyQ1VrYz0nICdzZWxmJzsgZnJhbWUtc3JjICdzZWxmJzsgc3R5bGUtc3JjICd1bnNhZmUtaW5saW5lJzsiPgoKCTwhLS0gRGlzYWJsZSBwaW5jaCB6b29taW5nIC0tPgoJPG1ldGEgbmFtZT0idmlld3BvcnQiCgkJY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMCwgbWF4aW11bS1zY2FsZT0xLjAsIG1pbmltdW0tc2NhbGU9MS4wLCB1c2VyLXNjYWxhYmxlPW5vIj4KPC9oZWFkPgoKPGJvZHkgc3R5bGU9Im1hcmdpbjogMDsgb3ZlcmZsb3c6IGhpZGRlbjsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJSIgcm9sZT0iZG9jdW1lbnQiPgoJPHNjcmlwdCBhc3luYyB0eXBlPSJtb2R1bGUiPgoJCS8vIEB0cy1jaGVjawoJCS8vLyA8cmVmZXJlbmNlIGxpYj0iZG9tIiAvPgoKCQljb25zdCBpc1NhZmFyaSA9ICgKCQkJbmF2aWdhdG9yLnZlbmRvciAmJiBuYXZpZ2F0b3IudmVuZG9yLmluZGV4T2YoJ0FwcGxlJykgPiAtMSAmJgoJCQluYXZpZ2F0b3IudXNlckFnZW50ICYmCgkJCW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ3JpT1MnKSA9PT0gLTEgJiYKCQkJbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGeGlPUycpID09PSAtMQoJCSk7CgoJCWNvbnN0IGlzRmlyZWZveCA9ICgKCQkJbmF2aWdhdG9yLnVzZXJBZ2VudCAmJgoJCQluYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+PSAwCgkJKTsKCgkJY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTChsb2NhdGlvbi50b1N0cmluZygpKS5zZWFyY2hQYXJhbXM7CgkJY29uc3QgSUQgPSBzZWFyY2hQYXJhbXMuZ2V0KCdpZCcpOwoJCWNvbnN0IHdlYnZpZXdPcmlnaW4gPSBzZWFyY2hQYXJhbXMuZ2V0KCdvcmlnaW4nKTsKCQljb25zdCBvbkVsZWN0cm9uID0gc2VhcmNoUGFyYW1zLmdldCgncGxhdGZvcm0nKSA9PT0gJ2VsZWN0cm9uJzsKCQljb25zdCBkaXNhYmxlU2VydmljZVdvcmtlciA9IHNlYXJjaFBhcmFtcy5oYXMoJ2Rpc2FibGVTZXJ2aWNlV29ya2VyJyk7CgkJY29uc3QgZXhwZWN0ZWRXb3JrZXJWZXJzaW9uID0gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldCgnc3dWZXJzaW9uJykpOwoJCWNvbnN0IHNlcnZpY2VXb3JrZXJVcmkgPSBzZWFyY2hQYXJhbXMuZ2V0KCdzZXJ2aWNlV29ya2VyVXJpJyk7CgkJY29uc3QgZmFrZUh0bWxVcmkgPSBzZWFyY2hQYXJhbXMuZ2V0KCdmYWtlSHRtbFVyaScpOwoKCQkvKioKCQkgKiBVc2UgcG9sbGluZyB0byB0cmFjayBmb2N1cyBvZiBtYWluIHdlYnZpZXcgYW5kIGlmcmFtZXMgd2l0aGluIHRoZSB3ZWJ2aWV3CgkJICoKCQkgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlcnMKCQkgKiBAcGFyYW0geygpID0+IHZvaWR9IGhhbmRsZXJzLm9uRm9jdXMKCQkgKiBAcGFyYW0geygpID0+IHZvaWR9IGhhbmRsZXJzLm9uQmx1cgoJCSAqLwoJCWNvbnN0IHRyYWNrRm9jdXMgPSAoeyBvbkZvY3VzLCBvbkJsdXIgfSkgPT4gewoJCQljb25zdCBpbnRlcnZhbCA9IDI1MDsKCQkJbGV0IGlzRm9jdXNlZCA9IGRvY3VtZW50Lmhhc0ZvY3VzKCk7CgkJCXNldEludGVydmFsKCgpID0+IHsKCQkJCWNvbnN0IGlzQ3VycmVudGx5Rm9jdXNlZCA9IGRvY3VtZW50Lmhhc0ZvY3VzKCk7CgkJCQlpZiAoaXNDdXJyZW50bHlGb2N1c2VkID09PSBpc0ZvY3VzZWQpIHsKCQkJCQlyZXR1cm47CgkJCQl9CgkJCQlpc0ZvY3VzZWQgPSBpc0N1cnJlbnRseUZvY3VzZWQ7CgkJCQlpZiAoaXNDdXJyZW50bHlGb2N1c2VkKSB7CgkJCQkJb25Gb2N1cygpOwoJCQkJfSBlbHNlIHsKCQkJCQlvbkJsdXIoKTsKCQkJCX0KCQkJfSwgaW50ZXJ2YWwpOwoJCX07CgoJCWNvbnN0IGdldEFjdGl2ZUZyYW1lID0gKCkgPT4gewoJCQlyZXR1cm4gLyoqIEB0eXBlIHtIVE1MSUZyYW1lRWxlbWVudCB8IHVuZGVmaW5lZH0gKi8gKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhY3RpdmUtZnJhbWUnKSk7CgkJfTsKCgkJY29uc3QgZ2V0UGVuZGluZ0ZyYW1lID0gKCkgPT4gewoJCQlyZXR1cm4gLyoqIEB0eXBlIHtIVE1MSUZyYW1lRWxlbWVudCB8IHVuZGVmaW5lZH0gKi8gKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwZW5kaW5nLWZyYW1lJykpOwoJCX07CgoJCS8qKgoJCSAqIEB0ZW1wbGF0ZSBUCgkJICogQHBhcmFtIHtUIHwgdW5kZWZpbmVkIHwgbnVsbH0gb2JqCgkJICogQHJldHVybiB7VH0KCQkgKi8KCQlmdW5jdGlvbiBhc3NlcnRJc0RlZmluZWQob2JqKSB7CgkJCWlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyB8fCBvYmogPT09IG51bGwpIHsKCQkJCXRocm93IG5ldyBFcnJvcignRm91bmQgdW5leHBlY3RlZCBudWxsJyk7CgkJCX0KCQkJcmV0dXJuIG9iajsKCQl9CgoJCWNvbnN0IHZzY29kZVBvc3RNZXNzYWdlRnVuY05hbWUgPSAnX192c2NvZGVfcG9zdF9tZXNzYWdlX18nOwoKCQljb25zdCBkZWZhdWx0U3R5bGVzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTsKCQlkZWZhdWx0U3R5bGVzLmlkID0gJ19kZWZhdWx0U3R5bGVzJzsKCQlkZWZhdWx0U3R5bGVzLnRleHRDb250ZW50ID0gYAoJCQlodG1sIHsKCQkJCXNjcm9sbGJhci1jb2xvcjogdmFyKC0tdnNjb2RlLXNjcm9sbGJhclNsaWRlci1iYWNrZ3JvdW5kKSB2YXIoLS12c2NvZGUtZWRpdG9yLWJhY2tncm91bmQpOwoJCQl9CgoJCQlib2R5IHsKCQkJCWJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OwoJCQkJY29sb3I6IHZhcigtLXZzY29kZS1lZGl0b3ItZm9yZWdyb3VuZCk7CgkJCQlmb250LWZhbWlseTogdmFyKC0tdnNjb2RlLWZvbnQtZmFtaWx5KTsKCQkJCWZvbnQtd2VpZ2h0OiB2YXIoLS12c2NvZGUtZm9udC13ZWlnaHQpOwoJCQkJZm9udC1zaXplOiB2YXIoLS12c2NvZGUtZm9udC1zaXplKTsKCQkJCW1hcmdpbjogMDsKCQkJCXBhZGRpbmc6IDAgMjBweDsKCQkJfQoKCQkJaW1nLCB2aWRlbyB7CgkJCQltYXgtd2lkdGg6IDEwMCU7CgkJCQltYXgtaGVpZ2h0OiAxMDAlOwoJCQl9CgoJCQlhLCBhIGNvZGUgewoJCQkJY29sb3I6IHZhcigtLXZzY29kZS10ZXh0TGluay1mb3JlZ3JvdW5kKTsKCQkJfQoKCQkJYTpob3ZlciB7CgkJCQljb2xvcjogdmFyKC0tdnNjb2RlLXRleHRMaW5rLWFjdGl2ZUZvcmVncm91bmQpOwoJCQl9CgoJCQlhOmZvY3VzLAoJCQlpbnB1dDpmb2N1cywKCQkJc2VsZWN0OmZvY3VzLAoJCQl0ZXh0YXJlYTpmb2N1cyB7CgkJCQlvdXRsaW5lOiAxcHggc29saWQgLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yOwoJCQkJb3V0bGluZS1vZmZzZXQ6IC0xcHg7CgkJCX0KCgkJCWNvZGUgewoJCQkJY29sb3I6IHZhcigtLXZzY29kZS10ZXh0UHJlZm9ybWF0LWZvcmVncm91bmQpOwoJCQl9CgoJCQlibG9ja3F1b3RlIHsKCQkJCWJhY2tncm91bmQ6IHZhcigtLXZzY29kZS10ZXh0QmxvY2tRdW90ZS1iYWNrZ3JvdW5kKTsKCQkJCWJvcmRlci1jb2xvcjogdmFyKC0tdnNjb2RlLXRleHRCbG9ja1F1b3RlLWJvcmRlcik7CgkJCX0KCgkJCWtiZCB7CgkJCQliYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS12c2NvZGUta2V5YmluZGluZ0xhYmVsLWJhY2tncm91bmQpOwoJCQkJY29sb3I6IHZhcigtLXZzY29kZS1rZXliaW5kaW5nTGFiZWwtZm9yZWdyb3VuZCk7CgkJCQlib3JkZXItc3R5bGU6IHNvbGlkOwoJCQkJYm9yZGVyLXdpZHRoOiAxcHg7CgkJCQlib3JkZXItcmFkaXVzOiAzcHg7CgkJCQlib3JkZXItY29sb3I6IHZhcigtLXZzY29kZS1rZXliaW5kaW5nTGFiZWwtYm9yZGVyKTsKCQkJCWJvcmRlci1ib3R0b20tY29sb3I6IHZhcigtLXZzY29kZS1rZXliaW5kaW5nTGFiZWwtYm90dG9tQm9yZGVyKTsKCQkJCWJveC1zaGFkb3c6IGluc2V0IDAgLTFweCAwIHZhcigtLXZzY29kZS13aWRnZXQtc2hhZG93KTsKCQkJCXZlcnRpY2FsLWFsaWduOiBtaWRkbGU7CgkJCQlwYWRkaW5nOiAxcHggM3B4OwoJCQl9CgoJCQk6Oi13ZWJraXQtc2Nyb2xsYmFyIHsKCQkJCXdpZHRoOiAxMHB4OwoJCQkJaGVpZ2h0OiAxMHB4OwoJCQl9CgoJCQk6Oi13ZWJraXQtc2Nyb2xsYmFyLWNvcm5lciB7CgkJCQliYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS12c2NvZGUtZWRpdG9yLWJhY2tncm91bmQpOwoJCQl9CgoJCQk6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iIHsKCQkJCWJhY2tncm91bmQtY29sb3I6IHZhcigtLXZzY29kZS1zY3JvbGxiYXJTbGlkZXItYmFja2dyb3VuZCk7CgkJCX0KCQkJOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjpob3ZlciB7CgkJCQliYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS12c2NvZGUtc2Nyb2xsYmFyU2xpZGVyLWhvdmVyQmFja2dyb3VuZCk7CgkJCX0KCQkJOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjphY3RpdmUgewoJCQkJYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdnNjb2RlLXNjcm9sbGJhclNsaWRlci1hY3RpdmVCYWNrZ3JvdW5kKTsKCQkJfQoJCQk6OmhpZ2hsaWdodChmaW5kLWhpZ2hsaWdodCkgewoJCQkJYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdnNjb2RlLWVkaXRvci1maW5kTWF0Y2hIaWdobGlnaHRCYWNrZ3JvdW5kKTsKCQkJfQoJCQk6OmhpZ2hsaWdodChjdXJyZW50LWZpbmQtaGlnaGxpZ2h0KSB7CgkJCQliYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS12c2NvZGUtZWRpdG9yLWZpbmRNYXRjaEJhY2tncm91bmQpOwoJCQl9YDsKCgkJLyoqCgkJICogQHBhcmFtIHtib29sZWFufSBhbGxvd011bHRpcGxlQVBJQWNxdWlyZQoJCSAqIEBwYXJhbSB7Kn0gW3N0YXRlXQoJCSAqIEByZXR1cm4ge3N0cmluZ30KCQkgKi8KCQlmdW5jdGlvbiBnZXRWc0NvZGVBcGlTY3JpcHQoYWxsb3dNdWx0aXBsZUFQSUFjcXVpcmUsIHN0YXRlKSB7CgkJCWNvbnN0IGVuY29kZWRTdGF0ZSA9IHN0YXRlID8gZW5jb2RlVVJJQ29tcG9uZW50KHN0YXRlKSA6IHVuZGVmaW5lZDsKCQkJcmV0dXJuIC8qIGpzICovYAoJCQkJCWdsb2JhbFRoaXMuYWNxdWlyZVZzQ29kZUFwaSA9IChmdW5jdGlvbigpIHsKCQkJCQkJY29uc3Qgb3JpZ2luYWxQb3N0TWVzc2FnZSA9IHdpbmRvdy5wYXJlbnRbJyR7dnNjb2RlUG9zdE1lc3NhZ2VGdW5jTmFtZX0nXS5iaW5kKHdpbmRvdy5wYXJlbnQpOwoJCQkJCQljb25zdCBkb1Bvc3RNZXNzYWdlID0gKGNoYW5uZWwsIGRhdGEsIHRyYW5zZmVyKSA9PiB7CgkJCQkJCQlvcmlnaW5hbFBvc3RNZXNzYWdlKGNoYW5uZWwsIGRhdGEsIHRyYW5zZmVyKTsKCQkJCQkJfTsKCgkJCQkJCWxldCBhY3F1aXJlZCA9IGZhbHNlOwoKCQkJCQkJbGV0IHN0YXRlID0gJHtzdGF0ZSA/IGBKU09OLnBhcnNlKGRlY29kZVVSSUNvbXBvbmVudCgiJHtlbmNvZGVkU3RhdGV9IikpYCA6IHVuZGVmaW5lZH07CgoJCQkJCQlyZXR1cm4gKCkgPT4gewoJCQkJCQkJaWYgKGFjcXVpcmVkICYmICEke2FsbG93TXVsdGlwbGVBUElBY3F1aXJlfSkgewoJCQkJCQkJCXRocm93IG5ldyBFcnJvcignQW4gaW5zdGFuY2Ugb2YgdGhlIFZTIENvZGUgQVBJIGhhcyBhbHJlYWR5IGJlZW4gYWNxdWlyZWQnKTsKCQkJCQkJCX0KCQkJCQkJCWFjcXVpcmVkID0gdHJ1ZTsKCQkJCQkJCXJldHVybiBPYmplY3QuZnJlZXplKHsKCQkJCQkJCQlwb3N0TWVzc2FnZTogZnVuY3Rpb24obWVzc2FnZSwgdHJhbnNmZXIpIHsKCQkJCQkJCQkJZG9Qb3N0TWVzc2FnZSgnb25tZXNzYWdlJywgeyBtZXNzYWdlLCB0cmFuc2ZlciB9LCB0cmFuc2Zlcik7CgkJCQkJCQkJfSwKCQkJCQkJCQlzZXRTdGF0ZTogZnVuY3Rpb24obmV3U3RhdGUpIHsKCQkJCQkJCQkJc3RhdGUgPSBuZXdTdGF0ZTsKCQkJCQkJCQkJZG9Qb3N0TWVzc2FnZSgnZG8tdXBkYXRlLXN0YXRlJywgSlNPTi5zdHJpbmdpZnkobmV3U3RhdGUpKTsKCQkJCQkJCQkJcmV0dXJuIG5ld1N0YXRlOwoJCQkJCQkJCX0sCgkJCQkJCQkJZ2V0U3RhdGU6IGZ1bmN0aW9uKCkgewoJCQkJCQkJCQlyZXR1cm4gc3RhdGU7CgkJCQkJCQkJfQoJCQkJCQkJfSk7CgkJCQkJCX07CgkJCQkJfSkoKTsKCQkJCQlkZWxldGUgd2luZG93LnBhcmVudDsKCQkJCQlkZWxldGUgd2luZG93LnRvcDsKCQkJCQlkZWxldGUgd2luZG93LmZyYW1lRWxlbWVudDsKCQkJCWA7CgkJfQoKCQkvKiogQHR5cGUge1Byb21pc2U8dm9pZD59ICovCgkJY29uc3Qgd29ya2VyUmVhZHkgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7CgkJCWlmIChkaXNhYmxlU2VydmljZVdvcmtlcikgewoJCQkJcmV0dXJuIHJlc29sdmUoKTsKCQkJfQoKCQkJaWYgKCFhcmVTZXJ2aWNlV29ya2Vyc0VuYWJsZWQoKSkgewoJCQkJcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ1NlcnZpY2UgV29ya2VycyBhcmUgbm90IGVuYWJsZWQuIFdlYnZpZXdzIHdpbGwgbm90IHdvcmsuIFRyeSBkaXNhYmxpbmcgcHJpdmF0ZS9pbmNvZ25pdG8gbW9kZS4nKSk7CgkJCX0KCgkJCWNvbnN0IHN3UGF0aCA9IGVuY29kZVVSSShgJHtzZXJ2aWNlV29ya2VyVXJpfT92PSR7ZXhwZWN0ZWRXb3JrZXJWZXJzaW9ufSZ2c2NvZGUtcmVzb3VyY2UtYmFzZS1hdXRob3JpdHk9JHtzZWFyY2hQYXJhbXMuZ2V0KCd2c2NvZGUtcmVzb3VyY2UtYmFzZS1hdXRob3JpdHknKX0mcmVtb3RlQXV0aG9yaXR5PSR7c2VhcmNoUGFyYW1zLmdldCgncmVtb3RlQXV0aG9yaXR5JykgPz8gJyd9YCk7CgkJCW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKHN3UGF0aCkKCQkJCS50aGVuKGFzeW5jIHJlZ2lzdHJhdGlvbiA9PiB7CgkJCQkJLyoqCgkJCQkJICogQHBhcmFtIHtNZXNzYWdlRXZlbnR9IGV2ZW50CgkJCQkJICovCgkJCQkJY29uc3QgdmVyc2lvbkhhbmRsZXIgPSBhc3luYyAoZXZlbnQpID0+IHsKCQkJCQkJaWYgKGV2ZW50LmRhdGEuY2hhbm5lbCAhPT0gJ3ZlcnNpb24nKSB7CgkJCQkJCQlyZXR1cm47CgkJCQkJCX0KCgkJCQkJCW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB2ZXJzaW9uSGFuZGxlcik7CgkJCQkJCWlmIChldmVudC5kYXRhLnZlcnNpb24gPT09IGV4cGVjdGVkV29ya2VyVmVyc2lvbikgewoJCQkJCQkJcmV0dXJuIHJlc29sdmUoKTsKCQkJCQkJfSBlbHNlIHsKCQkJCQkJCWNvbnNvbGUubG9nKGBGb3VuZCB1bmV4cGVjdGVkIHNlcnZpY2Ugd29ya2VyIHZlcnNpb24uIEZvdW5kOiAke2V2ZW50LmRhdGEudmVyc2lvbn0uIEV4cGVjdGVkOiAke2V4cGVjdGVkV29ya2VyVmVyc2lvbn1gKTsKCQkJCQkJCWNvbnNvbGUubG9nKGBBdHRlbXB0aW5nIHRvIHJlbG9hZCBzZXJ2aWNlIHdvcmtlcmApOwoKCQkJCQkJCS8vIElmIHdlIGhhdmUgdGhlIHdyb25nIHZlcnNpb24sIHRyeSBvbmNlIChhbmQgb25seSBvbmNlKSB0byB1bnJlZ2lzdGVyIGFuZCByZS1yZWdpc3RlcgoJCQkJCQkJLy8gTm90ZSB0aGF0IGAudXBkYXRlYCBkb2Vzbid0IHNlZW0gdG8gd29yayBkZXNrdG9wIGVsZWN0cm9uIGF0IHRoZSBtb21lbnQgc28gd2UgdXNlCgkJCQkJCQkvLyBgdW5yZWdpc3RlcmAgYW5kIGByZWdpc3RlcmAgaGVyZS4KCQkJCQkJCXJldHVybiByZWdpc3RyYXRpb24udW5yZWdpc3RlcigpCgkJCQkJCQkJLnRoZW4oKCkgPT4gbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVnaXN0ZXIoc3dQYXRoKSkKCQkJCQkJCQkuZmluYWxseSgoKSA9PiB7IHJlc29sdmUoKTsgfSk7CgkJCQkJCX0KCQkJCQl9OwoJCQkJCW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB2ZXJzaW9uSGFuZGxlcik7CgoJCQkJCWNvbnN0IHBvc3RWZXJzaW9uTWVzc2FnZSA9ICgvKiogQHR5cGUge1NlcnZpY2VXb3JrZXJ9ICovIGNvbnRyb2xsZXIpID0+IHsKCQkJCQkJY29udHJvbGxlci5wb3N0TWVzc2FnZSh7IGNoYW5uZWw6ICd2ZXJzaW9uJyB9KTsKCQkJCQl9OwoKCQkJCQkvLyBBdCB0aGlzIHBvaW50LCBlaXRoZXIgdGhlIHNlcnZpY2Ugd29ya2VyIGlzIHJlYWR5IGFuZAoJCQkJCS8vIGJlY2FtZSBvdXIgY29udHJvbGxlciwgb3Igd2UgbmVlZCB0byB3YWl0IGZvciBpdC4KCQkJCQkvLyBOb3RlIHRoYXQgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlciBjb3VsZCBiZSBhCgkJCQkJLy8gY29udHJvbGxlciBmcm9tIGEgcHJldmlvdXNseSBsb2FkZWQgc2VydmljZSB3b3JrZXIuCgkJCQkJY29uc3QgY3VycmVudENvbnRyb2xsZXIgPSBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyOwoJCQkJCWlmIChjdXJyZW50Q29udHJvbGxlcj8uc2NyaXB0VVJMLmVuZHNXaXRoKHN3UGF0aCkpIHsKCQkJCQkJLy8gc2VydmljZSB3b3JrZXIgYWxyZWFkeSBsb2FkZWQgJiByZWFkeSB0byByZWNlaXZlIG1lc3NhZ2VzCgkJCQkJCXBvc3RWZXJzaW9uTWVzc2FnZShjdXJyZW50Q29udHJvbGxlcik7CgkJCQkJfSBlbHNlIHsKCQkJCQkJaWYgKGN1cnJlbnRDb250cm9sbGVyKSB7CgkJCQkJCQljb25zb2xlLmxvZyhgRm91bmQgdW5leHBlY3RlZCBzZXJ2aWNlIHdvcmtlciBjb250cm9sbGVyLiBGb3VuZDogJHtjdXJyZW50Q29udHJvbGxlci5zY3JpcHRVUkx9LiBFeHBlY3RlZDogJHtzd1BhdGh9LiBXYWl0aW5nIGZvciBjb250cm9sbGVyY2hhbmdlLmApOwoJCQkJCQl9IGVsc2UgewoJCQkJCQkJY29uc29sZS5sb2coYE5vIHNlcnZpY2Ugd29ya2VyIGNvbnRyb2xsZXIgZm91bmQuIFdhaXRpbmcgZm9yIGNvbnRyb2xsZXJjaGFuZ2UuYCk7CgkJCQkJCX0KCgkJCQkJCS8vIEVpdGhlciB0aGVyZSdzIG5vIGNvbnRyb2xsaW5nIHNlcnZpY2Ugd29ya2VyLCBvciBpdCdzIGFuIG9sZCBvbmUuCgkJCQkJCS8vIFdhaXQgZm9yIGl0IHRvIGNoYW5nZSBiZWZvcmUgcG9zdGluZyB0aGUgbWVzc2FnZQoJCQkJCQljb25zdCBvbkNvbnRyb2xsZXJDaGFuZ2UgPSAoKSA9PiB7CgkJCQkJCQluYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250cm9sbGVyY2hhbmdlJywgb25Db250cm9sbGVyQ2hhbmdlKTsKCQkJCQkJCWlmIChuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyKSB7CgkJCQkJCQkJcG9zdFZlcnNpb25NZXNzYWdlKG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIpOwoJCQkJCQkJfSBlbHNlIHsKCQkJCQkJCQlyZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTm8gY29udHJvbGxlciBmb3VuZC4nKSk7CgkJCQkJCQl9CgkJCQkJCX07CgkJCQkJCW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRyb2xsZXJjaGFuZ2UnLCBvbkNvbnRyb2xsZXJDaGFuZ2UpOwoJCQkJCX0KCQkJCX0pLmNhdGNoKGVycm9yID0+IHsKCQkJCQlpZiAoIW9uRWxlY3Ryb24gJiYgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCd1c2VyIGRlbmllZCBwZXJtaXNzaW9uJykpIHsKCQkJCQkJcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYENvdWxkIG5vdCByZWdpc3RlciBzZXJ2aWNlIHdvcmtlci4gUGxlYXNlIG1ha2Ugc3VyZSB0aGlyZCBwYXJ0eSBjb29raWVzIGFyZSBlbmFibGVkOiAke2Vycm9yfWApKTsKCQkJCQl9CgkJCQkJcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYENvdWxkIG5vdCByZWdpc3RlciBzZXJ2aWNlIHdvcmtlcjogJHtlcnJvcn0uYCkpOwoJCQkJfSk7CgkJfSk7CgoJCS8qKgoJCSAqICBAdHlwZSB7aW1wb3J0KCcuLi93ZWJ2aWV3TWVzc2FnZXMnKS5XZWJ2aWV3SG9zdE1lc3NhZ2luZ30KCQkgKi8KCQljb25zdCBob3N0TWVzc2FnaW5nID0gbmV3IGNsYXNzIEhvc3RNZXNzYWdpbmcgewoKCQkJY29uc3RydWN0b3IoKSB7CgkJCQl0aGlzLmNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTsKCgkJCQkvKiogQHR5cGUge01hcDxzdHJpbmcsIEFycmF5PChldmVudDogTWVzc2FnZUV2ZW50LCBkYXRhOiBhbnkpID0+IHZvaWQ+Pn0gKi8KCQkJCXRoaXMuaGFuZGxlcnMgPSBuZXcgTWFwKCk7CgoJCQkJdGhpcy5jaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IChlKSA9PiB7CgkJCQkJY29uc3QgY2hhbm5lbCA9IGUuZGF0YS5jaGFubmVsOwoJCQkJCWNvbnN0IGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycy5nZXQoY2hhbm5lbCk7CgkJCQkJaWYgKGhhbmRsZXJzKSB7CgkJCQkJCWZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykgewoJCQkJCQkJaGFuZGxlcihlLCBlLmRhdGEuYXJncyk7CgkJCQkJCX0KCQkJCQl9IGVsc2UgewoJCQkJCQljb25zb2xlLmxvZygnbm8gaGFuZGxlciBmb3IgJywgZSk7CgkJCQkJfQoJCQkJfTsKCQkJfQoKCQkJcG9zdE1lc3NhZ2UoY2hhbm5lbCwgZGF0YSwgdHJhbnNmZXIpIHsKCQkJCXRoaXMuY2hhbm5lbC5wb3J0MS5wb3N0TWVzc2FnZSh7IGNoYW5uZWwsIGRhdGEgfSwgdHJhbnNmZXIpOwoJCQl9CgoJCQlvbk1lc3NhZ2UoY2hhbm5lbCwgaGFuZGxlcikgewoJCQkJbGV0IGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycy5nZXQoY2hhbm5lbCk7CgkJCQlpZiAoIWhhbmRsZXJzKSB7CgkJCQkJaGFuZGxlcnMgPSBbXTsKCQkJCQl0aGlzLmhhbmRsZXJzLnNldChjaGFubmVsLCBoYW5kbGVycyk7CgkJCQl9CgkJCQloYW5kbGVycy5wdXNoKGhhbmRsZXIpOwoJCQl9CgoJCQlhc3luYyBzaWduYWxSZWFkeSgpIHsKCQkJCWNvbnN0IHN0YXJ0ID0gKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyBwYXJlbnRPcmlnaW4pID0+IHsKCQkJCQl3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKHsgdGFyZ2V0OiBJRCwgY2hhbm5lbDogJ3dlYnZpZXctcmVhZHknLCBkYXRhOiB7fSB9LCBwYXJlbnRPcmlnaW4sIFt0aGlzLmNoYW5uZWwucG9ydDJdKTsKCQkJCX07CgoJCQkJY29uc3QgcGFyZW50T3JpZ2luID0gc2VhcmNoUGFyYW1zLmdldCgncGFyZW50T3JpZ2luJyk7CgoJCQkJcmV0dXJuIHN0YXJ0KHBhcmVudE9yaWdpbik7CgkJCX0KCQl9KCk7CgoJCWNvbnN0IHVubG9hZE1vbml0b3IgPSBuZXcgY2xhc3MgewoKCQkJY29uc3RydWN0b3IoKSB7CgkJCQl0aGlzLmNvbmZpcm1CZWZvcmVDbG9zZSA9ICdrZXlib2FyZE9ubHknOwoJCQkJdGhpcy5pc01vZGlmaWVyS2V5RG93biA9IGZhbHNlOwoKCQkJCWhvc3RNZXNzYWdpbmcub25NZXNzYWdlKCdzZXQtY29uZmlybS1iZWZvcmUtY2xvc2UnLCAoX2UsIGRhdGEpID0+IHsKCQkJCQl0aGlzLmNvbmZpcm1CZWZvcmVDbG9zZSA9IGRhdGE7CgkJCQl9KTsKCgkJCQlob3N0TWVzc2FnaW5nLm9uTWVzc2FnZSgnY29udGVudCcsIChfZSwgZGF0YSkgPT4gewoJCQkJCXRoaXMuY29uZmlybUJlZm9yZUNsb3NlID0gZGF0YS5jb25maXJtQmVmb3JlQ2xvc2U7CgkJCQl9KTsKCgkJCQl3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgKGV2ZW50KSA9PiB7CgkJCQkJaWYgKG9uRWxlY3Ryb24pIHsKCQkJCQkJcmV0dXJuOwoJCQkJCX0KCgkJCQkJc3dpdGNoICh0aGlzLmNvbmZpcm1CZWZvcmVDbG9zZSkgewoJCQkJCQljYXNlICdhbHdheXMnOiB7CgkJCQkJCQlldmVudC5wcmV2ZW50RGVmYXVsdCgpOwoJCQkJCQkJZXZlbnQucmV0dXJuVmFsdWUgPSAnJzsKCQkJCQkJCXJldHVybiAnJzsKCQkJCQkJfQoJCQkJCQljYXNlICduZXZlcic6IHsKCQkJCQkJCWJyZWFrOwoJCQkJCQl9CgkJCQkJCWNhc2UgJ2tleWJvYXJkT25seSc6CgkJCQkJCWRlZmF1bHQ6IHsKCQkJCQkJCWlmICh0aGlzLmlzTW9kaWZpZXJLZXlEb3duKSB7CgkJCQkJCQkJZXZlbnQucHJldmVudERlZmF1bHQoKTsKCQkJCQkJCQlldmVudC5yZXR1cm5WYWx1ZSA9ICcnOwoJCQkJCQkJCXJldHVybiAnJzsKCQkJCQkJCX0KCQkJCQkJCWJyZWFrOwoJCQkJCQl9CgkJCQkJfQoJCQkJfSk7CgkJCX0KCgkJCW9uSWZyYW1lTG9hZGVkKC8qKiBAdHlwZSB7SFRNTElGcmFtZUVsZW1lbnR9ICovIGZyYW1lKSB7CgkJCQlhc3NlcnRJc0RlZmluZWQoZnJhbWUuY29udGVudFdpbmRvdykuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGUgPT4gewoJCQkJCXRoaXMuaXNNb2RpZmllcktleURvd24gPSBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuYWx0S2V5OwoJCQkJfSk7CgoJCQkJYXNzZXJ0SXNEZWZpbmVkKGZyYW1lLmNvbnRlbnRXaW5kb3cpLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKCkgPT4gewoJCQkJCXRoaXMuaXNNb2RpZmllcktleURvd24gPSBmYWxzZTsKCQkJCX0pOwoJCQl9CgkJfTsKCgkJLy8gc3RhdGUKCQlsZXQgZmlyc3RMb2FkID0gdHJ1ZTsKCQkvKiogQHR5cGUge2FueX0gKi8KCQlsZXQgbG9hZFRpbWVvdXQ7CgkJbGV0IHN0eWxlVmVyc2lvbiA9IDA7CgoJCS8qKiBAdHlwZSB7QXJyYXk8eyByZWFkb25seSBtZXNzYWdlOiBhbnksIHRyYW5zZmVyPzogQXJyYXlCdWZmZXJbXSB9Pn0gKi8KCQlsZXQgcGVuZGluZ01lc3NhZ2VzID0gW107CgoJCWNvbnN0IGluaXREYXRhID0gewoJCQkvKiogQHR5cGUge251bWJlciB8IHVuZGVmaW5lZH0gKi8KCQkJaW5pdGlhbFNjcm9sbFByb2dyZXNzOiB1bmRlZmluZWQsCgoJCQkvKiogQHR5cGUge3sgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gfCB1bmRlZmluZWR9ICovCgkJCXN0eWxlczogdW5kZWZpbmVkLAoKCQkJLyoqIEB0eXBlIHtzdHJpbmcgfCB1bmRlZmluZWR9ICovCgkJCWFjdGl2ZVRoZW1lOiB1bmRlZmluZWQsCgoJCQkvKiogQHR5cGUge3N0cmluZyB8IHVuZGVmaW5lZH0gKi8KCQkJdGhlbWVJZDogdW5kZWZpbmVkLAoKCQkJLyoqIEB0eXBlIHtzdHJpbmcgfCB1bmRlZmluZWR9ICovCgkJCXRoZW1lTGFiZWw6IHVuZGVmaW5lZCwKCgkJCS8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8KCQkJc2NyZWVuUmVhZGVyOiBmYWxzZSwKCgkJCS8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8KCQkJcmVkdWNlTW90aW9uOiBmYWxzZSwKCQl9OwoKCQlpZiAoIWRpc2FibGVTZXJ2aWNlV29ya2VyKSB7CgkJCWhvc3RNZXNzYWdpbmcub25NZXNzYWdlKCdkaWQtbG9hZC1yZXNvdXJjZScsIChfZXZlbnQsIGRhdGEpID0+IHsKCQkJCWFzc2VydElzRGVmaW5lZChuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyKS5wb3N0TWVzc2FnZSh7IGNoYW5uZWw6ICdkaWQtbG9hZC1yZXNvdXJjZScsIGRhdGEgfSwgZGF0YS5kYXRhPy5idWZmZXIgPyBbZGF0YS5kYXRhLmJ1ZmZlcl0gOiBbXSk7CgkJCX0pOwoKCQkJaG9zdE1lc3NhZ2luZy5vbk1lc3NhZ2UoJ2RpZC1sb2FkLWxvY2FsaG9zdCcsIChfZXZlbnQsIGRhdGEpID0+IHsKCQkJCWFzc2VydElzRGVmaW5lZChuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyKS5wb3N0TWVzc2FnZSh7IGNoYW5uZWw6ICdkaWQtbG9hZC1sb2NhbGhvc3QnLCBkYXRhIH0pOwoJCQl9KTsKCgkJCW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudCA9PiB7CgkJCQlzd2l0Y2ggKGV2ZW50LmRhdGEuY2hhbm5lbCkgewoJCQkJCWNhc2UgJ2xvYWQtcmVzb3VyY2UnOgoJCQkJCWNhc2UgJ2xvYWQtbG9jYWxob3N0JzoKCQkJCQkJaG9zdE1lc3NhZ2luZy5wb3N0TWVzc2FnZShldmVudC5kYXRhLmNoYW5uZWwsIGV2ZW50LmRhdGEpOwoJCQkJCQlyZXR1cm47CgkJCQl9CgkJCX0pOwoJCX0KCgkJLyoqCgkJICogQHBhcmFtIHtIVE1MRG9jdW1lbnQ/fSBkb2N1bWVudAoJCSAqIEBwYXJhbSB7SFRNTEVsZW1lbnQ/fSBib2R5CgkJICovCgkJY29uc3QgYXBwbHlTdHlsZXMgPSAoZG9jdW1lbnQsIGJvZHkpID0+IHsKCQkJaWYgKCFkb2N1bWVudCkgewoJCQkJcmV0dXJuOwoJCQl9CgoJCQlpZiAoYm9keSkgewoJCQkJYm9keS5jbGFzc0xpc3QucmVtb3ZlKCd2c2NvZGUtbGlnaHQnLCAndnNjb2RlLWRhcmsnLCAndnNjb2RlLWhpZ2gtY29udHJhc3QnLCAndnNjb2RlLWhpZ2gtY29udHJhc3QtbGlnaHQnLCAndnNjb2RlLXJlZHVjZS1tb3Rpb24nLCAndnNjb2RlLXVzaW5nLXNjcmVlbi1yZWFkZXInKTsKCgkJCQlpZiAoaW5pdERhdGEuYWN0aXZlVGhlbWUpIHsKCQkJCQlib2R5LmNsYXNzTGlzdC5hZGQoaW5pdERhdGEuYWN0aXZlVGhlbWUpOwoJCQkJCWlmIChpbml0RGF0YS5hY3RpdmVUaGVtZSA9PT0gJ3ZzY29kZS1oaWdoLWNvbnRyYXN0LWxpZ2h0JykgewoJCQkJCQkvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eQoJCQkJCQlib2R5LmNsYXNzTGlzdC5hZGQoJ3ZzY29kZS1oaWdoLWNvbnRyYXN0Jyk7CgkJCQkJfQoJCQkJfQoKCQkJCWlmIChpbml0RGF0YS5yZWR1Y2VNb3Rpb24pIHsKCQkJCQlib2R5LmNsYXNzTGlzdC5hZGQoJ3ZzY29kZS1yZWR1Y2UtbW90aW9uJyk7CgkJCQl9CgoJCQkJaWYgKGluaXREYXRhLnNjcmVlblJlYWRlcikgewoJCQkJCWJvZHkuY2xhc3NMaXN0LmFkZCgndnNjb2RlLXVzaW5nLXNjcmVlbi1yZWFkZXInKTsKCQkJCX0KCgkJCQlib2R5LmRhdGFzZXQudnNjb2RlVGhlbWVLaW5kID0gaW5pdERhdGEuYWN0aXZlVGhlbWU7CgkJCQkvKiogQGRlcHJlY2F0ZWQgZGF0YS12c2NvZGUtdGhlbWUtbmFtZSB3aWxsIGJlIHJlbW92ZWQsIHVzZSBkYXRhLXZzY29kZS10aGVtZS1pZCBpbnN0ZWFkICovCgkJCQlib2R5LmRhdGFzZXQudnNjb2RlVGhlbWVOYW1lID0gaW5pdERhdGEudGhlbWVMYWJlbCB8fCAnJzsKCQkJCWJvZHkuZGF0YXNldC52c2NvZGVUaGVtZUlkID0gaW5pdERhdGEudGhlbWVJZCB8fCAnJzsKCQkJfQoKCQkJaWYgKGluaXREYXRhLnN0eWxlcykgewoJCQkJY29uc3QgZG9jdW1lbnRTdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTsKCgkJCQkvLyBSZW1vdmUgc3RhbGUgcHJvcGVydGllcwoJCQkJZm9yIChsZXQgaSA9IGRvY3VtZW50U3R5bGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKCQkJCQljb25zdCBwcm9wZXJ0eSA9IGRvY3VtZW50U3R5bGVbaV07CgoJCQkJCS8vIERvbid0IHJlbW92ZSBwcm9wZXJ0aWVzIHRoYXQgdGhlIHdlYnZpZXcgbWlnaHQgaGF2ZSBhZGRlZCBzZXBhcmF0ZWx5CgkJCQkJaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LnN0YXJ0c1dpdGgoJy0tdnNjb2RlLScpKSB7CgkJCQkJCWRvY3VtZW50U3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpOwoJCQkJCX0KCQkJCX0KCgkJCQkvLyBSZS1hZGQgbmV3IHByb3BlcnRpZXMKCQkJCWZvciAoY29uc3QgW3ZhcmlhYmxlLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5pdERhdGEuc3R5bGVzKSkgewoJCQkJCWRvY3VtZW50U3R5bGUuc2V0UHJvcGVydHkoYC0tJHt2YXJpYWJsZX1gLCB2YWx1ZSk7CgkJCQl9CgkJCX0KCQl9OwoKCQkvKioKCQkgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50CgkJICovCgkJY29uc3QgaGFuZGxlSW5uZXJDbGljayA9IChldmVudCkgPT4gewoJCQlpZiAoIWV2ZW50Py52aWV3Py5kb2N1bWVudCkgewoJCQkJcmV0dXJuOwoJCQl9CgoJCQljb25zdCBiYXNlRWxlbWVudCA9IGV2ZW50LnZpZXcuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpOwoKCQkJZm9yIChjb25zdCBwYXRoRWxlbWVudCBvZiBldmVudC5jb21wb3NlZFBhdGgoKSkgewoJCQkJLyoqIEB0eXBlIHthbnl9ICovCgkJCQljb25zdCBub2RlID0gcGF0aEVsZW1lbnQ7CgkJCQlpZiAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScgJiYgbm9kZS5ocmVmKSB7CgkJCQkJaWYgKG5vZGUuZ2V0QXR0cmlidXRlKCdocmVmJykgPT09ICcjJykgewoJCQkJCQlldmVudC52aWV3LnNjcm9sbFRvKDAsIDApOwoJCQkJCX0gZWxzZSBpZiAobm9kZS5oYXNoICYmIChub2RlLmdldEF0dHJpYnV0ZSgnaHJlZicpID09PSBub2RlLmhhc2ggfHwgKGJhc2VFbGVtZW50ICYmIG5vZGUuaHJlZiA9PT0gYmFzZUVsZW1lbnQuaHJlZiArIG5vZGUuaGFzaCkpKSB7CgkJCQkJCWNvbnN0IGZyYWdtZW50ID0gbm9kZS5oYXNoLnNsaWNlKDEpOwoJCQkJCQljb25zdCBkZWNvZGVkRnJhZ21lbnQgPSBkZWNvZGVVUklDb21wb25lbnQoZnJhZ21lbnQpOwoJCQkJCQljb25zdCBzY3JvbGxUYXJnZXQgPSBldmVudC52aWV3LmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGZyYWdtZW50KSA/PyBldmVudC52aWV3LmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRlY29kZWRGcmFnbWVudCk7CgkJCQkJCWlmIChzY3JvbGxUYXJnZXQpIHsKCQkJCQkJCXNjcm9sbFRhcmdldC5zY3JvbGxJbnRvVmlldygpOwoJCQkJCQl9IGVsc2UgaWYgKGRlY29kZWRGcmFnbWVudC50b0xvd2VyQ2FzZSgpID09PSAndG9wJykgewoJCQkJCQkJZXZlbnQudmlldy5zY3JvbGxUbygwLCAwKTsKCQkJCQkJfQoJCQkJCX0gZWxzZSB7CgkJCQkJCWhvc3RNZXNzYWdpbmcucG9zdE1lc3NhZ2UoJ2RpZC1jbGljay1saW5rJywgeyB1cmk6IG5vZGUuaHJlZi5iYXNlVmFsIHx8IG5vZGUuaHJlZiB9KTsKCQkJCQl9CgkJCQkJZXZlbnQucHJldmVudERlZmF1bHQoKTsKCQkJCQlyZXR1cm47CgkJCQl9CgkJCX0KCQl9OwoKCQkvKioKCQkgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50CgkJICovCgkJY29uc3QgaGFuZGxlQXV4Q2xpY2sgPSAoZXZlbnQpID0+IHsKCQkJLy8gUHJldmVudCBtaWRkbGUgY2xpY2tzIG9wZW5pbmcgYSBicm9rZW4gbGluayBpbiB0aGUgYnJvd3NlcgoJCQlpZiAoIWV2ZW50Py52aWV3Py5kb2N1bWVudCkgewoJCQkJcmV0dXJuOwoJCQl9CgoJCQlpZiAoZXZlbnQuYnV0dG9uID09PSAxKSB7CgkJCQlmb3IgKGNvbnN0IHBhdGhFbGVtZW50IG9mIGV2ZW50LmNvbXBvc2VkUGF0aCgpKSB7CgkJCQkJLyoqIEB0eXBlIHthbnl9ICovCgkJCQkJY29uc3Qgbm9kZSA9IHBhdGhFbGVtZW50OwoJCQkJCWlmIChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJyAmJiBub2RlLmhyZWYpIHsKCQkJCQkJZXZlbnQucHJldmVudERlZmF1bHQoKTsKCQkJCQkJcmV0dXJuOwoJCQkJCX0KCQkJCX0KCQkJfQoJCX07CgoJCS8qKgoJCSAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZQoJCSAqLwoJCWNvbnN0IGhhbmRsZUlubmVyS2V5ZG93biA9IChlKSA9PiB7CgkJCS8vIElmIHRoZSBrZXlwcmVzcyB3b3VsZCB0cmlnZ2VyIGEgYnJvd3NlciBldmVudCwgc3VjaCBhcyBjb3B5IG9yIHBhc3RlLAoJCQkvLyBtYWtlIHN1cmUgd2UgYmxvY2sgdGhlIGJyb3dzZXIgZnJvbSBkaXNwYXRjaGluZyBpdC4gSW5zdGVhZCBWUyBDb2RlCgkJCS8vIGhhbmRsZXMgdGhlc2UgZXZlbnRzIGFuZCB3aWxsIGRpc3BhdGNoIGEgY29weS9wYXN0ZSBiYWNrIHRvIHRoZSB3ZWJ2aWV3CgkJCS8vIGlmIG5lZWRlZAoJCQlpZiAoaXNVbmRvUmVkbyhlKSB8fCBpc1ByaW50KGUpIHx8IGlzRmluZEV2ZW50KGUpIHx8IGlzU2F2ZUV2ZW50KGUpKSB7CgkJCQllLnByZXZlbnREZWZhdWx0KCk7CgkJCX0gZWxzZSBpZiAoaXNDb3B5UGFzdGVPckN1dChlKSkgewoJCQkJaWYgKG9uRWxlY3Ryb24pIHsKCQkJCQllLnByZXZlbnREZWZhdWx0KCk7CgkJCQl9IGVsc2UgewoJCQkJCXJldHVybjsgLy8gbGV0IHRoZSBicm93c2VyIGhhbmRsZSB0aGlzCgkJCQl9CgkJCX0gZWxzZSBpZiAoIW9uRWxlY3Ryb24gJiYgKGlzQ2xvc2VUYWIoZSkgfHwgaXNOZXdXaW5kb3coZSkpKSB7CgkJCQkvLyBQcmV2ZW50IEN0cmwrVyBjbG9zaW5nIHdpbmRvdyAvIEN0cmwrTiBvcGVuaW5nIG5ldyB3aW5kb3cgaW4gUFdBLgoJCQkJLy8gKE5vIGVmZmVjdCBpbiBhIHJlZ3VsYXIgYnJvd3NlciB0YWIuKQoJCQkJZS5wcmV2ZW50RGVmYXVsdCgpOwoJCQl9CgoJCQlob3N0TWVzc2FnaW5nLnBvc3RNZXNzYWdlKCdkaWQta2V5ZG93bicsIHsKCQkJCWtleTogZS5rZXksCgkJCQlrZXlDb2RlOiBlLmtleUNvZGUsCgkJCQljb2RlOiBlLmNvZGUsCgkJCQlzaGlmdEtleTogZS5zaGlmdEtleSwKCQkJCWFsdEtleTogZS5hbHRLZXksCgkJCQljdHJsS2V5OiBlLmN0cmxLZXksCgkJCQltZXRhS2V5OiBlLm1ldGFLZXksCgkJCQlyZXBlYXQ6IGUucmVwZWF0CgkJCX0pOwoJCX07CgkJLyoqCgkJICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlCgkJICovCgkJY29uc3QgaGFuZGxlSW5uZXJLZXl1cCA9IChlKSA9PiB7CgkJCWhvc3RNZXNzYWdpbmcucG9zdE1lc3NhZ2UoJ2RpZC1rZXl1cCcsIHsKCQkJCWtleTogZS5rZXksCgkJCQlrZXlDb2RlOiBlLmtleUNvZGUsCgkJCQljb2RlOiBlLmNvZGUsCgkJCQlzaGlmdEtleTogZS5zaGlmdEtleSwKCQkJCWFsdEtleTogZS5hbHRLZXksCgkJCQljdHJsS2V5OiBlLmN0cmxLZXksCgkJCQltZXRhS2V5OiBlLm1ldGFLZXksCgkJCQlyZXBlYXQ6IGUucmVwZWF0CgkJCX0pOwoJCX07CgoJCS8qKgoJCSAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZQoJCSAqIEByZXR1cm4ge2Jvb2xlYW59CgkJICovCgkJZnVuY3Rpb24gaXNDb3B5UGFzdGVPckN1dChlKSB7CgkJCWNvbnN0IGhhc01ldGEgPSBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5OwoJCQkvLyA0NToga2V5Q29kZSBvZiAiSW5zZXJ0IgoJCQljb25zdCBzaGlmdEluc2VydCA9IGUuc2hpZnRLZXkgJiYgZS5rZXlDb2RlID09PSA0NTsKCQkJLy8gNjcsIDg2LCA4ODoga2V5Q29kZSBvZiAiQyIsICJWIiwgIlgiCgkJCXJldHVybiAoaGFzTWV0YSAmJiBbNjcsIDg2LCA4OF0uaW5jbHVkZXMoZS5rZXlDb2RlKSkgfHwgc2hpZnRJbnNlcnQ7CgkJfQoKCQkvKioKCQkgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGUKCQkgKiBAcmV0dXJuIHtib29sZWFufQoJCSAqLwoJCWZ1bmN0aW9uIGlzVW5kb1JlZG8oZSkgewoJCQljb25zdCBoYXNNZXRhID0gZS5jdHJsS2V5IHx8IGUubWV0YUtleTsKCQkJLy8gOTAsIDg5OiBrZXlDb2RlIG9mICJaIiwgIlkiCgkJCXJldHVybiBoYXNNZXRhICYmIFs5MCwgODldLmluY2x1ZGVzKGUua2V5Q29kZSk7CgkJfQoKCQkvKioKCQkgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGUKCQkgKiBAcmV0dXJuIHtib29sZWFufQoJCSAqLwoJCWZ1bmN0aW9uIGlzUHJpbnQoZSkgewoJCQljb25zdCBoYXNNZXRhID0gZS5jdHJsS2V5IHx8IGUubWV0YUtleTsKCQkJLy8gODA6IGtleUNvZGUgb2YgIlAiCgkJCXJldHVybiBoYXNNZXRhICYmIGUua2V5Q29kZSA9PT0gODA7CgkJfQoKCQkvKioKCQkgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGUKCQkgKiBAcmV0dXJuIHtib29sZWFufQoJCSAqLwoJCWZ1bmN0aW9uIGlzRmluZEV2ZW50KGUpIHsKCQkJY29uc3QgaGFzTWV0YSA9IGUuY3RybEtleSB8fCBlLm1ldGFLZXk7CgkJCS8vIDcwOiBrZXlDb2RlIG9mICJGIgoJCQlyZXR1cm4gaGFzTWV0YSAmJiBlLmtleUNvZGUgPT09IDcwOwoJCX0KCgkJLyoqCgkJICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlCgkJICogQHJldHVybiB7Ym9vbGVhbn0KCQkgKi8KCQlmdW5jdGlvbiBpc1NhdmVFdmVudChlKSB7CgkJCWNvbnN0IGhhc01ldGEgPSBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5OwoJCQkvLyA4Mzoga2V5Q29kZSBvZiAiUyIKCQkJcmV0dXJuIGhhc01ldGEgJiYgZS5rZXlDb2RlID09PSA4MzsKCQl9CgoJCS8qKgoJCSAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZQoJCSAqIEByZXR1cm4ge2Jvb2xlYW59CgkJICovCgkJZnVuY3Rpb24gaXNDbG9zZVRhYihlKSB7CgkJCWNvbnN0IGhhc01ldGEgPSBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5OwoJCQkvLyA4Nzoga2V5Q29kZSBvZiAiVyIKCQkJcmV0dXJuIGhhc01ldGEgJiYgZS5rZXlDb2RlID09PSA4NzsKCQl9CgoJCS8qKgoJCSAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZQoJCSAqIEByZXR1cm4ge2Jvb2xlYW59CgkJICovCgkJZnVuY3Rpb24gaXNOZXdXaW5kb3coZSkgewoJCQljb25zdCBoYXNNZXRhID0gZS5jdHJsS2V5IHx8IGUubWV0YUtleTsKCQkJLy8gNzg6IGtleUNvZGUgb2YgIk4iCgkJCXJldHVybiBoYXNNZXRhICYmIGUua2V5Q29kZSA9PT0gNzg7CgkJfQoKCQlsZXQgaXNIYW5kbGluZ1Njcm9sbCA9IGZhbHNlOwoKCQkvKioKCQkgKiBAcGFyYW0ge1doZWVsRXZlbnR9IGV2ZW50CgkJICovCgkJY29uc3QgaGFuZGxlV2hlZWwgPSAoZXZlbnQpID0+IHsKCQkJaWYgKGlzSGFuZGxpbmdTY3JvbGwpIHsKCQkJCXJldHVybjsKCQkJfQoKCQkJaG9zdE1lc3NhZ2luZy5wb3N0TWVzc2FnZSgnZGlkLXNjcm9sbC13aGVlbCcsIHsKCQkJCWRlbHRhTW9kZTogZXZlbnQuZGVsdGFNb2RlLAoJCQkJZGVsdGFYOiBldmVudC5kZWx0YVgsCgkJCQlkZWx0YVk6IGV2ZW50LmRlbHRhWSwKCQkJCWRlbHRhWjogZXZlbnQuZGVsdGFaLAoJCQkJZGV0YWlsOiBldmVudC5kZXRhaWwsCgkJCQl0eXBlOiBldmVudC50eXBlCgkJCX0pOwoJCX07CgoJCS8qKgoJCSAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50CgkJICovCgkJY29uc3QgaGFuZGxlSW5uZXJTY3JvbGwgPSAoZXZlbnQpID0+IHsKCQkJaWYgKGlzSGFuZGxpbmdTY3JvbGwpIHsKCQkJCXJldHVybjsKCQkJfQoKCQkJY29uc3QgdGFyZ2V0ID0gLyoqIEB0eXBlIHtIVE1MRG9jdW1lbnQgfCBudWxsfSAqLyAoZXZlbnQudGFyZ2V0KTsKCQkJY29uc3QgY3VycmVudFRhcmdldCA9IC8qKiBAdHlwZSB7V2luZG93IHwgbnVsbH0gKi8gKGV2ZW50LmN1cnJlbnRUYXJnZXQpOwoJCQlpZiAoIWN1cnJlbnRUYXJnZXQgfHwgIXRhcmdldD8uYm9keSkgewoJCQkJcmV0dXJuOwoJCQl9CgoJCQljb25zdCBwcm9ncmVzcyA9IGN1cnJlbnRUYXJnZXQuc2Nyb2xsWSAvIHRhcmdldC5ib2R5LmNsaWVudEhlaWdodDsKCQkJaWYgKGlzTmFOKHByb2dyZXNzKSkgewoJCQkJcmV0dXJuOwoJCQl9CgoJCQlpc0hhbmRsaW5nU2Nyb2xsID0gdHJ1ZTsKCQkJd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7CgkJCQl0cnkgewoJCQkJCWhvc3RNZXNzYWdpbmcucG9zdE1lc3NhZ2UoJ2RpZC1zY3JvbGwnLCB7IHNjcm9sbFlQZXJjZW50YWdlOiBwcm9ncmVzcyB9KTsKCQkJCX0gY2F0Y2ggKGUpIHsKCQkJCQkvLyBub29wCgkJCQl9CgkJCQlpc0hhbmRsaW5nU2Nyb2xsID0gZmFsc2U7CgkJCX0pOwoJCX07CgoJCWZ1bmN0aW9uIGhhbmRsZUlubmVyRHJhZ1N0YXJ0RXZlbnQoLyoqIEB0eXBlIHtEcmFnRXZlbnR9ICovIGUpIHsKCQkJaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgewoJCQkJLy8gRXh0ZW5zaW9uIGNvZGUgaGFzIGFscmVhZHkgaGFuZGxlZCB0aGlzIGV2ZW50CgkJCQlyZXR1cm47CgkJCX0KCgkJCWlmICghZS5kYXRhVHJhbnNmZXIgfHwgZS5zaGlmdEtleSkgewoJCQkJcmV0dXJuOwoJCQl9CgoJCQkvLyBPbmx5IGhhbmRsZSBkcmFncyBmcm9tIG91dHNpZGUgZWRpdG9yIGZvciBub3cKCQkJaWYgKGUuZGF0YVRyYW5zZmVyLml0ZW1zLmxlbmd0aCAmJiBBcnJheS5wcm90b3R5cGUuZXZlcnkuY2FsbChlLmRhdGFUcmFuc2Zlci5pdGVtcywgaXRlbSA9PiBpdGVtLmtpbmQgPT09ICdmaWxlJykpIHsKCQkJCWhvc3RNZXNzYWdpbmcucG9zdE1lc3NhZ2UoJ2RyYWctc3RhcnQnLCB1bmRlZmluZWQpOwoJCQl9CgkJfQoKCQkvKioKCQkgKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrCgkJICovCgkJZnVuY3Rpb24gb25Eb21SZWFkeShjYWxsYmFjaykgewoJCQlpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7CgkJCQljYWxsYmFjaygpOwoJCQl9IGVsc2UgewoJCQkJZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGNhbGxiYWNrKTsKCQkJfQoJCX0KCgkJZnVuY3Rpb24gYXJlU2VydmljZVdvcmtlcnNFbmFibGVkKCkgewoJCQl0cnkgewoJCQkJcmV0dXJuICEhbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXI7CgkJCX0gY2F0Y2ggKGUpIHsKCQkJCXJldHVybiBmYWxzZTsKCQkJfQoJCX0KCgkJLyoqCgkJICogQHBhcmFtIHtpbXBvcnQoJy4uL3dlYnZpZXdNZXNzYWdlcycpLlVwZGF0ZUNvbnRlbnRFdmVudH0gZGF0YQoJCSAqIEByZXR1cm4ge3N0cmluZ30KCQkgKi8KCQlmdW5jdGlvbiB0b0NvbnRlbnRIdG1sKGRhdGEpIHsKCQkJY29uc3Qgb3B0aW9ucyA9IGRhdGEub3B0aW9uczsKCQkJY29uc3QgdGV4dCA9IGRhdGEuY29udGVudHM7CgkJCWNvbnN0IG5ld0RvY3VtZW50ID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCAndGV4dC9odG1sJyk7CgoJCQluZXdEb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhJykuZm9yRWFjaChhID0+IHsKCQkJCWlmICghYS50aXRsZSkgewoJCQkJCWNvbnN0IGhyZWYgPSBhLmdldEF0dHJpYnV0ZSgnaHJlZicpOwoJCQkJCWlmICh0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycpIHsKCQkJCQkJYS50aXRsZSA9IGhyZWY7CgkJCQkJfQoJCQkJfQoJCQl9KTsKCgkJCS8vIFNldCBkZWZhdWx0IGFyaWEgcm9sZQoJCQlpZiAoIW5ld0RvY3VtZW50LmJvZHkuaGFzQXR0cmlidXRlKCdyb2xlJykpIHsKCQkJCW5ld0RvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RvY3VtZW50Jyk7CgkJCX0KCgkJCS8vIEluamVjdCBkZWZhdWx0IHNjcmlwdAoJCQlpZiAob3B0aW9ucy5hbGxvd1NjcmlwdHMpIHsKCQkJCWNvbnN0IGRlZmF1bHRTY3JpcHQgPSBuZXdEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTsKCQkJCWRlZmF1bHRTY3JpcHQuaWQgPSAnX3ZzY29kZUFwaVNjcmlwdCc7CgkJCQlkZWZhdWx0U2NyaXB0LnRleHRDb250ZW50ID0gZ2V0VnNDb2RlQXBpU2NyaXB0KG9wdGlvbnMuYWxsb3dNdWx0aXBsZUFQSUFjcXVpcmUsIGRhdGEuc3RhdGUpOwoJCQkJbmV3RG9jdW1lbnQuaGVhZC5wcmVwZW5kKGRlZmF1bHRTY3JpcHQpOwoJCQl9CgoJCQkvLyBJbmplY3QgZGVmYXVsdCBzdHlsZXMKCQkJbmV3RG9jdW1lbnQuaGVhZC5wcmVwZW5kKGRlZmF1bHRTdHlsZXMuY2xvbmVOb2RlKHRydWUpKTsKCgkJCWFwcGx5U3R5bGVzKG5ld0RvY3VtZW50LCBuZXdEb2N1bWVudC5ib2R5KTsKCgkJCS8vIFN0cmlwIG91dCB1bnN1cHBvcnRlZCBodHRwLWVxdWl2IHRhZ3MKCQkJZm9yIChjb25zdCBtZXRhRWxlbWVudCBvZiBBcnJheS5mcm9tKG5ld0RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ21ldGEnKSkpIHsKCQkJCWNvbnN0IGh0dHBFcXVpdiA9IG1ldGFFbGVtZW50LmdldEF0dHJpYnV0ZSgnaHR0cC1lcXVpdicpOwoJCQkJaWYgKGh0dHBFcXVpdiAmJiAhL14oY29udGVudC1zZWN1cml0eS1wb2xpY3l8ZGVmYXVsdC1zdHlsZXxjb250ZW50LXR5cGUpJC9pLnRlc3QoaHR0cEVxdWl2KSkgewoJCQkJCWNvbnNvbGUud2FybihgUmVtb3ZpbmcgdW5zdXBwb3J0ZWQgbWV0YSBodHRwLWVxdWl2OiAke2h0dHBFcXVpdn1gKTsKCQkJCQltZXRhRWxlbWVudC5yZW1vdmUoKTsKCQkJCX0KCQkJfQoKCQkJLy8gQ2hlY2sgZm9yIENTUAoJCQljb25zdCBjc3AgPSBuZXdEb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW2h0dHAtZXF1aXY9IkNvbnRlbnQtU2VjdXJpdHktUG9saWN5Il0nKTsKCQkJaWYgKCFjc3ApIHsKCQkJCWhvc3RNZXNzYWdpbmcucG9zdE1lc3NhZ2UoJ25vLWNzcC1mb3VuZCcsIHVuZGVmaW5lZCk7CgkJCX0gZWxzZSB7CgkJCQl0cnkgewoJCQkJCS8vIEF0dGVtcHQgdG8gcmV3cml0ZSBDU1BzIHRoYXQgaGFyZGNvZGUgb2xkLXN0eWxlIHJlc291cmNlIGVuZHBvaW50CgkJCQkJY29uc3QgY3NwQ29udGVudCA9IGNzcC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKTsKCQkJCQlpZiAoY3NwQ29udGVudCkgewoJCQkJCQljb25zdCBuZXdDc3AgPSBjc3BDb250ZW50LnJlcGxhY2UoLyh2c2NvZGUtd2Vidmlldy1yZXNvdXJjZXx2c2NvZGUtcmVzb3VyY2UpOig/PShcc3w7fCQpKS9nLCBkYXRhLmNzcFNvdXJjZSk7CgkJCQkJCWNzcC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCBuZXdDc3ApOwoJCQkJCX0KCQkJCX0gY2F0Y2ggKGUpIHsKCQkJCQljb25zb2xlLmVycm9yKGBDb3VsZCBub3QgcmV3cml0ZSBjc3A6ICR7ZX1gKTsKCQkJCX0KCQkJfQoKCQkJLy8gc2V0IERPQ1RZUEUgZm9yIG5ld0RvY3VtZW50IGV4cGxpY2l0bHkgYXMgRE9NUGFyc2VyLnBhcnNlRnJvbVN0cmluZyBzdHJpcHMgaXQgb2ZmCgkJCS8vIGFuZCBET0NUWVBFIGlzIG5lZWRlZCBpbiB0aGUgaWZyYW1lIHRvIGVuc3VyZSB0aGF0IHRoZSB1c2VyIGFnZW50IHN0eWxlc2hlZXQgaXMgY29ycmVjdGx5IG92ZXJyaWRkZW4KCQkJcmV0dXJuICc8IURPQ1RZUEUgaHRtbD5cbicgKyBuZXdEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MOwoJCX0KCgkJLy8gQWxzbyBmb3J3YXJkIGV2ZW50cyBiZWZvcmUgdGhlIGNvbnRlbnRzIG9mIHRoZSB3ZWJ2aWV3IGhhdmUgbG9hZGVkCgkJd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVJbm5lcktleWRvd24pOwoJCXdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZUlubmVyS2V5dXApOwoJCXdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBoYW5kbGVJbm5lckRyYWdTdGFydEV2ZW50KTsKCQl3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBoYW5kbGVJbm5lckRyYWdTdGFydEV2ZW50KTsKCgkJb25Eb21SZWFkeSgoKSA9PiB7CgkJCWlmICghZG9jdW1lbnQuYm9keSkgewoJCQkJcmV0dXJuOwoJCQl9CgoJCQlob3N0TWVzc2FnaW5nLm9uTWVzc2FnZSgnc3R5bGVzJywgKF9ldmVudCwgZGF0YSkgPT4gewoJCQkJKytzdHlsZVZlcnNpb247CgoJCQkJaW5pdERhdGEuc3R5bGVzID0gZGF0YS5zdHlsZXM7CgkJCQlpbml0RGF0YS5hY3RpdmVUaGVtZSA9IGRhdGEuYWN0aXZlVGhlbWU7CgkJCQlpbml0RGF0YS50aGVtZUxhYmVsID0gZGF0YS50aGVtZUxhYmVsOwoJCQkJaW5pdERhdGEudGhlbWVJZCA9IGRhdGEudGhlbWVJZDsKCQkJCWluaXREYXRhLnJlZHVjZU1vdGlvbiA9IGRhdGEucmVkdWNlTW90aW9uOwoJCQkJaW5pdERhdGEuc2NyZWVuUmVhZGVyID0gZGF0YS5zY3JlZW5SZWFkZXI7CgoJCQkJY29uc3QgdGFyZ2V0ID0gZ2V0QWN0aXZlRnJhbWUoKTsKCQkJCWlmICghdGFyZ2V0KSB7CgkJCQkJcmV0dXJuOwoJCQkJfQoKCQkJCWlmICh0YXJnZXQuY29udGVudERvY3VtZW50KSB7CgkJCQkJYXBwbHlTdHlsZXModGFyZ2V0LmNvbnRlbnREb2N1bWVudCwgdGFyZ2V0LmNvbnRlbnREb2N1bWVudC5ib2R5KTsKCQkJCX0KCQkJfSk7CgoJCQkvLyBwcm9wYWdhdGUgZm9jdXMKCQkJaG9zdE1lc3NhZ2luZy5vbk1lc3NhZ2UoJ2ZvY3VzJywgKCkgPT4gewoJCQkJY29uc3QgYWN0aXZlRnJhbWUgPSBnZXRBY3RpdmVGcmFtZSgpOwoJCQkJaWYgKCFhY3RpdmVGcmFtZSB8fCAhYWN0aXZlRnJhbWUuY29udGVudFdpbmRvdykgewoJCQkJCS8vIEZvY3VzIHRoZSB0b3AgbGV2ZWwgd2VidmlldyBpbnN0ZWFkCgkJCQkJd2luZG93LmZvY3VzKCk7CgkJCQkJcmV0dXJuOwoJCQkJfQoKCQkJCWlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBhY3RpdmVGcmFtZSkgewoJCQkJCS8vIFdlIGFyZSBhbHJlYWR5IGZvY3VzZWQgb24gdGhlIGlmcmFtZSAob3Igb25lIG9mIGl0cyBjaGlsZHJlbikgc28gbm8gbmVlZAoJCQkJCS8vIHRvIHJlZm9jdXMuCgkJCQkJcmV0dXJuOwoJCQkJfQoKCQkJCWFjdGl2ZUZyYW1lLmNvbnRlbnRXaW5kb3cuZm9jdXMoKTsKCQkJfSk7CgoJCQkvLyB1cGRhdGUgaWZyYW1lLWNvbnRlbnRzCgkJCWxldCB1cGRhdGVJZCA9IDA7CgkJCWhvc3RNZXNzYWdpbmcub25NZXNzYWdlKCdjb250ZW50JywgYXN5bmMgKF9ldmVudCwgLyoqIEB0eXBlIHtpbXBvcnQoJy4uL3dlYnZpZXdNZXNzYWdlcycpLlVwZGF0ZUNvbnRlbnRFdmVudH0gKi8gZGF0YSkgPT4gewoJCQkJY29uc3QgY3VycmVudFVwZGF0ZUlkID0gKyt1cGRhdGVJZDsKCQkJCXRyeSB7CgkJCQkJYXdhaXQgd29ya2VyUmVhZHk7CgkJCQl9IGNhdGNoIChlKSB7CgkJCQkJY29uc29sZS5lcnJvcihgV2VidmlldyBmYXRhbCBlcnJvcjogJHtlfWApOwoJCQkJCWhvc3RNZXNzYWdpbmcucG9zdE1lc3NhZ2UoJ2ZhdGFsLWVycm9yJywgeyBtZXNzYWdlOiBlICsgJycgfSk7CgkJCQkJcmV0dXJuOwoJCQkJfQoKCQkJCWlmIChjdXJyZW50VXBkYXRlSWQgIT09IHVwZGF0ZUlkKSB7CgkJCQkJcmV0dXJuOwoJCQkJfQoKCQkJCWNvbnN0IG9wdGlvbnMgPSBkYXRhLm9wdGlvbnM7CgkJCQljb25zdCBuZXdEb2N1bWVudCA9IHRvQ29udGVudEh0bWwoZGF0YSk7CgoJCQkJY29uc3QgaW5pdGlhbFN0eWxlVmVyc2lvbiA9IHN0eWxlVmVyc2lvbjsKCgkJCQljb25zdCBmcmFtZSA9IGdldEFjdGl2ZUZyYW1lKCk7CgkJCQljb25zdCB3YXNGaXJzdExvYWQgPSBmaXJzdExvYWQ7CgkJCQkvLyBrZWVwIGN1cnJlbnQgc2Nyb2xsWSBhcm91bmQgYW5kIHVzZSBsYXRlcgoJCQkJLyoqIEB0eXBlIHsoYm9keTogSFRNTEVsZW1lbnQsIHdpbmRvdzogV2luZG93KSA9PiB2b2lkfSAqLwoJCQkJbGV0IHNldEluaXRpYWxTY3JvbGxQb3NpdGlvbjsKCQkJCWlmIChmaXJzdExvYWQpIHsKCQkJCQlmaXJzdExvYWQgPSBmYWxzZTsKCQkJCQlzZXRJbml0aWFsU2Nyb2xsUG9zaXRpb24gPSAoYm9keSwgd2luZG93KSA9PiB7CgkJCQkJCWlmICh0eXBlb2YgaW5pdERhdGEuaW5pdGlhbFNjcm9sbFByb2dyZXNzID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oaW5pdERhdGEuaW5pdGlhbFNjcm9sbFByb2dyZXNzKSkgewoJCQkJCQkJaWYgKHdpbmRvdy5zY3JvbGxZID09PSAwKSB7CgkJCQkJCQkJd2luZG93LnNjcm9sbCgwLCBib2R5LmNsaWVudEhlaWdodCAqIGluaXREYXRhLmluaXRpYWxTY3JvbGxQcm9ncmVzcyk7CgkJCQkJCQl9CgkJCQkJCX0KCQkJCQl9OwoJCQkJfSBlbHNlIHsKCQkJCQljb25zdCBzY3JvbGxZID0gZnJhbWUgJiYgZnJhbWUuY29udGVudERvY3VtZW50ICYmIGZyYW1lLmNvbnRlbnREb2N1bWVudC5ib2R5ID8gYXNzZXJ0SXNEZWZpbmVkKGZyYW1lLmNvbnRlbnRXaW5kb3cpLnNjcm9sbFkgOiAwOwoJCQkJCXNldEluaXRpYWxTY3JvbGxQb3NpdGlvbiA9IChib2R5LCB3aW5kb3cpID0+IHsKCQkJCQkJaWYgKHdpbmRvdy5zY3JvbGxZID09PSAwKSB7CgkJCQkJCQl3aW5kb3cuc2Nyb2xsKDAsIHNjcm9sbFkpOwoJCQkJCQl9CgkJCQkJfTsKCQkJCX0KCgkJCQkvLyBDbGVhbiB1cCBvbGQgcGVuZGluZyBmcmFtZXMgYW5kIHNldCBjdXJyZW50IG9uZSBhcyBuZXcgb25lCgkJCQljb25zdCBwcmV2aW91c1BlbmRpbmdGcmFtZSA9IGdldFBlbmRpbmdGcmFtZSgpOwoJCQkJaWYgKHByZXZpb3VzUGVuZGluZ0ZyYW1lKSB7CgkJCQkJcHJldmlvdXNQZW5kaW5nRnJhbWUuc2V0QXR0cmlidXRlKCdpZCcsICcnKTsKCQkJCQlkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHByZXZpb3VzUGVuZGluZ0ZyYW1lKTsKCQkJCX0KCQkJCWlmICghd2FzRmlyc3RMb2FkKSB7CgkJCQkJcGVuZGluZ01lc3NhZ2VzID0gW107CgkJCQl9CgoJCQkJY29uc3QgbmV3RnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTsKCQkJCW5ld0ZyYW1lLnRpdGxlID0gZGF0YS50aXRsZTsKCQkJCW5ld0ZyYW1lLnNldEF0dHJpYnV0ZSgnaWQnLCAncGVuZGluZy1mcmFtZScpOwoJCQkJbmV3RnJhbWUuc2V0QXR0cmlidXRlKCdmcmFtZWJvcmRlcicsICcwJyk7CgoJCQkJY29uc3Qgc2FuZGJveFJ1bGVzID0gbmV3IFNldChbJ2FsbG93LXNhbWUtb3JpZ2luJywgJ2FsbG93LXBvaW50ZXItbG9jayddKTsKCQkJCWlmIChvcHRpb25zLmFsbG93U2NyaXB0cykgewoJCQkJCXNhbmRib3hSdWxlcy5hZGQoJ2FsbG93LXNjcmlwdHMnKTsKCQkJCQlzYW5kYm94UnVsZXMuYWRkKCdhbGxvdy1kb3dubG9hZHMnKTsKCQkJCX0KCQkJCWlmIChvcHRpb25zLmFsbG93Rm9ybXMpIHsKCQkJCQlzYW5kYm94UnVsZXMuYWRkKCdhbGxvdy1mb3JtcycpOwoJCQkJfQoJCQkJbmV3RnJhbWUuc2V0QXR0cmlidXRlKCdzYW5kYm94JywgQXJyYXkuZnJvbShzYW5kYm94UnVsZXMpLmpvaW4oJyAnKSk7CgoJCQkJY29uc3QgYWxsb3dSdWxlcyA9IFsnY3Jvc3Mtb3JpZ2luLWlzb2xhdGVkOycsICdhdXRvcGxheTsnXTsKCQkJCWlmICghaXNGaXJlZm94ICYmIG9wdGlvbnMuYWxsb3dTY3JpcHRzKSB7CgkJCQkJYWxsb3dSdWxlcy5wdXNoKCdjbGlwYm9hcmQtcmVhZDsnLCAnY2xpcGJvYXJkLXdyaXRlOycpOwoJCQkJfQoJCQkJbmV3RnJhbWUuc2V0QXR0cmlidXRlKCdhbGxvdycsIGFsbG93UnVsZXMuam9pbignICcpKTsKCQkJCS8vIFdlIHNob3VsZCBqdXN0IGJlIGFibGUgdG8gdXNlIHNyY2RvYywgYnV0IEkgd2Fzbid0CgkJCQkvLyBzZWVpbmcgdGhlIHNlcnZpY2Ugd29ya2VyIGFwcGx5aW5nIHByb3Blcmx5LgoJCQkJLy8gRmFrZSBsb2FkIGFuIGVtcHR5IG9uIHRoZSBjb3JyZWN0IG9yaWdpbiBhbmQgdGhlbiB3cml0ZSByZWFsIGh0bWwKCQkJCS8vIGludG8gaXQgdG8gZ2V0IGFyb3VuZCB0aGlzLgoJCQkJY29uc3QgZmFrZVVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBpZDogSUQgfSk7CgkJCQlpZiAoZ2xvYmFsVGhpcy5jcm9zc09yaWdpbklzb2xhdGVkKSB7CgkJCQkJZmFrZVVybFBhcmFtcy5zZXQoJ3ZzY29kZS1jb2knLCAnMycpOyAvKkNPT1ArQ09FUCovCgkJCQl9CgkJCQluZXdGcmFtZS5zcmMgPSBgJHtmYWtlSHRtbFVyaX0/JHtmYWtlVXJsUGFyYW1zLnRvU3RyaW5nKCl9YDsKCgkJCQluZXdGcmFtZS5zdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6IGJsb2NrOyBtYXJnaW46IDA7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgdmlzaWJpbGl0eTogaGlkZGVuJzsKCQkJCWRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobmV3RnJhbWUpOwoKCQkJCW5ld0ZyYW1lLmNvbnRlbnRXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUlubmVyS2V5ZG93bik7CgkJCQluZXdGcmFtZS5jb250ZW50V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgaGFuZGxlSW5uZXJLZXl1cCk7CgoJCQkJLyoqCgkJCQkgKiBAcGFyYW0ge0RvY3VtZW50fSBjb250ZW50RG9jdW1lbnQKCQkJCSAqLwoJCQkJZnVuY3Rpb24gb25GcmFtZUxvYWRlZChjb250ZW50RG9jdW1lbnQpIHsKCQkJCQkvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05NzgzMjUKCQkJCQlzZXRUaW1lb3V0KCgpID0+IHsKCQkJCQkJY29udGVudERvY3VtZW50Lm9wZW4oKTsKCQkJCQkJY29udGVudERvY3VtZW50LndyaXRlKG5ld0RvY3VtZW50KTsKCQkJCQkJY29udGVudERvY3VtZW50LmNsb3NlKCk7CgkJCQkJCWhvb2t1cE9uTG9hZEhhbmRsZXJzKG5ld0ZyYW1lKTsKCgkJCQkJCWlmIChpbml0aWFsU3R5bGVWZXJzaW9uICE9PSBzdHlsZVZlcnNpb24pIHsKCQkJCQkJCWFwcGx5U3R5bGVzKGNvbnRlbnREb2N1bWVudCwgY29udGVudERvY3VtZW50LmJvZHkpOwoJCQkJCQl9CgkJCQkJfSwgMCk7CgkJCQl9CgoJCQkJaWYgKCFvcHRpb25zLmFsbG93U2NyaXB0cyAmJiBpc1NhZmFyaSkgewoJCQkJCS8vIE9uIFNhZmFyaSBmb3IgaWZyYW1lcyB3aXRoIHNjcmlwdHMgZGlzYWJsZWQsIHRoZSBgRE9NQ29udGVudExvYWRlZGAgbmV2ZXIgc2VlbXMgdG8gYmUgZmlyZWQ6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0zMzYwNAoJCQkJCS8vIFVzZSBwb2xsaW5nIGluc3RlYWQuCgkJCQkJY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7CgkJCQkJCS8vIElmIHRoZSBmcmFtZSBpcyBubyBsb25nZXIgbW91bnRlZCwgbG9hZGluZyBoYXMgc3RvcHBlZAoJCQkJCQlpZiAoIW5ld0ZyYW1lLnBhcmVudEVsZW1lbnQpIHsKCQkJCQkJCWNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpOwoJCQkJCQkJcmV0dXJuOwoJCQkJCQl9CgoJCQkJCQljb25zdCBjb250ZW50RG9jdW1lbnQgPSBhc3NlcnRJc0RlZmluZWQobmV3RnJhbWUuY29udGVudERvY3VtZW50KTsKCQkJCQkJaWYgKGNvbnRlbnREb2N1bWVudC5sb2NhdGlvbi5wYXRobmFtZS5lbmRzV2l0aCgnL2Zha2UuaHRtbCcpICYmIGNvbnRlbnREb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnbG9hZGluZycpIHsKCQkJCQkJCWNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpOwoJCQkJCQkJb25GcmFtZUxvYWRlZChjb250ZW50RG9jdW1lbnQpOwoJCQkJCQl9CgkJCQkJfSwgMTApOwoJCQkJfSBlbHNlIHsKCQkJCQlhc3NlcnRJc0RlZmluZWQobmV3RnJhbWUuY29udGVudFdpbmRvdykuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGUgPT4gewoJCQkJCQljb25zdCBjb250ZW50RG9jdW1lbnQgPSBlLnRhcmdldCA/ICgvKiogQHR5cGUge0hUTUxEb2N1bWVudH0gKi8gKGUudGFyZ2V0KSkgOiB1bmRlZmluZWQ7CgkJCQkJCW9uRnJhbWVMb2FkZWQoYXNzZXJ0SXNEZWZpbmVkKGNvbnRlbnREb2N1bWVudCkpOwoJCQkJCX0pOwoJCQkJfQoKCQkJCS8qKgoJCQkJICogQHBhcmFtIHtEb2N1bWVudH0gY29udGVudERvY3VtZW50CgkJCQkgKiBAcGFyYW0ge1dpbmRvd30gY29udGVudFdpbmRvdwoJCQkJICovCgkJCQljb25zdCBvbkxvYWQgPSAoY29udGVudERvY3VtZW50LCBjb250ZW50V2luZG93KSA9PiB7CgkJCQkJaWYgKGNvbnRlbnREb2N1bWVudCAmJiBjb250ZW50RG9jdW1lbnQuYm9keSkgewoJCQkJCQkvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L3ZzY29kZS9pc3N1ZXMvMTI4NjUKCQkJCQkJLy8gY2hlY2sgbmV3IHNjcm9sbFkgYW5kIHJlc2V0IGlmIG5lY2Vzc2FyeQoJCQkJCQlzZXRJbml0aWFsU2Nyb2xsUG9zaXRpb24oY29udGVudERvY3VtZW50LmJvZHksIGNvbnRlbnRXaW5kb3cpOwoJCQkJCX0KCgkJCQkJY29uc3QgbmV3RnJhbWUgPSBnZXRQZW5kaW5nRnJhbWUoKTsKCQkJCQlpZiAobmV3RnJhbWUgJiYgbmV3RnJhbWUuY29udGVudERvY3VtZW50ICYmIG5ld0ZyYW1lLmNvbnRlbnREb2N1bWVudCA9PT0gY29udGVudERvY3VtZW50KSB7CgkJCQkJCWNvbnN0IHdhc0ZvY3VzZWQgPSBkb2N1bWVudC5oYXNGb2N1cygpOwoJCQkJCQljb25zdCBvbGRBY3RpdmVGcmFtZSA9IGdldEFjdGl2ZUZyYW1lKCk7CgkJCQkJCWlmIChvbGRBY3RpdmVGcmFtZSkgewoJCQkJCQkJZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvbGRBY3RpdmVGcmFtZSk7CgkJCQkJCX0KCQkJCQkJLy8gU3R5bGVzIG1heSBoYXZlIGNoYW5nZWQgc2luY2Ugd2UgY3JlYXRlZCB0aGUgZWxlbWVudC4gTWFrZSBzdXJlIHdlIHJlLXN0eWxlCgkJCQkJCWlmIChpbml0aWFsU3R5bGVWZXJzaW9uICE9PSBzdHlsZVZlcnNpb24pIHsKCQkJCQkJCWFwcGx5U3R5bGVzKG5ld0ZyYW1lLmNvbnRlbnREb2N1bWVudCwgbmV3RnJhbWUuY29udGVudERvY3VtZW50LmJvZHkpOwoJCQkJCQl9CgkJCQkJCW5ld0ZyYW1lLnNldEF0dHJpYnV0ZSgnaWQnLCAnYWN0aXZlLWZyYW1lJyk7CgkJCQkJCW5ld0ZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7CgoJCQkJCQljb250ZW50V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZUlubmVyU2Nyb2xsKTsKCQkJCQkJY29udGVudFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGhhbmRsZVdoZWVsKTsKCgkJCQkJCWlmICh3YXNGb2N1c2VkKSB7CgkJCQkJCQljb250ZW50V2luZG93LmZvY3VzKCk7CgkJCQkJCX0KCgkJCQkJCXBlbmRpbmdNZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlKSA9PiB7CgkJCQkJCQljb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2UubWVzc2FnZSwgd2luZG93Lm9yaWdpbiwgbWVzc2FnZS50cmFuc2Zlcik7CgkJCQkJCX0pOwoJCQkJCQlwZW5kaW5nTWVzc2FnZXMgPSBbXTsKCQkJCQl9CgkJCQl9OwoKCQkJCS8qKgoJCQkJICogQHBhcmFtIHtIVE1MSUZyYW1lRWxlbWVudH0gbmV3RnJhbWUKCQkJCSAqLwoJCQkJZnVuY3Rpb24gaG9va3VwT25Mb2FkSGFuZGxlcnMobmV3RnJhbWUpIHsKCQkJCQljbGVhclRpbWVvdXQobG9hZFRpbWVvdXQpOwoJCQkJCWxvYWRUaW1lb3V0ID0gdW5kZWZpbmVkOwoJCQkJCWxvYWRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7CgkJCQkJCWNsZWFyVGltZW91dChsb2FkVGltZW91dCk7CgkJCQkJCWxvYWRUaW1lb3V0ID0gdW5kZWZpbmVkOwoJCQkJCQlvbkxvYWQoYXNzZXJ0SXNEZWZpbmVkKG5ld0ZyYW1lLmNvbnRlbnREb2N1bWVudCksIGFzc2VydElzRGVmaW5lZChuZXdGcmFtZS5jb250ZW50V2luZG93KSk7CgkJCQkJfSwgMjAwKTsKCgkJCQkJY29uc3QgY29udGVudFdpbmRvdyA9IGFzc2VydElzRGVmaW5lZChuZXdGcmFtZS5jb250ZW50V2luZG93KTsKCgkJCQkJY29udGVudFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKGUpIHsKCQkJCQkJY29uc3QgY29udGVudERvY3VtZW50ID0gLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKGUudGFyZ2V0KTsKCgkJCQkJCWlmIChsb2FkVGltZW91dCkgewoJCQkJCQkJY2xlYXJUaW1lb3V0KGxvYWRUaW1lb3V0KTsKCQkJCQkJCWxvYWRUaW1lb3V0ID0gdW5kZWZpbmVkOwoJCQkJCQkJb25Mb2FkKGNvbnRlbnREb2N1bWVudCwgdGhpcyk7CgkJCQkJCX0KCQkJCQl9KTsKCgkJCQkJLy8gQnViYmxlIG91dCB2YXJpb3VzIGV2ZW50cwoJCQkJCWNvbnRlbnRXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVJbm5lckNsaWNrKTsKCQkJCQljb250ZW50V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2F1eGNsaWNrJywgaGFuZGxlQXV4Q2xpY2spOwoJCQkJCWNvbnRlbnRXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUlubmVyS2V5ZG93bik7CgkJCQkJY29udGVudFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZUlubmVyS2V5dXApOwoJCQkJCWNvbnRlbnRXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBlID0+IHsKCQkJCQkJaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgewoJCQkJCQkJLy8gRXh0ZW5zaW9uIGNvZGUgaGFzIGFscmVhZHkgaGFuZGxlZCB0aGlzIGV2ZW50CgkJCQkJCQlyZXR1cm47CgkJCQkJCX0KCgkJCQkJCWUucHJldmVudERlZmF1bHQoKTsKCgkJCQkJCS8qKiBAdHlwZSB7IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+fSAqLwoJCQkJCQlsZXQgY29udGV4dCA9IHt9OwoKCQkJCQkJLyoqIEB0eXBlIHtIVE1MRWxlbWVudCB8IG51bGx9ICovCgkJCQkJCWxldCBlbCA9IGUudGFyZ2V0OwoJCQkJCQl3aGlsZSAodHJ1ZSkgewoJCQkJCQkJaWYgKCFlbCkgewoJCQkJCQkJCWJyZWFrOwoJCQkJCQkJfQoKCQkJCQkJCS8vIFNlYXJjaCBzZWxmL2FuY2VzdG9ycyBmb3IgdGhlIGNsb3Nlc3QgY29udGV4dCBkYXRhIGF0dHJpYnV0ZQoJCQkJCQkJZWwgPSBlbC5jbG9zZXN0KCdbZGF0YS12c2NvZGUtY29udGV4dF0nKTsKCQkJCQkJCWlmICghZWwpIHsKCQkJCQkJCQlicmVhazsKCQkJCQkJCX0KCgkJCQkJCQl0cnkgewoJCQkJCQkJCWNvbnRleHQgPSB7IC4uLkpTT04ucGFyc2UoZWwuZGF0YXNldC52c2NvZGVDb250ZXh0KSwgLi4uY29udGV4dCB9OwoJCQkJCQkJfSBjYXRjaCAoZSkgewoJCQkJCQkJCWNvbnNvbGUuZXJyb3IoYEVycm9yIHBhcnNpbmcgJ2RhdGEtdnNjb2RlLWNvbnRleHQnIGFzIGpzb25gLCBlbCwgZSk7CgkJCQkJCQl9CgoJCQkJCQkJZWwgPSBlbC5wYXJlbnRFbGVtZW50OwoJCQkJCQl9CgoJCQkJCQlob3N0TWVzc2FnaW5nLnBvc3RNZXNzYWdlKCdkaWQtY29udGV4dC1tZW51JywgewoJCQkJCQkJY2xpZW50WDogZS5jbGllbnRYLAoJCQkJCQkJY2xpZW50WTogZS5jbGllbnRZLAoJCQkJCQkJY29udGV4dDogY29udGV4dAoJCQkJCQl9KTsKCQkJCQl9KTsKCgkJCQkJY29udGVudFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBoYW5kbGVJbm5lckRyYWdTdGFydEV2ZW50KTsKCQkJCQljb250ZW50V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgaGFuZGxlSW5uZXJEcmFnU3RhcnRFdmVudCk7CgoJCQkJCXVubG9hZE1vbml0b3Iub25JZnJhbWVMb2FkZWQobmV3RnJhbWUpOwoJCQkJfQoJCQl9KTsKCgkJCS8vIHByb3BhZ2F0ZSB2c2NvZGUtY29udGV4dC1tZW51LXZpc2libGUgY2xhc3MKCQkJaG9zdE1lc3NhZ2luZy5vbk1lc3NhZ2UoJ3NldC1jb250ZXh0LW1lbnUtdmlzaWJsZScsIChfZXZlbnQsIGRhdGEpID0+IHsKCQkJCWNvbnN0IHRhcmdldCA9IGdldEFjdGl2ZUZyYW1lKCk7CgkJCQlpZiAodGFyZ2V0ICYmIHRhcmdldC5jb250ZW50RG9jdW1lbnQpIHsKCQkJCQl0YXJnZXQuY29udGVudERvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnRvZ2dsZSgndnNjb2RlLWNvbnRleHQtbWVudS12aXNpYmxlJywgZGF0YS52aXNpYmxlKTsKCQkJCX0KCQkJfSk7CgoJCQlob3N0TWVzc2FnaW5nLm9uTWVzc2FnZSgnc2V0LXRpdGxlJywgYXN5bmMgKF9ldmVudCwgZGF0YSkgPT4gewoJCQkJY29uc3QgdGFyZ2V0ID0gZ2V0QWN0aXZlRnJhbWUoKTsKCQkJCWlmICh0YXJnZXQpIHsKCQkJCQl0YXJnZXQudGl0bGUgPSBkYXRhOwoJCQkJfQoJCQl9KTsKCgkJCS8vIEZvcndhcmQgbWVzc2FnZSB0byB0aGUgZW1iZWRkZWQgaWZyYW1lCgkJCWhvc3RNZXNzYWdpbmcub25NZXNzYWdlKCdtZXNzYWdlJywgKF9ldmVudCwgZGF0YSkgPT4gewoJCQkJY29uc3QgcGVuZGluZyA9IGdldFBlbmRpbmdGcmFtZSgpOwoJCQkJaWYgKCFwZW5kaW5nKSB7CgkJCQkJY29uc3QgdGFyZ2V0ID0gZ2V0QWN0aXZlRnJhbWUoKTsKCQkJCQlpZiAodGFyZ2V0KSB7CgkJCQkJCWFzc2VydElzRGVmaW5lZCh0YXJnZXQuY29udGVudFdpbmRvdykucG9zdE1lc3NhZ2UoZGF0YS5tZXNzYWdlLCB3aW5kb3cub3JpZ2luLCBkYXRhLnRyYW5zZmVyKTsKCQkJCQkJcmV0dXJuOwoJCQkJCX0KCQkJCX0KCQkJCXBlbmRpbmdNZXNzYWdlcy5wdXNoKGRhdGEpOwoJCQl9KTsKCgkJCWhvc3RNZXNzYWdpbmcub25NZXNzYWdlKCdpbml0aWFsLXNjcm9sbC1wb3NpdGlvbicsIChfZXZlbnQsIHByb2dyZXNzKSA9PiB7CgkJCQlpbml0RGF0YS5pbml0aWFsU2Nyb2xsUHJvZ3Jlc3MgPSBwcm9ncmVzczsKCQkJfSk7CgoJCQlob3N0TWVzc2FnaW5nLm9uTWVzc2FnZSgnZXhlY0NvbW1hbmQnLCAoX2V2ZW50LCBkYXRhKSA9PiB7CgkJCQljb25zdCB0YXJnZXQgPSBnZXRBY3RpdmVGcmFtZSgpOwoJCQkJaWYgKCF0YXJnZXQpIHsKCQkJCQlyZXR1cm47CgkJCQl9CgkJCQlhc3NlcnRJc0RlZmluZWQodGFyZ2V0LmNvbnRlbnREb2N1bWVudCkuZXhlY0NvbW1hbmQoZGF0YSk7CgkJCX0pOwoKCQkJLyoqIEB0eXBlIHtzdHJpbmcgfCB1bmRlZmluZWR9ICovCgkJCWxldCBsYXN0RmluZFZhbHVlID0gdW5kZWZpbmVkOwoKCQkJaG9zdE1lc3NhZ2luZy5vbk1lc3NhZ2UoJ2ZpbmQnLCAoX2V2ZW50LCBkYXRhKSA9PiB7CgkJCQljb25zdCB0YXJnZXQgPSBnZXRBY3RpdmVGcmFtZSgpOwoJCQkJaWYgKCF0YXJnZXQpIHsKCQkJCQlyZXR1cm47CgkJCQl9CgoJCQkJaWYgKCFkYXRhLnByZXZpb3VzICYmIGxhc3RGaW5kVmFsdWUgIT09IGRhdGEudmFsdWUgJiYgdGFyZ2V0LmNvbnRlbnRXaW5kb3cpIHsKCQkJCQkvLyBSZXNldCBzZWxlY3Rpb24gc28gd2Ugc3RhcnQgc2VhcmNoIGF0IHRoZSBoZWFkIG9mIHRoZSBsYXN0IHNlYXJjaAoJCQkJCWNvbnN0IHNlbGVjdGlvbiA9IHRhcmdldC5jb250ZW50V2luZG93LmdldFNlbGVjdGlvbigpOwoJCQkJCWlmIChzZWxlY3Rpb24pIHsKCQkJCQkJc2VsZWN0aW9uLmNvbGxhcHNlKHNlbGVjdGlvbi5hbmNob3JOb2RlKTsKCQkJCQl9CgkJCQl9CgkJCQlsYXN0RmluZFZhbHVlID0gZGF0YS52YWx1ZTsKCgkJCQljb25zdCBkaWRGaW5kID0gKC8qKiBAdHlwZSB7YW55fSAqLyAodGFyZ2V0LmNvbnRlbnRXaW5kb3cpKS5maW5kKAoJCQkJCWRhdGEudmFsdWUsCgkJCQkJLyogY2FzZVNlbnNpdGl2ZSovIGZhbHNlLAoJCQkJCS8qIGJhY2t3YXJkcyovIGRhdGEucHJldmlvdXMsCgkJCQkJLyogd3JhcEFyb3VuZCovIHRydWUsCgkJCQkJLyogd2hvbGVXb3JkICovIGZhbHNlLAoJCQkJCS8qIHNlYXJjaEluRnJhbWVzKi8gZmFsc2UsCgkJCQkJZmFsc2UpOwoJCQkJaG9zdE1lc3NhZ2luZy5wb3N0TWVzc2FnZSgnZGlkLWZpbmQnLCBkaWRGaW5kKTsKCQkJfSk7CgoJCQlob3N0TWVzc2FnaW5nLm9uTWVzc2FnZSgnZmluZC1zdG9wJywgKF9ldmVudCwgZGF0YSkgPT4gewoJCQkJY29uc3QgdGFyZ2V0ID0gZ2V0QWN0aXZlRnJhbWUoKTsKCQkJCWlmICghdGFyZ2V0KSB7CgkJCQkJcmV0dXJuOwoJCQkJfQoKCQkJCWxhc3RGaW5kVmFsdWUgPSB1bmRlZmluZWQ7CgoJCQkJaWYgKCFkYXRhLmNsZWFyU2VsZWN0aW9uICYmIHRhcmdldC5jb250ZW50V2luZG93KSB7CgkJCQkJY29uc3Qgc2VsZWN0aW9uID0gdGFyZ2V0LmNvbnRlbnRXaW5kb3cuZ2V0U2VsZWN0aW9uKCk7CgkJCQkJaWYgKHNlbGVjdGlvbikgewoJCQkJCQlmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGlvbi5yYW5nZUNvdW50OyBpKyspIHsKCQkJCQkJCXNlbGVjdGlvbi5yZW1vdmVSYW5nZShzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKSk7CgkJCQkJCX0KCQkJCQl9CgkJCQl9CgkJCX0pOwoKCQkJdHJhY2tGb2N1cyh7CgkJCQlvbkZvY3VzOiAoKSA9PiBob3N0TWVzc2FnaW5nLnBvc3RNZXNzYWdlKCdkaWQtZm9jdXMnLCB1bmRlZmluZWQpLAoJCQkJb25CbHVyOiAoKSA9PiBob3N0TWVzc2FnaW5nLnBvc3RNZXNzYWdlKCdkaWQtYmx1cicsIHVuZGVmaW5lZCkKCQkJfSk7CgoJCQkoLyoqIEB0eXBlIHthbnl9ICovICh3aW5kb3cpKVt2c2NvZGVQb3N0TWVzc2FnZUZ1bmNOYW1lXSA9ICgvKiogQHR5cGUge3N0cmluZ30gKi8gY29tbWFuZCwgLyoqIEB0eXBlIHthbnl9ICovIGRhdGEpID0+IHsKCQkJCXN3aXRjaCAoY29tbWFuZCkgewoJCQkJCWNhc2UgJ29ubWVzc2FnZSc6CgkJCQkJY2FzZSAnZG8tdXBkYXRlLXN0YXRlJzoKCQkJCQkJaG9zdE1lc3NhZ2luZy5wb3N0TWVzc2FnZShjb21tYW5kLCBkYXRhKTsKCQkJCQkJYnJlYWs7CgkJCQl9CgkJCX07CgoJCQlob3N0TWVzc2FnaW5nLnNpZ25hbFJlYWR5KCk7CgkJfSk7Cgk8L3NjcmlwdD4KPC9ib2R5PgoKPC9odG1sPgo=", self.location).href, Oo),
  "vs/workbench/contrib/webview/browser/pre/index-no-csp.html": () => Os(new URL("data:text/html;base64,PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIiBzdHlsZT0id2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsiPgoKPGhlYWQ+Cgk8bWV0YSBjaGFyc2V0PSJVVEYtOCI+CgoJPCEtLSBEaXNhYmxlIHBpbmNoIHpvb21pbmcgLS0+Cgk8bWV0YSBuYW1lPSJ2aWV3cG9ydCIKCQljb250ZW50PSJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MS4wLCBtYXhpbXVtLXNjYWxlPTEuMCwgbWluaW11bS1zY2FsZT0xLjAsIHVzZXItc2NhbGFibGU9bm8iPgo8L2hlYWQ+Cgo8Ym9keSBzdHlsZT0ibWFyZ2luOiAwOyBvdmVyZmxvdzogaGlkZGVuOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlIiByb2xlPSJkb2N1bWVudCI+Cgk8IS0tIFRPRE86IFJlbW92ZSBhZGRpdGlvbmFsIHNjcmlwdCB0YWcgb25jZSBGaXJlZm94IGlzIGZpeGVkIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE3Mzc4ODIgLS0+Cgk8c2NyaXB0Pjwvc2NyaXB0PgoJPHNjcmlwdCBhc3luYyB0eXBlPSJtb2R1bGUiPgoJCS8vIEB0cy1jaGVjawoJCS8vLyA8cmVmZXJlbmNlIGxpYj0iZG9tIiAvPgoKCQljb25zdCBpc1NhZmFyaSA9ICgKCQkJbmF2aWdhdG9yLnZlbmRvciAmJiBuYXZpZ2F0b3IudmVuZG9yLmluZGV4T2YoJ0FwcGxlJykgPiAtMSAmJgoJCQluYXZpZ2F0b3IudXNlckFnZW50ICYmCgkJCW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ3JpT1MnKSA9PT0gLTEgJiYKCQkJbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGeGlPUycpID09PSAtMQoJCSk7CgoJCWNvbnN0IGlzRmlyZWZveCA9ICgKCQkJbmF2aWdhdG9yLnVzZXJBZ2VudCAmJgoJCQluYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+PSAwCgkJKTsKCgkJY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTChsb2NhdGlvbi50b1N0cmluZygpKS5zZWFyY2hQYXJhbXM7CgkJY29uc3QgSUQgPSBzZWFyY2hQYXJhbXMuZ2V0KCdpZCcpOwoJCWNvbnN0IHdlYnZpZXdPcmlnaW4gPSBzZWFyY2hQYXJhbXMuZ2V0KCdvcmlnaW4nKTsKCQljb25zdCBvbkVsZWN0cm9uID0gc2VhcmNoUGFyYW1zLmdldCgncGxhdGZvcm0nKSA9PT0gJ2VsZWN0cm9uJzsKCQljb25zdCBkaXNhYmxlU2VydmljZVdvcmtlciA9IHNlYXJjaFBhcmFtcy5oYXMoJ2Rpc2FibGVTZXJ2aWNlV29ya2VyJyk7CgkJY29uc3QgZXhwZWN0ZWRXb3JrZXJWZXJzaW9uID0gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldCgnc3dWZXJzaW9uJykpOwoJCWNvbnN0IHNlcnZpY2VXb3JrZXJVcmkgPSBzZWFyY2hQYXJhbXMuZ2V0KCdzZXJ2aWNlV29ya2VyVXJpJyk7CgkJY29uc3QgZmFrZUh0bWxVcmkgPSBzZWFyY2hQYXJhbXMuZ2V0KCdmYWtlSHRtbFVyaScpOwoKCQkvKioKCQkgKiBVc2UgcG9sbGluZyB0byB0cmFjayBmb2N1cyBvZiBtYWluIHdlYnZpZXcgYW5kIGlmcmFtZXMgd2l0aGluIHRoZSB3ZWJ2aWV3CgkJICoKCQkgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlcnMKCQkgKiBAcGFyYW0geygpID0+IHZvaWR9IGhhbmRsZXJzLm9uRm9jdXMKCQkgKiBAcGFyYW0geygpID0+IHZvaWR9IGhhbmRsZXJzLm9uQmx1cgoJCSAqLwoJCWNvbnN0IHRyYWNrRm9jdXMgPSAoeyBvbkZvY3VzLCBvbkJsdXIgfSkgPT4gewoJCQljb25zdCBpbnRlcnZhbCA9IDI1MDsKCQkJbGV0IGlzRm9jdXNlZCA9IGRvY3VtZW50Lmhhc0ZvY3VzKCk7CgkJCXNldEludGVydmFsKCgpID0+IHsKCQkJCWNvbnN0IGlzQ3VycmVudGx5Rm9jdXNlZCA9IGRvY3VtZW50Lmhhc0ZvY3VzKCk7CgkJCQlpZiAoaXNDdXJyZW50bHlGb2N1c2VkID09PSBpc0ZvY3VzZWQpIHsKCQkJCQlyZXR1cm47CgkJCQl9CgkJCQlpc0ZvY3VzZWQgPSBpc0N1cnJlbnRseUZvY3VzZWQ7CgkJCQlpZiAoaXNDdXJyZW50bHlGb2N1c2VkKSB7CgkJCQkJb25Gb2N1cygpOwoJCQkJfSBlbHNlIHsKCQkJCQlvbkJsdXIoKTsKCQkJCX0KCQkJfSwgaW50ZXJ2YWwpOwoJCX07CgoJCWNvbnN0IGdldEFjdGl2ZUZyYW1lID0gKCkgPT4gewoJCQlyZXR1cm4gLyoqIEB0eXBlIHtIVE1MSUZyYW1lRWxlbWVudCB8IHVuZGVmaW5lZH0gKi8gKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhY3RpdmUtZnJhbWUnKSk7CgkJfTsKCgkJY29uc3QgZ2V0UGVuZGluZ0ZyYW1lID0gKCkgPT4gewoJCQlyZXR1cm4gLyoqIEB0eXBlIHtIVE1MSUZyYW1lRWxlbWVudCB8IHVuZGVmaW5lZH0gKi8gKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwZW5kaW5nLWZyYW1lJykpOwoJCX07CgoJCS8qKgoJCSAqIEB0ZW1wbGF0ZSBUCgkJICogQHBhcmFtIHtUIHwgdW5kZWZpbmVkIHwgbnVsbH0gb2JqCgkJICogQHJldHVybiB7VH0KCQkgKi8KCQlmdW5jdGlvbiBhc3NlcnRJc0RlZmluZWQob2JqKSB7CgkJCWlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyB8fCBvYmogPT09IG51bGwpIHsKCQkJCXRocm93IG5ldyBFcnJvcignRm91bmQgdW5leHBlY3RlZCBudWxsJyk7CgkJCX0KCQkJcmV0dXJuIG9iajsKCQl9CgoJCWNvbnN0IHZzY29kZVBvc3RNZXNzYWdlRnVuY05hbWUgPSAnX192c2NvZGVfcG9zdF9tZXNzYWdlX18nOwoKCQljb25zdCBkZWZhdWx0U3R5bGVzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTsKCQlkZWZhdWx0U3R5bGVzLmlkID0gJ19kZWZhdWx0U3R5bGVzJzsKCQlkZWZhdWx0U3R5bGVzLnRleHRDb250ZW50ID0gYAoJCQlodG1sIHsKCQkJCXNjcm9sbGJhci1jb2xvcjogdmFyKC0tdnNjb2RlLXNjcm9sbGJhclNsaWRlci1iYWNrZ3JvdW5kKSB2YXIoLS12c2NvZGUtZWRpdG9yLWJhY2tncm91bmQpOwoJCQl9CgoJCQlib2R5IHsKCQkJCWJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OwoJCQkJY29sb3I6IHZhcigtLXZzY29kZS1lZGl0b3ItZm9yZWdyb3VuZCk7CgkJCQlmb250LWZhbWlseTogdmFyKC0tdnNjb2RlLWZvbnQtZmFtaWx5KTsKCQkJCWZvbnQtd2VpZ2h0OiB2YXIoLS12c2NvZGUtZm9udC13ZWlnaHQpOwoJCQkJZm9udC1zaXplOiB2YXIoLS12c2NvZGUtZm9udC1zaXplKTsKCQkJCW1hcmdpbjogMDsKCQkJCXBhZGRpbmc6IDAgMjBweDsKCQkJfQoKCQkJaW1nLCB2aWRlbyB7CgkJCQltYXgtd2lkdGg6IDEwMCU7CgkJCQltYXgtaGVpZ2h0OiAxMDAlOwoJCQl9CgoJCQlhLCBhIGNvZGUgewoJCQkJY29sb3I6IHZhcigtLXZzY29kZS10ZXh0TGluay1mb3JlZ3JvdW5kKTsKCQkJfQoKCQkJYTpob3ZlciB7CgkJCQljb2xvcjogdmFyKC0tdnNjb2RlLXRleHRMaW5rLWFjdGl2ZUZvcmVncm91bmQpOwoJCQl9CgoJCQlhOmZvY3VzLAoJCQlpbnB1dDpmb2N1cywKCQkJc2VsZWN0OmZvY3VzLAoJCQl0ZXh0YXJlYTpmb2N1cyB7CgkJCQlvdXRsaW5lOiAxcHggc29saWQgLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yOwoJCQkJb3V0bGluZS1vZmZzZXQ6IC0xcHg7CgkJCX0KCgkJCWNvZGUgewoJCQkJY29sb3I6IHZhcigtLXZzY29kZS10ZXh0UHJlZm9ybWF0LWZvcmVncm91bmQpOwoJCQl9CgoJCQlibG9ja3F1b3RlIHsKCQkJCWJhY2tncm91bmQ6IHZhcigtLXZzY29kZS10ZXh0QmxvY2tRdW90ZS1iYWNrZ3JvdW5kKTsKCQkJCWJvcmRlci1jb2xvcjogdmFyKC0tdnNjb2RlLXRleHRCbG9ja1F1b3RlLWJvcmRlcik7CgkJCX0KCgkJCWtiZCB7CgkJCQliYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS12c2NvZGUta2V5YmluZGluZ0xhYmVsLWJhY2tncm91bmQpOwoJCQkJY29sb3I6IHZhcigtLXZzY29kZS1rZXliaW5kaW5nTGFiZWwtZm9yZWdyb3VuZCk7CgkJCQlib3JkZXItc3R5bGU6IHNvbGlkOwoJCQkJYm9yZGVyLXdpZHRoOiAxcHg7CgkJCQlib3JkZXItcmFkaXVzOiAzcHg7CgkJCQlib3JkZXItY29sb3I6IHZhcigtLXZzY29kZS1rZXliaW5kaW5nTGFiZWwtYm9yZGVyKTsKCQkJCWJvcmRlci1ib3R0b20tY29sb3I6IHZhcigtLXZzY29kZS1rZXliaW5kaW5nTGFiZWwtYm90dG9tQm9yZGVyKTsKCQkJCWJveC1zaGFkb3c6IGluc2V0IDAgLTFweCAwIHZhcigtLXZzY29kZS13aWRnZXQtc2hhZG93KTsKCQkJCXZlcnRpY2FsLWFsaWduOiBtaWRkbGU7CgkJCQlwYWRkaW5nOiAxcHggM3B4OwoJCQl9CgoJCQk6Oi13ZWJraXQtc2Nyb2xsYmFyIHsKCQkJCXdpZHRoOiAxMHB4OwoJCQkJaGVpZ2h0OiAxMHB4OwoJCQl9CgoJCQk6Oi13ZWJraXQtc2Nyb2xsYmFyLWNvcm5lciB7CgkJCQliYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS12c2NvZGUtZWRpdG9yLWJhY2tncm91bmQpOwoJCQl9CgoJCQk6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iIHsKCQkJCWJhY2tncm91bmQtY29sb3I6IHZhcigtLXZzY29kZS1zY3JvbGxiYXJTbGlkZXItYmFja2dyb3VuZCk7CgkJCX0KCQkJOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjpob3ZlciB7CgkJCQliYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS12c2NvZGUtc2Nyb2xsYmFyU2xpZGVyLWhvdmVyQmFja2dyb3VuZCk7CgkJCX0KCQkJOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjphY3RpdmUgewoJCQkJYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdnNjb2RlLXNjcm9sbGJhclNsaWRlci1hY3RpdmVCYWNrZ3JvdW5kKTsKCQkJfQoJCQk6OmhpZ2hsaWdodChmaW5kLWhpZ2hsaWdodCkgewoJCQkJYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdnNjb2RlLWVkaXRvci1maW5kTWF0Y2hIaWdobGlnaHRCYWNrZ3JvdW5kKTsKCQkJfQoJCQk6OmhpZ2hsaWdodChjdXJyZW50LWZpbmQtaGlnaGxpZ2h0KSB7CgkJCQliYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS12c2NvZGUtZWRpdG9yLWZpbmRNYXRjaEJhY2tncm91bmQpOwoJCQl9YDsKCgkJLyoqCgkJICogQHBhcmFtIHtib29sZWFufSBhbGxvd011bHRpcGxlQVBJQWNxdWlyZQoJCSAqIEBwYXJhbSB7Kn0gW3N0YXRlXQoJCSAqIEByZXR1cm4ge3N0cmluZ30KCQkgKi8KCQlmdW5jdGlvbiBnZXRWc0NvZGVBcGlTY3JpcHQoYWxsb3dNdWx0aXBsZUFQSUFjcXVpcmUsIHN0YXRlKSB7CgkJCWNvbnN0IGVuY29kZWRTdGF0ZSA9IHN0YXRlID8gZW5jb2RlVVJJQ29tcG9uZW50KHN0YXRlKSA6IHVuZGVmaW5lZDsKCQkJcmV0dXJuIC8qIGpzICovYAoJCQkJCWdsb2JhbFRoaXMuYWNxdWlyZVZzQ29kZUFwaSA9IChmdW5jdGlvbigpIHsKCQkJCQkJY29uc3Qgb3JpZ2luYWxQb3N0TWVzc2FnZSA9IHdpbmRvdy5wYXJlbnRbJyR7dnNjb2RlUG9zdE1lc3NhZ2VGdW5jTmFtZX0nXS5iaW5kKHdpbmRvdy5wYXJlbnQpOwoJCQkJCQljb25zdCBkb1Bvc3RNZXNzYWdlID0gKGNoYW5uZWwsIGRhdGEsIHRyYW5zZmVyKSA9PiB7CgkJCQkJCQlvcmlnaW5hbFBvc3RNZXNzYWdlKGNoYW5uZWwsIGRhdGEsIHRyYW5zZmVyKTsKCQkJCQkJfTsKCgkJCQkJCWxldCBhY3F1aXJlZCA9IGZhbHNlOwoKCQkJCQkJbGV0IHN0YXRlID0gJHtzdGF0ZSA/IGBKU09OLnBhcnNlKGRlY29kZVVSSUNvbXBvbmVudCgiJHtlbmNvZGVkU3RhdGV9IikpYCA6IHVuZGVmaW5lZH07CgoJCQkJCQlyZXR1cm4gKCkgPT4gewoJCQkJCQkJaWYgKGFjcXVpcmVkICYmICEke2FsbG93TXVsdGlwbGVBUElBY3F1aXJlfSkgewoJCQkJCQkJCXRocm93IG5ldyBFcnJvcignQW4gaW5zdGFuY2Ugb2YgdGhlIFZTIENvZGUgQVBJIGhhcyBhbHJlYWR5IGJlZW4gYWNxdWlyZWQnKTsKCQkJCQkJCX0KCQkJCQkJCWFjcXVpcmVkID0gdHJ1ZTsKCQkJCQkJCXJldHVybiBPYmplY3QuZnJlZXplKHsKCQkJCQkJCQlwb3N0TWVzc2FnZTogZnVuY3Rpb24obWVzc2FnZSwgdHJhbnNmZXIpIHsKCQkJCQkJCQkJZG9Qb3N0TWVzc2FnZSgnb25tZXNzYWdlJywgeyBtZXNzYWdlLCB0cmFuc2ZlciB9LCB0cmFuc2Zlcik7CgkJCQkJCQkJfSwKCQkJCQkJCQlzZXRTdGF0ZTogZnVuY3Rpb24obmV3U3RhdGUpIHsKCQkJCQkJCQkJc3RhdGUgPSBuZXdTdGF0ZTsKCQkJCQkJCQkJZG9Qb3N0TWVzc2FnZSgnZG8tdXBkYXRlLXN0YXRlJywgSlNPTi5zdHJpbmdpZnkobmV3U3RhdGUpKTsKCQkJCQkJCQkJcmV0dXJuIG5ld1N0YXRlOwoJCQkJCQkJCX0sCgkJCQkJCQkJZ2V0U3RhdGU6IGZ1bmN0aW9uKCkgewoJCQkJCQkJCQlyZXR1cm4gc3RhdGU7CgkJCQkJCQkJfQoJCQkJCQkJfSk7CgkJCQkJCX07CgkJCQkJfSkoKTsKCQkJCQlkZWxldGUgd2luZG93LnBhcmVudDsKCQkJCQlkZWxldGUgd2luZG93LnRvcDsKCQkJCQlkZWxldGUgd2luZG93LmZyYW1lRWxlbWVudDsKCQkJCWA7CgkJfQoKCQkvKiogQHR5cGUge1Byb21pc2U8dm9pZD59ICovCgkJY29uc3Qgd29ya2VyUmVhZHkgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7CgkJCWlmIChkaXNhYmxlU2VydmljZVdvcmtlcikgewoJCQkJcmV0dXJuIHJlc29sdmUoKTsKCQkJfQoKCQkJaWYgKCFhcmVTZXJ2aWNlV29ya2Vyc0VuYWJsZWQoKSkgewoJCQkJcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ1NlcnZpY2UgV29ya2VycyBhcmUgbm90IGVuYWJsZWQuIFdlYnZpZXdzIHdpbGwgbm90IHdvcmsuIFRyeSBkaXNhYmxpbmcgcHJpdmF0ZS9pbmNvZ25pdG8gbW9kZS4nKSk7CgkJCX0KCgkJCWNvbnN0IHN3UGF0aCA9IGVuY29kZVVSSShgJHtzZXJ2aWNlV29ya2VyVXJpfT92PSR7ZXhwZWN0ZWRXb3JrZXJWZXJzaW9ufSZ2c2NvZGUtcmVzb3VyY2UtYmFzZS1hdXRob3JpdHk9JHtzZWFyY2hQYXJhbXMuZ2V0KCd2c2NvZGUtcmVzb3VyY2UtYmFzZS1hdXRob3JpdHknKX0mcmVtb3RlQXV0aG9yaXR5PSR7c2VhcmNoUGFyYW1zLmdldCgncmVtb3RlQXV0aG9yaXR5JykgPz8gJyd9YCk7CgkJCW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKHN3UGF0aCkKCQkJCS50aGVuKGFzeW5jIHJlZ2lzdHJhdGlvbiA9PiB7CgkJCQkJLyoqCgkJCQkJICogQHBhcmFtIHtNZXNzYWdlRXZlbnR9IGV2ZW50CgkJCQkJICovCgkJCQkJY29uc3QgdmVyc2lvbkhhbmRsZXIgPSBhc3luYyAoZXZlbnQpID0+IHsKCQkJCQkJaWYgKGV2ZW50LmRhdGEuY2hhbm5lbCAhPT0gJ3ZlcnNpb24nKSB7CgkJCQkJCQlyZXR1cm47CgkJCQkJCX0KCgkJCQkJCW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB2ZXJzaW9uSGFuZGxlcik7CgkJCQkJCWlmIChldmVudC5kYXRhLnZlcnNpb24gPT09IGV4cGVjdGVkV29ya2VyVmVyc2lvbikgewoJCQkJCQkJcmV0dXJuIHJlc29sdmUoKTsKCQkJCQkJfSBlbHNlIHsKCQkJCQkJCWNvbnNvbGUubG9nKGBGb3VuZCB1bmV4cGVjdGVkIHNlcnZpY2Ugd29ya2VyIHZlcnNpb24uIEZvdW5kOiAke2V2ZW50LmRhdGEudmVyc2lvbn0uIEV4cGVjdGVkOiAke2V4cGVjdGVkV29ya2VyVmVyc2lvbn1gKTsKCQkJCQkJCWNvbnNvbGUubG9nKGBBdHRlbXB0aW5nIHRvIHJlbG9hZCBzZXJ2aWNlIHdvcmtlcmApOwoKCQkJCQkJCS8vIElmIHdlIGhhdmUgdGhlIHdyb25nIHZlcnNpb24sIHRyeSBvbmNlIChhbmQgb25seSBvbmNlKSB0byB1bnJlZ2lzdGVyIGFuZCByZS1yZWdpc3RlcgoJCQkJCQkJLy8gTm90ZSB0aGF0IGAudXBkYXRlYCBkb2Vzbid0IHNlZW0gdG8gd29yayBkZXNrdG9wIGVsZWN0cm9uIGF0IHRoZSBtb21lbnQgc28gd2UgdXNlCgkJCQkJCQkvLyBgdW5yZWdpc3RlcmAgYW5kIGByZWdpc3RlcmAgaGVyZS4KCQkJCQkJCXJldHVybiByZWdpc3RyYXRpb24udW5yZWdpc3RlcigpCgkJCQkJCQkJLnRoZW4oKCkgPT4gbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVnaXN0ZXIoc3dQYXRoKSkKCQkJCQkJCQkuZmluYWxseSgoKSA9PiB7IHJlc29sdmUoKTsgfSk7CgkJCQkJCX0KCQkJCQl9OwoJCQkJCW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB2ZXJzaW9uSGFuZGxlcik7CgoJCQkJCWNvbnN0IHBvc3RWZXJzaW9uTWVzc2FnZSA9ICgvKiogQHR5cGUge1NlcnZpY2VXb3JrZXJ9ICovIGNvbnRyb2xsZXIpID0+IHsKCQkJCQkJY29udHJvbGxlci5wb3N0TWVzc2FnZSh7IGNoYW5uZWw6ICd2ZXJzaW9uJyB9KTsKCQkJCQl9OwoKCQkJCQkvLyBBdCB0aGlzIHBvaW50LCBlaXRoZXIgdGhlIHNlcnZpY2Ugd29ya2VyIGlzIHJlYWR5IGFuZAoJCQkJCS8vIGJlY2FtZSBvdXIgY29udHJvbGxlciwgb3Igd2UgbmVlZCB0byB3YWl0IGZvciBpdC4KCQkJCQkvLyBOb3RlIHRoYXQgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlciBjb3VsZCBiZSBhCgkJCQkJLy8gY29udHJvbGxlciBmcm9tIGEgcHJldmlvdXNseSBsb2FkZWQgc2VydmljZSB3b3JrZXIuCgkJCQkJY29uc3QgY3VycmVudENvbnRyb2xsZXIgPSBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyOwoJCQkJCWlmIChjdXJyZW50Q29udHJvbGxlcj8uc2NyaXB0VVJMLmVuZHNXaXRoKHN3UGF0aCkpIHsKCQkJCQkJLy8gc2VydmljZSB3b3JrZXIgYWxyZWFkeSBsb2FkZWQgJiByZWFkeSB0byByZWNlaXZlIG1lc3NhZ2VzCgkJCQkJCXBvc3RWZXJzaW9uTWVzc2FnZShjdXJyZW50Q29udHJvbGxlcik7CgkJCQkJfSBlbHNlIHsKCQkJCQkJaWYgKGN1cnJlbnRDb250cm9sbGVyKSB7CgkJCQkJCQljb25zb2xlLmxvZyhgRm91bmQgdW5leHBlY3RlZCBzZXJ2aWNlIHdvcmtlciBjb250cm9sbGVyLiBGb3VuZDogJHtjdXJyZW50Q29udHJvbGxlci5zY3JpcHRVUkx9LiBFeHBlY3RlZDogJHtzd1BhdGh9LiBXYWl0aW5nIGZvciBjb250cm9sbGVyY2hhbmdlLmApOwoJCQkJCQl9IGVsc2UgewoJCQkJCQkJY29uc29sZS5sb2coYE5vIHNlcnZpY2Ugd29ya2VyIGNvbnRyb2xsZXIgZm91bmQuIFdhaXRpbmcgZm9yIGNvbnRyb2xsZXJjaGFuZ2UuYCk7CgkJCQkJCX0KCgkJCQkJCS8vIEVpdGhlciB0aGVyZSdzIG5vIGNvbnRyb2xsaW5nIHNlcnZpY2Ugd29ya2VyLCBvciBpdCdzIGFuIG9sZCBvbmUuCgkJCQkJCS8vIFdhaXQgZm9yIGl0IHRvIGNoYW5nZSBiZWZvcmUgcG9zdGluZyB0aGUgbWVzc2FnZQoJCQkJCQljb25zdCBvbkNvbnRyb2xsZXJDaGFuZ2UgPSAoKSA9PiB7CgkJCQkJCQluYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250cm9sbGVyY2hhbmdlJywgb25Db250cm9sbGVyQ2hhbmdlKTsKCQkJCQkJCWlmIChuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyKSB7CgkJCQkJCQkJcG9zdFZlcnNpb25NZXNzYWdlKG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIpOwoJCQkJCQkJfSBlbHNlIHsKCQkJCQkJCQlyZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTm8gY29udHJvbGxlciBmb3VuZC4nKSk7CgkJCQkJCQl9CgkJCQkJCX07CgkJCQkJCW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRyb2xsZXJjaGFuZ2UnLCBvbkNvbnRyb2xsZXJDaGFuZ2UpOwoJCQkJCX0KCQkJCX0pLmNhdGNoKGVycm9yID0+IHsKCQkJCQlpZiAoIW9uRWxlY3Ryb24gJiYgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCd1c2VyIGRlbmllZCBwZXJtaXNzaW9uJykpIHsKCQkJCQkJcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYENvdWxkIG5vdCByZWdpc3RlciBzZXJ2aWNlIHdvcmtlci4gUGxlYXNlIG1ha2Ugc3VyZSB0aGlyZCBwYXJ0eSBjb29raWVzIGFyZSBlbmFibGVkOiAke2Vycm9yfWApKTsKCQkJCQl9CgkJCQkJcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYENvdWxkIG5vdCByZWdpc3RlciBzZXJ2aWNlIHdvcmtlcjogJHtlcnJvcn0uYCkpOwoJCQkJfSk7CgkJfSk7CgoJCS8qKgoJCSAqICBAdHlwZSB7aW1wb3J0KCcuLi93ZWJ2aWV3TWVzc2FnZXMnKS5XZWJ2aWV3SG9zdE1lc3NhZ2luZ30KCQkgKi8KCQljb25zdCBob3N0TWVzc2FnaW5nID0gbmV3IGNsYXNzIEhvc3RNZXNzYWdpbmcgewoKCQkJY29uc3RydWN0b3IoKSB7CgkJCQl0aGlzLmNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTsKCgkJCQkvKiogQHR5cGUge01hcDxzdHJpbmcsIEFycmF5PChldmVudDogTWVzc2FnZUV2ZW50LCBkYXRhOiBhbnkpID0+IHZvaWQ+Pn0gKi8KCQkJCXRoaXMuaGFuZGxlcnMgPSBuZXcgTWFwKCk7CgoJCQkJdGhpcy5jaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IChlKSA9PiB7CgkJCQkJY29uc3QgY2hhbm5lbCA9IGUuZGF0YS5jaGFubmVsOwoJCQkJCWNvbnN0IGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycy5nZXQoY2hhbm5lbCk7CgkJCQkJaWYgKGhhbmRsZXJzKSB7CgkJCQkJCWZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykgewoJCQkJCQkJaGFuZGxlcihlLCBlLmRhdGEuYXJncyk7CgkJCQkJCX0KCQkJCQl9IGVsc2UgewoJCQkJCQljb25zb2xlLmxvZygnbm8gaGFuZGxlciBmb3IgJywgZSk7CgkJCQkJfQoJCQkJfTsKCQkJfQoKCQkJcG9zdE1lc3NhZ2UoY2hhbm5lbCwgZGF0YSwgdHJhbnNmZXIpIHsKCQkJCXRoaXMuY2hhbm5lbC5wb3J0MS5wb3N0TWVzc2FnZSh7IGNoYW5uZWwsIGRhdGEgfSwgdHJhbnNmZXIpOwoJCQl9CgoJCQlvbk1lc3NhZ2UoY2hhbm5lbCwgaGFuZGxlcikgewoJCQkJbGV0IGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycy5nZXQoY2hhbm5lbCk7CgkJCQlpZiAoIWhhbmRsZXJzKSB7CgkJCQkJaGFuZGxlcnMgPSBbXTsKCQkJCQl0aGlzLmhhbmRsZXJzLnNldChjaGFubmVsLCBoYW5kbGVycyk7CgkJCQl9CgkJCQloYW5kbGVycy5wdXNoKGhhbmRsZXIpOwoJCQl9CgoJCQlhc3luYyBzaWduYWxSZWFkeSgpIHsKCQkJCWNvbnN0IHN0YXJ0ID0gKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyBwYXJlbnRPcmlnaW4pID0+IHsKCQkJCQl3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKHsgdGFyZ2V0OiBJRCwgY2hhbm5lbDogJ3dlYnZpZXctcmVhZHknLCBkYXRhOiB7fSB9LCBwYXJlbnRPcmlnaW4sIFt0aGlzLmNoYW5uZWwucG9ydDJdKTsKCQkJCX07CgoJCQkJY29uc3QgcGFyZW50T3JpZ2luID0gc2VhcmNoUGFyYW1zLmdldCgncGFyZW50T3JpZ2luJyk7CgoJCQkJcmV0dXJuIHN0YXJ0KHBhcmVudE9yaWdpbik7CgkJCX0KCQl9KCk7CgoJCWNvbnN0IHVubG9hZE1vbml0b3IgPSBuZXcgY2xhc3MgewoKCQkJY29uc3RydWN0b3IoKSB7CgkJCQl0aGlzLmNvbmZpcm1CZWZvcmVDbG9zZSA9ICdrZXlib2FyZE9ubHknOwoJCQkJdGhpcy5pc01vZGlmaWVyS2V5RG93biA9IGZhbHNlOwoKCQkJCWhvc3RNZXNzYWdpbmcub25NZXNzYWdlKCdzZXQtY29uZmlybS1iZWZvcmUtY2xvc2UnLCAoX2UsIGRhdGEpID0+IHsKCQkJCQl0aGlzLmNvbmZpcm1CZWZvcmVDbG9zZSA9IGRhdGE7CgkJCQl9KTsKCgkJCQlob3N0TWVzc2FnaW5nLm9uTWVzc2FnZSgnY29udGVudCcsIChfZSwgZGF0YSkgPT4gewoJCQkJCXRoaXMuY29uZmlybUJlZm9yZUNsb3NlID0gZGF0YS5jb25maXJtQmVmb3JlQ2xvc2U7CgkJCQl9KTsKCgkJCQl3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgKGV2ZW50KSA9PiB7CgkJCQkJaWYgKG9uRWxlY3Ryb24pIHsKCQkJCQkJcmV0dXJuOwoJCQkJCX0KCgkJCQkJc3dpdGNoICh0aGlzLmNvbmZpcm1CZWZvcmVDbG9zZSkgewoJCQkJCQljYXNlICdhbHdheXMnOiB7CgkJCQkJCQlldmVudC5wcmV2ZW50RGVmYXVsdCgpOwoJCQkJCQkJZXZlbnQucmV0dXJuVmFsdWUgPSAnJzsKCQkJCQkJCXJldHVybiAnJzsKCQkJCQkJfQoJCQkJCQljYXNlICduZXZlcic6IHsKCQkJCQkJCWJyZWFrOwoJCQkJCQl9CgkJCQkJCWNhc2UgJ2tleWJvYXJkT25seSc6CgkJCQkJCWRlZmF1bHQ6IHsKCQkJCQkJCWlmICh0aGlzLmlzTW9kaWZpZXJLZXlEb3duKSB7CgkJCQkJCQkJZXZlbnQucHJldmVudERlZmF1bHQoKTsKCQkJCQkJCQlldmVudC5yZXR1cm5WYWx1ZSA9ICcnOwoJCQkJCQkJCXJldHVybiAnJzsKCQkJCQkJCX0KCQkJCQkJCWJyZWFrOwoJCQkJCQl9CgkJCQkJfQoJCQkJfSk7CgkJCX0KCgkJCW9uSWZyYW1lTG9hZGVkKC8qKiBAdHlwZSB7SFRNTElGcmFtZUVsZW1lbnR9ICovIGZyYW1lKSB7CgkJCQlhc3NlcnRJc0RlZmluZWQoZnJhbWUuY29udGVudFdpbmRvdykuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGUgPT4gewoJCQkJCXRoaXMuaXNNb2RpZmllcktleURvd24gPSBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuYWx0S2V5OwoJCQkJfSk7CgoJCQkJYXNzZXJ0SXNEZWZpbmVkKGZyYW1lLmNvbnRlbnRXaW5kb3cpLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKCkgPT4gewoJCQkJCXRoaXMuaXNNb2RpZmllcktleURvd24gPSBmYWxzZTsKCQkJCX0pOwoJCQl9CgkJfTsKCgkJLy8gc3RhdGUKCQlsZXQgZmlyc3RMb2FkID0gdHJ1ZTsKCQkvKiogQHR5cGUge2FueX0gKi8KCQlsZXQgbG9hZFRpbWVvdXQ7CgkJbGV0IHN0eWxlVmVyc2lvbiA9IDA7CgoJCS8qKiBAdHlwZSB7QXJyYXk8eyByZWFkb25seSBtZXNzYWdlOiBhbnksIHRyYW5zZmVyPzogQXJyYXlCdWZmZXJbXSB9Pn0gKi8KCQlsZXQgcGVuZGluZ01lc3NhZ2VzID0gW107CgoJCWNvbnN0IGluaXREYXRhID0gewoJCQkvKiogQHR5cGUge251bWJlciB8IHVuZGVmaW5lZH0gKi8KCQkJaW5pdGlhbFNjcm9sbFByb2dyZXNzOiB1bmRlZmluZWQsCgoJCQkvKiogQHR5cGUge3sgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gfCB1bmRlZmluZWR9ICovCgkJCXN0eWxlczogdW5kZWZpbmVkLAoKCQkJLyoqIEB0eXBlIHtzdHJpbmcgfCB1bmRlZmluZWR9ICovCgkJCWFjdGl2ZVRoZW1lOiB1bmRlZmluZWQsCgoJCQkvKiogQHR5cGUge3N0cmluZyB8IHVuZGVmaW5lZH0gKi8KCQkJdGhlbWVJZDogdW5kZWZpbmVkLAoKCQkJLyoqIEB0eXBlIHtzdHJpbmcgfCB1bmRlZmluZWR9ICovCgkJCXRoZW1lTGFiZWw6IHVuZGVmaW5lZCwKCgkJCS8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8KCQkJc2NyZWVuUmVhZGVyOiBmYWxzZSwKCgkJCS8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8KCQkJcmVkdWNlTW90aW9uOiBmYWxzZSwKCQl9OwoKCQlpZiAoIWRpc2FibGVTZXJ2aWNlV29ya2VyKSB7CgkJCWhvc3RNZXNzYWdpbmcub25NZXNzYWdlKCdkaWQtbG9hZC1yZXNvdXJjZScsIChfZXZlbnQsIGRhdGEpID0+IHsKCQkJCWFzc2VydElzRGVmaW5lZChuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyKS5wb3N0TWVzc2FnZSh7IGNoYW5uZWw6ICdkaWQtbG9hZC1yZXNvdXJjZScsIGRhdGEgfSwgZGF0YS5kYXRhPy5idWZmZXIgPyBbZGF0YS5kYXRhLmJ1ZmZlcl0gOiBbXSk7CgkJCX0pOwoKCQkJaG9zdE1lc3NhZ2luZy5vbk1lc3NhZ2UoJ2RpZC1sb2FkLWxvY2FsaG9zdCcsIChfZXZlbnQsIGRhdGEpID0+IHsKCQkJCWFzc2VydElzRGVmaW5lZChuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyKS5wb3N0TWVzc2FnZSh7IGNoYW5uZWw6ICdkaWQtbG9hZC1sb2NhbGhvc3QnLCBkYXRhIH0pOwoJCQl9KTsKCgkJCW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudCA9PiB7CgkJCQlzd2l0Y2ggKGV2ZW50LmRhdGEuY2hhbm5lbCkgewoJCQkJCWNhc2UgJ2xvYWQtcmVzb3VyY2UnOgoJCQkJCWNhc2UgJ2xvYWQtbG9jYWxob3N0JzoKCQkJCQkJaG9zdE1lc3NhZ2luZy5wb3N0TWVzc2FnZShldmVudC5kYXRhLmNoYW5uZWwsIGV2ZW50LmRhdGEpOwoJCQkJCQlyZXR1cm47CgkJCQl9CgkJCX0pOwoJCX0KCgkJLyoqCgkJICogQHBhcmFtIHtIVE1MRG9jdW1lbnQ/fSBkb2N1bWVudAoJCSAqIEBwYXJhbSB7SFRNTEVsZW1lbnQ/fSBib2R5CgkJICovCgkJY29uc3QgYXBwbHlTdHlsZXMgPSAoZG9jdW1lbnQsIGJvZHkpID0+IHsKCQkJaWYgKCFkb2N1bWVudCkgewoJCQkJcmV0dXJuOwoJCQl9CgoJCQlpZiAoYm9keSkgewoJCQkJYm9keS5jbGFzc0xpc3QucmVtb3ZlKCd2c2NvZGUtbGlnaHQnLCAndnNjb2RlLWRhcmsnLCAndnNjb2RlLWhpZ2gtY29udHJhc3QnLCAndnNjb2RlLWhpZ2gtY29udHJhc3QtbGlnaHQnLCAndnNjb2RlLXJlZHVjZS1tb3Rpb24nLCAndnNjb2RlLXVzaW5nLXNjcmVlbi1yZWFkZXInKTsKCgkJCQlpZiAoaW5pdERhdGEuYWN0aXZlVGhlbWUpIHsKCQkJCQlib2R5LmNsYXNzTGlzdC5hZGQoaW5pdERhdGEuYWN0aXZlVGhlbWUpOwoJCQkJCWlmIChpbml0RGF0YS5hY3RpdmVUaGVtZSA9PT0gJ3ZzY29kZS1oaWdoLWNvbnRyYXN0LWxpZ2h0JykgewoJCQkJCQkvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eQoJCQkJCQlib2R5LmNsYXNzTGlzdC5hZGQoJ3ZzY29kZS1oaWdoLWNvbnRyYXN0Jyk7CgkJCQkJfQoJCQkJfQoKCQkJCWlmIChpbml0RGF0YS5yZWR1Y2VNb3Rpb24pIHsKCQkJCQlib2R5LmNsYXNzTGlzdC5hZGQoJ3ZzY29kZS1yZWR1Y2UtbW90aW9uJyk7CgkJCQl9CgoJCQkJaWYgKGluaXREYXRhLnNjcmVlblJlYWRlcikgewoJCQkJCWJvZHkuY2xhc3NMaXN0LmFkZCgndnNjb2RlLXVzaW5nLXNjcmVlbi1yZWFkZXInKTsKCQkJCX0KCgkJCQlib2R5LmRhdGFzZXQudnNjb2RlVGhlbWVLaW5kID0gaW5pdERhdGEuYWN0aXZlVGhlbWU7CgkJCQkvKiogQGRlcHJlY2F0ZWQgZGF0YS12c2NvZGUtdGhlbWUtbmFtZSB3aWxsIGJlIHJlbW92ZWQsIHVzZSBkYXRhLXZzY29kZS10aGVtZS1pZCBpbnN0ZWFkICovCgkJCQlib2R5LmRhdGFzZXQudnNjb2RlVGhlbWVOYW1lID0gaW5pdERhdGEudGhlbWVMYWJlbCB8fCAnJzsKCQkJCWJvZHkuZGF0YXNldC52c2NvZGVUaGVtZUlkID0gaW5pdERhdGEudGhlbWVJZCB8fCAnJzsKCQkJfQoKCQkJaWYgKGluaXREYXRhLnN0eWxlcykgewoJCQkJY29uc3QgZG9jdW1lbnRTdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTsKCgkJCQkvLyBSZW1vdmUgc3RhbGUgcHJvcGVydGllcwoJCQkJZm9yIChsZXQgaSA9IGRvY3VtZW50U3R5bGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKCQkJCQljb25zdCBwcm9wZXJ0eSA9IGRvY3VtZW50U3R5bGVbaV07CgoJCQkJCS8vIERvbid0IHJlbW92ZSBwcm9wZXJ0aWVzIHRoYXQgdGhlIHdlYnZpZXcgbWlnaHQgaGF2ZSBhZGRlZCBzZXBhcmF0ZWx5CgkJCQkJaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LnN0YXJ0c1dpdGgoJy0tdnNjb2RlLScpKSB7CgkJCQkJCWRvY3VtZW50U3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpOwoJCQkJCX0KCQkJCX0KCgkJCQkvLyBSZS1hZGQgbmV3IHByb3BlcnRpZXMKCQkJCWZvciAoY29uc3QgW3ZhcmlhYmxlLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5pdERhdGEuc3R5bGVzKSkgewoJCQkJCWRvY3VtZW50U3R5bGUuc2V0UHJvcGVydHkoYC0tJHt2YXJpYWJsZX1gLCB2YWx1ZSk7CgkJCQl9CgkJCX0KCQl9OwoKCQkvKioKCQkgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50CgkJICovCgkJY29uc3QgaGFuZGxlSW5uZXJDbGljayA9IChldmVudCkgPT4gewoJCQlpZiAoIWV2ZW50Py52aWV3Py5kb2N1bWVudCkgewoJCQkJcmV0dXJuOwoJCQl9CgoJCQljb25zdCBiYXNlRWxlbWVudCA9IGV2ZW50LnZpZXcuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpOwoKCQkJZm9yIChjb25zdCBwYXRoRWxlbWVudCBvZiBldmVudC5jb21wb3NlZFBhdGgoKSkgewoJCQkJLyoqIEB0eXBlIHthbnl9ICovCgkJCQljb25zdCBub2RlID0gcGF0aEVsZW1lbnQ7CgkJCQlpZiAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScgJiYgbm9kZS5ocmVmKSB7CgkJCQkJaWYgKG5vZGUuZ2V0QXR0cmlidXRlKCdocmVmJykgPT09ICcjJykgewoJCQkJCQlldmVudC52aWV3LnNjcm9sbFRvKDAsIDApOwoJCQkJCX0gZWxzZSBpZiAobm9kZS5oYXNoICYmIChub2RlLmdldEF0dHJpYnV0ZSgnaHJlZicpID09PSBub2RlLmhhc2ggfHwgKGJhc2VFbGVtZW50ICYmIG5vZGUuaHJlZiA9PT0gYmFzZUVsZW1lbnQuaHJlZiArIG5vZGUuaGFzaCkpKSB7CgkJCQkJCWNvbnN0IGZyYWdtZW50ID0gbm9kZS5oYXNoLnNsaWNlKDEpOwoJCQkJCQljb25zdCBkZWNvZGVkRnJhZ21lbnQgPSBkZWNvZGVVUklDb21wb25lbnQoZnJhZ21lbnQpOwoJCQkJCQljb25zdCBzY3JvbGxUYXJnZXQgPSBldmVudC52aWV3LmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGZyYWdtZW50KSA/PyBldmVudC52aWV3LmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRlY29kZWRGcmFnbWVudCk7CgkJCQkJCWlmIChzY3JvbGxUYXJnZXQpIHsKCQkJCQkJCXNjcm9sbFRhcmdldC5zY3JvbGxJbnRvVmlldygpOwoJCQkJCQl9IGVsc2UgaWYgKGRlY29kZWRGcmFnbWVudC50b0xvd2VyQ2FzZSgpID09PSAndG9wJykgewoJCQkJCQkJZXZlbnQudmlldy5zY3JvbGxUbygwLCAwKTsKCQkJCQkJfQoJCQkJCX0gZWxzZSB7CgkJCQkJCWhvc3RNZXNzYWdpbmcucG9zdE1lc3NhZ2UoJ2RpZC1jbGljay1saW5rJywgeyB1cmk6IG5vZGUuaHJlZi5iYXNlVmFsIHx8IG5vZGUuaHJlZiB9KTsKCQkJCQl9CgkJCQkJZXZlbnQucHJldmVudERlZmF1bHQoKTsKCQkJCQlyZXR1cm47CgkJCQl9CgkJCX0KCQl9OwoKCQkvKioKCQkgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50CgkJICovCgkJY29uc3QgaGFuZGxlQXV4Q2xpY2sgPSAoZXZlbnQpID0+IHsKCQkJLy8gUHJldmVudCBtaWRkbGUgY2xpY2tzIG9wZW5pbmcgYSBicm9rZW4gbGluayBpbiB0aGUgYnJvd3NlcgoJCQlpZiAoIWV2ZW50Py52aWV3Py5kb2N1bWVudCkgewoJCQkJcmV0dXJuOwoJCQl9CgoJCQlpZiAoZXZlbnQuYnV0dG9uID09PSAxKSB7CgkJCQlmb3IgKGNvbnN0IHBhdGhFbGVtZW50IG9mIGV2ZW50LmNvbXBvc2VkUGF0aCgpKSB7CgkJCQkJLyoqIEB0eXBlIHthbnl9ICovCgkJCQkJY29uc3Qgbm9kZSA9IHBhdGhFbGVtZW50OwoJCQkJCWlmIChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJyAmJiBub2RlLmhyZWYpIHsKCQkJCQkJZXZlbnQucHJldmVudERlZmF1bHQoKTsKCQkJCQkJcmV0dXJuOwoJCQkJCX0KCQkJCX0KCQkJfQoJCX07CgoJCS8qKgoJCSAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZQoJCSAqLwoJCWNvbnN0IGhhbmRsZUlubmVyS2V5ZG93biA9IChlKSA9PiB7CgkJCS8vIElmIHRoZSBrZXlwcmVzcyB3b3VsZCB0cmlnZ2VyIGEgYnJvd3NlciBldmVudCwgc3VjaCBhcyBjb3B5IG9yIHBhc3RlLAoJCQkvLyBtYWtlIHN1cmUgd2UgYmxvY2sgdGhlIGJyb3dzZXIgZnJvbSBkaXNwYXRjaGluZyBpdC4gSW5zdGVhZCBWUyBDb2RlCgkJCS8vIGhhbmRsZXMgdGhlc2UgZXZlbnRzIGFuZCB3aWxsIGRpc3BhdGNoIGEgY29weS9wYXN0ZSBiYWNrIHRvIHRoZSB3ZWJ2aWV3CgkJCS8vIGlmIG5lZWRlZAoJCQlpZiAoaXNVbmRvUmVkbyhlKSB8fCBpc1ByaW50KGUpIHx8IGlzRmluZEV2ZW50KGUpIHx8IGlzU2F2ZUV2ZW50KGUpKSB7CgkJCQllLnByZXZlbnREZWZhdWx0KCk7CgkJCX0gZWxzZSBpZiAoaXNDb3B5UGFzdGVPckN1dChlKSkgewoJCQkJaWYgKG9uRWxlY3Ryb24pIHsKCQkJCQllLnByZXZlbnREZWZhdWx0KCk7CgkJCQl9IGVsc2UgewoJCQkJCXJldHVybjsgLy8gbGV0IHRoZSBicm93c2VyIGhhbmRsZSB0aGlzCgkJCQl9CgkJCX0gZWxzZSBpZiAoIW9uRWxlY3Ryb24gJiYgKGlzQ2xvc2VUYWIoZSkgfHwgaXNOZXdXaW5kb3coZSkpKSB7CgkJCQkvLyBQcmV2ZW50IEN0cmwrVyBjbG9zaW5nIHdpbmRvdyAvIEN0cmwrTiBvcGVuaW5nIG5ldyB3aW5kb3cgaW4gUFdBLgoJCQkJLy8gKE5vIGVmZmVjdCBpbiBhIHJlZ3VsYXIgYnJvd3NlciB0YWIuKQoJCQkJZS5wcmV2ZW50RGVmYXVsdCgpOwoJCQl9CgoJCQlob3N0TWVzc2FnaW5nLnBvc3RNZXNzYWdlKCdkaWQta2V5ZG93bicsIHsKCQkJCWtleTogZS5rZXksCgkJCQlrZXlDb2RlOiBlLmtleUNvZGUsCgkJCQljb2RlOiBlLmNvZGUsCgkJCQlzaGlmdEtleTogZS5zaGlmdEtleSwKCQkJCWFsdEtleTogZS5hbHRLZXksCgkJCQljdHJsS2V5OiBlLmN0cmxLZXksCgkJCQltZXRhS2V5OiBlLm1ldGFLZXksCgkJCQlyZXBlYXQ6IGUucmVwZWF0CgkJCX0pOwoJCX07CgkJLyoqCgkJICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlCgkJICovCgkJY29uc3QgaGFuZGxlSW5uZXJLZXl1cCA9IChlKSA9PiB7CgkJCWhvc3RNZXNzYWdpbmcucG9zdE1lc3NhZ2UoJ2RpZC1rZXl1cCcsIHsKCQkJCWtleTogZS5rZXksCgkJCQlrZXlDb2RlOiBlLmtleUNvZGUsCgkJCQljb2RlOiBlLmNvZGUsCgkJCQlzaGlmdEtleTogZS5zaGlmdEtleSwKCQkJCWFsdEtleTogZS5hbHRLZXksCgkJCQljdHJsS2V5OiBlLmN0cmxLZXksCgkJCQltZXRhS2V5OiBlLm1ldGFLZXksCgkJCQlyZXBlYXQ6IGUucmVwZWF0CgkJCX0pOwoJCX07CgoJCS8qKgoJCSAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZQoJCSAqIEByZXR1cm4ge2Jvb2xlYW59CgkJICovCgkJZnVuY3Rpb24gaXNDb3B5UGFzdGVPckN1dChlKSB7CgkJCWNvbnN0IGhhc01ldGEgPSBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5OwoJCQkvLyA0NToga2V5Q29kZSBvZiAiSW5zZXJ0IgoJCQljb25zdCBzaGlmdEluc2VydCA9IGUuc2hpZnRLZXkgJiYgZS5rZXlDb2RlID09PSA0NTsKCQkJLy8gNjcsIDg2LCA4ODoga2V5Q29kZSBvZiAiQyIsICJWIiwgIlgiCgkJCXJldHVybiAoaGFzTWV0YSAmJiBbNjcsIDg2LCA4OF0uaW5jbHVkZXMoZS5rZXlDb2RlKSkgfHwgc2hpZnRJbnNlcnQ7CgkJfQoKCQkvKioKCQkgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGUKCQkgKiBAcmV0dXJuIHtib29sZWFufQoJCSAqLwoJCWZ1bmN0aW9uIGlzVW5kb1JlZG8oZSkgewoJCQljb25zdCBoYXNNZXRhID0gZS5jdHJsS2V5IHx8IGUubWV0YUtleTsKCQkJLy8gOTAsIDg5OiBrZXlDb2RlIG9mICJaIiwgIlkiCgkJCXJldHVybiBoYXNNZXRhICYmIFs5MCwgODldLmluY2x1ZGVzKGUua2V5Q29kZSk7CgkJfQoKCQkvKioKCQkgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGUKCQkgKiBAcmV0dXJuIHtib29sZWFufQoJCSAqLwoJCWZ1bmN0aW9uIGlzUHJpbnQoZSkgewoJCQljb25zdCBoYXNNZXRhID0gZS5jdHJsS2V5IHx8IGUubWV0YUtleTsKCQkJLy8gODA6IGtleUNvZGUgb2YgIlAiCgkJCXJldHVybiBoYXNNZXRhICYmIGUua2V5Q29kZSA9PT0gODA7CgkJfQoKCQkvKioKCQkgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGUKCQkgKiBAcmV0dXJuIHtib29sZWFufQoJCSAqLwoJCWZ1bmN0aW9uIGlzRmluZEV2ZW50KGUpIHsKCQkJY29uc3QgaGFzTWV0YSA9IGUuY3RybEtleSB8fCBlLm1ldGFLZXk7CgkJCS8vIDcwOiBrZXlDb2RlIG9mICJGIgoJCQlyZXR1cm4gaGFzTWV0YSAmJiBlLmtleUNvZGUgPT09IDcwOwoJCX0KCgkJLyoqCgkJICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlCgkJICogQHJldHVybiB7Ym9vbGVhbn0KCQkgKi8KCQlmdW5jdGlvbiBpc1NhdmVFdmVudChlKSB7CgkJCWNvbnN0IGhhc01ldGEgPSBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5OwoJCQkvLyA4Mzoga2V5Q29kZSBvZiAiUyIKCQkJcmV0dXJuIGhhc01ldGEgJiYgZS5rZXlDb2RlID09PSA4MzsKCQl9CgoJCS8qKgoJCSAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZQoJCSAqIEByZXR1cm4ge2Jvb2xlYW59CgkJICovCgkJZnVuY3Rpb24gaXNDbG9zZVRhYihlKSB7CgkJCWNvbnN0IGhhc01ldGEgPSBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5OwoJCQkvLyA4Nzoga2V5Q29kZSBvZiAiVyIKCQkJcmV0dXJuIGhhc01ldGEgJiYgZS5rZXlDb2RlID09PSA4NzsKCQl9CgoJCS8qKgoJCSAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZQoJCSAqIEByZXR1cm4ge2Jvb2xlYW59CgkJICovCgkJZnVuY3Rpb24gaXNOZXdXaW5kb3coZSkgewoJCQljb25zdCBoYXNNZXRhID0gZS5jdHJsS2V5IHx8IGUubWV0YUtleTsKCQkJLy8gNzg6IGtleUNvZGUgb2YgIk4iCgkJCXJldHVybiBoYXNNZXRhICYmIGUua2V5Q29kZSA9PT0gNzg7CgkJfQoKCQlsZXQgaXNIYW5kbGluZ1Njcm9sbCA9IGZhbHNlOwoKCQkvKioKCQkgKiBAcGFyYW0ge1doZWVsRXZlbnR9IGV2ZW50CgkJICovCgkJY29uc3QgaGFuZGxlV2hlZWwgPSAoZXZlbnQpID0+IHsKCQkJaWYgKGlzSGFuZGxpbmdTY3JvbGwpIHsKCQkJCXJldHVybjsKCQkJfQoKCQkJaG9zdE1lc3NhZ2luZy5wb3N0TWVzc2FnZSgnZGlkLXNjcm9sbC13aGVlbCcsIHsKCQkJCWRlbHRhTW9kZTogZXZlbnQuZGVsdGFNb2RlLAoJCQkJZGVsdGFYOiBldmVudC5kZWx0YVgsCgkJCQlkZWx0YVk6IGV2ZW50LmRlbHRhWSwKCQkJCWRlbHRhWjogZXZlbnQuZGVsdGFaLAoJCQkJZGV0YWlsOiBldmVudC5kZXRhaWwsCgkJCQl0eXBlOiBldmVudC50eXBlCgkJCX0pOwoJCX07CgoJCS8qKgoJCSAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50CgkJICovCgkJY29uc3QgaGFuZGxlSW5uZXJTY3JvbGwgPSAoZXZlbnQpID0+IHsKCQkJaWYgKGlzSGFuZGxpbmdTY3JvbGwpIHsKCQkJCXJldHVybjsKCQkJfQoKCQkJY29uc3QgdGFyZ2V0ID0gLyoqIEB0eXBlIHtIVE1MRG9jdW1lbnQgfCBudWxsfSAqLyAoZXZlbnQudGFyZ2V0KTsKCQkJY29uc3QgY3VycmVudFRhcmdldCA9IC8qKiBAdHlwZSB7V2luZG93IHwgbnVsbH0gKi8gKGV2ZW50LmN1cnJlbnRUYXJnZXQpOwoJCQlpZiAoIWN1cnJlbnRUYXJnZXQgfHwgIXRhcmdldD8uYm9keSkgewoJCQkJcmV0dXJuOwoJCQl9CgoJCQljb25zdCBwcm9ncmVzcyA9IGN1cnJlbnRUYXJnZXQuc2Nyb2xsWSAvIHRhcmdldC5ib2R5LmNsaWVudEhlaWdodDsKCQkJaWYgKGlzTmFOKHByb2dyZXNzKSkgewoJCQkJcmV0dXJuOwoJCQl9CgoJCQlpc0hhbmRsaW5nU2Nyb2xsID0gdHJ1ZTsKCQkJd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7CgkJCQl0cnkgewoJCQkJCWhvc3RNZXNzYWdpbmcucG9zdE1lc3NhZ2UoJ2RpZC1zY3JvbGwnLCB7IHNjcm9sbFlQZXJjZW50YWdlOiBwcm9ncmVzcyB9KTsKCQkJCX0gY2F0Y2ggKGUpIHsKCQkJCQkvLyBub29wCgkJCQl9CgkJCQlpc0hhbmRsaW5nU2Nyb2xsID0gZmFsc2U7CgkJCX0pOwoJCX07CgoJCWZ1bmN0aW9uIGhhbmRsZUlubmVyRHJhZ1N0YXJ0RXZlbnQoLyoqIEB0eXBlIHtEcmFnRXZlbnR9ICovIGUpIHsKCQkJaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgewoJCQkJLy8gRXh0ZW5zaW9uIGNvZGUgaGFzIGFscmVhZHkgaGFuZGxlZCB0aGlzIGV2ZW50CgkJCQlyZXR1cm47CgkJCX0KCgkJCWlmICghZS5kYXRhVHJhbnNmZXIgfHwgZS5zaGlmdEtleSkgewoJCQkJcmV0dXJuOwoJCQl9CgoJCQkvLyBPbmx5IGhhbmRsZSBkcmFncyBmcm9tIG91dHNpZGUgZWRpdG9yIGZvciBub3cKCQkJaWYgKGUuZGF0YVRyYW5zZmVyLml0ZW1zLmxlbmd0aCAmJiBBcnJheS5wcm90b3R5cGUuZXZlcnkuY2FsbChlLmRhdGFUcmFuc2Zlci5pdGVtcywgaXRlbSA9PiBpdGVtLmtpbmQgPT09ICdmaWxlJykpIHsKCQkJCWhvc3RNZXNzYWdpbmcucG9zdE1lc3NhZ2UoJ2RyYWctc3RhcnQnLCB1bmRlZmluZWQpOwoJCQl9CgkJfQoKCQkvKioKCQkgKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrCgkJICovCgkJZnVuY3Rpb24gb25Eb21SZWFkeShjYWxsYmFjaykgewoJCQlpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7CgkJCQljYWxsYmFjaygpOwoJCQl9IGVsc2UgewoJCQkJZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGNhbGxiYWNrKTsKCQkJfQoJCX0KCgkJZnVuY3Rpb24gYXJlU2VydmljZVdvcmtlcnNFbmFibGVkKCkgewoJCQl0cnkgewoJCQkJcmV0dXJuICEhbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXI7CgkJCX0gY2F0Y2ggKGUpIHsKCQkJCXJldHVybiBmYWxzZTsKCQkJfQoJCX0KCgkJLyoqCgkJICogQHBhcmFtIHtpbXBvcnQoJy4uL3dlYnZpZXdNZXNzYWdlcycpLlVwZGF0ZUNvbnRlbnRFdmVudH0gZGF0YQoJCSAqIEByZXR1cm4ge3N0cmluZ30KCQkgKi8KCQlmdW5jdGlvbiB0b0NvbnRlbnRIdG1sKGRhdGEpIHsKCQkJY29uc3Qgb3B0aW9ucyA9IGRhdGEub3B0aW9uczsKCQkJY29uc3QgdGV4dCA9IGRhdGEuY29udGVudHM7CgkJCWNvbnN0IG5ld0RvY3VtZW50ID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCAndGV4dC9odG1sJyk7CgoJCQluZXdEb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhJykuZm9yRWFjaChhID0+IHsKCQkJCWlmICghYS50aXRsZSkgewoJCQkJCWNvbnN0IGhyZWYgPSBhLmdldEF0dHJpYnV0ZSgnaHJlZicpOwoJCQkJCWlmICh0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycpIHsKCQkJCQkJYS50aXRsZSA9IGhyZWY7CgkJCQkJfQoJCQkJfQoJCQl9KTsKCgkJCS8vIFNldCBkZWZhdWx0IGFyaWEgcm9sZQoJCQlpZiAoIW5ld0RvY3VtZW50LmJvZHkuaGFzQXR0cmlidXRlKCdyb2xlJykpIHsKCQkJCW5ld0RvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RvY3VtZW50Jyk7CgkJCX0KCgkJCS8vIEluamVjdCBkZWZhdWx0IHNjcmlwdAoJCQlpZiAob3B0aW9ucy5hbGxvd1NjcmlwdHMpIHsKCQkJCWNvbnN0IGRlZmF1bHRTY3JpcHQgPSBuZXdEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTsKCQkJCWRlZmF1bHRTY3JpcHQuaWQgPSAnX3ZzY29kZUFwaVNjcmlwdCc7CgkJCQlkZWZhdWx0U2NyaXB0LnRleHRDb250ZW50ID0gZ2V0VnNDb2RlQXBpU2NyaXB0KG9wdGlvbnMuYWxsb3dNdWx0aXBsZUFQSUFjcXVpcmUsIGRhdGEuc3RhdGUpOwoJCQkJbmV3RG9jdW1lbnQuaGVhZC5wcmVwZW5kKGRlZmF1bHRTY3JpcHQpOwoJCQl9CgoJCQkvLyBJbmplY3QgZGVmYXVsdCBzdHlsZXMKCQkJbmV3RG9jdW1lbnQuaGVhZC5wcmVwZW5kKGRlZmF1bHRTdHlsZXMuY2xvbmVOb2RlKHRydWUpKTsKCgkJCWFwcGx5U3R5bGVzKG5ld0RvY3VtZW50LCBuZXdEb2N1bWVudC5ib2R5KTsKCgkJCS8vIFN0cmlwIG91dCB1bnN1cHBvcnRlZCBodHRwLWVxdWl2IHRhZ3MKCQkJZm9yIChjb25zdCBtZXRhRWxlbWVudCBvZiBBcnJheS5mcm9tKG5ld0RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ21ldGEnKSkpIHsKCQkJCWNvbnN0IGh0dHBFcXVpdiA9IG1ldGFFbGVtZW50LmdldEF0dHJpYnV0ZSgnaHR0cC1lcXVpdicpOwoJCQkJaWYgKGh0dHBFcXVpdiAmJiAhL14oY29udGVudC1zZWN1cml0eS1wb2xpY3l8ZGVmYXVsdC1zdHlsZXxjb250ZW50LXR5cGUpJC9pLnRlc3QoaHR0cEVxdWl2KSkgewoJCQkJCWNvbnNvbGUud2FybihgUmVtb3ZpbmcgdW5zdXBwb3J0ZWQgbWV0YSBodHRwLWVxdWl2OiAke2h0dHBFcXVpdn1gKTsKCQkJCQltZXRhRWxlbWVudC5yZW1vdmUoKTsKCQkJCX0KCQkJfQoKCQkJLy8gQ2hlY2sgZm9yIENTUAoJCQljb25zdCBjc3AgPSBuZXdEb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW2h0dHAtZXF1aXY9IkNvbnRlbnQtU2VjdXJpdHktUG9saWN5Il0nKTsKCQkJaWYgKCFjc3ApIHsKCQkJCWhvc3RNZXNzYWdpbmcucG9zdE1lc3NhZ2UoJ25vLWNzcC1mb3VuZCcsIHVuZGVmaW5lZCk7CgkJCX0gZWxzZSB7CgkJCQl0cnkgewoJCQkJCS8vIEF0dGVtcHQgdG8gcmV3cml0ZSBDU1BzIHRoYXQgaGFyZGNvZGUgb2xkLXN0eWxlIHJlc291cmNlIGVuZHBvaW50CgkJCQkJY29uc3QgY3NwQ29udGVudCA9IGNzcC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKTsKCQkJCQlpZiAoY3NwQ29udGVudCkgewoJCQkJCQljb25zdCBuZXdDc3AgPSBjc3BDb250ZW50LnJlcGxhY2UoLyh2c2NvZGUtd2Vidmlldy1yZXNvdXJjZXx2c2NvZGUtcmVzb3VyY2UpOig/PShcc3w7fCQpKS9nLCBkYXRhLmNzcFNvdXJjZSk7CgkJCQkJCWNzcC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCBuZXdDc3ApOwoJCQkJCX0KCQkJCX0gY2F0Y2ggKGUpIHsKCQkJCQljb25zb2xlLmVycm9yKGBDb3VsZCBub3QgcmV3cml0ZSBjc3A6ICR7ZX1gKTsKCQkJCX0KCQkJfQoKCQkJLy8gc2V0IERPQ1RZUEUgZm9yIG5ld0RvY3VtZW50IGV4cGxpY2l0bHkgYXMgRE9NUGFyc2VyLnBhcnNlRnJvbVN0cmluZyBzdHJpcHMgaXQgb2ZmCgkJCS8vIGFuZCBET0NUWVBFIGlzIG5lZWRlZCBpbiB0aGUgaWZyYW1lIHRvIGVuc3VyZSB0aGF0IHRoZSB1c2VyIGFnZW50IHN0eWxlc2hlZXQgaXMgY29ycmVjdGx5IG92ZXJyaWRkZW4KCQkJcmV0dXJuICc8IURPQ1RZUEUgaHRtbD5cbicgKyBuZXdEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MOwoJCX0KCgkJLy8gQWxzbyBmb3J3YXJkIGV2ZW50cyBiZWZvcmUgdGhlIGNvbnRlbnRzIG9mIHRoZSB3ZWJ2aWV3IGhhdmUgbG9hZGVkCgkJd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVJbm5lcktleWRvd24pOwoJCXdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZUlubmVyS2V5dXApOwoJCXdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBoYW5kbGVJbm5lckRyYWdTdGFydEV2ZW50KTsKCQl3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBoYW5kbGVJbm5lckRyYWdTdGFydEV2ZW50KTsKCgkJb25Eb21SZWFkeSgoKSA9PiB7CgkJCWlmICghZG9jdW1lbnQuYm9keSkgewoJCQkJcmV0dXJuOwoJCQl9CgoJCQlob3N0TWVzc2FnaW5nLm9uTWVzc2FnZSgnc3R5bGVzJywgKF9ldmVudCwgZGF0YSkgPT4gewoJCQkJKytzdHlsZVZlcnNpb247CgoJCQkJaW5pdERhdGEuc3R5bGVzID0gZGF0YS5zdHlsZXM7CgkJCQlpbml0RGF0YS5hY3RpdmVUaGVtZSA9IGRhdGEuYWN0aXZlVGhlbWU7CgkJCQlpbml0RGF0YS50aGVtZUxhYmVsID0gZGF0YS50aGVtZUxhYmVsOwoJCQkJaW5pdERhdGEudGhlbWVJZCA9IGRhdGEudGhlbWVJZDsKCQkJCWluaXREYXRhLnJlZHVjZU1vdGlvbiA9IGRhdGEucmVkdWNlTW90aW9uOwoJCQkJaW5pdERhdGEuc2NyZWVuUmVhZGVyID0gZGF0YS5zY3JlZW5SZWFkZXI7CgoJCQkJY29uc3QgdGFyZ2V0ID0gZ2V0QWN0aXZlRnJhbWUoKTsKCQkJCWlmICghdGFyZ2V0KSB7CgkJCQkJcmV0dXJuOwoJCQkJfQoKCQkJCWlmICh0YXJnZXQuY29udGVudERvY3VtZW50KSB7CgkJCQkJYXBwbHlTdHlsZXModGFyZ2V0LmNvbnRlbnREb2N1bWVudCwgdGFyZ2V0LmNvbnRlbnREb2N1bWVudC5ib2R5KTsKCQkJCX0KCQkJfSk7CgoJCQkvLyBwcm9wYWdhdGUgZm9jdXMKCQkJaG9zdE1lc3NhZ2luZy5vbk1lc3NhZ2UoJ2ZvY3VzJywgKCkgPT4gewoJCQkJY29uc3QgYWN0aXZlRnJhbWUgPSBnZXRBY3RpdmVGcmFtZSgpOwoJCQkJaWYgKCFhY3RpdmVGcmFtZSB8fCAhYWN0aXZlRnJhbWUuY29udGVudFdpbmRvdykgewoJCQkJCS8vIEZvY3VzIHRoZSB0b3AgbGV2ZWwgd2VidmlldyBpbnN0ZWFkCgkJCQkJd2luZG93LmZvY3VzKCk7CgkJCQkJcmV0dXJuOwoJCQkJfQoKCQkJCWlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBhY3RpdmVGcmFtZSkgewoJCQkJCS8vIFdlIGFyZSBhbHJlYWR5IGZvY3VzZWQgb24gdGhlIGlmcmFtZSAob3Igb25lIG9mIGl0cyBjaGlsZHJlbikgc28gbm8gbmVlZAoJCQkJCS8vIHRvIHJlZm9jdXMuCgkJCQkJcmV0dXJuOwoJCQkJfQoKCQkJCWFjdGl2ZUZyYW1lLmNvbnRlbnRXaW5kb3cuZm9jdXMoKTsKCQkJfSk7CgoJCQkvLyB1cGRhdGUgaWZyYW1lLWNvbnRlbnRzCgkJCWxldCB1cGRhdGVJZCA9IDA7CgkJCWhvc3RNZXNzYWdpbmcub25NZXNzYWdlKCdjb250ZW50JywgYXN5bmMgKF9ldmVudCwgLyoqIEB0eXBlIHtpbXBvcnQoJy4uL3dlYnZpZXdNZXNzYWdlcycpLlVwZGF0ZUNvbnRlbnRFdmVudH0gKi8gZGF0YSkgPT4gewoJCQkJY29uc3QgY3VycmVudFVwZGF0ZUlkID0gKyt1cGRhdGVJZDsKCQkJCXRyeSB7CgkJCQkJYXdhaXQgd29ya2VyUmVhZHk7CgkJCQl9IGNhdGNoIChlKSB7CgkJCQkJY29uc29sZS5lcnJvcihgV2VidmlldyBmYXRhbCBlcnJvcjogJHtlfWApOwoJCQkJCWhvc3RNZXNzYWdpbmcucG9zdE1lc3NhZ2UoJ2ZhdGFsLWVycm9yJywgeyBtZXNzYWdlOiBlICsgJycgfSk7CgkJCQkJcmV0dXJuOwoJCQkJfQoKCQkJCWlmIChjdXJyZW50VXBkYXRlSWQgIT09IHVwZGF0ZUlkKSB7CgkJCQkJcmV0dXJuOwoJCQkJfQoKCQkJCWNvbnN0IG9wdGlvbnMgPSBkYXRhLm9wdGlvbnM7CgkJCQljb25zdCBuZXdEb2N1bWVudCA9IHRvQ29udGVudEh0bWwoZGF0YSk7CgoJCQkJY29uc3QgaW5pdGlhbFN0eWxlVmVyc2lvbiA9IHN0eWxlVmVyc2lvbjsKCgkJCQljb25zdCBmcmFtZSA9IGdldEFjdGl2ZUZyYW1lKCk7CgkJCQljb25zdCB3YXNGaXJzdExvYWQgPSBmaXJzdExvYWQ7CgkJCQkvLyBrZWVwIGN1cnJlbnQgc2Nyb2xsWSBhcm91bmQgYW5kIHVzZSBsYXRlcgoJCQkJLyoqIEB0eXBlIHsoYm9keTogSFRNTEVsZW1lbnQsIHdpbmRvdzogV2luZG93KSA9PiB2b2lkfSAqLwoJCQkJbGV0IHNldEluaXRpYWxTY3JvbGxQb3NpdGlvbjsKCQkJCWlmIChmaXJzdExvYWQpIHsKCQkJCQlmaXJzdExvYWQgPSBmYWxzZTsKCQkJCQlzZXRJbml0aWFsU2Nyb2xsUG9zaXRpb24gPSAoYm9keSwgd2luZG93KSA9PiB7CgkJCQkJCWlmICh0eXBlb2YgaW5pdERhdGEuaW5pdGlhbFNjcm9sbFByb2dyZXNzID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oaW5pdERhdGEuaW5pdGlhbFNjcm9sbFByb2dyZXNzKSkgewoJCQkJCQkJaWYgKHdpbmRvdy5zY3JvbGxZID09PSAwKSB7CgkJCQkJCQkJd2luZG93LnNjcm9sbCgwLCBib2R5LmNsaWVudEhlaWdodCAqIGluaXREYXRhLmluaXRpYWxTY3JvbGxQcm9ncmVzcyk7CgkJCQkJCQl9CgkJCQkJCX0KCQkJCQl9OwoJCQkJfSBlbHNlIHsKCQkJCQljb25zdCBzY3JvbGxZID0gZnJhbWUgJiYgZnJhbWUuY29udGVudERvY3VtZW50ICYmIGZyYW1lLmNvbnRlbnREb2N1bWVudC5ib2R5ID8gYXNzZXJ0SXNEZWZpbmVkKGZyYW1lLmNvbnRlbnRXaW5kb3cpLnNjcm9sbFkgOiAwOwoJCQkJCXNldEluaXRpYWxTY3JvbGxQb3NpdGlvbiA9IChib2R5LCB3aW5kb3cpID0+IHsKCQkJCQkJaWYgKHdpbmRvdy5zY3JvbGxZID09PSAwKSB7CgkJCQkJCQl3aW5kb3cuc2Nyb2xsKDAsIHNjcm9sbFkpOwoJCQkJCQl9CgkJCQkJfTsKCQkJCX0KCgkJCQkvLyBDbGVhbiB1cCBvbGQgcGVuZGluZyBmcmFtZXMgYW5kIHNldCBjdXJyZW50IG9uZSBhcyBuZXcgb25lCgkJCQljb25zdCBwcmV2aW91c1BlbmRpbmdGcmFtZSA9IGdldFBlbmRpbmdGcmFtZSgpOwoJCQkJaWYgKHByZXZpb3VzUGVuZGluZ0ZyYW1lKSB7CgkJCQkJcHJldmlvdXNQZW5kaW5nRnJhbWUuc2V0QXR0cmlidXRlKCdpZCcsICcnKTsKCQkJCQlkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHByZXZpb3VzUGVuZGluZ0ZyYW1lKTsKCQkJCX0KCQkJCWlmICghd2FzRmlyc3RMb2FkKSB7CgkJCQkJcGVuZGluZ01lc3NhZ2VzID0gW107CgkJCQl9CgoJCQkJY29uc3QgbmV3RnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTsKCQkJCW5ld0ZyYW1lLnRpdGxlID0gZGF0YS50aXRsZTsKCQkJCW5ld0ZyYW1lLnNldEF0dHJpYnV0ZSgnaWQnLCAncGVuZGluZy1mcmFtZScpOwoJCQkJbmV3RnJhbWUuc2V0QXR0cmlidXRlKCdmcmFtZWJvcmRlcicsICcwJyk7CgoJCQkJY29uc3Qgc2FuZGJveFJ1bGVzID0gbmV3IFNldChbJ2FsbG93LXNhbWUtb3JpZ2luJywgJ2FsbG93LXBvaW50ZXItbG9jayddKTsKCQkJCWlmIChvcHRpb25zLmFsbG93U2NyaXB0cykgewoJCQkJCXNhbmRib3hSdWxlcy5hZGQoJ2FsbG93LXNjcmlwdHMnKTsKCQkJCQlzYW5kYm94UnVsZXMuYWRkKCdhbGxvdy1kb3dubG9hZHMnKTsKCQkJCX0KCQkJCWlmIChvcHRpb25zLmFsbG93Rm9ybXMpIHsKCQkJCQlzYW5kYm94UnVsZXMuYWRkKCdhbGxvdy1mb3JtcycpOwoJCQkJfQoJCQkJbmV3RnJhbWUuc2V0QXR0cmlidXRlKCdzYW5kYm94JywgQXJyYXkuZnJvbShzYW5kYm94UnVsZXMpLmpvaW4oJyAnKSk7CgoJCQkJY29uc3QgYWxsb3dSdWxlcyA9IFsnY3Jvc3Mtb3JpZ2luLWlzb2xhdGVkOycsICdhdXRvcGxheTsnXTsKCQkJCWlmICghaXNGaXJlZm94ICYmIG9wdGlvbnMuYWxsb3dTY3JpcHRzKSB7CgkJCQkJYWxsb3dSdWxlcy5wdXNoKCdjbGlwYm9hcmQtcmVhZDsnLCAnY2xpcGJvYXJkLXdyaXRlOycpOwoJCQkJfQoJCQkJbmV3RnJhbWUuc2V0QXR0cmlidXRlKCdhbGxvdycsIGFsbG93UnVsZXMuam9pbignICcpKTsKCQkJCS8vIFdlIHNob3VsZCBqdXN0IGJlIGFibGUgdG8gdXNlIHNyY2RvYywgYnV0IEkgd2Fzbid0CgkJCQkvLyBzZWVpbmcgdGhlIHNlcnZpY2Ugd29ya2VyIGFwcGx5aW5nIHByb3Blcmx5LgoJCQkJLy8gRmFrZSBsb2FkIGFuIGVtcHR5IG9uIHRoZSBjb3JyZWN0IG9yaWdpbiBhbmQgdGhlbiB3cml0ZSByZWFsIGh0bWwKCQkJCS8vIGludG8gaXQgdG8gZ2V0IGFyb3VuZCB0aGlzLgoJCQkJY29uc3QgZmFrZVVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBpZDogSUQgfSk7CgkJCQlpZiAoZ2xvYmFsVGhpcy5jcm9zc09yaWdpbklzb2xhdGVkKSB7CgkJCQkJZmFrZVVybFBhcmFtcy5zZXQoJ3ZzY29kZS1jb2knLCAnMycpOyAvKkNPT1ArQ09FUCovCgkJCQl9CgkJCQluZXdGcmFtZS5zcmMgPSBgJHtmYWtlSHRtbFVyaX0/JHtmYWtlVXJsUGFyYW1zLnRvU3RyaW5nKCl9YDsKCgkJCQluZXdGcmFtZS5zdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6IGJsb2NrOyBtYXJnaW46IDA7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgdmlzaWJpbGl0eTogaGlkZGVuJzsKCQkJCWRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobmV3RnJhbWUpOwoKCQkJCW5ld0ZyYW1lLmNvbnRlbnRXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUlubmVyS2V5ZG93bik7CgkJCQluZXdGcmFtZS5jb250ZW50V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgaGFuZGxlSW5uZXJLZXl1cCk7CgoJCQkJLyoqCgkJCQkgKiBAcGFyYW0ge0RvY3VtZW50fSBjb250ZW50RG9jdW1lbnQKCQkJCSAqLwoJCQkJZnVuY3Rpb24gb25GcmFtZUxvYWRlZChjb250ZW50RG9jdW1lbnQpIHsKCQkJCQkvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05NzgzMjUKCQkJCQlzZXRUaW1lb3V0KCgpID0+IHsKCQkJCQkJY29udGVudERvY3VtZW50Lm9wZW4oKTsKCQkJCQkJY29udGVudERvY3VtZW50LndyaXRlKG5ld0RvY3VtZW50KTsKCQkJCQkJY29udGVudERvY3VtZW50LmNsb3NlKCk7CgkJCQkJCWhvb2t1cE9uTG9hZEhhbmRsZXJzKG5ld0ZyYW1lKTsKCgkJCQkJCWlmIChpbml0aWFsU3R5bGVWZXJzaW9uICE9PSBzdHlsZVZlcnNpb24pIHsKCQkJCQkJCWFwcGx5U3R5bGVzKGNvbnRlbnREb2N1bWVudCwgY29udGVudERvY3VtZW50LmJvZHkpOwoJCQkJCQl9CgkJCQkJfSwgMCk7CgkJCQl9CgoJCQkJaWYgKCFvcHRpb25zLmFsbG93U2NyaXB0cyAmJiBpc1NhZmFyaSkgewoJCQkJCS8vIE9uIFNhZmFyaSBmb3IgaWZyYW1lcyB3aXRoIHNjcmlwdHMgZGlzYWJsZWQsIHRoZSBgRE9NQ29udGVudExvYWRlZGAgbmV2ZXIgc2VlbXMgdG8gYmUgZmlyZWQ6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0zMzYwNAoJCQkJCS8vIFVzZSBwb2xsaW5nIGluc3RlYWQuCgkJCQkJY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7CgkJCQkJCS8vIElmIHRoZSBmcmFtZSBpcyBubyBsb25nZXIgbW91bnRlZCwgbG9hZGluZyBoYXMgc3RvcHBlZAoJCQkJCQlpZiAoIW5ld0ZyYW1lLnBhcmVudEVsZW1lbnQpIHsKCQkJCQkJCWNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpOwoJCQkJCQkJcmV0dXJuOwoJCQkJCQl9CgoJCQkJCQljb25zdCBjb250ZW50RG9jdW1lbnQgPSBhc3NlcnRJc0RlZmluZWQobmV3RnJhbWUuY29udGVudERvY3VtZW50KTsKCQkJCQkJaWYgKGNvbnRlbnREb2N1bWVudC5sb2NhdGlvbi5wYXRobmFtZS5lbmRzV2l0aCgnL2Zha2UuaHRtbCcpICYmIGNvbnRlbnREb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnbG9hZGluZycpIHsKCQkJCQkJCWNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpOwoJCQkJCQkJb25GcmFtZUxvYWRlZChjb250ZW50RG9jdW1lbnQpOwoJCQkJCQl9CgkJCQkJfSwgMTApOwoJCQkJfSBlbHNlIHsKCQkJCQlhc3NlcnRJc0RlZmluZWQobmV3RnJhbWUuY29udGVudFdpbmRvdykuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGUgPT4gewoJCQkJCQljb25zdCBjb250ZW50RG9jdW1lbnQgPSBlLnRhcmdldCA/ICgvKiogQHR5cGUge0hUTUxEb2N1bWVudH0gKi8gKGUudGFyZ2V0KSkgOiB1bmRlZmluZWQ7CgkJCQkJCW9uRnJhbWVMb2FkZWQoYXNzZXJ0SXNEZWZpbmVkKGNvbnRlbnREb2N1bWVudCkpOwoJCQkJCX0pOwoJCQkJfQoKCQkJCS8qKgoJCQkJICogQHBhcmFtIHtEb2N1bWVudH0gY29udGVudERvY3VtZW50CgkJCQkgKiBAcGFyYW0ge1dpbmRvd30gY29udGVudFdpbmRvdwoJCQkJICovCgkJCQljb25zdCBvbkxvYWQgPSAoY29udGVudERvY3VtZW50LCBjb250ZW50V2luZG93KSA9PiB7CgkJCQkJaWYgKGNvbnRlbnREb2N1bWVudCAmJiBjb250ZW50RG9jdW1lbnQuYm9keSkgewoJCQkJCQkvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L3ZzY29kZS9pc3N1ZXMvMTI4NjUKCQkJCQkJLy8gY2hlY2sgbmV3IHNjcm9sbFkgYW5kIHJlc2V0IGlmIG5lY2Vzc2FyeQoJCQkJCQlzZXRJbml0aWFsU2Nyb2xsUG9zaXRpb24oY29udGVudERvY3VtZW50LmJvZHksIGNvbnRlbnRXaW5kb3cpOwoJCQkJCX0KCgkJCQkJY29uc3QgbmV3RnJhbWUgPSBnZXRQZW5kaW5nRnJhbWUoKTsKCQkJCQlpZiAobmV3RnJhbWUgJiYgbmV3RnJhbWUuY29udGVudERvY3VtZW50ICYmIG5ld0ZyYW1lLmNvbnRlbnREb2N1bWVudCA9PT0gY29udGVudERvY3VtZW50KSB7CgkJCQkJCWNvbnN0IHdhc0ZvY3VzZWQgPSBkb2N1bWVudC5oYXNGb2N1cygpOwoJCQkJCQljb25zdCBvbGRBY3RpdmVGcmFtZSA9IGdldEFjdGl2ZUZyYW1lKCk7CgkJCQkJCWlmIChvbGRBY3RpdmVGcmFtZSkgewoJCQkJCQkJZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvbGRBY3RpdmVGcmFtZSk7CgkJCQkJCX0KCQkJCQkJLy8gU3R5bGVzIG1heSBoYXZlIGNoYW5nZWQgc2luY2Ugd2UgY3JlYXRlZCB0aGUgZWxlbWVudC4gTWFrZSBzdXJlIHdlIHJlLXN0eWxlCgkJCQkJCWlmIChpbml0aWFsU3R5bGVWZXJzaW9uICE9PSBzdHlsZVZlcnNpb24pIHsKCQkJCQkJCWFwcGx5U3R5bGVzKG5ld0ZyYW1lLmNvbnRlbnREb2N1bWVudCwgbmV3RnJhbWUuY29udGVudERvY3VtZW50LmJvZHkpOwoJCQkJCQl9CgkJCQkJCW5ld0ZyYW1lLnNldEF0dHJpYnV0ZSgnaWQnLCAnYWN0aXZlLWZyYW1lJyk7CgkJCQkJCW5ld0ZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7CgoJCQkJCQljb250ZW50V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZUlubmVyU2Nyb2xsKTsKCQkJCQkJY29udGVudFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGhhbmRsZVdoZWVsKTsKCgkJCQkJCWlmICh3YXNGb2N1c2VkKSB7CgkJCQkJCQljb250ZW50V2luZG93LmZvY3VzKCk7CgkJCQkJCX0KCgkJCQkJCXBlbmRpbmdNZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlKSA9PiB7CgkJCQkJCQljb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2UubWVzc2FnZSwgd2luZG93Lm9yaWdpbiwgbWVzc2FnZS50cmFuc2Zlcik7CgkJCQkJCX0pOwoJCQkJCQlwZW5kaW5nTWVzc2FnZXMgPSBbXTsKCQkJCQl9CgkJCQl9OwoKCQkJCS8qKgoJCQkJICogQHBhcmFtIHtIVE1MSUZyYW1lRWxlbWVudH0gbmV3RnJhbWUKCQkJCSAqLwoJCQkJZnVuY3Rpb24gaG9va3VwT25Mb2FkSGFuZGxlcnMobmV3RnJhbWUpIHsKCQkJCQljbGVhclRpbWVvdXQobG9hZFRpbWVvdXQpOwoJCQkJCWxvYWRUaW1lb3V0ID0gdW5kZWZpbmVkOwoJCQkJCWxvYWRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7CgkJCQkJCWNsZWFyVGltZW91dChsb2FkVGltZW91dCk7CgkJCQkJCWxvYWRUaW1lb3V0ID0gdW5kZWZpbmVkOwoJCQkJCQlvbkxvYWQoYXNzZXJ0SXNEZWZpbmVkKG5ld0ZyYW1lLmNvbnRlbnREb2N1bWVudCksIGFzc2VydElzRGVmaW5lZChuZXdGcmFtZS5jb250ZW50V2luZG93KSk7CgkJCQkJfSwgMjAwKTsKCgkJCQkJY29uc3QgY29udGVudFdpbmRvdyA9IGFzc2VydElzRGVmaW5lZChuZXdGcmFtZS5jb250ZW50V2luZG93KTsKCgkJCQkJY29udGVudFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKGUpIHsKCQkJCQkJY29uc3QgY29udGVudERvY3VtZW50ID0gLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKGUudGFyZ2V0KTsKCgkJCQkJCWlmIChsb2FkVGltZW91dCkgewoJCQkJCQkJY2xlYXJUaW1lb3V0KGxvYWRUaW1lb3V0KTsKCQkJCQkJCWxvYWRUaW1lb3V0ID0gdW5kZWZpbmVkOwoJCQkJCQkJb25Mb2FkKGNvbnRlbnREb2N1bWVudCwgdGhpcyk7CgkJCQkJCX0KCQkJCQl9KTsKCgkJCQkJLy8gQnViYmxlIG91dCB2YXJpb3VzIGV2ZW50cwoJCQkJCWNvbnRlbnRXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVJbm5lckNsaWNrKTsKCQkJCQljb250ZW50V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2F1eGNsaWNrJywgaGFuZGxlQXV4Q2xpY2spOwoJCQkJCWNvbnRlbnRXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUlubmVyS2V5ZG93bik7CgkJCQkJY29udGVudFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZUlubmVyS2V5dXApOwoJCQkJCWNvbnRlbnRXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBlID0+IHsKCQkJCQkJaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgewoJCQkJCQkJLy8gRXh0ZW5zaW9uIGNvZGUgaGFzIGFscmVhZHkgaGFuZGxlZCB0aGlzIGV2ZW50CgkJCQkJCQlyZXR1cm47CgkJCQkJCX0KCgkJCQkJCWUucHJldmVudERlZmF1bHQoKTsKCgkJCQkJCS8qKiBAdHlwZSB7IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+fSAqLwoJCQkJCQlsZXQgY29udGV4dCA9IHt9OwoKCQkJCQkJLyoqIEB0eXBlIHtIVE1MRWxlbWVudCB8IG51bGx9ICovCgkJCQkJCWxldCBlbCA9IGUudGFyZ2V0OwoJCQkJCQl3aGlsZSAodHJ1ZSkgewoJCQkJCQkJaWYgKCFlbCkgewoJCQkJCQkJCWJyZWFrOwoJCQkJCQkJfQoKCQkJCQkJCS8vIFNlYXJjaCBzZWxmL2FuY2VzdG9ycyBmb3IgdGhlIGNsb3Nlc3QgY29udGV4dCBkYXRhIGF0dHJpYnV0ZQoJCQkJCQkJZWwgPSBlbC5jbG9zZXN0KCdbZGF0YS12c2NvZGUtY29udGV4dF0nKTsKCQkJCQkJCWlmICghZWwpIHsKCQkJCQkJCQlicmVhazsKCQkJCQkJCX0KCgkJCQkJCQl0cnkgewoJCQkJCQkJCWNvbnRleHQgPSB7IC4uLkpTT04ucGFyc2UoZWwuZGF0YXNldC52c2NvZGVDb250ZXh0KSwgLi4uY29udGV4dCB9OwoJCQkJCQkJfSBjYXRjaCAoZSkgewoJCQkJCQkJCWNvbnNvbGUuZXJyb3IoYEVycm9yIHBhcnNpbmcgJ2RhdGEtdnNjb2RlLWNvbnRleHQnIGFzIGpzb25gLCBlbCwgZSk7CgkJCQkJCQl9CgoJCQkJCQkJZWwgPSBlbC5wYXJlbnRFbGVtZW50OwoJCQkJCQl9CgoJCQkJCQlob3N0TWVzc2FnaW5nLnBvc3RNZXNzYWdlKCdkaWQtY29udGV4dC1tZW51JywgewoJCQkJCQkJY2xpZW50WDogZS5jbGllbnRYLAoJCQkJCQkJY2xpZW50WTogZS5jbGllbnRZLAoJCQkJCQkJY29udGV4dDogY29udGV4dAoJCQkJCQl9KTsKCQkJCQl9KTsKCgkJCQkJY29udGVudFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBoYW5kbGVJbm5lckRyYWdTdGFydEV2ZW50KTsKCQkJCQljb250ZW50V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgaGFuZGxlSW5uZXJEcmFnU3RhcnRFdmVudCk7CgoJCQkJCXVubG9hZE1vbml0b3Iub25JZnJhbWVMb2FkZWQobmV3RnJhbWUpOwoJCQkJfQoJCQl9KTsKCgkJCS8vIHByb3BhZ2F0ZSB2c2NvZGUtY29udGV4dC1tZW51LXZpc2libGUgY2xhc3MKCQkJaG9zdE1lc3NhZ2luZy5vbk1lc3NhZ2UoJ3NldC1jb250ZXh0LW1lbnUtdmlzaWJsZScsIChfZXZlbnQsIGRhdGEpID0+IHsKCQkJCWNvbnN0IHRhcmdldCA9IGdldEFjdGl2ZUZyYW1lKCk7CgkJCQlpZiAodGFyZ2V0ICYmIHRhcmdldC5jb250ZW50RG9jdW1lbnQpIHsKCQkJCQl0YXJnZXQuY29udGVudERvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnRvZ2dsZSgndnNjb2RlLWNvbnRleHQtbWVudS12aXNpYmxlJywgZGF0YS52aXNpYmxlKTsKCQkJCX0KCQkJfSk7CgoJCQlob3N0TWVzc2FnaW5nLm9uTWVzc2FnZSgnc2V0LXRpdGxlJywgYXN5bmMgKF9ldmVudCwgZGF0YSkgPT4gewoJCQkJY29uc3QgdGFyZ2V0ID0gZ2V0QWN0aXZlRnJhbWUoKTsKCQkJCWlmICh0YXJnZXQpIHsKCQkJCQl0YXJnZXQudGl0bGUgPSBkYXRhOwoJCQkJfQoJCQl9KTsKCgkJCS8vIEZvcndhcmQgbWVzc2FnZSB0byB0aGUgZW1iZWRkZWQgaWZyYW1lCgkJCWhvc3RNZXNzYWdpbmcub25NZXNzYWdlKCdtZXNzYWdlJywgKF9ldmVudCwgZGF0YSkgPT4gewoJCQkJY29uc3QgcGVuZGluZyA9IGdldFBlbmRpbmdGcmFtZSgpOwoJCQkJaWYgKCFwZW5kaW5nKSB7CgkJCQkJY29uc3QgdGFyZ2V0ID0gZ2V0QWN0aXZlRnJhbWUoKTsKCQkJCQlpZiAodGFyZ2V0KSB7CgkJCQkJCWFzc2VydElzRGVmaW5lZCh0YXJnZXQuY29udGVudFdpbmRvdykucG9zdE1lc3NhZ2UoZGF0YS5tZXNzYWdlLCB3aW5kb3cub3JpZ2luLCBkYXRhLnRyYW5zZmVyKTsKCQkJCQkJcmV0dXJuOwoJCQkJCX0KCQkJCX0KCQkJCXBlbmRpbmdNZXNzYWdlcy5wdXNoKGRhdGEpOwoJCQl9KTsKCgkJCWhvc3RNZXNzYWdpbmcub25NZXNzYWdlKCdpbml0aWFsLXNjcm9sbC1wb3NpdGlvbicsIChfZXZlbnQsIHByb2dyZXNzKSA9PiB7CgkJCQlpbml0RGF0YS5pbml0aWFsU2Nyb2xsUHJvZ3Jlc3MgPSBwcm9ncmVzczsKCQkJfSk7CgoJCQlob3N0TWVzc2FnaW5nLm9uTWVzc2FnZSgnZXhlY0NvbW1hbmQnLCAoX2V2ZW50LCBkYXRhKSA9PiB7CgkJCQljb25zdCB0YXJnZXQgPSBnZXRBY3RpdmVGcmFtZSgpOwoJCQkJaWYgKCF0YXJnZXQpIHsKCQkJCQlyZXR1cm47CgkJCQl9CgkJCQlhc3NlcnRJc0RlZmluZWQodGFyZ2V0LmNvbnRlbnREb2N1bWVudCkuZXhlY0NvbW1hbmQoZGF0YSk7CgkJCX0pOwoKCQkJLyoqIEB0eXBlIHtzdHJpbmcgfCB1bmRlZmluZWR9ICovCgkJCWxldCBsYXN0RmluZFZhbHVlID0gdW5kZWZpbmVkOwoKCQkJaG9zdE1lc3NhZ2luZy5vbk1lc3NhZ2UoJ2ZpbmQnLCAoX2V2ZW50LCBkYXRhKSA9PiB7CgkJCQljb25zdCB0YXJnZXQgPSBnZXRBY3RpdmVGcmFtZSgpOwoJCQkJaWYgKCF0YXJnZXQpIHsKCQkJCQlyZXR1cm47CgkJCQl9CgoJCQkJaWYgKCFkYXRhLnByZXZpb3VzICYmIGxhc3RGaW5kVmFsdWUgIT09IGRhdGEudmFsdWUgJiYgdGFyZ2V0LmNvbnRlbnRXaW5kb3cpIHsKCQkJCQkvLyBSZXNldCBzZWxlY3Rpb24gc28gd2Ugc3RhcnQgc2VhcmNoIGF0IHRoZSBoZWFkIG9mIHRoZSBsYXN0IHNlYXJjaAoJCQkJCWNvbnN0IHNlbGVjdGlvbiA9IHRhcmdldC5jb250ZW50V2luZG93LmdldFNlbGVjdGlvbigpOwoJCQkJCWlmIChzZWxlY3Rpb24pIHsKCQkJCQkJc2VsZWN0aW9uLmNvbGxhcHNlKHNlbGVjdGlvbi5hbmNob3JOb2RlKTsKCQkJCQl9CgkJCQl9CgkJCQlsYXN0RmluZFZhbHVlID0gZGF0YS52YWx1ZTsKCgkJCQljb25zdCBkaWRGaW5kID0gKC8qKiBAdHlwZSB7YW55fSAqLyAodGFyZ2V0LmNvbnRlbnRXaW5kb3cpKS5maW5kKAoJCQkJCWRhdGEudmFsdWUsCgkJCQkJLyogY2FzZVNlbnNpdGl2ZSovIGZhbHNlLAoJCQkJCS8qIGJhY2t3YXJkcyovIGRhdGEucHJldmlvdXMsCgkJCQkJLyogd3JhcEFyb3VuZCovIHRydWUsCgkJCQkJLyogd2hvbGVXb3JkICovIGZhbHNlLAoJCQkJCS8qIHNlYXJjaEluRnJhbWVzKi8gZmFsc2UsCgkJCQkJZmFsc2UpOwoJCQkJaG9zdE1lc3NhZ2luZy5wb3N0TWVzc2FnZSgnZGlkLWZpbmQnLCBkaWRGaW5kKTsKCQkJfSk7CgoJCQlob3N0TWVzc2FnaW5nLm9uTWVzc2FnZSgnZmluZC1zdG9wJywgKF9ldmVudCwgZGF0YSkgPT4gewoJCQkJY29uc3QgdGFyZ2V0ID0gZ2V0QWN0aXZlRnJhbWUoKTsKCQkJCWlmICghdGFyZ2V0KSB7CgkJCQkJcmV0dXJuOwoJCQkJfQoKCQkJCWxhc3RGaW5kVmFsdWUgPSB1bmRlZmluZWQ7CgoJCQkJaWYgKCFkYXRhLmNsZWFyU2VsZWN0aW9uICYmIHRhcmdldC5jb250ZW50V2luZG93KSB7CgkJCQkJY29uc3Qgc2VsZWN0aW9uID0gdGFyZ2V0LmNvbnRlbnRXaW5kb3cuZ2V0U2VsZWN0aW9uKCk7CgkJCQkJaWYgKHNlbGVjdGlvbikgewoJCQkJCQlmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGlvbi5yYW5nZUNvdW50OyBpKyspIHsKCQkJCQkJCXNlbGVjdGlvbi5yZW1vdmVSYW5nZShzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKSk7CgkJCQkJCX0KCQkJCQl9CgkJCQl9CgkJCX0pOwoKCQkJdHJhY2tGb2N1cyh7CgkJCQlvbkZvY3VzOiAoKSA9PiBob3N0TWVzc2FnaW5nLnBvc3RNZXNzYWdlKCdkaWQtZm9jdXMnLCB1bmRlZmluZWQpLAoJCQkJb25CbHVyOiAoKSA9PiBob3N0TWVzc2FnaW5nLnBvc3RNZXNzYWdlKCdkaWQtYmx1cicsIHVuZGVmaW5lZCkKCQkJfSk7CgoJCQkoLyoqIEB0eXBlIHthbnl9ICovICh3aW5kb3cpKVt2c2NvZGVQb3N0TWVzc2FnZUZ1bmNOYW1lXSA9ICgvKiogQHR5cGUge3N0cmluZ30gKi8gY29tbWFuZCwgLyoqIEB0eXBlIHthbnl9ICovIGRhdGEpID0+IHsKCQkJCXN3aXRjaCAoY29tbWFuZCkgewoJCQkJCWNhc2UgJ29ubWVzc2FnZSc6CgkJCQkJY2FzZSAnZG8tdXBkYXRlLXN0YXRlJzoKCQkJCQkJaG9zdE1lc3NhZ2luZy5wb3N0TWVzc2FnZShjb21tYW5kLCBkYXRhKTsKCQkJCQkJYnJlYWs7CgkJCQl9CgkJCX07CgoJCQlob3N0TWVzc2FnaW5nLnNpZ25hbFJlYWR5KCk7CgkJfSk7Cgk8L3NjcmlwdD4KPC9ib2R5PgoKPC9odG1sPgo=", self.location).href, Oo),
  "vs/workbench/contrib/webview/browser/pre/fake.html": () => Os(new URL("data:text/html;base64,PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KPGhlYWQ+Cgk8bWV0YSBjaGFyc2V0PSJVVEYtOCI+Cgk8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMCI+Cgk8dGl0bGU+RmFrZTwvdGl0bGU+CjwvaGVhZD4KPGJvZHk+CjwvYm9keT4KPC9odG1sPgo=", self.location).href, Oo)
});
dw(async (c) => {
  var s, n, r;
  const e = c.get(ii), t = c.get(Me);
  c.get(oi), e.getPaneComposites(1);
  const i = c.get(Vd), o = document.createElement("div");
  o.style.display = "none", document.body.append(o);
  for (const { id: a, role: d, classes: h, options: g } of [
    { id: "workbench.parts.activitybar", role: "none", classes: ["activitybar", "left"] },
    { id: "workbench.parts.sidebar", role: "none", classes: ["sidebar", "left"] },
    { id: "workbench.parts.editor", role: "main", classes: ["editor"], options: { restorePreviousState: !1 } },
    { id: "workbench.parts.panel", role: "none", classes: ["panel", "basepanel", lw(2)] },
    { id: "workbench.parts.auxiliarybar", role: "none", classes: ["auxiliarybar", "basepanel", "right"] },
    { id: "workbench.parts.statusbar", role: "status", classes: ["statusbar"] }
  ]) {
    const p = pS(a, d, h), m = i.getPart(a);
    m.create(p, g), mS(p, m), o.append(p);
  }
  await e.openPaneComposite((s = t.getDefaultViewContainer(0)) == null ? void 0 : s.id, 0), await e.openPaneComposite((n = t.getDefaultViewContainer(1)) == null ? void 0 : n.id, 1), await e.openPaneComposite((r = t.getDefaultViewContainer(2)) == null ? void 0 : r.id, 2);
});
function cJ(c, e) {
  return e != null && (Oo = e), {
    ...zv(),
    ...gS(),
    ...Uv({
      isKeybindingConfigurationVisible: Vr,
      shouldUseGlobalPicker: Vr
    }),
    [Mn.toString()]: new T(hw, [], !1),
    [Me.toString()]: new T(ea, [], !0),
    [Eo.toString()]: new T(ia, [], !0),
    [ii.toString()]: new T(ua, [], !0),
    [Lt.toString()]: new T(pa, [], !0),
    [ht.toString()]: new T(ma, [], !0),
    [No.toString()]: new T(vw, [], !0),
    [rg.toString()]: new T(jv, [], !1),
    [ce.toString()]: new T(Nc, [], !1),
    [oi.toString()]: new T(vc, [], !1),
    [qv.toString()]: new T(Dc, [], !0),
    [D.toString()]: new T(ww, [c, Vr], !1),
    [Zs.toString()]: new T(bc, [], !1),
    [Xt.toString()]: new T($v, [], !0),
    [Fn.toString()]: new T(ew, [], !0),
    [tw.toString()]: new T(iw, [], !0),
    [ow.toString()]: new T(sw, [], !0),
    [nw.toString()]: new T(wc, [], !1),
    [Yn.toString()]: new T(Tk, [], !0),
    [$u.toString()]: new T(kc, [], !0),
    [As.toString()]: new T(Zc, [], !0),
    [zu.toString()]: new T(rw, [], !0),
    [qu.toString()]: new T(aw, [], !0)
  };
}
export {
  ia as ActivityService,
  da as ActivitybarPart,
  hJ as ConfirmResult,
  pa as HoverService,
  la as PanelPart,
  uJ as Parts,
  jr as SidebarPart,
  vc as StatusbarPart,
  gJ as ViewContainerLocation,
  Bo as attachPart,
  cJ as default,
  Vr as isEditorPartVisible,
  zI as isPartVisibile,
  MI as onPartVisibilityChange,
  nJ as registerCustomView,
  sJ as registerEditorPane,
  jI as renderActivitybarPar,
  eJ as renderAuxiliaryPart,
  tJ as renderEditorPart,
  $I as renderPanelPart,
  mS as renderPart,
  qI as renderSidebarPart,
  iJ as renderStatusBarPart,
  UI as setPartVisibility
};

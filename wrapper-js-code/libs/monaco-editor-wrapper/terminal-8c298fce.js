import { c5 as at, G as g, bk as te, t4 as Ya, ws as se, wt as $r, wu as Jt, wv as fi, t5 as Qa, aw as re, tz as os, _ as X, a as D, cR as Bi, ww as li, wx as Ae, bY as dt, ag as Me, e as le, U as oe, aN as Se, ac as ti, D as ue, hW as Ja, g as Oi, oP as Mt, e2 as Le, wy as ai, S as me, e3 as Ts, dn as Za, jJ as ec, cz as tn, aR as ve, wz as E, ak as Vo, al as $o, wA as we, wB as yt, wC as Bt, wD as ii, pD as Wt, dA as Ur, dl as Vn, aG as R, wE as De, cQ as $n, cb as xi, gk as no, ab as Ee, ap as Fi, wF as Et, bD as qe, bF as Un, bE as tt, dI as ri, e$ as tc, dC as Gn, fJ as ic, bW as Gr, c3 as bi, fk as zn, bU as Te, w6 as zr, I as Kn, bG as nc, rj as qn, cL as sc, bL as rc, bM as oc, hh as Hi, jy as Uo, sj as ac, lu as jn, F as Pt, vQ as cc, n as Wi, sk as Go, aW as Xn, bH as nn, aZ as lc, wG as hc, m1 as zo, wH as dc, wI as Kr, ji as de, pj as hi, wJ as yn, vc as ut, aj as mt, kz as sn, aK as Ni, wK as ht, wL as Ko, ad as _i, wM as uc, wN as mc, oO as Gi, ut as gi, iZ as fc, O as be, rM as Yn, wO as qr, wP as rn, aM as Qn, f as _c, ul as gc, b as qo, E as V, wQ as pc, wR as cn, wS as ln, wT as vc, bT as ki, wU as jo, bB as Jn, sE as pi, wV as xn, wW as kn, wX as In, wY as hn, a$ as Sc, wZ as bc, sN as wc, sM as Cc, B as yc, w_ as ni, uq as xc, w$ as kc, c2 as Xo, iz as Yo, dw as Qo, k9 as Ic, aT as ci, aP as Zn, x0 as Tc, aI as J, aS as Jo, x1 as Dc, x2 as so, kK as es, pP as Ec, x3 as Ac, x4 as Lc, us as Pc, x5 as ro, x6 as Rc, x7 as Mc, cE as dn, x8 as Bc, x9 as Zo, xa as ea, pO as Ii, eY as wt, jw as Oc, xb as Ds, xc as Es, q1 as ts, xd as ta, ax as Fc, d as ye, xe as ia, dz as di, xf as ft, qQ as Lt, k as je, aO as on, dv as Hc, a2 as he, a4 as et, f0 as is, r5 as jr, r6 as Xr, xg as Wc, xh as Nc, xi as Vc, xj as As, xk as $c, xl as Uc, xm as Gc, xn as zc, y as Zt, K as Qe, $ as Ve, he as Kc, dg as qc, z as Ft, q as jc, hP as Xc, xo as Yc, o as Nt, i5 as Qc, xp as Jc, mg as Zc, J as si, pl as el, rD as tl, eA as as, vO as il, xq as nl, b3 as sl, eM as rl, xr as na, cs as sa, xs as ol, xt as al, xu as cl, xv as ll, xw as hl, xx as dl, xy as ul, xz as ml, xA as fl, xB as _l, xC as gl, tO as Re, xD as Ot, ai as Fe, kq as vi, Q as Oe, te as Ls, eE as ra, xE as oa, qc as pl, aE as vl, xF as oo, xG as Sl, bh as rt, il as bl, sH as vn, xH as wl, xI as Cl, xJ as yl, k5 as xl, hG as kl, hF as Il, xK as Ye, w as Tl, xL as Ps, d9 as ao, fi as Dl, rJ as Rs, eO as El, xM as fe, a8 as Al, b6 as co, xN as Ll, l$ as Pl, e7 as Rl, dW as Ml, xO as Bl, xP as aa, d0 as Ol, xQ as Ms, xR as Fl, af as ui, fU as Yr, bX as ns, oB as Hl, ah as an, fu as zi, fv as Tn, dX as wi, ae as ss, xS as Wl, xT as Nl, xU as it, xV as Vl, f4 as ca, xW as Ki, jD as Ce, xX as $l, xY as Ul, dG as la, ir as ha, c7 as da, xZ as Gl, x_ as zl, x$ as Kl, dx as Qr, eQ as ql, cZ as ua, cY as Dn, y0 as jl, h_ as Jr, y1 as ma, y2 as fa, c$ as Bs, m5 as lo, y3 as un, y4 as Xl, y5 as Yl, y6 as Ql, y7 as Jl, an as Zl, iW as eh, iY as th, bv as ih, y8 as nh, cH as _a, p7 as sh, di as rh, dj as oh, ba as ah, c1 as En, sV as ga, oH as ch, kJ as lh, d1 as ho, y9 as hh, u4 as uo, vC as dh, kt as uh, a3 as mh, b$ as pa, bO as He, ya as mo, hV as fh, sK as _h, st as gh, sI as ph, wl as fo, jf as vh, bz as va, yb as _o, yc as mn, yd as Sh, dR as bh, ye as An, dF as wh, yf as Ch, jW as yh, mv as xh, bA as Sa, hO as kh, eV as Ih, j7 as Th, l as We, ft as Dh, at as ba, aC as Eh, yg as Ah, kP as fn, uG as Lh, yh as Ph, sA as Rh, sv as Mh, a1 as Bh, l_ as Oh, yi as Fh, yj as Hh, lD as _t, yk as Wh, yl as Nh, ym as Vh } from "./verifyPrepare-778b382e.js";
import { m as $h, p as wa, s as Uh, a as Gh, w as Ne, i as gt, t as Vi, e as Ci, b as zh } from "./quickPickPin-1d33fc54.js";
import { s as Kh } from "./logConstants-dafc31db.js";
import { g as qh } from "./viewsService-20cca09f.js";
import { D as Ca } from "./dropdownWithPrimaryActionViewItem-07aebec1.js";
function yi(h, e = {}) {
  let t = "";
  return e.excludeLeadingNewLine || (t += `\r
`), t += "\x1B[0m\x1B[7m * ", e.loudFormatting ? t += "\x1B[0;104m" : t += "\x1B[0m", t += ` ${h} \x1B[0m
\r`, t;
}
const ya = at("terminal-view-icon", te.terminal, g("terminalViewIcon", "View icon of the terminal view.")), jh = at("terminal-rename", te.gear, g("renameTerminalIcon", "Icon for rename in the terminal quick menu.")), xa = at("terminal-kill", te.trash, g("killTerminalIcon", "Icon for killing a terminal instance.")), Xh = at("terminal-new", te.add, g("newTerminalIcon", "Icon for creating a new terminal instance.")), Yh = at("terminal-configure-profile", te.gear, g(
  "configureTerminalProfileIcon",
  "Icon for creating a new terminal profile."
)), Qh = at("terminal-decoration-mark", te.circleSmallFilled, g("terminalDecorationMark", "Icon for a terminal decoration mark.")), Jh = at("terminal-decoration-incomplete", te.circle, g(
  "terminalDecorationIncomplete",
  "Icon for a terminal decoration of a command that was incomplete."
)), Zh = at("terminal-decoration-error", te.errorSmall, g(
  "terminalDecorationError",
  "Icon for a terminal decoration of a command that errored."
)), ed = at("terminal-decoration-success", te.circleFilled, g(
  "terminalDecorationSuccess",
  "Icon for a terminal decoration of a command that was successful."
)), td = at("terminal-command-history-remove", te.close, g(
  "terminalCommandHistoryRemove",
  "Icon for removing a terminal command from command history."
)), id = at("terminal-command-history-output", te.output, g(
  "terminalCommandHistoryOutput",
  "Icon for viewing output of a terminal command."
)), nd = at("terminal-command-history-fuzzy-search", te.searchFuzzy, g(
  "terminalCommandHistoryFuzzySearch",
  "Icon for toggling fuzzy search of command history."
)), Q = {
  terminal: g("terminal", "Terminal"),
  new: g("terminal.new", "New Terminal"),
  doNotShowAgain: g("doNotShowAgain", "Do Not Show Again"),
  currentSessionCategory: g("currentSessionCategory", "current session"),
  previousSessionCategory: g("previousSessionCategory", "previous session"),
  actionCategory: {
    value: g("terminalCategory", "Terminal"),
    original: "Terminal"
  },
  focus: {
    value: g("workbench.action.terminal.focus", "Focus Terminal"),
    original: "Focus Terminal"
  },
  kill: {
    value: g("killTerminal", "Kill Terminal"),
    original: "Kill Terminal",
    short: g("killTerminal.short", "Kill")
  },
  moveToEditor: {
    value: g("moveToEditor", "Move Terminal into Editor Area"),
    original: "Move Terminal into Editor Area"
  },
  moveToTerminalPanel: {
    value: g(
      "workbench.action.terminal.moveToTerminalPanel",
      "Move Terminal into Panel"
    ),
    original: "Move Terminal into Panel"
  },
  changeIcon: {
    value: g("workbench.action.terminal.changeIcon", "Change Icon..."),
    original: "Change Icon..."
  },
  changeColor: {
    value: g("workbench.action.terminal.changeColor", "Change Color..."),
    original: "Change Color..."
  },
  split: {
    value: g("splitTerminal", "Split Terminal"),
    original: "Split Terminal",
    short: g("splitTerminal.short", "Split")
  },
  unsplit: {
    value: g("unsplitTerminal", "Unsplit Terminal"),
    original: "Unsplit Terminal"
  },
  rename: {
    value: g("workbench.action.terminal.rename", "Rename..."),
    original: "Rename..."
  },
  toggleSizeToContentWidth: {
    value: g(
      "workbench.action.terminal.sizeToContentWidthInstance",
      "Toggle Size to Content Width"
    ),
    original: "Toggle Size to Content Width"
  },
  focusHover: {
    value: g("workbench.action.terminal.focusHover", "Focus Hover"),
    original: "Focus Hover"
  },
  sendSequence: {
    value: g(
      "workbench.action.terminal.sendSequence",
      "Send Custom Sequence To Terminal"
    ),
    original: "Send Custom Sequence To Terminal"
  },
  newWithCwd: {
    value: g(
      "workbench.action.terminal.newWithCwd",
      "Create New Terminal Starting in a Custom Working Directory"
    ),
    original: "Create New Terminal Starting in a Custom Working Directory"
  },
  renameWithArgs: {
    value: g(
      "workbench.action.terminal.renameWithArg",
      "Rename the Currently Active Terminal"
    ),
    original: "Rename the Currently Active Terminal"
  }
};
let ct = [];
var Ei;
let Yi = (Ei = class extends Ya {
  constructor(e, t, i, s, c, l, n) {
    super(Ei.PREFIX, { canAcceptInBackground: !0 }), this._editorService = e, this._terminalService = t, this._terminalEditorService = i, this._terminalGroupService = s, this._commandService = c, this._themeService = l, this._instantiationService = n;
  }
  _getPicks(e) {
    ct = [], ct.push({ type: "separator", label: "panel" });
    const t = this._terminalGroupService.groups;
    for (let l = 0; l < t.length; l++) {
      const n = t[l];
      for (let r = 0; r < n.terminalInstances.length; r++) {
        const a = n.terminalInstances[r], f = this._createPick(a, r, e, { groupIndex: l, groupSize: n.terminalInstances.length });
        f && ct.push(f);
      }
    }
    ct.length > 0 && ct.push({ type: "separator", label: "editor" });
    const i = this._terminalEditorService.instances;
    for (let l = 0; l < i.length; l++) {
      const n = i[l];
      n.target = se.Editor;
      const r = this._createPick(n, l, e);
      r && ct.push(r);
    }
    ct.length > 0 && ct.push({ type: "separator" });
    const s = g("workbench.action.terminal.newplus", "Create New Terminal");
    ct.push({
      label: `$(plus) ${s}`,
      ariaLabel: s,
      accept: () => this._commandService.executeCommand("workbench.action.terminal.new")
    });
    const c = g(
      "workbench.action.terminal.newWithProfilePlus",
      "Create New Terminal With Profile"
    );
    return ct.push({
      label: `$(plus) ${c}`,
      ariaLabel: c,
      accept: () => this._commandService.executeCommand("workbench.action.terminal.newWithProfile")
    }), ct;
  }
  _createPick(e, t, i, s) {
    const c = this._instantiationService.invokeFunction($r, e), l = s ? s.groupSize > 1 ? `${s.groupIndex + 1}.${t + 1}` : `${s.groupIndex + 1}` : `${t + 1}`, n = `$(${c}) ${l}: ${e.title}`, r = [], a = Jt(e);
    a && r.push(a);
    const f = fi(e, this._themeService.getColorTheme().type);
    f && r.push(...f);
    const m = Qa(i, n, !0);
    if (m)
      return {
        label: n,
        description: e.description,
        highlights: { label: m },
        buttons: [
          {
            iconClass: re.asClassName(jh),
            tooltip: g("renameTerminal", "Rename Terminal")
          },
          {
            iconClass: re.asClassName(xa),
            tooltip: Q.kill.value
          }
        ],
        iconClasses: r,
        trigger: (C) => {
          switch (C) {
            case 0:
              return this._commandService.executeCommand("workbench.action.terminal.rename", e), os.NO_ACTION;
            case 1:
              return this._terminalService.safeDisposeTerminal(e), os.REMOVE_ITEM;
          }
          return os.NO_ACTION;
        },
        accept: (C, b) => {
          if (e.target === se.Editor) {
            const p = this._editorService.findEditors(e.resource);
            this._terminalEditorService.openEditor(e, { viewColumn: p == null ? void 0 : p[0].groupId }), this._terminalEditorService.setActiveInstance(e);
          } else
            this._terminalGroupService.showPanel(!b.inBackground), this._terminalGroupService.setActiveInstance(e);
        }
      };
  }
}, Ei.PREFIX = "term ", Ei);
Yi = X([
  D(0, Bi),
  D(1, li),
  D(2, li),
  D(3, Ae),
  D(4, dt),
  D(5, Me),
  D(6, le)
], Yi);
function ka(h, e) {
  const t = [{
    name: null,
    description: g("terminalAutomaticProfile", "Automatically detect the default")
  }];
  return t.push(...h.map((i) => ({
    name: i.profileName,
    description: sd(i)
  }))), e && t.push(...e.map((i) => ({
    name: i.title,
    description: rd(i)
  }))), {
    values: t.map((i) => i.name),
    markdownDescriptions: t.map((i) => i.description)
  };
}
function sd(h) {
  let e = `$(${re.isThemeIcon(h.icon) ? h.icon.id : h.icon ? h.icon : te.terminal.id}) ${h.profileName}
- path: ${h.path}`;
  return h.args && (typeof h.args == "string" ? e += `
- args: "${h.args}"` : e += `
- args: [${h.args.length === 0 ? "" : `'${h.args.join("','")}'`}]`), h.overrideName !== void 0 && (e += `
- overrideName: ${h.overrideName}`), h.color && (e += `
- color: ${h.color}`), h.env && (e += `
- env: ${JSON.stringify(h.env)}`), e;
}
function rd(h) {
  return `$(${re.isThemeIcon(h.icon) ? h.icon.id : h.icon ? h.icon : te.terminal.id}) ${h.title}
- extensionIdentifier: ${h.extensionIdentifier}`;
}
function Ia(h, e) {
  if (!h && !e)
    return !0;
  if (typeof h == "string" && typeof e == "string")
    return h === e;
  if (Array.isArray(h) && Array.isArray(e)) {
    if (h.length !== e.length)
      return !1;
    for (let t = 0; t < h.length; t++)
      if (h[t] !== e[t])
        return !1;
    return !0;
  }
  return !1;
}
function od(h, e) {
  if (!h && !e)
    return !0;
  if (!h || !e)
    return !1;
  if (re.isThemeIcon(h) && re.isThemeIcon(e))
    return h.id === e.id && h.color === e.color;
  if (typeof h == "object" && "light" in h && "dark" in h && typeof e == "object" && "light" in e && "dark" in e) {
    const t = h, i = e;
    if ((oe.isUri(t.light) || It(t.light)) && (oe.isUri(t.dark) || It(t.dark)) && (oe.isUri(i.light) || It(i.light)) && (oe.isUri(i.dark) || It(i.dark)))
      return t.light.path === i.light.path && t.dark.path === i.dark.path;
  }
  if (oe.isUri(h) && oe.isUri(e) || It(h) || It(e)) {
    const t = h, i = e;
    return t.path === i.path && t.scheme === i.scheme;
  }
  return !1;
}
function It(h) {
  return h ? typeof h.path == "string" && typeof h.scheme == "string" : !1;
}
let cs;
function Ln(h) {
  return cs || (cs = h.get(le).createInstance(Pn, "commands")), cs;
}
let ls;
function Os(h) {
  return ls || (ls = h.get(le).createInstance(Pn, "dirs")), ls;
}
const Sn = /* @__PURE__ */ new Map();
async function ad(h, e) {
  const t = Sn.get(e);
  if (t === null)
    return [];
  if (t !== void 0)
    return t;
  let i;
  switch (e) {
    case "bash":
      i = await ld(h);
      break;
    case "pwsh":
      i = await dd(h);
      break;
    case "zsh":
      i = await hd(h);
      break;
    case "fish":
      i = await ud(h);
      break;
    default:
      return [];
  }
  if (i === void 0)
    return Sn.set(e, null), [];
  const s = Array.from(i);
  return Sn.set(e, s), s;
}
function cd() {
  Sn.clear();
}
let Pn = class extends ue {
  get entries() {
    return this._ensureUpToDate(), this._entries.entries();
  }
  constructor(e, t, i) {
    super(), this._storageDataKey = e, this._configurationService = t, this._storageService = i, this._timestamp = 0, this._isReady = !1, this._isStale = !0, this._entries = new Ja(this._getHistoryLimit()), this._configurationService.onDidChangeConfiguration((s) => {
      s.affectsConfiguration("terminal.integrated.shellIntegration.history") && (this._entries.limit = this._getHistoryLimit());
    }), this._storageService.onDidChangeValue((s) => {
      s.key === this._getTimestampStorageKey() && !this._isStale && (this._isStale = this._storageService.getNumber(this._getTimestampStorageKey(), -1, 0) !== this._timestamp);
    });
  }
  add(e, t) {
    this._ensureUpToDate(), this._entries.set(e, t), this._saveState();
  }
  remove(e) {
    this._ensureUpToDate(), this._entries.delete(e), this._saveState();
  }
  clear() {
    this._ensureUpToDate(), this._entries.clear(), this._saveState();
  }
  _ensureUpToDate() {
    this._isReady || (this._loadState(), this._isReady = !0), this._isStale && (this._entries.clear(), this._loadState(), this._isStale = !1);
  }
  _loadState() {
    this._timestamp = this._storageService.getNumber(this._getTimestampStorageKey(), -1, 0);
    const e = this._loadPersistedState();
    if (e)
      for (const t of e.entries)
        this._entries.set(t.key, t.value);
  }
  _loadPersistedState() {
    const e = this._storageService.get(this._getEntriesStorageKey(), -1);
    if (e === void 0 || e.length === 0)
      return;
    let t;
    try {
      t = JSON.parse(e);
    } catch {
      return;
    }
    return t;
  }
  _saveState() {
    const e = { entries: [] };
    this._entries.forEach((t, i) => e.entries.push({ key: i, value: t })), this._storageService.store(this._getEntriesStorageKey(), JSON.stringify(e), -1, 1), this._timestamp = Date.now(), this._storageService.store(this._getTimestampStorageKey(), this._timestamp, -1, 1);
  }
  _getHistoryLimit() {
    const e = this._configurationService.getValue("terminal.integrated.shellIntegration.history");
    return typeof e == "number" ? e : 100;
  }
  _getTimestampStorageKey() {
    return `terminal.history.timestamp.${this._storageDataKey}`;
  }
  _getEntriesStorageKey() {
    return `terminal.history.entries.${this._storageDataKey}`;
  }
};
Pn = X([
  D(1, Se),
  D(2, ti)
], Pn);
async function ld(h) {
  const e = h.get(Oi), t = h.get(Mt), i = await t.getEnvironment();
  if ((i == null ? void 0 : i.os) === 1 || !i && Le)
    return;
  const s = await Qi(ai.HOME, ".bash_history", !1, e, t);
  if (s === void 0)
    return;
  const c = s.split(`
`), l = /* @__PURE__ */ new Set();
  let n, r, a;
  for (let f = 0; f < c.length; f++) {
    n = c[f], r === void 0 ? r = n : r += `
${n}`;
    for (let m = 0; m < n.length; m++)
      a ? n[m] === a && (a = void 0) : n[m].match(/['"]/) && (a = n[m]);
    a === void 0 && (r.length > 0 && l.add(r.trim()), r = void 0);
  }
  return l.values();
}
async function hd(h) {
  const e = h.get(Oi), t = h.get(Mt), i = await t.getEnvironment();
  if ((i == null ? void 0 : i.os) === 1 || !i && Le)
    return;
  const s = await Qi(ai.HOME, ".zsh_history", !1, e, t);
  if (s === void 0)
    return;
  const c = s.split(/\:\s\d+\:\d+;/), l = /* @__PURE__ */ new Set();
  for (let n = 0; n < c.length; n++) {
    const r = c[n].replace(/\\\n/g, `
`).trim();
    r.length > 0 && l.add(r);
  }
  return l.values();
}
async function dd(h) {
  const e = h.get(Oi), t = h.get(Mt);
  let i, s;
  const c = await t.getEnvironment(), l = (c == null ? void 0 : c.os) === 1 || !c && Le;
  l ? (i = ai.APPDATA, s = "\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt") : (i = ai.HOME, s = ".local/share/powershell/PSReadline/ConsoleHost_history.txt");
  const n = await Qi(i, s, l, e, t);
  if (n === void 0)
    return;
  const r = n.split(`
`), a = /* @__PURE__ */ new Set();
  let f, m, C;
  for (let b = 0; b < r.length; b++) {
    if (f = r[b], m === void 0 ? m = f : m += `
${f}`, !f.endsWith("`")) {
      const p = m.trim();
      p.length > 0 && a.add(p), m = void 0;
      continue;
    }
    for (let p = 0; p < f.length; p++)
      C ? f[p] === C && (C = void 0) : f[p].match(/`/) && (C = f[p]);
    if (C)
      m = m.replace(/`$/, ""), C = void 0;
    else {
      const p = m.trim();
      p.length > 0 && a.add(p), m = void 0;
    }
  }
  return a.values();
}
async function ud(h) {
  const e = h.get(Oi), t = h.get(Mt), i = await t.getEnvironment();
  if ((i == null ? void 0 : i.os) === 1 || !i && Le)
    return;
  const c = await (ai.XDG_DATA_HOME ? Qi(ai.XDG_DATA_HOME, "fish/fish_history", !1, e, t) : Qi(ai.HOME, ".local/share/fish/fish_history", !1, e, t));
  if (c === void 0)
    return;
  const l = /* @__PURE__ */ new Set(), n = c.split(`
`).filter((r) => r.startsWith("- cmd:")).map((r) => r.substring(6).trimStart());
  for (let r = 0; r < n.length; r++) {
    const a = md(n[r]).trim();
    a.length > 0 && l.add(a);
  }
  return l.values();
}
function md(h) {
  return fd(/(^|[^\\])((?:\\\\)*)(\\n)/g, h, `$1$2
`);
}
function fd(h, e, t) {
  let i, s = e;
  for (; ; )
    if (i = s, s = s.replace(h, t), s === i)
      return s;
}
async function Qi(h, e, t, i, s) {
  var r;
  if (!h)
    return;
  const c = !!((r = s.getConnection()) != null && r.remoteAuthority), l = oe.from({
    scheme: c ? me.vscodeRemote : me.file,
    path: (t ? Ts.join : Za.join)(h, e)
  });
  let n;
  try {
    n = await i.readFile(l);
  } catch (a) {
    if (a instanceof ec && a.fileOperationResult === 1)
      return;
    throw a;
  }
  if (n !== void 0)
    return n.value.toString();
}
const Ta = "─────────", Da = g("showTerminalTabs", "Show Tabs"), Rn = Q.actionCategory;
async function Ea(h, e, t, i) {
  switch (h.config.splitCwd) {
    case "workspaceRoot":
      if (t !== void 0 && i !== void 0) {
        if (t.length === 1)
          return t[0].uri;
        if (t.length > 1) {
          const s = {
            placeHolder: g(
              "workbench.action.terminal.newWorkspacePlaceholder",
              "Select current working directory for new terminal"
            )
          }, c = await i.executeCommand(zr, [s]);
          return c ? Promise.resolve(c.uri) : void 0;
        }
      }
      return "";
    case "initial":
      return e.getInitialCwd();
    case "inherited":
      return e.getCwd();
  }
}
const Aa = async (h, e) => {
  const t = h.get(we).activeInstance;
  if (t) {
    const i = Wt(e) && "text" in e ? bn(e.text) : void 0;
    if (!i)
      return;
    const s = h.get(qn), c = h.get(tt), n = h.get(jn).getLastActiveWorkspaceRoot(t.isRemote ? me.vscodeRemote : me.file), r = n ? Pt(c.getWorkspaceFolder(n)) : void 0, a = await s.resolveAsync(r, i);
    t.sendText(a, !1);
  }
};
let Fs = class extends ve {
  constructor(e) {
    super("workbench.action.terminal.launchHelp", g("terminalLaunchHelp", "Open Help")), this._openerService = e;
  }
  async run() {
    this._openerService.open("https://aka.ms/vscode-troubleshoot-terminal-launch");
  }
};
Fs = X([
  D(0, tn)
], Fs);
function ie(h) {
  h.f1 = h.f1 ?? !0, h.category = h.category ?? Rn, h.precondition = h.precondition ?? E.processSupported;
  const e = h.run, t = h;
  return delete t.run, Vo(class extends $o {
    constructor() {
      super(t);
    }
    run(i, s) {
      return e(La(i), i, s);
    }
  });
}
function pe(h) {
  const e = h.run;
  return ie({
    ...h,
    run: (t, i, s) => {
      const c = t.service.activeInstance;
      if (c)
        return e(c, t, i, s);
    }
  });
}
function Xe(h) {
  const e = h.run;
  return ie({
    ...h,
    run: (t, i, s) => {
      const c = cc.find(t.service.detachedXterms, (n) => n.isFocused);
      if (c)
        return e(c, i, void 0, s);
      const l = t.service.activeInstance;
      if (l != null && l.xterm)
        return e(l.xterm, i, l, s);
    }
  });
}
function La(h) {
  return {
    service: h.get(we),
    groupService: h.get(Ae),
    instanceService: h.get(yt),
    editorService: h.get(li),
    profileService: h.get(Bt),
    profileResolverService: h.get(ii)
  };
}
function _d() {
  ie({
    id: "workbench.action.terminal.newInActiveWorkspace",
    title: { value: g(
      "workbench.action.terminal.newInActiveWorkspace",
      "Create New Terminal (In Active Workspace)"
    ), original: "Create New Terminal (In Active Workspace)" },
    run: async (h) => {
      if (h.service.isProcessSupportRegistered) {
        const e = await h.service.createTerminal({ location: h.service.defaultLocation });
        if (!e)
          return;
        h.service.setActiveInstance(e);
      }
      await h.groupService.showPanel(!0);
    }
  }), Ra([]), ie({
    id: "workbench.action.createTerminalEditor",
    title: { value: g(
      "workbench.action.terminal.createTerminalEditor",
      "Create New Terminal in Editor Area"
    ), original: "Create New Terminal in Editor Area" },
    run: async (h, e, t) => {
      const i = Wt(t) && "location" in t ? t : { location: se.Editor };
      (await h.service.createTerminal(i)).focusWhenReady();
    }
  }), ie({
    id: "workbench.action.createTerminalEditorSameGroup",
    title: { value: g(
      "workbench.action.terminal.createTerminalEditor",
      "Create New Terminal in Editor Area"
    ), original: "Create New Terminal in Editor Area" },
    f1: !1,
    run: async (h, e, t) => {
      const i = e.get(Ur);
      (await h.service.createTerminal({
        location: { viewColumn: i.activeGroup.index }
      })).focusWhenReady();
    }
  }), ie({
    id: "workbench.action.createTerminalEditorSide",
    title: { value: g(
      "workbench.action.terminal.createTerminalEditorSide",
      "Create New Terminal in Editor Area to the Side"
    ), original: "Create New Terminal in Editor Area to the Side" },
    run: async (h) => {
      (await h.service.createTerminal({
        location: { viewColumn: Vn }
      })).focusWhenReady();
    }
  }), pe({
    id: "workbench.action.terminal.moveToEditor",
    title: Q.moveToEditor,
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.terminalEditorActive.toNegated(), E.viewShowing),
    run: (h, e) => e.service.moveToEditor(h)
  }), ie({
    id: "workbench.action.terminal.moveToEditorInstance",
    title: Q.moveToEditor,
    f1: !1,
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.isOpen),
    run: async (h, e) => {
      const t = xt(e);
      if (!(!t || t.length === 0)) {
        for (const i of t)
          h.service.moveToEditor(i);
        t[t.length - 1].focus();
      }
    }
  }), ie({
    id: "workbench.action.terminal.moveToTerminalPanel",
    title: Q.moveToTerminalPanel,
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.terminalEditorActive),
    run: (h, e, t) => {
      const i = Ma(t) ?? h.editorService.activeInstance;
      i && h.service.moveToTerminalView(i);
    }
  }), ie({
    id: "workbench.action.terminal.showTabs",
    title: { value: g("workbench.action.terminal.showTabs", "Show Tabs"), original: "Show Tabs" },
    f1: !1,
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => h.groupService.showTabs()
  }), ie({
    id: "workbench.action.terminal.focusPreviousPane",
    title: { value: g(
      "workbench.action.terminal.focusPreviousPane",
      "Focus Previous Terminal in Terminal Group"
    ), original: "Focus Previous Terminal in Terminal Group" },
    keybinding: {
      primary: 527,
      secondary: [528],
      mac: {
        primary: 2575,
        secondary: [2576]
      },
      when: E.focus,
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: async (h) => {
      var e;
      (e = h.groupService.activeGroup) == null || e.focusPreviousPane(), await h.groupService.showPanel(!0);
    }
  }), ie({
    id: "workbench.action.terminal.focusNextPane",
    title: { value: g(
      "workbench.action.terminal.focusNextPane",
      "Focus Next Terminal in Terminal Group"
    ), original: "Focus Next Terminal in Terminal Group" },
    keybinding: {
      primary: 529,
      secondary: [530],
      mac: {
        primary: 2577,
        secondary: [2578]
      },
      when: E.focus,
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: async (h) => {
      var e;
      (e = h.groupService.activeGroup) == null || e.focusNextPane(), await h.groupService.showPanel(!0);
    }
  }), pe({
    id: "workbench.action.terminal.runRecentCommand",
    title: { value: g("workbench.action.terminal.runRecentCommand", "Run Recent Command..."), original: "Run Recent Command..." },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    keybinding: [
      {
        primary: 2096,
        mac: { primary: 304 },
        when: R.and(E.focus, De),
        weight: 200
      },
      {
        primary: 2608,
        mac: { primary: 816 },
        when: R.and(E.focus, De.negate()),
        weight: 200
      }
    ],
    run: async (h, e) => {
      await h.runRecent("command"), (h == null ? void 0 : h.target) === se.Editor ? await e.editorService.revealActiveEditor() : await e.groupService.showPanel(!1);
    }
  }), pe({
    id: "workbench.action.terminal.copyLastCommandOutput",
    title: { value: g("workbench.action.terminal.copyLastCommand", "Copy Last Command Output"), original: "Copy Last Command Output" },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: async (h, e, t) => {
      var n;
      const i = t.get($n), s = (n = h.capabilities.get(2)) == null ? void 0 : n.commands;
      if (!s || s.length === 0)
        return;
      const c = s[s.length - 1];
      if (!(c != null && c.hasOutput()))
        return;
      const l = c.getOutput();
      xi(l) && await i.writeText(l);
    }
  }), pe({
    id: "workbench.action.terminal.goToRecentDirectory",
    title: { value: g(
      "workbench.action.terminal.goToRecentDirectory",
      "Go to Recent Directory..."
    ), original: "Go to Recent Directory..." },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    keybinding: {
      primary: 2085,
      when: E.focus,
      weight: 200
    },
    run: async (h, e) => {
      await h.runRecent("cwd"), (h == null ? void 0 : h.target) === se.Editor ? await e.editorService.revealActiveEditor() : await e.groupService.showPanel(!1);
    }
  }), ie({
    id: "workbench.action.terminal.resizePaneLeft",
    title: { value: g("workbench.action.terminal.resizePaneLeft", "Resize Terminal Left"), original: "Resize Terminal Left" },
    keybinding: {
      linux: { primary: 3087 },
      mac: { primary: 2319 },
      when: E.focus,
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => {
      var e;
      return (e = h.groupService.activeGroup) == null ? void 0 : e.resizePane(0);
    }
  }), ie({
    id: "workbench.action.terminal.resizePaneRight",
    title: { value: g("workbench.action.terminal.resizePaneRight", "Resize Terminal Right"), original: "Resize Terminal Right" },
    keybinding: {
      linux: { primary: 3089 },
      mac: { primary: 2321 },
      when: E.focus,
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => {
      var e;
      return (e = h.groupService.activeGroup) == null ? void 0 : e.resizePane(1);
    }
  }), ie({
    id: "workbench.action.terminal.resizePaneUp",
    title: { value: g("workbench.action.terminal.resizePaneUp", "Resize Terminal Up"), original: "Resize Terminal Up" },
    keybinding: {
      mac: { primary: 2320 },
      when: E.focus,
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => {
      var e;
      return (e = h.groupService.activeGroup) == null ? void 0 : e.resizePane(2);
    }
  }), ie({
    id: "workbench.action.terminal.resizePaneDown",
    title: { value: g("workbench.action.terminal.resizePaneDown", "Resize Terminal Down"), original: "Resize Terminal Down" },
    keybinding: {
      mac: { primary: 2322 },
      when: E.focus,
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => {
      var e;
      return (e = h.groupService.activeGroup) == null ? void 0 : e.resizePane(3);
    }
  }), ie({
    id: "workbench.action.terminal.focus",
    title: Q.focus,
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: async (h) => {
      const e = h.service.activeInstance || await h.service.createTerminal({ location: se.Panel });
      if (e)
        return h.service.setActiveInstance(e), h.groupService.showPanel(!0);
    }
  }), ie({
    id: "workbench.action.terminal.focusTabs",
    title: { value: g("workbench.action.terminal.focus.tabsView", "Focus Terminal Tabs View"), original: "Focus Terminal Tabs View" },
    keybinding: {
      primary: 3165,
      weight: 200,
      when: R.or(E.tabsFocus, E.focus)
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => h.groupService.focusTabs()
  }), ie({
    id: "workbench.action.terminal.focusNext",
    title: { value: g("workbench.action.terminal.focusNext", "Focus Next Terminal Group"), original: "Focus Next Terminal Group" },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    keybinding: {
      primary: 2060,
      mac: {
        primary: 3166
      },
      when: R.and(E.focus, E.editorFocus.negate()),
      weight: 200
    },
    run: async (h) => {
      h.groupService.setActiveGroupToNext(), await h.groupService.showPanel(!0);
    }
  }), ie({
    id: "workbench.action.terminal.focusPrevious",
    title: { value: g("workbench.action.terminal.focusPrevious", "Focus Previous Terminal Group"), original: "Focus Previous Terminal Group" },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    keybinding: {
      primary: 2059,
      mac: {
        primary: 3164
      },
      when: R.and(E.focus, E.editorFocus.negate()),
      weight: 200
    },
    run: async (h) => {
      h.groupService.setActiveGroupToPrevious(), await h.groupService.showPanel(!0);
    }
  }), ie({
    id: "workbench.action.terminal.runSelectedText",
    title: { value: g(
      "workbench.action.terminal.runSelectedText",
      "Run Selected Text In Active Terminal"
    ), original: "Run Selected Text In Active Terminal" },
    run: async (h, e) => {
      const i = e.get(no).getActiveCodeEditor();
      if (!i || !i.hasModel())
        return;
      const s = await h.service.getActiveOrCreateInstance({ acceptsInput: !0 }), c = i.getSelection();
      let l;
      if (c.isEmpty())
        l = i.getModel().getLineContent(c.selectionStartLineNumber).trim();
      else {
        const n = Le ? 1 : 2;
        l = i.getModel().getValueInRange(c, n);
      }
      s.sendText(l, !0, !0), await h.service.revealActiveTerminal();
    }
  }), ie({
    id: "workbench.action.terminal.runActiveFile",
    title: { value: g(
      "workbench.action.terminal.runActiveFile",
      "Run Active File In Active Terminal"
    ), original: "Run Active File In Active Terminal" },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: async (h, e) => {
      const t = e.get(no), i = e.get(Ee), s = e.get(Fi), c = t.getActiveCodeEditor();
      if (!c || !c.hasModel())
        return;
      const l = await h.service.getActiveOrCreateInstance({ acceptsInput: !0 }), n = l ? l.isRemote : !!s.remoteAuthority, r = c.getModel().uri;
      if (!n && r.scheme !== me.file && r.scheme !== me.vscodeUserData || n && r.scheme !== me.vscodeRemote) {
        i.warn(g(
          "workbench.action.terminal.runActiveFile.noFile",
          "Only files on disk can be run in the terminal"
        ));
        return;
      }
      return await l.sendPath(r, !0), h.groupService.showPanel();
    }
  }), Xe({
    id: "workbench.action.terminal.scrollDown",
    title: { value: g("workbench.action.terminal.scrollDown", "Scroll Down (Line)"), original: "Scroll Down (Line)" },
    keybinding: {
      primary: 2572,
      linux: { primary: 3090 },
      when: R.and(E.focusInAny, E.altBufferActive.negate()),
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => h.scrollDownLine()
  }), Xe({
    id: "workbench.action.terminal.scrollDownPage",
    title: { value: g("workbench.action.terminal.scrollDownPage", "Scroll Down (Page)"), original: "Scroll Down (Page)" },
    keybinding: {
      primary: 1036,
      mac: { primary: 12 },
      when: R.and(E.focusInAny, E.altBufferActive.negate()),
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => h.scrollDownPage()
  }), Xe({
    id: "workbench.action.terminal.scrollToBottom",
    title: { value: g("workbench.action.terminal.scrollToBottom", "Scroll to Bottom"), original: "Scroll to Bottom" },
    keybinding: {
      primary: 2061,
      linux: { primary: 1037 },
      when: R.and(E.focusInAny, E.altBufferActive.negate()),
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => h.scrollToBottom()
  }), Xe({
    id: "workbench.action.terminal.scrollUp",
    title: { value: g("workbench.action.terminal.scrollUp", "Scroll Up (Line)"), original: "Scroll Up (Line)" },
    keybinding: {
      primary: 2571,
      linux: { primary: 3088 },
      when: R.and(E.focusInAny, E.altBufferActive.negate()),
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => h.scrollUpLine()
  }), Xe({
    id: "workbench.action.terminal.scrollUpPage",
    title: { value: g("workbench.action.terminal.scrollUpPage", "Scroll Up (Page)"), original: "Scroll Up (Page)" },
    f1: !0,
    category: Rn,
    keybinding: {
      primary: 1035,
      mac: { primary: 11 },
      when: R.and(E.focusInAny, E.altBufferActive.negate()),
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => h.scrollUpPage()
  }), Xe({
    id: "workbench.action.terminal.scrollToTop",
    title: { value: g("workbench.action.terminal.scrollToTop", "Scroll to Top"), original: "Scroll to Top" },
    keybinding: {
      primary: 2062,
      linux: { primary: 1038 },
      when: R.and(E.focusInAny, E.altBufferActive.negate()),
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => h.scrollToTop()
  }), Xe({
    id: "workbench.action.terminal.clearSelection",
    title: { value: g("workbench.action.terminal.clearSelection", "Clear Selection"), original: "Clear Selection" },
    keybinding: {
      primary: 9,
      when: R.and(
        E.focusInAny,
        E.textSelected,
        E.notFindVisible
      ),
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => {
      h.hasSelection() && h.clearSelection();
    }
  }), ie({
    id: "workbench.action.terminal.changeIcon",
    title: Q.changeIcon,
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h, e, t) => {
      var i;
      return (i = Hs(h, t)) == null ? void 0 : i.changeIcon();
    }
  }), ie({
    id: "workbench.action.terminal.changeIconPanel",
    title: Q.changeIcon,
    f1: !1,
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => {
      var e;
      return (e = h.groupService.activeInstance) == null ? void 0 : e.changeIcon();
    }
  }), ie({
    id: "workbench.action.terminal.changeIconInstance",
    title: Q.changeIcon,
    f1: !1,
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.tabsSingularSelection),
    run: (h, e) => {
      var t;
      return (t = xt(e)) == null ? void 0 : t[0].changeIcon();
    }
  }), ie({
    id: "workbench.action.terminal.changeColor",
    title: Q.changeColor,
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h, e, t) => {
      var i;
      return (i = Hs(h, t)) == null ? void 0 : i.changeColor();
    }
  }), ie({
    id: "workbench.action.terminal.changeColorPanel",
    title: Q.changeColor,
    f1: !1,
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => {
      var e;
      return (e = h.groupService.activeInstance) == null ? void 0 : e.changeColor();
    }
  }), ie({
    id: "workbench.action.terminal.changeColorInstance",
    title: Q.changeColor,
    f1: !1,
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.tabsSingularSelection),
    run: (h, e) => {
      var t;
      return (t = xt(e)) == null ? void 0 : t[0].changeColor();
    }
  }), ie({
    id: "workbench.action.terminal.rename",
    title: Q.rename,
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h, e, t) => go(h, e, t)
  }), ie({
    id: "workbench.action.terminal.renamePanel",
    title: Q.rename,
    f1: !1,
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h, e) => go(h, e)
  }), ie({
    id: "workbench.action.terminal.renameInstance",
    title: Q.rename,
    f1: !1,
    keybinding: {
      primary: 60,
      mac: {
        primary: 3
      },
      when: R.and(E.tabsFocus),
      weight: 200
    },
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.tabsSingularSelection),
    run: async (h, e) => {
      var s;
      const t = e.get(Ee), i = (s = xt(e)) == null ? void 0 : s[0];
      i && (h.service.setEditingTerminal(i), h.service.setEditable(i, {
        validationMessage: (c) => gd(c),
        onFinish: async (c, l) => {
          if (h.service.setEditable(i, null), h.service.setEditingTerminal(void 0), l)
            try {
              await i.rename(c);
            } catch (n) {
              t.error(n);
            }
        }
      }));
    }
  }), pe({
    id: "workbench.action.terminal.detachSession",
    title: { value: g("workbench.action.terminal.detachSession", "Detach Session"), original: "Detach Session" },
    run: (h) => h.detachProcessAndDispose(Et.User)
  }), ie({
    id: "workbench.action.terminal.attachToSession",
    title: { value: g("workbench.action.terminal.attachToSession", "Attach to Session"), original: "Attach to Session" },
    run: async (h, e) => {
      var C;
      const t = e.get(qe), i = e.get(Un), s = e.get(Mt), c = e.get(Ee), l = ((C = s.getConnection()) == null ? void 0 : C.remoteAuthority) ?? void 0, n = await e.get(yt).getBackend(l);
      if (!n)
        throw new Error(`No backend registered for remote authority '${l}'`);
      const r = await n.listProcesses();
      n.reduceConnectionGraceTime();
      const f = r.filter((b) => !h.service.isAttachedToTerminal(b)).map((b) => {
        const p = i.getUriLabel(oe.file(b.cwd));
        return {
          label: b.title,
          detail: b.workspaceName ? `${b.workspaceName} ⸱ ${p}` : p,
          description: b.pid ? String(b.pid) : "",
          term: b
        };
      });
      if (f.length === 0) {
        c.info(g("noUnattachedTerminals", "There are no unattached terminals to attach to"));
        return;
      }
      const m = await t.pick(f, { canPickMany: !1 });
      if (m) {
        const b = await h.service.createTerminal({
          config: { attachPersistentProcess: m.term }
        });
        h.service.setActiveInstance(b), await Ui(b, h);
      }
    }
  }), ie({
    id: "workbench.action.quickOpenTerm",
    title: { value: g("quickAccessTerminal", "Switch Active Terminal"), original: "Switch Active Terminal" },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h, e) => e.get(qe).quickAccess.show(Yi.PREFIX)
  }), pe({
    id: "workbench.action.terminal.scrollToPreviousCommand",
    title: { value: g(
      "workbench.action.terminal.scrollToPreviousCommand",
      "Scroll To Previous Command"
    ), original: "Scroll To Previous Command" },
    keybinding: {
      primary: 2064,
      when: R.and(E.focus, De.negate()),
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => {
      var e;
      return (e = h.xterm) == null ? void 0 : e.markTracker.scrollToPreviousMark(void 0, void 0, h.capabilities.has(2));
    }
  }), pe({
    id: "workbench.action.terminal.scrollToNextCommand",
    title: { value: g("workbench.action.terminal.scrollToNextCommand", "Scroll To Next Command"), original: "Scroll To Next Command" },
    keybinding: {
      primary: 2066,
      when: R.and(E.focus, De.negate()),
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => {
      var e;
      (e = h.xterm) == null || e.markTracker.scrollToNextMark(), h.focus();
    }
  }), pe({
    id: "workbench.action.terminal.selectToPreviousCommand",
    title: { value: g(
      "workbench.action.terminal.selectToPreviousCommand",
      "Select To Previous Command"
    ), original: "Select To Previous Command" },
    keybinding: {
      primary: 3088,
      when: E.focus,
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => {
      var e;
      (e = h.xterm) == null || e.markTracker.selectToPreviousMark(), h.focus();
    }
  }), pe({
    id: "workbench.action.terminal.selectToNextCommand",
    title: { value: g("workbench.action.terminal.selectToNextCommand", "Select To Next Command"), original: "Select To Next Command" },
    keybinding: {
      primary: 3090,
      when: E.focus,
      weight: 200
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h) => {
      var e;
      (e = h.xterm) == null || e.markTracker.selectToNextMark(), h.focus();
    }
  }), Xe({
    id: "workbench.action.terminal.selectToPreviousLine",
    title: { value: g(
      "workbench.action.terminal.selectToPreviousLine",
      "Select To Previous Line"
    ), original: "Select To Previous Line" },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: async (h, e, t) => {
      h.markTracker.selectToPreviousLine(), (t || h).focus();
    }
  }), Xe({
    id: "workbench.action.terminal.selectToNextLine",
    title: { value: g("workbench.action.terminal.selectToNextLine", "Select To Next Line"), original: "Select To Next Line" },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: async (h, e, t) => {
      h.markTracker.selectToNextLine(), (t || h).focus();
    }
  }), ie({
    id: "workbench.action.terminal.sendSequence",
    title: Q.sendSequence,
    f1: !1,
    description: {
      description: Q.sendSequence.value,
      args: [{
        name: "args",
        schema: {
          type: "object",
          required: ["text"],
          properties: {
            text: {
              description: g("sendSequence", "The sequence of text to send to the terminal"),
              type: "string"
            }
          }
        }
      }]
    },
    run: (h, e, t) => Aa(e, t)
  }), ie({
    id: "workbench.action.terminal.newWithCwd",
    title: Q.newWithCwd,
    description: {
      description: Q.newWithCwd.value,
      args: [{
        name: "args",
        schema: {
          type: "object",
          required: ["cwd"],
          properties: {
            cwd: {
              description: g(
                "workbench.action.terminal.newWithCwd.cwd",
                "The directory to start the terminal at"
              ),
              type: "string"
            }
          }
        }
      }]
    },
    run: async (h, e, t) => {
      const i = Wt(t) && "cwd" in t ? bn(t.cwd) : void 0, s = await h.service.createTerminal({ cwd: i });
      s && (h.service.setActiveInstance(s), await Ui(s, h));
    }
  }), pe({
    id: "workbench.action.terminal.renameWithArg",
    title: Q.renameWithArgs,
    description: {
      description: Q.renameWithArgs.value,
      args: [{
        name: "args",
        schema: {
          type: "object",
          required: ["name"],
          properties: {
            name: {
              description: g(
                "workbench.action.terminal.renameWithArg.name",
                "The new name for the terminal"
              ),
              type: "string",
              minLength: 1
            }
          }
        }
      }]
    },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: async (h, e, t, i) => {
      const s = t.get(Ee), c = Wt(i) && "name" in i ? bn(i.name) : void 0;
      if (!c) {
        s.warn(g(
          "workbench.action.terminal.renameWithArg.noName",
          "No name argument provided"
        ));
        return;
      }
      h.rename(c);
    }
  }), pe({
    id: "workbench.action.terminal.relaunch",
    title: { value: g("workbench.action.terminal.relaunch", "Relaunch Active Terminal"), original: "Relaunch Active Terminal" },
    run: (h) => h.relaunch()
  }), ie({
    id: "workbench.action.terminal.split",
    title: Q.split,
    precondition: R.or(
      E.processSupported,
      E.webExtensionContributedProfile
    ),
    keybinding: {
      primary: 3098,
      weight: 200,
      mac: {
        primary: 2141,
        secondary: [1306]
      },
      when: E.focus
    },
    icon: te.splitHorizontal,
    run: async (h, e, t) => {
      const i = Wt(t) ? t : void 0, s = e.get(dt), c = e.get(tt), l = Pa(i), n = (await h.service.getInstanceHost(l == null ? void 0 : l.location)).activeInstance;
      if (!n)
        return;
      const r = await Ea(h.service.configHelper, n, c.getWorkspace().folders, s);
      if (r === void 0)
        return;
      const a = await h.service.createTerminal({ location: { parentTerminal: n }, config: l == null ? void 0 : l.config, cwd: r });
      await Ui(a, h);
    }
  }), ie({
    id: "workbench.action.terminal.splitInstance",
    title: Q.split,
    f1: !1,
    keybinding: {
      primary: 3098,
      mac: {
        primary: 2141,
        secondary: [1306]
      },
      weight: 200,
      when: E.tabsFocus
    },
    run: async (h, e) => {
      const t = xt(e);
      if (t) {
        const i = [];
        for (const s of t)
          i.push((async () => {
            await h.service.createTerminal({ location: { parentTerminal: s } }), await h.groupService.showPanel(!0);
          })());
        await Promise.all(i);
      }
    }
  }), pe({
    id: "workbench.action.terminal.unsplit",
    title: Q.unsplit,
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h, e) => e.groupService.unsplitInstance(h)
  }), ie({
    id: "workbench.action.terminal.unsplitInstance",
    title: Q.unsplit,
    f1: !1,
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: async (h, e) => {
      const t = xt(e);
      if ((t == null ? void 0 : t.length) === 1) {
        const i = h.groupService.getGroupForInstance(t[0]);
        i && (i == null ? void 0 : i.terminalInstances.length) > 1 && h.groupService.unsplitInstance(t[0]);
      }
    }
  }), ie({
    id: "workbench.action.terminal.joinInstance",
    title: { value: g("workbench.action.terminal.joinInstance", "Join Terminals"), original: "Join Terminals" },
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.tabsSingularSelection.toNegated()),
    run: async (h, e) => {
      const t = xt(e);
      t && t.length > 1 && h.groupService.joinInstances(t);
    }
  }), ie({
    id: "workbench.action.terminal.join",
    title: { value: g("workbench.action.terminal.join", "Join Terminals"), original: "Join Terminals" },
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    )),
    run: async (h, e) => {
      const t = e.get(Me), i = e.get(Ee), s = e.get(qe), c = [];
      if (h.groupService.instances.length <= 1) {
        i.warn(g(
          "workbench.action.terminal.join.insufficientTerminals",
          "Insufficient terminals for the join action"
        ));
        return;
      }
      const l = h.groupService.instances.filter((r) => {
        var a;
        return r.instanceId !== ((a = h.groupService.activeInstance) == null ? void 0 : a.instanceId);
      });
      for (const r of l) {
        const a = h.groupService.getGroupForInstance(r);
        if ((a == null ? void 0 : a.terminalInstances.length) === 1) {
          const m = `$(${$r(e, r)}): ${r.title}`, C = [], b = Jt(r);
          b && C.push(b);
          const p = fi(r, t.getColorTheme().type);
          p && C.push(...p), c.push({
            terminal: r,
            label: m,
            iconClasses: C
          });
        }
      }
      if (c.length === 0) {
        i.warn(g(
          "workbench.action.terminal.join.onlySplits",
          "All terminals are joined already"
        ));
        return;
      }
      const n = await s.pick(c, {});
      n && h.groupService.joinInstances([n.terminal, h.groupService.activeInstance]);
    }
  }), pe({
    id: "workbench.action.terminal.splitInActiveWorkspace",
    title: { value: g(
      "workbench.action.terminal.splitInActiveWorkspace",
      "Split Terminal (In Active Workspace)"
    ), original: "Split Terminal (In Active Workspace)" },
    run: async (h, e) => {
      const t = await e.service.createTerminal({ location: { parentTerminal: h } });
      (t == null ? void 0 : t.target) !== se.Editor && await e.groupService.showPanel(!0);
    }
  }), Xe({
    id: "workbench.action.terminal.selectAll",
    title: { value: g("workbench.action.terminal.selectAll", "Select All"), original: "Select All" },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    keybinding: [{
      primary: 0,
      mac: { primary: 2079 },
      weight: 200,
      when: E.focusInAny
    }],
    run: (h) => h.selectAll()
  }), ie({
    id: "workbench.action.terminal.new",
    title: { value: g("workbench.action.terminal.new", "Create New Terminal"), original: "Create New Terminal" },
    precondition: R.or(
      E.processSupported,
      E.webExtensionContributedProfile
    ),
    icon: Xh,
    keybinding: {
      primary: 3163,
      mac: { primary: 1371 },
      weight: 200
    },
    run: async (h, e, t) => {
      var n;
      let i = Wt(t) ? t : void 0;
      const s = e.get(tt), c = e.get(dt), l = s.getWorkspace().folders;
      if (i && i instanceof MouseEvent && (i.altKey || i.ctrlKey)) {
        await h.service.createTerminal({ location: { splitActiveTerminal: !0 } });
        return;
      }
      if (h.service.isProcessSupportRegistered) {
        i = !i || i instanceof MouseEvent ? {} : i;
        let r;
        if (l.length <= 1)
          r = await h.service.createTerminal(i);
        else {
          const a = (n = await pd(e)) == null ? void 0 : n.cwd;
          if (!a)
            return;
          i.cwd = a, r = await h.service.createTerminal(i);
        }
        h.service.setActiveInstance(r), await Ui(r, h);
      } else
        h.profileService.contributedProfiles.length > 0 ? c.executeCommand("workbench.action.terminal.newWithProfile") : c.executeCommand("workbench.action.terminal.toggleTerminal");
    }
  }), ie({
    id: "workbench.action.terminal.kill",
    title: { value: g("workbench.action.terminal.kill", "Kill the Active Terminal Instance"), original: "Kill the Active Terminal Instance" },
    precondition: R.or(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.isOpen),
    icon: xa,
    run: async (h) => {
      const e = h.groupService.activeInstance;
      e && (await h.service.safeDisposeTerminal(e), h.groupService.instances.length > 0 && await h.groupService.showPanel(!0));
    }
  }), ie({
    id: "workbench.action.terminal.killAll",
    title: { value: g("workbench.action.terminal.killAll", "Kill All Terminals"), original: "Kill All Terminals" },
    precondition: R.or(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.isOpen),
    icon: te.trash,
    run: async (h) => {
      const e = [];
      for (const t of h.service.instances)
        e.push(h.service.safeDisposeTerminal(t));
      await Promise.all(e);
    }
  }), ie({
    id: "workbench.action.terminal.killEditor",
    title: { value: g(
      "workbench.action.terminal.killEditor",
      "Kill the Active Terminal in Editor Area"
    ), original: "Kill the Active Terminal in Editor Area" },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    keybinding: {
      primary: 2101,
      win: { primary: 2110, secondary: [2101] },
      weight: 200,
      when: R.and(E.focus, ri.Scheme.isEqualTo(me.vscodeTerminal), E.editorFocus)
    },
    run: (h, e) => e.get(dt).executeCommand(tc)
  }), ie({
    id: "workbench.action.terminal.killInstance",
    title: Q.kill,
    f1: !1,
    precondition: R.or(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.isOpen),
    keybinding: {
      primary: 20,
      mac: {
        primary: 2049,
        secondary: [20]
      },
      weight: 200,
      when: E.tabsFocus
    },
    run: async (h, e) => {
      var c;
      const t = xt(e);
      if (!t)
        return;
      const i = e.get(Gn), s = [];
      for (const l of t)
        s.push(h.service.safeDisposeTerminal(l));
      await Promise.all(s), h.service.instances.length > 0 && (h.groupService.focusTabs(), (c = i.lastFocusedList) == null || c.focusNext());
    }
  }), ie({
    id: "workbench.action.terminal.focusHover",
    title: Q.focusHover,
    precondition: R.or(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.isOpen),
    keybinding: {
      primary: ic(2089, 2087),
      weight: 200,
      when: R.or(E.tabsFocus, E.focus)
    },
    run: (h) => h.groupService.focusHover()
  }), pe({
    id: "workbench.action.terminal.clear",
    title: { value: g("workbench.action.terminal.clear", "Clear"), original: "Clear" },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    keybinding: [{
      primary: 0,
      mac: { primary: 2089 },
      weight: 200 + 1,
      when: R.and(E.focus, De.negate())
    }],
    run: (h) => h.clearBuffer()
  }), ie({
    id: "workbench.action.terminal.selectDefaultShell",
    title: { value: g("workbench.action.terminal.selectDefaultShell", "Select Default Profile"), original: "Select Default Profile" },
    run: (h) => h.service.showProfileQuickPick("setDefault")
  }), ie({
    id: "workbench.action.terminal.openSettings",
    title: { value: g("workbench.action.terminal.openSettings", "Configure Terminal Settings"), original: "Configure Terminal Settings" },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: (h, e) => e.get(Gr).openSettings({ jsonEditor: !1, query: "@feature:terminal" })
  }), pe({
    id: "workbench.action.terminal.setDimensions",
    title: { value: g("workbench.action.terminal.setFixedDimensions", "Set Fixed Dimensions"), original: "Set Fixed Dimensions" },
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.isOpen),
    run: (h) => h.setFixedDimensions()
  }), pe({
    id: "workbench.action.terminal.sizeToContentWidth",
    title: { value: g(
      "workbench.action.terminal.sizeToContentWidth",
      "Toggle Size to Content Width"
    ), original: "Toggle Size to Content Width" },
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.isOpen),
    keybinding: {
      primary: 568,
      weight: 200,
      when: E.focus
    },
    run: (h) => h.toggleSizeToContentWidth()
  }), ie({
    id: "workbench.action.terminal.sizeToContentWidthInstance",
    title: Q.toggleSizeToContentWidth,
    f1: !1,
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.focus),
    run: (h, e) => {
      var t;
      return (t = xt(e)) == null ? void 0 : t[0].toggleSizeToContentWidth();
    }
  }), ie({
    id: "workbench.action.terminal.clearPreviousSessionHistory",
    title: { value: g(
      "workbench.action.terminal.clearPreviousSessionHistory",
      "Clear Previous Session History"
    ), original: "Clear Previous Session History" },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: async (h, e) => {
      Ln(e).clear(), cd();
    }
  }), pe({
    id: "workbench.action.terminal.selectPrevSuggestion",
    title: { value: g(
      "workbench.action.terminal.selectPrevSuggestion",
      "Select the Previous Suggestion"
    ), original: "Select the Previous Suggestion" },
    f1: !1,
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.focus, E.isOpen, E.suggestWidgetVisible),
    keybinding: {
      primary: 16,
      weight: 200 + 1
    },
    run: (h) => h.selectPreviousSuggestion()
  }), pe({
    id: "workbench.action.terminal.selectPrevPageSuggestion",
    title: { value: g(
      "workbench.action.terminal.selectPrevPageSuggestion",
      "Select the Previous Page Suggestion"
    ), original: "Select the Previous Page Suggestion" },
    f1: !1,
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.focus, E.isOpen, E.suggestWidgetVisible),
    keybinding: {
      primary: 11,
      weight: 200 + 1
    },
    run: (h) => h.selectPreviousPageSuggestion()
  }), pe({
    id: "workbench.action.terminal.selectNextSuggestion",
    title: { value: g(
      "workbench.action.terminal.selectNextSuggestion",
      "Select the Next Suggestion"
    ), original: "Select the Next Suggestion" },
    f1: !1,
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.focus, E.isOpen, E.suggestWidgetVisible),
    keybinding: {
      primary: 18,
      weight: 200 + 1
    },
    run: (h) => h.selectNextSuggestion()
  }), pe({
    id: "workbench.action.terminal.selectNextPageSuggestion",
    title: { value: g(
      "workbench.action.terminal.selectNextPageSuggestion",
      "Select the Next Page Suggestion"
    ), original: "Select the Next Page Suggestion" },
    f1: !1,
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.focus, E.isOpen, E.suggestWidgetVisible),
    keybinding: {
      primary: 12,
      weight: 200 + 1
    },
    run: (h) => h.selectNextPageSuggestion()
  }), pe({
    id: "workbench.action.terminal.acceptSelectedSuggestion",
    title: { value: g(
      "workbench.action.terminal.acceptSelectedSuggestion",
      "Accept Selected Suggestion"
    ), original: "Accept Selected Suggestion" },
    f1: !1,
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.focus, E.isOpen, E.suggestWidgetVisible),
    keybinding: {
      primary: 3,
      secondary: [2],
      weight: 200 + 1
    },
    run: (h) => h.acceptSelectedSuggestion()
  }), pe({
    id: "workbench.action.terminal.hideSuggestWidget",
    title: { value: g("workbench.action.terminal.hideSuggestWidget", "Hide Suggest Widget"), original: "Hide Suggest Widget" },
    f1: !1,
    precondition: R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.focus, E.isOpen, E.suggestWidgetVisible),
    keybinding: {
      primary: 9,
      weight: 200 + 1
    },
    run: (h) => h.hideSuggestWidget()
  }), bi.clipboard.writeText && (Xe({
    id: "workbench.action.terminal.copySelection",
    title: { value: g("workbench.action.terminal.copySelection", "Copy Selection"), original: "Copy Selection" },
    precondition: R.or(E.textSelectedInFocused, R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.textSelected)),
    keybinding: [{
      primary: 3105,
      mac: { primary: 2081 },
      weight: 200,
      when: R.or(R.and(E.textSelected, E.focus), E.textSelectedInFocused)
    }],
    run: (h) => h.copySelection()
  }), Xe({
    id: "workbench.action.terminal.copyAndClearSelection",
    title: { value: g(
      "workbench.action.terminal.copyAndClearSelection",
      "Copy and Clear Selection"
    ), original: "Copy and Clear Selection" },
    precondition: R.or(E.textSelectedInFocused, R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.textSelected)),
    keybinding: [{
      win: { primary: 2081 },
      weight: 200,
      when: R.or(R.and(E.textSelected, E.focus), E.textSelectedInFocused)
    }],
    run: async (h) => {
      await h.copySelection(), h.clearSelection();
    }
  }), Xe({
    id: "workbench.action.terminal.copySelectionAsHtml",
    title: { value: g("workbench.action.terminal.copySelectionAsHtml", "Copy Selection as HTML"), original: "Copy Selection as HTML" },
    f1: !0,
    category: Rn,
    precondition: R.or(E.textSelectedInFocused, R.and(R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ), E.textSelected)),
    run: (h) => h.copySelection(!0)
  })), bi.clipboard.readText && pe({
    id: "workbench.action.terminal.paste",
    title: { value: g("workbench.action.terminal.paste", "Paste into Active Terminal"), original: "Paste into Active Terminal" },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    keybinding: [{
      primary: 2100,
      win: { primary: 2100, secondary: [3124] },
      linux: { primary: 3124 },
      weight: 200,
      when: E.focus
    }],
    run: (h) => h.paste()
  }), bi.clipboard.readText && zn && pe({
    id: "workbench.action.terminal.pasteSelection",
    title: { value: g(
      "workbench.action.terminal.pasteSelection",
      "Paste Selection into Active Terminal"
    ), original: "Paste Selection into Active Terminal" },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    keybinding: [{
      linux: { primary: 1043 },
      weight: 200,
      when: E.focus
    }],
    run: (h) => h.pasteSelection()
  }), ie({
    id: "workbench.action.terminal.switchTerminal",
    title: { value: g("workbench.action.terminal.switchTerminal", "Switch Terminal"), original: "Switch Terminal" },
    precondition: R.or(
      E.processSupported,
      E.terminalHasBeenCreated
    ),
    run: async (h, e, t) => {
      const i = bn(t);
      if (!i)
        return;
      if (i === Ta) {
        h.service.refreshActiveGroup();
        return;
      }
      if (i === Da) {
        e.get(Se).updateValue("terminal.integrated.tabs.enabled", !0);
        return;
      }
      const c = /^([0-9]+): /.exec(i);
      if (c)
        return h.groupService.setActiveGroupByIndex(Number(c[1]) - 1), h.groupService.showPanel(!0);
      const l = h.profileService.availableProfiles, n = i.substring(4);
      if (l) {
        const r = l.find((a) => a.profileName === n);
        if (r) {
          const a = await h.service.createTerminal({
            config: r
          });
          h.service.setActiveInstance(a);
        } else
          console.warn(`No profile with name "${n}"`);
      } else
        console.warn(`Unmatched terminal item: "${i}"`);
    }
  });
}
function xt(h) {
  var l;
  const e = h.get(Gn), t = h.get(we);
  if (!((l = e.lastFocusedList) != null && l.getSelection()))
    return;
  const i = e.lastFocusedList.getSelection(), s = e.lastFocusedList.getFocus(), c = [];
  if (s.length === 1 && !i.includes(s[0]))
    return c.push(t.getInstanceFromIndex(s[0])), c;
  for (const n of i)
    c.push(t.getInstanceFromIndex(n));
  return c;
}
function gd(h) {
  return !h || h.trim().length === 0 ? {
    content: g(
      "emptyTerminalNameInfo",
      "Providing no name will reset it to the default value"
    ),
    severity: Te.Info
  } : null;
}
function Pa(h) {
  return Wt(h) && "profileName" in h ? { config: h, location: h.location } : h;
}
let _n;
function Ra(h) {
  const e = ka(h);
  _n == null || _n.dispose(), _n = Vo(class extends $o {
    constructor() {
      super({
        id: "workbench.action.terminal.newWithProfile",
        title: { value: g(
          "workbench.action.terminal.newWithProfile",
          "Create New Terminal (With Profile)"
        ), original: "Create New Terminal (With Profile)" },
        f1: !0,
        category: Rn,
        precondition: R.or(
          E.processSupported,
          E.webExtensionContributedProfile
        ),
        description: {
          description: "workbench.action.terminal.newWithProfile",
          args: [{
            name: "args",
            schema: {
              type: "object",
              required: ["profileName"],
              properties: {
                profileName: {
                  description: g(
                    "workbench.action.terminal.newWithProfile.profileName",
                    "The name of the profile to create"
                  ),
                  type: "string",
                  enum: e.values,
                  markdownEnumDescriptions: e.markdownDescriptions
                }
              }
            }
          }]
        }
      });
    }
    async run(t, i, s) {
      const c = La(t), l = t.get(tt), n = t.get(dt);
      let r, a, f, m;
      if (Wt(i) && i && "profileName" in i) {
        const b = c.profileService.availableProfiles.find((p) => p.profileName === i.profileName);
        if (!b)
          throw new Error(`Could not find terminal profile "${i.profileName}"`);
        a = { config: b };
      } else
        i instanceof MouseEvent || i instanceof PointerEvent || i instanceof KeyboardEvent ? (r = i, a = s ? { config: s } : void 0) : a = Pa(i);
      if (r && (r.altKey || r.ctrlKey)) {
        const b = c.service.activeInstance;
        if (b) {
          await c.service.createTerminal({ location: { parentTerminal: b }, config: a == null ? void 0 : a.config });
          return;
        }
      }
      if (l.getWorkspace().folders.length > 1) {
        const b = {
          placeHolder: g(
            "workbench.action.terminal.newWorkspacePlaceholder",
            "Select current working directory for new terminal"
          )
        }, p = await n.executeCommand(zr, [b]);
        if (!p)
          return;
        m = p.uri;
      }
      a ? (a.cwd = m, f = await c.service.createTerminal(a)) : f = await c.service.showProfileQuickPick("createInstance", m), f && (c.service.setActiveInstance(f), await Ui(f, c));
    }
  });
}
function Hs(h, e) {
  return h.service.getInstanceFromResource(Ma(e)) || h.service.activeInstance;
}
async function pd(h, e) {
  const t = h.get(qe), i = h.get(Un), s = h.get(tt), c = h.get(Kn), l = h.get(nc), n = h.get(Se), r = h.get(qn), a = s.getWorkspace().folders;
  if (!a.length)
    return;
  const f = await Promise.all(a.map(
    (o) => vd(o, n, r)
  )), m = Sd(f);
  if (m.length === 1)
    return m[0];
  const C = m.map((o) => {
    const _ = o.folder.name, u = o.isOverridden ? g(
      "workbench.action.terminal.overriddenCwdDescription",
      "(Overriden) {0}",
      i.getUriLabel(o.cwd, { relative: !o.isAbsolute })
    ) : i.getUriLabel(sc(o.cwd), { relative: !0 });
    return {
      label: _,
      description: u !== _ ? u : void 0,
      pair: o,
      iconClasses: rc(c, l, o.cwd, oc.ROOT_FOLDER)
    };
  }), b = {
    placeHolder: g(
      "workbench.action.terminal.newWorkspacePlaceholder",
      "Select current working directory for new terminal"
    ),
    matchOnDescription: !0,
    canPickMany: !1
  }, p = e || Hi.None, S = await t.pick(C, b, p);
  return S == null ? void 0 : S.pair;
}
async function vd(h, e, t) {
  const i = e.getValue("terminal.integrated.cwd", { resource: h.uri });
  if (!xi(i) || i.length === 0)
    return { folder: h, cwd: h.uri, isAbsolute: !1, isOverridden: !1 };
  const s = await t.resolveAsync(h, i);
  return Uo(s) || s.startsWith(ac.VARIABLE_LHS) ? { folder: h, isAbsolute: !0, isOverridden: !0, cwd: oe.from({ scheme: h.uri.scheme, path: s }) } : { folder: h, isAbsolute: !1, isOverridden: !0, cwd: oe.joinPath(h.uri, s) };
}
function Sd(h) {
  const e = /* @__PURE__ */ new Map();
  for (const s of h) {
    const c = s.cwd.toString();
    (!e.get(c) || c === s.folder.uri.toString()) && e.set(c, s);
  }
  const t = new Set(e.values());
  return h.filter((s) => t.has(s));
}
async function Ui(h, e) {
  h.target === se.Editor ? (await e.editorService.revealActiveEditor(), await h.focusWhenReady(!0)) : await e.groupService.showPanel(!0);
}
async function go(h, e, t) {
  const i = Hs(h, t);
  if (i) {
    const s = await e.get(qe).input({
      value: i.title,
      prompt: g("workbench.action.terminal.rename.prompt", "Enter terminal name")
    });
    i.rename(s);
  }
}
function Ma(h) {
  return oe.isUri(h) ? h : void 0;
}
function bn(h) {
  return xi(h) ? h : void 0;
}
var bd = '.monaco-action-bar .action-item .action-label.extension-action{line-height:normal;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.monaco-action-bar .action-dropdown-item>.action-label.extension-action.label,.monaco-action-bar .action-item>.action-label.extension-action.label{padding:0 5px}.monaco-action-bar .action-dropdown-item>.monaco-dropdown .action-label{padding:0}.monaco-action-bar .action-item .action-label.extension-action.label{outline-offset:1px}.monaco-action-bar .action-dropdown-item .action-label.extension-action.label,.monaco-action-bar .action-item .action-label.extension-action.label,.monaco-action-bar .action-item .action-label.extension-action.text{height:auto;line-height:14px;width:auto}.monaco-action-bar .action-item .action-label.extension-action.built-in-status{border-color:var(--vscode-foreground)}.monaco-action-bar .action-item .action-label.extension-action.label,.monaco-action-bar .action-item.action-dropdown-item>.action-dropdown-item-separator{background-color:var(--vscode-extensionButton-background)!important}.monaco-action-bar .action-item .action-label.extension-action.label{color:var(--vscode-extensionButton-foreground)!important}.monaco-action-bar .action-item .action-label.extension-action.label:hover{background-color:var(--vscode-extensionButton-hoverBackground)!important}.monaco-action-bar .action-item.action-dropdown-item>.action-dropdown-item-separator>div{background-color:var(--vscode-extensionButton-separator)}.monaco-action-bar .action-item .action-label.extension-action.label.prominent,.monaco-action-bar .action-item.action-dropdown-item>.action-dropdown-item-separator.prominent{background-color:var(--vscode-extensionButton-prominentBackground)}.monaco-action-bar .action-item .action-label.extension-action.label.prominent{color:var(--vscode-extensionButton-prominentForeground)!important}.monaco-action-bar .action-item .action-label.extension-action.label.prominent:hover{background-color:var(--vscode-extensionButton-prominentHoverBackground)}.monaco-action-bar .action-item .action-label.extension-action:not(.disabled){border:1px solid var(--vscode-contrastBorder)}.monaco-action-bar .action-item.action-dropdown-item>.action-dropdown-item-separator{border-bottom:1px solid var(--vscode-contrastBorder);border-top:1px solid var(--vscode-contrastBorder)}.monaco-action-bar .action-item .action-label.extension-action.extension-status-error{color:var(--vscode-editorError-foreground)}.monaco-action-bar .action-item .action-label.extension-action.extension-status-warning{color:var(--vscode-editorWarning-foreground)}.monaco-action-bar .action-item .action-label.extension-action.extension-status-info{color:var(--vscode-editorInfo-foreground)}.monaco-action-bar .action-dropdown-item .action-label.extension-action.label,.monaco-action-bar .action-item .action-label.extension-action.icon,.monaco-action-bar .action-item:not(.disabled) .action-label.extension-action.label,.monaco-action-bar .action-item:not(.disabled) .action-label.extension-action.text{margin-top:2px}.monaco-action-bar .action-item .action-label.extension-action.manage.hide,.monaco-action-bar .action-item.action-dropdown-item .action-label.extension-action.hide,.monaco-action-bar .action-item.action-dropdown-item.disabled,.monaco-action-bar .action-item.disabled .action-label.disable-status.hide,.monaco-action-bar .action-item.disabled .action-label.extension-action.extension-sync,.monaco-action-bar .action-item.disabled .action-label.extension-action.hide,.monaco-action-bar .action-item.disabled .action-label.extension-action.hide-when-disabled,.monaco-action-bar .action-item.disabled .action-label.extension-action.ignore,.monaco-action-bar .action-item.disabled .action-label.extension-action.install:not(.installing),.monaco-action-bar .action-item.disabled .action-label.extension-action.language,.monaco-action-bar .action-item.disabled .action-label.extension-action.migrate,.monaco-action-bar .action-item.disabled .action-label.extension-action.reload,.monaco-action-bar .action-item.disabled .action-label.extension-action.theme,.monaco-action-bar .action-item.disabled .action-label.extension-action.undo-ignore,.monaco-action-bar .action-item.disabled .action-label.extension-action.uninstall:not(.uninstalling),.monaco-action-bar .action-item.disabled .action-label.extension-action.update,.monaco-action-bar .action-item.disabled .action-label.extension-status-label.hide,.monaco-action-bar .action-item.disabled .action-label.extension-status.hide{display:none}.monaco-action-bar .extension-action.label{display:inherit}.monaco-action-bar .action-item.disabled .action-label.extension-status:before{opacity:1}.monaco-action-bar .action-item.disabled .action-label.extension-status-label:before{content:"\\2713";padding-right:4px}.monaco-action-bar .action-item.disabled .action-label.extension-action{opacity:1}.monaco-action-bar .action-item.disabled .action-label.extension-action.text{font-style:italic;opacity:.9}';
Wi(bd, {});
const po = [
  "{",
  "	// See https://go.microsoft.com/fwlink/?LinkId=827846 to learn about workspace recommendations.",
  "	// Extension identifier format: ${publisher}.${name}. Example: vscode.csharp",
  "",
  "	// List of extensions which should be recommended for users of this workspace.",
  '	"recommendations": [',
  "		",
  "	],",
  "	// List of extensions recommended by VS Code that should not be recommended for users of this workspace.",
  '	"unwantedRecommendations": [',
  "		",
  "	]",
  "}"
].join(`
`), wd = Go("extensionRecommendationsService"), Cd = Go("IExtensionIgnoredRecommendationsService"), Ba = ".vscode/extensions.json";
let Ti = class extends ve {
  constructor(e, t, i, s, c, l, n, r, a, f, m, C, b, p) {
    super("extension.promptExtensionInstallFailure"), this.extension = e, this.version = t, this.installOperation = i, this.error = s, this.productService = c, this.openerService = l, this.notificationService = n, this.dialogService = r, this.commandService = a, this.logService = f, this.extensionManagementServerService = m, this.instantiationService = C, this.galleryService = b, this.extensionManifestPropertiesService = p;
  }
  async run() {
    if (yc(this.error))
      return;
    if (this.logService.error(this.error), this.error.name === ni.Unsupported) {
      const l = ki ? g("VS Code for Web", "{0} for the Web", this.productService.nameLong) : this.productService.nameLong, n = g(
        "cannot be installed",
        "The '{0}' extension is not available in {1}. Click 'More Information' to learn more.",
        this.extension.displayName || this.extension.identifier.id,
        l
      ), { confirmed: r } = await this.dialogService.confirm({
        type: Te.Info,
        message: n,
        primaryButton: g(
          { key: "more information", comment: ["&& denotes a mnemonic"] },
          "&&More Information"
        ),
        cancelButton: g("close", "Close")
      });
      r && this.openerService.open(ki ? oe.parse("https://aka.ms/vscode-web-extensions-guide") : oe.parse("https://aka.ms/vscode-remote"));
      return;
    }
    if ([ni.Incompatible, ni.IncompatibleTargetPlatform, ni.Malicious, ni.ReleaseVersionNotFound, ni.Deprecated].includes(this.error.name)) {
      await this.dialogService.info(xc(this.error));
      return;
    }
    if (ni.Signature === this.error.name) {
      await this.dialogService.prompt({
        type: "error",
        message: g(
          "signature verification failed",
          "{0} cannot verify the '{1}' extension. Are you sure you want to install it?",
          this.productService.nameLong,
          this.extension.displayName || this.extension.identifier.id
        ),
        buttons: [{
          label: g("install anyway", "Install Anyway"),
          run: () => {
            const l = this.instantiationService.createInstance(Ws, { donotVerifySignature: !0 });
            return l.extension = this.extension, l.run();
          }
        }],
        cancelButton: g("cancel", "Cancel")
      });
      return;
    }
    const e = this.installOperation === 3 ? g(
      "update operation",
      "Error while updating '{0}' extension.",
      this.extension.displayName || this.extension.identifier.id
    ) : g(
      "install operation",
      "Error while installing '{0}' extension.",
      this.extension.displayName || this.extension.identifier.id
    );
    let t;
    const i = [], s = await this.getDownloadUrl();
    s && (t = g(
      "check logs",
      "Please check the [log]({0}) for more details.",
      `command:${Kh}`
    ), i.push({
      label: g("download", "Try Downloading Manually..."),
      run: () => this.openerService.open(s).then(() => {
        this.notificationService.prompt(Te.Info, g(
          "install vsix",
          "Once downloaded, please manually install the downloaded VSIX of '{0}'.",
          this.extension.identifier.id
        ), [{
          label: g("installVSIX", "Install from VSIX..."),
          run: () => this.commandService.executeCommand(kc)
        }]);
      })
    }));
    const c = `${e}${t ? ` ${t}` : ""}`;
    this.notificationService.prompt(Te.Error, c, i);
  }
  async getDownloadUrl() {
    if (Xo || !this.extension.gallery || !this.productService.extensionsGallery || !this.extensionManagementServerService.localExtensionManagementServer && !this.extensionManagementServerService.remoteExtensionManagementServer)
      return;
    let e = this.extension.gallery.properties.targetPlatform;
    if (e !== "universal" && e !== "undefined" && this.extensionManagementServerService.remoteExtensionManagementServer)
      try {
        const t = await this.galleryService.getManifest(this.extension.gallery, Hi.None);
        t && this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(t) && (e = await this.extensionManagementServerService.remoteExtensionManagementServer.extensionManagementService.getTargetPlatform());
      } catch (t) {
        this.logService.error(t);
        return;
      }
    if (e !== "unknown")
      return oe.parse(
        `${this.productService.extensionsGallery.serviceUrl}/publishers/${this.extension.publisher}/vsextensions/${this.extension.name}/${this.version}/vspackage${e !== "undefined" ? `?targetPlatform=${e}` : ""}`
      );
  }
};
Ti = X([
  D(4, Xn),
  D(5, tn),
  D(6, Ee),
  D(7, nn),
  D(8, dt),
  D(9, lc),
  D(10, hc),
  D(11, le),
  D(12, zo),
  D(13, dc)
], Ti);
const kt = class kt extends ve {
  constructor() {
    super(...arguments), this._extension = null;
  }
  get extension() {
    return this._extension;
  }
  set extension(e) {
    this._extension = e, this.update();
  }
};
kt.EXTENSION_ACTION_CLASS = "extension-action", kt.TEXT_ACTION_CLASS = `${kt.EXTENSION_ACTION_CLASS} text`, kt.LABEL_ACTION_CLASS = `${kt.EXTENSION_ACTION_CLASS} label`, kt.ICON_ACTION_CLASS = `${kt.EXTENSION_ACTION_CLASS} icon`;
let ne = kt;
var Ai;
let Ws = (Ai = class extends ne {
  set manifest(e) {
    this._manifest = e, this.updateLabel();
  }
  constructor(e, t, i, s, c, l, n, r, a) {
    super("extensions.install", g("install", "Install"), Ai.Class, !1), this.extensionsWorkbenchService = t, this.instantiationService = i, this.runtimeExtensionService = s, this.workbenchThemeService = c, this.labelService = l, this.dialogService = n, this.preferencesService = r, this.telemetryService = a, this._manifest = null, this.updateThrottler = new Kr(), this.options = { ...e, isMachineScoped: !1 }, this.update(), this._register(this.labelService.onDidChangeFormatters(() => this.updateLabel(), this));
  }
  update() {
    this.updateThrottler.queue(() => this.computeAndUpdateEnablement());
  }
  async computeAndUpdateEnablement() {
    this.enabled = !1, this.extension && (this.extension.isBuiltin || this.extensionsWorkbenchService.canSetLanguage(this.extension) || this.extension.state === 3 && await this.extensionsWorkbenchService.canInstall(this.extension) && (this.enabled = this.options.installPreReleaseVersion ? this.extension.hasPreReleaseVersion : this.extension.hasReleaseVersion, this.updateLabel()));
  }
  async run() {
    if (!this.extension)
      return;
    if (this.extension.deprecationInfo) {
      let t = g(
        "deprecated message",
        "This extension is deprecated as it is no longer being maintained."
      ), i;
      (function(l) {
        l[l.InstallAnyway = 0] = "InstallAnyway", l[l.ShowAlternateExtension = 1] = "ShowAlternateExtension", l[l.ConfigureSettings = 2] = "ConfigureSettings", l[l.Cancel = 3] = "Cancel";
      })(i || (i = {}));
      const s = [
        {
          label: g("install anyway", "Install Anyway"),
          run: () => i.InstallAnyway
        }
      ];
      if (this.extension.deprecationInfo.extension) {
        t = g(
          "deprecated with alternate extension message",
          "This extension is deprecated. Use the {0} extension instead.",
          this.extension.deprecationInfo.extension.displayName
        );
        const l = this.extension.deprecationInfo.extension;
        s.push({
          label: g(
            { key: "Show alternate extension", comment: ["&& denotes a mnemonic"] },
            "&&Open {0}",
            this.extension.deprecationInfo.extension.displayName
          ),
          run: async () => {
            const [n] = await this.extensionsWorkbenchService.getExtensions([{ id: l.id, preRelease: l.preRelease }], Hi.None);
            return await this.extensionsWorkbenchService.open(n), i.ShowAlternateExtension;
          }
        });
      } else if (this.extension.deprecationInfo.settings) {
        t = g(
          "deprecated with alternate settings message",
          "This extension is deprecated as this functionality is now built-in to VS Code."
        );
        const l = this.extension.deprecationInfo.settings;
        s.push({
          label: g(
            { key: "configure in settings", comment: ["&& denotes a mnemonic"] },
            "&&Configure Settings"
          ),
          run: async () => (await this.preferencesService.openSettings({ query: l.map((n) => `@id:${n}`).join(" ") }), i.ConfigureSettings)
        });
      } else
        this.extension.deprecationInfo.additionalInfo && (t = new de(`${t} ${this.extension.deprecationInfo.additionalInfo}`));
      const { result: c } = await this.dialogService.prompt({
        type: Te.Warning,
        message: g(
          "install confirmation",
          "Are you sure you want to install '{0}'?",
          this.extension.displayName
        ),
        detail: xi(t) ? t : void 0,
        custom: xi(t) ? void 0 : {
          markdownDetails: [{
            markdown: t
          }]
        },
        buttons: s,
        cancelButton: {
          run: () => i.Cancel
        }
      });
      if (c !== i.InstallAnyway)
        return;
    }
    this.extensionsWorkbenchService.open(this.extension, { showPreReleaseVersion: this.options.installPreReleaseVersion }), hi(g(
      "installExtensionStart",
      "Installing extension {0} started. An editor is now open with more details on this extension",
      this.extension.displayName
    )), this.telemetryService.publicLog("extensions:action:install", { ...this.extension.telemetryData, actionId: this.id });
    const e = await this.install(this.extension);
    if (e != null && e.local) {
      hi(g(
        "installExtensionComplete",
        "Installing extension {0} is completed.",
        this.extension.displayName
      ));
      const t = await this.getRunningExtension(e.local);
      if (t && !(t.activationEvents && t.activationEvents.some((i) => i.startsWith("onLanguage")))) {
        const i = await this.getThemeAction(e);
        if (i) {
          i.extension = e;
          try {
            return i.run({ showCurrentTheme: !0, ignoreFocusLost: !0 });
          } finally {
            i.dispose();
          }
        }
      }
    }
  }
  async getThemeAction(e) {
    if ((await this.workbenchThemeService.getColorThemes()).some((c) => Ct(c, e)))
      return this.instantiationService.createInstance(Xs);
    if ((await this.workbenchThemeService.getFileIconThemes()).some((c) => Ct(c, e)))
      return this.instantiationService.createInstance(Ys);
    if ((await this.workbenchThemeService.getProductIconThemes()).some((c) => Ct(c, e)))
      return this.instantiationService.createInstance(Qs);
  }
  async install(e) {
    try {
      return await this.extensionsWorkbenchService.install(e, this.options);
    } catch (t) {
      await this.instantiationService.createInstance(Ti, e, e.latestVersion, 2, t).run();
      return;
    }
  }
  async getRunningExtension(e) {
    const t = await this.runtimeExtensionService.getExtension(e.identifier.id);
    return t || (this.runtimeExtensionService.canAddExtension(yn(e)) ? new Promise((i, s) => {
      const c = this.runtimeExtensionService.onDidChangeExtensions(async () => {
        const l = await this.runtimeExtensionService.getExtension(e.identifier.id);
        l && (c.dispose(), i(l));
      });
    }) : null);
  }
  updateLabel() {
    this.label = this.getLabel();
  }
  getLabel(e) {
    var t, i;
    return this.options.installPreReleaseVersion && ((t = this.extension) != null && t.hasPreReleaseVersion) ? e ? g("install pre-release", "Install Pre-Release") : g("install pre-release version", "Install Pre-Release Version") : (i = this.extension) != null && i.hasPreReleaseVersion ? e ? g("install", "Install") : g("install release version", "Install Release Version") : g("install", "Install");
  }
}, Ai.Class = `${ne.LABEL_ACTION_CLASS} prominent install`, Ai);
Ws = X([
  D(1, ut),
  D(2, le),
  D(3, mt),
  D(4, sn),
  D(5, Un),
  D(6, nn),
  D(7, Gr),
  D(8, Ni)
], Ws);
const oi = class oi extends ne {
  constructor() {
    super("extension.installing", oi.LABEL, oi.CLASS, !1);
  }
  update() {
    this.class = `${oi.CLASS}${this.extension && this.extension.state === 0 ? "" : " hide"}`;
  }
};
oi.LABEL = g("installing", "Installing"), oi.CLASS = `${ne.LABEL_ACTION_CLASS} install installing`;
let vo = oi;
var Je;
Je = class extends ne {
  constructor(e, t, i, s, c, l) {
    super(e, Je.INSTALL_LABEL, Je.Class, !1), this.server = t, this.canInstallAnyWhere = i, this.extensionsWorkbenchService = s, this.extensionManagementServerService = c, this.extensionManifestPropertiesService = l, this.updateWhenCounterExtensionChanges = !0, this.update();
  }
  update() {
    if (this.enabled = !1, this.class = Je.Class, this.canInstall()) {
      const e = this.extensionsWorkbenchService.installed.filter((t) => ht(t.identifier, this.extension.identifier) && t.server === this.server)[0];
      e ? e.state === 0 && !e.local && (this.enabled = !0, this.label = Je.INSTALLING_LABEL, this.class = Je.InstallingClass) : (this.enabled = !0, this.label = this.getInstallLabel());
    }
  }
  canInstall() {
    return !this.extension || !this.server || !this.extension.local || this.extension.state !== 1 || this.extension.type !== 1 || this.extension.enablementState === 2 || this.extension.enablementState === 0 || this.extension.enablementState === 4 ? !1 : !!(Ko(this.extension.local.manifest) || this.server === this.extensionManagementServerService.localExtensionManagementServer && this.extensionManifestPropertiesService.prefersExecuteOnUI(this.extension.local.manifest) || this.server === this.extensionManagementServerService.remoteExtensionManagementServer && this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(this.extension.local.manifest) || this.server === this.extensionManagementServerService.webExtensionManagementServer && this.extensionManifestPropertiesService.prefersExecuteOnWeb(this.extension.local.manifest) || this.canInstallAnyWhere && (this.server === this.extensionManagementServerService.localExtensionManagementServer && this.extensionManifestPropertiesService.canExecuteOnUI(this.extension.local.manifest) || this.server === this.extensionManagementServerService.remoteExtensionManagementServer && this.extensionManifestPropertiesService.canExecuteOnWorkspace(this.extension.local.manifest)));
  }
  async run() {
    var e, t;
    if ((e = this.extension) != null && e.local && (t = this.extension) != null && t.server && this.server)
      return this.extensionsWorkbenchService.open(this.extension), hi(g(
        "installExtensionStart",
        "Installing extension {0} started. An editor is now open with more details on this extension",
        this.extension.displayName
      )), this.extensionsWorkbenchService.installInServer(this.extension, this.server);
  }
}, Je.INSTALL_LABEL = g("install", "Install"), Je.INSTALLING_LABEL = g("installing", "Installing"), Je.Class = `${ne.LABEL_ACTION_CLASS} prominent install`, Je.InstallingClass = `${ne.LABEL_ACTION_CLASS} install installing`;
var Be;
let Ns = (Be = class extends ne {
  constructor(e) {
    super("extensions.uninstall", Be.UninstallLabel, Be.UninstallClass, !1), this.extensionsWorkbenchService = e, this.update();
  }
  update() {
    if (!this.extension) {
      this.enabled = !1;
      return;
    }
    const e = this.extension.state;
    if (e === 2) {
      this.label = Be.UninstallingLabel, this.class = Be.UnInstallingClass, this.enabled = !1;
      return;
    }
    if (this.label = Be.UninstallLabel, this.class = Be.UninstallClass, this.tooltip = Be.UninstallLabel, e !== 1) {
      this.enabled = !1;
      return;
    }
    if (this.extension.isBuiltin) {
      this.enabled = !1;
      return;
    }
    this.enabled = !0;
  }
  async run() {
    if (this.extension)
      return hi(g(
        "uninstallExtensionStart",
        "Uninstalling extension {0} started.",
        this.extension.displayName
      )), this.extensionsWorkbenchService.uninstall(this.extension).then(() => {
        hi(g(
          "uninstallExtensionComplete",
          "Please reload Visual Studio Code to complete the uninstallation of the extension {0}.",
          this.extension.displayName
        ));
      });
  }
}, Be.UninstallLabel = g("uninstallAction", "Uninstall"), Be.UninstallingLabel = g("Uninstalling", "Uninstalling"), Be.UninstallClass = `${ne.LABEL_ACTION_CLASS} uninstall`, Be.UnInstallingClass = `${ne.LABEL_ACTION_CLASS} uninstall uninstalling`, Be);
Ns = X([
  D(0, ut)
], Ns);
const Ht = class Ht extends ne {
  constructor(e, t, i) {
    super(e, t, Ht.DisabledClass, !1), this.extensionsWorkbenchService = i, this.updateThrottler = new Kr(), this.update();
  }
  update() {
    this.updateThrottler.queue(() => this.computeAndUpdateEnablement());
  }
  async computeAndUpdateEnablement() {
    if (this.enabled = !1, this.class = $s.DisabledClass, !this.extension || this.extension.deprecationInfo)
      return;
    const e = await this.extensionsWorkbenchService.canInstall(this.extension), t = this.extension.state === 1;
    this.enabled = e && t && this.extension.outdated, this.class = this.enabled ? Ht.EnabledClass : Ht.DisabledClass;
  }
};
Ht.EnabledClass = `${ne.LABEL_ACTION_CLASS} prominent update`, Ht.DisabledClass = `${Ht.EnabledClass} disabled`;
let Vs = Ht, $s = class extends Vs {
  constructor(e, t, i) {
    super("extensions.update", g("update", "Update"), t), this.verbose = e, this.instantiationService = i;
  }
  update() {
    super.update(), this.extension && (this.label = this.verbose ? g("update to", "Update to v{0}", this.extension.latestVersion) : g("update", "Update"));
  }
  async run() {
    if (this.extension)
      return hi(g(
        "updateExtensionStart",
        "Updating extension {0} to version {1} started.",
        this.extension.displayName,
        this.extension.latestVersion
      )), this.install(this.extension);
  }
  async install(e) {
    var t;
    try {
      await this.extensionsWorkbenchService.install(e, (t = e.local) != null && t.preRelease ? { installPreReleaseVersion: !0 } : void 0), hi(g(
        "updateExtensionComplete",
        "Updating extension {0} to version {1} completed.",
        e.displayName,
        e.latestVersion
      ));
    } catch (i) {
      this.instantiationService.createInstance(Ti, e, e.latestVersion, 3, i).run();
    }
  }
};
$s = X([
  D(1, ut),
  D(2, le)
], $s);
var pt;
pt = class extends ne {
  constructor(e, t) {
    super("extensionsAction.migrateDeprecatedExtension", g("migrateExtension", "Migrate"), pt.DisabledClass, !1), this.small = e, this.extensionsWorkbenchService = t, this.update();
  }
  update() {
    var t, i;
    if (this.enabled = !1, this.class = pt.DisabledClass, !((t = this.extension) != null && t.local) || this.extension.state !== 1 || !((i = this.extension.deprecationInfo) != null && i.extension))
      return;
    const e = this.extension.deprecationInfo.extension.id;
    this.extensionsWorkbenchService.local.some((s) => ht(s.identifier, { id: e })) || (this.enabled = !0, this.class = pt.EnabledClass, this.tooltip = g(
      "migrate to",
      "Migrate to {0}",
      this.extension.deprecationInfo.extension.displayName
    ), this.label = this.small ? g("migrate", "Migrate") : this.tooltip);
  }
  async run() {
    var i, s, c, l;
    if (!((s = (i = this.extension) == null ? void 0 : i.deprecationInfo) != null && s.extension))
      return;
    const e = this.extension.local;
    await this.extensionsWorkbenchService.uninstall(this.extension);
    const [t] = await this.extensionsWorkbenchService.getExtensions([{ id: this.extension.deprecationInfo.extension.id, preRelease: (l = (c = this.extension.deprecationInfo) == null ? void 0 : c.extension) == null ? void 0 : l.preRelease }], Hi.None);
    await this.extensionsWorkbenchService.install(t, { isMachineScoped: e == null ? void 0 : e.isMachineScoped });
  }
}, pt.EnabledClass = `${ne.LABEL_ACTION_CLASS} migrate`, pt.DisabledClass = `${pt.EnabledClass} disabled`;
let Mn = class extends ne {
  constructor(e, t, i, s, c) {
    super(e, t, i, s), this.instantiationService = c, this._actionViewItem = null;
  }
  createActionViewItem() {
    return this._actionViewItem = this.instantiationService.createInstance(Us, this), this._actionViewItem;
  }
  run({ actionGroups: e, disposeActionsOnHide: t }) {
    var i;
    return (i = this._actionViewItem) == null || i.showMenu(e, t), Promise.resolve();
  }
};
Mn = X([
  D(4, le)
], Mn);
let Us = class extends Yo {
  constructor(e, t) {
    super(null, e, { icon: !0, label: !0 }), this.contextMenuService = t;
  }
  showMenu(e, t) {
    if (this.element) {
      const i = this.getActions(e), s = Qo(this.element), c = { x: s.left, y: s.top + s.height + 10 };
      this.contextMenuService.showContextMenu({
        getAnchor: () => c,
        getActions: () => i,
        actionRunner: this.actionRunner,
        onHide: () => {
          t && Ic(i);
        }
      });
    }
  }
  getActions(e) {
    let t = [];
    for (const i of e)
      t = [...t, ...i, new ci()];
    return t.length ? t.slice(0, t.length - 1) : t;
  }
};
Us = X([
  D(1, _i)
], Us);
async function yd(h, e, t) {
  return t.invokeFunction(async (i) => {
    var C, b, p, S, o;
    const s = i.get(ut), c = i.get(Zn), l = i.get(wd), n = i.get(Cd), r = i.get(sn), a = [];
    if (h) {
      a.push(["extension", h.identifier.id]), a.push(["isBuiltinExtension", h.isBuiltin]), a.push(["isDefaultApplicationScopedExtension", h.local && Tc(h.local.manifest)]), a.push(["isApplicationScopedExtension", h.local && h.local.isApplicationScoped]), a.push(["extensionHasConfiguration", h.local && !!h.local.manifest.contributes && !!h.local.manifest.contributes.configuration]), a.push(["extensionHasKeybindings", h.local && !!h.local.manifest.contributes && !!h.local.manifest.contributes.keybindings]), a.push(["extensionHasCommands", h.local && !!h.local.manifest.contributes && !!((C = h.local.manifest.contributes) != null && C.commands)]), a.push(["isExtensionRecommended", !!l.getAllRecommendationsWithReason()[h.identifier.id.toLowerCase()]]), a.push(["isExtensionWorkspaceRecommended", ((b = l.getAllRecommendationsWithReason()[h.identifier.id.toLowerCase()]) == null ? void 0 : b.reasonId) === 0]), a.push(["isUserIgnoredRecommendation", n.globalIgnoredRecommendations.some((v) => v === h.identifier.id.toLowerCase())]), h.state === 1 && a.push(["extensionStatus", "installed"]), a.push(["installedExtensionIsPreReleaseVersion", !!((p = h.local) != null && p.isPreReleaseVersion)]), a.push(["installedExtensionIsOptedTpPreRelease", !!((S = h.local) != null && S.preRelease)]), a.push(["galleryExtensionIsPreReleaseVersion", !!((o = h.gallery) != null && o.properties.isPreReleaseVersion)]), a.push(["extensionHasPreReleaseVersion", h.hasPreReleaseVersion]), a.push(["extensionHasReleaseVersion", h.hasReleaseVersion]);
      const [_, u, d] = await Promise.all([r.getColorThemes(), r.getFileIconThemes(), r.getProductIconThemes()]);
      a.push(["extensionHasColorThemes", _.some((v) => Ct(v, h))]), a.push(["extensionHasFileIconThemes", u.some((v) => Ct(v, h))]), a.push(["extensionHasProductIconThemes", d.some((v) => Ct(v, h))]), a.push(["canSetLanguage", s.canSetLanguage(h)]), a.push(["isActiveLanguagePackExtension", h.gallery && Yn === qr(h.gallery)]);
    }
    const f = c.createMenu(J.ExtensionContext, e.createOverlay(a)), m = f.getActions({ shouldForwardArgs: !0 });
    return f.dispose(), m;
  });
}
function hs(h, e) {
  const t = [];
  for (const [, i] of h)
    t.push(i.map((s) => s instanceof Jo ? s : e.createInstance(Gs, s)));
  return t;
}
var nt;
nt = class extends Mn {
  constructor(e, t, i) {
    super(nt.ID, "", "", !0, e), this.extensionService = t, this.contextKeyService = i, this.tooltip = g("manage", "Manage"), this.update();
  }
  async getActionGroups() {
    const e = [], t = await yd(this.extension, this.contextKeyService, this.instantiationService), i = [], s = [], c = [];
    for (const [l, n] of t)
      l === uc ? s.push(...hs([[l, n]], this.instantiationService)[0]) : l === mc ? i.push(...hs([[l, n]], this.instantiationService)[0]) : c.push(...hs([[l, n]], this.instantiationService));
    return i.length && e.push(i), e.push([
      this.instantiationService.createInstance(Ks),
      this.instantiationService.createInstance(zs)
    ]), e.push([
      this.instantiationService.createInstance(js),
      this.instantiationService.createInstance(qs)
    ]), e.push([
      ...s.length ? s : [],
      this.instantiationService.createInstance(Ji),
      this.instantiationService.createInstance(Ns)
    ]), c.forEach((l) => e.push(l)), e.forEach((l) => l.forEach((n) => {
      n instanceof ne && (n.extension = this.extension);
    })), e;
  }
  async run() {
    return await this.extensionService.whenInstalledExtensionsRegistered(), super.run({ actionGroups: await this.getActionGroups(), disposeActionsOnHide: !0 });
  }
  update() {
    if (this.class = nt.HideManageExtensionClass, this.enabled = !1, this.extension) {
      const e = this.extension.state;
      this.enabled = e === 1, this.class = this.enabled || e === 2 ? nt.Class : nt.HideManageExtensionClass, this.tooltip = e === 2 ? g("ManageExtensionAction.uninstallingTooltip", "Uninstalling") : "";
    }
  }
}, nt.ID = "extensions.manage", nt.Class = `${ne.ICON_ACTION_CLASS} manage ` + re.asClassName($h), nt.HideManageExtensionClass = `${nt.Class} hide`;
let Gs = class extends ne {
  constructor(e, t) {
    super(e.id, e.label), this.action = e, this.extensionsWorkbenchService = t;
  }
  update() {
    this.extension && (this.action.id === Dc ? this.checked = !this.extensionsWorkbenchService.isExtensionIgnoredToSync(this.extension) : this.checked = this.action.checked);
  }
  async run() {
    this.extension && await this.action.run(this.extension.local ? so(this.extension.local.manifest.publisher, this.extension.local.manifest.name) : this.extension.gallery ? so(this.extension.gallery.publisher, this.extension.gallery.name) : this.extension.identifier.id);
  }
};
Gs = X([
  D(1, ut)
], Gs);
var Tt;
Tt = class extends ne {
  constructor(e, t) {
    super(Tt.ID, e ? "" : Tt.TITLE.value, `${e ? ne.ICON_ACTION_CLASS + " " + re.asClassName(wa) : ne.LABEL_ACTION_CLASS} hide-when-disabled switch-to-prerelease`, !0), this.commandService = t, this.tooltip = g(
      "switch to pre-release version tooltip",
      "Switch to Pre-Release version of this extension"
    ), this.update();
  }
  update() {
    var e, t;
    this.enabled = !!this.extension && !this.extension.isBuiltin && !((e = this.extension.local) != null && e.isPreReleaseVersion) && !((t = this.extension.local) != null && t.preRelease) && this.extension.hasPreReleaseVersion && this.extension.state === 1;
  }
  async run() {
    var e;
    if (this.enabled)
      return this.commandService.executeCommand(Tt.ID, (e = this.extension) == null ? void 0 : e.identifier.id);
  }
}, Tt.ID = "workbench.extensions.action.switchToPreReleaseVersion", Tt.TITLE = { value: g("switch to pre-release version", "Switch to Pre-Release Version"), original: "Switch to  Pre-Release Version" };
var Dt;
Dt = class extends ne {
  constructor(e, t) {
    super(Dt.ID, e ? "" : Dt.TITLE.value, `${e ? ne.ICON_ACTION_CLASS + " " + re.asClassName(wa) : ne.LABEL_ACTION_CLASS} hide-when-disabled switch-to-released`), this.commandService = t, this.tooltip = g(
      "switch to release version tooltip",
      "Switch to Release version of this extension"
    ), this.update();
  }
  update() {
    var e;
    this.enabled = !!this.extension && !this.extension.isBuiltin && this.extension.state === 1 && !!((e = this.extension.local) != null && e.isPreReleaseVersion) && !!this.extension.hasReleaseVersion;
  }
  async run() {
    var e;
    if (this.enabled)
      return this.commandService.executeCommand(Dt.ID, (e = this.extension) == null ? void 0 : e.identifier.id);
  }
}, Dt.ID = "workbench.extensions.action.switchToReleaseVersion", Dt.TITLE = { value: g("switch to release version", "Switch to Release Version"), original: "Switch to Release Version" };
var Vt;
let Ji = (Vt = class extends ne {
  constructor(e, t, i, s, c) {
    super(Vt.ID, Vt.LABEL, ne.LABEL_ACTION_CLASS), this.extensionsWorkbenchService = e, this.extensionGalleryService = t, this.quickInputService = i, this.instantiationService = s, this.dialogService = c, this.update();
  }
  update() {
    this.enabled = !!this.extension && !this.extension.isBuiltin && !!this.extension.gallery && !!this.extension.local && !!this.extension.server && this.extension.state === 1 && !this.extension.deprecationInfo;
  }
  async run() {
    if (!this.enabled)
      return;
    const e = await this.extension.server.extensionManagementService.getTargetPlatform(), t = await this.extensionGalleryService.getAllCompatibleVersions(this.extension.gallery, this.extension.local.preRelease, e);
    if (!t.length) {
      await this.dialogService.info(g("no versions", "This extension has no other versions."));
      return;
    }
    const i = t.map((c, l) => ({
      id: c.version,
      label: c.version,
      description: `${Gi(new Date(Date.parse(c.date)), !0)}${c.isPreReleaseVersion ? ` (${g("pre-release", "pre-release")})` : ""}${c.version === this.extension.version ? ` (${g("current", "current")})` : ""}`,
      latest: l === 0,
      ariaLabel: `${c.isPreReleaseVersion ? "Pre-Release version" : "Release version"} ${c.version}`,
      isPreReleaseVersion: c.isPreReleaseVersion
    })), s = await this.quickInputService.pick(i, {
      placeHolder: g("selectVersion", "Select Version to Install"),
      matchOnDetail: !0
    });
    if (s) {
      if (this.extension.version === s.id)
        return;
      try {
        s.latest ? await this.extensionsWorkbenchService.install(this.extension, { installPreReleaseVersion: s.isPreReleaseVersion }) : await this.extensionsWorkbenchService.installVersion(this.extension, s.id, { installPreReleaseVersion: s.isPreReleaseVersion });
      } catch (c) {
        this.instantiationService.createInstance(Ti, this.extension, s.latest ? this.extension.latestVersion : s.id, 2, c).run();
      }
    }
    return null;
  }
}, Vt.ID = "workbench.extensions.action.install.anotherVersion", Vt.LABEL = g("install another version", "Install Another Version..."), Vt);
Ji = X([
  D(0, ut),
  D(1, zo),
  D(2, qe),
  D(3, le),
  D(4, nn)
], Ji);
var $t;
let zs = ($t = class extends ne {
  constructor(e, t) {
    super($t.ID, $t.LABEL, ne.LABEL_ACTION_CLASS), this.extensionsWorkbenchService = e, this.extensionEnablementService = t, this.tooltip = g(
      "enableForWorkspaceActionToolTip",
      "Enable this extension only in this workspace"
    ), this.update();
  }
  update() {
    this.enabled = !1, this.extension && this.extension.local && (this.enabled = this.extension.state === 1 && !this.extensionEnablementService.isEnabled(this.extension.local) && this.extensionEnablementService.canChangeWorkspaceEnablement(this.extension.local));
  }
  async run() {
    if (this.extension)
      return this.extensionsWorkbenchService.setEnablement(this.extension, 9);
  }
}, $t.ID = "extensions.enableForWorkspace", $t.LABEL = g("enableForWorkspaceAction", "Enable (Workspace)"), $t);
zs = X([
  D(0, ut),
  D(1, gi)
], zs);
var Ut;
let Ks = (Ut = class extends ne {
  constructor(e, t) {
    super(Ut.ID, Ut.LABEL, ne.LABEL_ACTION_CLASS), this.extensionsWorkbenchService = e, this.extensionEnablementService = t, this.tooltip = g("enableGloballyActionToolTip", "Enable this extension"), this.update();
  }
  update() {
    this.enabled = !1, this.extension && this.extension.local && (this.enabled = this.extension.state === 1 && this.extensionEnablementService.isDisabledGlobally(this.extension.local) && this.extensionEnablementService.canChangeEnablement(this.extension.local));
  }
  async run() {
    if (this.extension)
      return this.extensionsWorkbenchService.setEnablement(this.extension, 8);
  }
}, Ut.ID = "extensions.enableGlobally", Ut.LABEL = g("enableGloballyAction", "Enable"), Ut);
Ks = X([
  D(0, ut),
  D(1, gi)
], Ks);
var Gt;
let qs = (Gt = class extends ne {
  constructor(e, t, i, s) {
    super(Gt.ID, Gt.LABEL, ne.LABEL_ACTION_CLASS), this.workspaceContextService = e, this.extensionsWorkbenchService = t, this.extensionEnablementService = i, this.extensionService = s, this.tooltip = g(
      "disableForWorkspaceActionToolTip",
      "Disable this extension only in this workspace"
    ), this.update(), this._register(this.extensionService.onDidChangeExtensions(() => this.update()));
  }
  update() {
    this.enabled = !1, this.extension && this.extension.local && this.extensionService.extensions.some(
      (e) => ht({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier) && this.workspaceContextService.getWorkbenchState() !== 1
    ) && (this.enabled = this.extension.state === 1 && (this.extension.enablementState === 8 || this.extension.enablementState === 9) && this.extensionEnablementService.canChangeWorkspaceEnablement(this.extension.local));
  }
  async run() {
    if (this.extension)
      return this.extensionsWorkbenchService.setEnablement(this.extension, 7);
  }
}, Gt.ID = "extensions.disableForWorkspace", Gt.LABEL = g("disableForWorkspaceAction", "Disable (Workspace)"), Gt);
qs = X([
  D(0, tt),
  D(1, ut),
  D(2, gi),
  D(3, mt)
], qs);
var zt;
let js = (zt = class extends ne {
  constructor(e, t, i) {
    super(zt.ID, zt.LABEL, ne.LABEL_ACTION_CLASS), this.extensionsWorkbenchService = e, this.extensionEnablementService = t, this.extensionService = i, this.tooltip = g("disableGloballyActionToolTip", "Disable this extension"), this.update(), this._register(this.extensionService.onDidChangeExtensions(() => this.update()));
  }
  update() {
    this.enabled = !1, this.extension && this.extension.local && this.extensionService.extensions.some(
      (e) => ht({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier)
    ) && (this.enabled = this.extension.state === 1 && (this.extension.enablementState === 8 || this.extension.enablementState === 9) && this.extensionEnablementService.canChangeEnablement(this.extension.local));
  }
  async run() {
    if (this.extension)
      return this.extensionsWorkbenchService.setEnablement(this.extension, 6);
  }
}, zt.ID = "extensions.disableGlobally", zt.LABEL = g("disableGloballyAction", "Disable"), zt);
js = X([
  D(0, ut),
  D(1, gi),
  D(2, mt)
], js);
var vt;
vt = class extends ne {
  constructor(e, t) {
    super("extensions.reload", g("reloadAction", "Reload"), vt.DisabledClass, !1), this.hostService = e, this.extensionService = t, this.updateWhenCounterExtensionChanges = !0, this._register(this.extensionService.onDidChangeExtensions(() => this.update())), this.update();
  }
  update() {
    if (this.enabled = !1, this.tooltip = "", !this.extension)
      return;
    const e = this.extension.state;
    if (e === 0 || e === 2 || this.extension.local && this.extension.local.manifest && this.extension.local.manifest.contributes && this.extension.local.manifest.contributes.localizations && this.extension.local.manifest.contributes.localizations.length > 0)
      return;
    const t = this.extension.reloadRequiredStatus;
    this.enabled = t !== void 0, this.label = t !== void 0 ? g("reload required", "Reload Required") : "", this.tooltip = t !== void 0 ? t : "", this.class = this.enabled ? vt.EnabledClass : vt.DisabledClass;
  }
  run() {
    return Promise.resolve(this.hostService.reload());
  }
}, vt.EnabledClass = `${ne.LABEL_ACTION_CLASS} reload`, vt.DisabledClass = `${vt.EnabledClass} disabled`;
function Ct(h, e) {
  return !!(e && h.extensionData && fc.equals(h.extensionData.extensionId, e.identifier.id));
}
function Zr(h, e, t, i) {
  const s = [];
  for (const c of h)
    Ct(c, t) && !(i && c === e) && s.push({ label: c.label, id: c.id });
  return i && (s.push({ type: "separator", label: g("current", "current") }), s.push({ label: e.label, id: e.id })), s;
}
var $e;
let Xs = ($e = class extends ne {
  constructor(e, t, i, s) {
    super($e.ID, $e.TITLE.value, $e.DisabledClass, !1), this.workbenchThemeService = t, this.quickInputService = i, this.extensionEnablementService = s, this._register(be.any(e.onDidChangeExtensions, t.onDidColorThemeChange)(() => this.update(), this)), this.update();
  }
  update() {
    this.workbenchThemeService.getColorThemes().then((e) => {
      this.enabled = this.computeEnablement(e), this.class = this.enabled ? $e.EnabledClass : $e.DisabledClass;
    });
  }
  computeEnablement(e) {
    return !!this.extension && this.extension.state === 1 && this.extensionEnablementService.isEnabledEnablementState(this.extension.enablementState) && e.some((t) => Ct(t, this.extension));
  }
  async run({ showCurrentTheme: e, ignoreFocusLost: t } = { showCurrentTheme: !1, ignoreFocusLost: !1 }) {
    const i = await this.workbenchThemeService.getColorThemes();
    if (!this.computeEnablement(i))
      return;
    const s = this.workbenchThemeService.getColorTheme(), c = new es(100), l = Zr(i, s, this.extension, e), n = await this.quickInputService.pick(l, {
      placeHolder: g("select color theme", "Select Color Theme"),
      onDidFocus: (r) => c.trigger(() => this.workbenchThemeService.setColorTheme(r.id, void 0)),
      ignoreFocusLost: t
    });
    return this.workbenchThemeService.setColorTheme(n ? n.id : s.id, "auto");
  }
}, $e.ID = "workbench.extensions.action.setColorTheme", $e.TITLE = { value: g("workbench.extensions.action.setColorTheme", "Set Color Theme"), original: "Set Color Theme" }, $e.EnabledClass = `${ne.LABEL_ACTION_CLASS} theme`, $e.DisabledClass = `${$e.EnabledClass} disabled`, $e);
Xs = X([
  D(0, mt),
  D(1, sn),
  D(2, qe),
  D(3, gi)
], Xs);
var Ue;
let Ys = (Ue = class extends ne {
  constructor(e, t, i, s) {
    super(Ue.ID, Ue.TITLE.value, Ue.DisabledClass, !1), this.workbenchThemeService = t, this.quickInputService = i, this.extensionEnablementService = s, this._register(be.any(e.onDidChangeExtensions, t.onDidFileIconThemeChange)(() => this.update(), this)), this.update();
  }
  update() {
    this.workbenchThemeService.getFileIconThemes().then((e) => {
      this.enabled = this.computeEnablement(e), this.class = this.enabled ? Ue.EnabledClass : Ue.DisabledClass;
    });
  }
  computeEnablement(e) {
    return !!this.extension && this.extension.state === 1 && this.extensionEnablementService.isEnabledEnablementState(this.extension.enablementState) && e.some((t) => Ct(t, this.extension));
  }
  async run({ showCurrentTheme: e, ignoreFocusLost: t } = { showCurrentTheme: !1, ignoreFocusLost: !1 }) {
    const i = await this.workbenchThemeService.getFileIconThemes();
    if (!this.computeEnablement(i))
      return;
    const s = this.workbenchThemeService.getFileIconTheme(), c = new es(100), l = Zr(i, s, this.extension, e), n = await this.quickInputService.pick(l, {
      placeHolder: g("select file icon theme", "Select File Icon Theme"),
      onDidFocus: (r) => c.trigger(() => this.workbenchThemeService.setFileIconTheme(r.id, void 0)),
      ignoreFocusLost: t
    });
    return this.workbenchThemeService.setFileIconTheme(n ? n.id : s.id, "auto");
  }
}, Ue.ID = "workbench.extensions.action.setFileIconTheme", Ue.TITLE = { value: g("workbench.extensions.action.setFileIconTheme", "Set File Icon Theme"), original: "Set File Icon Theme" }, Ue.EnabledClass = `${ne.LABEL_ACTION_CLASS} theme`, Ue.DisabledClass = `${Ue.EnabledClass} disabled`, Ue);
Ys = X([
  D(0, mt),
  D(1, sn),
  D(2, qe),
  D(3, gi)
], Ys);
var Ge;
let Qs = (Ge = class extends ne {
  constructor(e, t, i, s) {
    super(Ge.ID, Ge.TITLE.value, Ge.DisabledClass, !1), this.workbenchThemeService = t, this.quickInputService = i, this.extensionEnablementService = s, this._register(be.any(e.onDidChangeExtensions, t.onDidProductIconThemeChange)(() => this.update(), this)), this.update();
  }
  update() {
    this.workbenchThemeService.getProductIconThemes().then((e) => {
      this.enabled = this.computeEnablement(e), this.class = this.enabled ? Ge.EnabledClass : Ge.DisabledClass;
    });
  }
  computeEnablement(e) {
    return !!this.extension && this.extension.state === 1 && this.extensionEnablementService.isEnabledEnablementState(this.extension.enablementState) && e.some((t) => Ct(t, this.extension));
  }
  async run({ showCurrentTheme: e, ignoreFocusLost: t } = { showCurrentTheme: !1, ignoreFocusLost: !1 }) {
    const i = await this.workbenchThemeService.getProductIconThemes();
    if (!this.computeEnablement(i))
      return;
    const s = this.workbenchThemeService.getProductIconTheme(), c = new es(100), l = Zr(i, s, this.extension, e), n = await this.quickInputService.pick(l, {
      placeHolder: g("select product icon theme", "Select Product Icon Theme"),
      onDidFocus: (r) => c.trigger(() => this.workbenchThemeService.setProductIconTheme(r.id, void 0)),
      ignoreFocusLost: t
    });
    return this.workbenchThemeService.setProductIconTheme(n ? n.id : s.id, "auto");
  }
}, Ge.ID = "workbench.extensions.action.setProductIconTheme", Ge.TITLE = { value: g(
  "workbench.extensions.action.setProductIconTheme",
  "Set Product Icon Theme"
), original: "Set Product Icon Theme" }, Ge.EnabledClass = `${ne.LABEL_ACTION_CLASS} theme`, Ge.DisabledClass = `${Ge.EnabledClass} disabled`, Ge);
Qs = X([
  D(0, mt),
  D(1, sn),
  D(2, qe),
  D(3, gi)
], Qs);
var ze;
ze = class extends ne {
  constructor(e) {
    super(ze.ID, ze.TITLE.value, ze.DisabledClass, !1), this.extensionsWorkbenchService = e, this.update();
  }
  update() {
    this.enabled = !1, this.class = ze.DisabledClass, this.extension && this.extensionsWorkbenchService.canSetLanguage(this.extension) && (this.extension.gallery && Yn === qr(this.extension.gallery) || (this.enabled = !0, this.class = ze.EnabledClass));
  }
  async run() {
    return this.extension && this.extensionsWorkbenchService.setLanguage(this.extension);
  }
}, ze.ID = "workbench.extensions.action.setDisplayLanguage", ze.TITLE = { value: g("workbench.extensions.action.setDisplayLanguage", "Set Display Language"), original: "Set Display Language" }, ze.EnabledClass = `${ne.LABEL_ACTION_CLASS} language`, ze.DisabledClass = `${ze.EnabledClass} disabled`;
var Ke;
Ke = class extends ne {
  constructor(e, t) {
    super(Ke.ID, Ke.TITLE.value, Ke.DisabledClass, !1), this.extensionsWorkbenchService = e, this.localeService = t, this.update();
  }
  update() {
    this.enabled = !1, this.class = Ke.DisabledClass, this.extension && this.extensionsWorkbenchService.canSetLanguage(this.extension) && (this.extension.gallery && Yn !== qr(this.extension.gallery) || (this.enabled = !0, this.class = Ke.EnabledClass));
  }
  async run() {
    return this.extension && this.localeService.clearLocalePreference();
  }
}, Ke.ID = "workbench.extensions.action.clearLanguage", Ke.TITLE = { value: g("workbench.extensions.action.clearLanguage", "Clear Display Language"), original: "Clear Display Language" }, Ke.EnabledClass = `${ne.LABEL_ACTION_CLASS} language`, Ke.DisabledClass = `${Ke.EnabledClass} disabled`;
var Kt;
Kt = class extends ve {
  constructor(e, t, i) {
    super(Kt.ID, Kt.LABEL, void 0, !1), this.paneCompositeService = t, this.extensionWorkbenchService = i, this.extensionId = e;
  }
  async run() {
    const e = await this.paneCompositeService.openPaneComposite(rn, 0, !0), t = e == null ? void 0 : e.getViewPaneContainer();
    t.search(`@id:${this.extensionId}`), t.focus();
    const [i] = await this.extensionWorkbenchService.getExtensions([{ id: this.extensionId }], { source: "install-recommendation" }, Hi.None);
    return i ? this.extensionWorkbenchService.open(i) : null;
  }
}, Kt.ID = "workbench.extensions.action.showRecommendedExtension", Kt.LABEL = g("showRecommendedExtension", "Show Recommended Extension");
var qt;
let Js = (qt = class extends ve {
  constructor(e, t, i, s) {
    super(qt.ID, qt.LABEL, void 0, !1), this.paneCompositeService = t, this.instantiationService = i, this.extensionWorkbenchService = s, this.extensionId = e;
  }
  async run() {
    const e = await this.paneCompositeService.openPaneComposite(rn, 0, !0), t = e == null ? void 0 : e.getViewPaneContainer();
    t.search(`@id:${this.extensionId}`), t.focus();
    const [i] = await this.extensionWorkbenchService.getExtensions([{ id: this.extensionId }], { source: "install-recommendation" }, Hi.None);
    if (i) {
      await this.extensionWorkbenchService.open(i);
      try {
        await this.extensionWorkbenchService.install(i);
      } catch (s) {
        this.instantiationService.createInstance(Ti, i, i.latestVersion, 2, s).run();
      }
    }
  }
}, qt.ID = "workbench.extensions.action.installRecommendedExtension", qt.LABEL = g("installRecommendedExtension", "Install Recommended Extension"), qt);
Js = X([
  D(1, Qn),
  D(2, le),
  D(3, ut)
], Js);
var jt;
jt = class extends ve {
  constructor(e, t) {
    super(jt.ID, "Ignore Recommendation"), this.extension = e, this.extensionRecommendationsManagementService = t, this.class = jt.Class, this.tooltip = g("ignoreExtensionRecommendation", "Do not recommend this extension again"), this.enabled = !0;
  }
  run() {
    return this.extensionRecommendationsManagementService.toggleGlobalIgnoredRecommendation(this.extension.identifier.id, !0), Promise.resolve();
  }
}, jt.ID = "extensions.ignore", jt.Class = `${ne.LABEL_ACTION_CLASS} ignore`;
var Xt;
Xt = class extends ve {
  constructor(e, t) {
    super(Xt.ID, "Undo"), this.extension = e, this.extensionRecommendationsManagementService = t, this.class = Xt.Class, this.tooltip = g("undo", "Undo"), this.enabled = !0;
  }
  run() {
    return this.extensionRecommendationsManagementService.toggleGlobalIgnoredRecommendation(this.extension.identifier.id, !1), Promise.resolve();
  }
}, Xt.ID = "extensions.ignore", Xt.Class = `${ne.LABEL_ACTION_CLASS} undo-ignore`;
let Bn = class extends ve {
  constructor(e, t) {
    super("extensions.searchExtensions", g("search recommendations", "Search Extensions"), void 0, !0), this.searchValue = e, this.paneCompositeService = t;
  }
  async run() {
    var t;
    const e = (t = await this.paneCompositeService.openPaneComposite(rn, 0, !0)) == null ? void 0 : t.getViewPaneContainer();
    e.search(this.searchValue), e.focus();
  }
};
Bn = X([
  D(1, Qn)
], Bn);
let On = class extends ve {
  constructor(e, t, i, s, c, l, n, r) {
    super(e, t), this.contextService = i, this.fileService = s, this.textFileService = c, this.editorService = l, this.jsonEditingService = n, this.textModelResolverService = r;
  }
  openExtensionsFile(e) {
    return this.getOrCreateExtensionsFile(e).then(({ created: t, content: i }) => this.getSelectionPosition(i, e, ["recommendations"]).then((s) => this.editorService.openEditor({
      resource: e,
      options: {
        pinned: t,
        selection: s
      }
    })), (t) => Promise.reject(new Error(g(
      "OpenExtensionsFile.failed",
      "Unable to create 'extensions.json' file inside the '.vscode' folder ({0}).",
      t
    ))));
  }
  openWorkspaceConfigurationFile(e) {
    return this.getOrUpdateWorkspaceConfigurationFile(e).then((t) => this.getSelectionPosition(t.value.toString(), t.resource, ["extensions", "recommendations"])).then((t) => this.editorService.openEditor({
      resource: e,
      options: {
        selection: t,
        forceReload: !0
      }
    }));
  }
  getOrUpdateWorkspaceConfigurationFile(e) {
    return Promise.resolve(this.fileService.readFile(e)).then((t) => {
      const i = Ec(t.value.toString()).extensions;
      return !i || !i.recommendations ? this.jsonEditingService.write(e, [{ path: ["extensions"], value: { recommendations: [] } }], !0).then(() => this.fileService.readFile(e)) : t;
    });
  }
  getSelectionPosition(e, t, i) {
    const s = Ac(e), c = Lc(s, i);
    if (c && c.parent && c.parent.children) {
      const l = c.parent.children[1], n = l.children && l.children.length ? l.children[l.children.length - 1] : null, r = n ? n.offset + n.length : l.offset + 1;
      return Promise.resolve(this.textModelResolverService.createModelReference(t)).then((a) => {
        const f = a.object.textEditorModel.getPositionAt(r);
        return a.dispose(), {
          startLineNumber: f.lineNumber,
          startColumn: f.column,
          endLineNumber: f.lineNumber,
          endColumn: f.column
        };
      });
    }
    return Promise.resolve(void 0);
  }
  getOrCreateExtensionsFile(e) {
    return Promise.resolve(this.fileService.readFile(e)).then((t) => ({ created: !1, extensionsFileResource: e, content: t.value.toString() }), (t) => this.textFileService.write(e, po).then(() => ({ created: !0, extensionsFileResource: e, content: po })));
  }
};
On = X([
  D(2, tt),
  D(3, Oi),
  D(4, _c),
  D(5, Bi),
  D(6, gc),
  D(7, qo)
], On);
var Li;
Li = class extends On {
  constructor(e, t, i, s, c, l, n, r) {
    super(e, t, c, i, s, l, n, r), this._register(this.contextService.onDidChangeWorkbenchState(() => this.update(), this)), this.update();
  }
  update() {
    this.enabled = this.contextService.getWorkbenchState() !== 1;
  }
  run() {
    switch (this.contextService.getWorkbenchState()) {
      case 2:
        return this.openExtensionsFile(this.contextService.getWorkspace().folders[0].toResource(Ba));
      case 3:
        return this.openWorkspaceConfigurationFile(this.contextService.getWorkspace().configuration);
    }
    return Promise.resolve();
  }
}, Li.ID = "workbench.extensions.action.configureWorkspaceRecommendedExtensions", Li.LABEL = g(
  "configureWorkspaceRecommendedExtensions",
  "Configure Recommended Extensions (Workspace)"
);
var Pi;
Pi = class extends On {
  constructor(e, t, i, s, c, l, n, r, a) {
    super(e, t, c, i, s, l, n, r), this.commandService = a;
  }
  run() {
    const t = this.contextService.getWorkspace().folders.length === 1 ? Promise.resolve(this.contextService.getWorkspace().folders[0]) : this.commandService.executeCommand(zr);
    return Promise.resolve(t).then((i) => i ? this.openExtensionsFile(i.toResource(Ba)) : null);
  }
}, Pi.ID = "workbench.extensions.action.configureWorkspaceFolderRecommendedExtensions", Pi.LABEL = g(
  "configureWorkspaceFolderRecommendedExtensions",
  "Configure Recommended Extensions (Workspace Folder)"
);
var St;
St = class extends ve {
  get extension() {
    return this._extension;
  }
  set extension(e) {
    this._extension && e && ht(this._extension.identifier, e.identifier) || (this.initialStatus = null, this.status = null, this.enablementState = null), this._extension = e, this.update();
  }
  constructor(e, t, i) {
    super("extensions.action.statusLabel", "", St.DISABLED_CLASS, !1), this.extensionService = e, this.extensionManagementServerService = t, this.extensionEnablementService = i, this.initialStatus = null, this.status = null, this.version = null, this.enablementState = null, this._extension = null;
  }
  update() {
    const e = this.computeLabel();
    this.label = e || "", this.class = e ? St.ENABLED_CLASS : St.DISABLED_CLASS;
  }
  computeLabel() {
    if (!this.extension)
      return null;
    const e = this.status, t = this.version, i = this.enablementState;
    this.status = this.extension.state, this.version = this.extension.version, this.initialStatus === null && (this.initialStatus = this.status), this.enablementState = this.extension.enablementState;
    const s = () => {
      const l = this.extensionService.extensions.filter((n) => ht({ id: n.identifier.value, uuid: n.uuid }, this.extension.identifier))[0];
      return this.extension.local ? l && this.extension.version === l.version ? !0 : this.extensionService.canAddExtension(yn(this.extension.local)) : !1;
    }, c = () => this.extension.local ? this.extensionService.extensions.every((l) => !(ht({ id: l.identifier.value, uuid: l.uuid }, this.extension.identifier) && this.extension.server === this.extensionManagementServerService.getExtensionManagementServer(jo(l)))) ? !0 : this.extensionService.canRemoveExtension(yn(this.extension.local)) : !1;
    if (e !== null) {
      if (e === 0 && this.status === 1)
        return s() ? this.initialStatus === 1 && this.version !== t ? g("updated", "Updated") : g("installed", "Installed") : null;
      if (e === 2 && this.status === 3)
        return this.initialStatus = this.status, c() ? g("uninstalled", "Uninstalled") : null;
    }
    if (i !== null) {
      const l = this.extensionEnablementService.isEnabledEnablementState(i), n = this.extensionEnablementService.isEnabledEnablementState(this.enablementState);
      if (!l && n)
        return s() ? g("enabled", "Enabled") : null;
      if (l && !n)
        return c() ? g("disabled", "Disabled") : null;
    }
    return null;
  }
  run() {
    return Promise.resolve();
  }
}, St.ENABLED_CLASS = `${ne.TEXT_ACTION_CLASS} extension-status-label`, St.DISABLED_CLASS = `${St.ENABLED_CLASS} hide`;
var bt;
bt = class extends Mn {
  constructor(e, t, i, s) {
    super("extensions.sync", "", bt.SYNC_CLASS, !1, s), this.configurationService = e, this.extensionsWorkbenchService = t, this.userDataSyncEnablementService = i, this._register(be.filter(this.configurationService.onDidChangeConfiguration, (c) => c.affectsConfiguration("settingsSync.ignoredExtensions"))(() => this.update())), this._register(i.onDidChangeEnablement(() => this.update())), this.update();
  }
  update() {
    if (this.enabled = !!this.extension && this.userDataSyncEnablementService.isEnabled() && this.extension.state === 1, this.extension) {
      const e = this.extensionsWorkbenchService.isExtensionIgnoredToSync(this.extension);
      this.class = e ? bt.IGNORED_SYNC_CLASS : bt.SYNC_CLASS, this.tooltip = e ? g("ignored", "This extension is ignored during sync") : g("synced", "This extension is synced");
    }
  }
  async run() {
    return super.run({
      actionGroups: [
        [
          new ve(
            "extensions.syncignore",
            this.extensionsWorkbenchService.isExtensionIgnoredToSync(this.extension) ? g("sync", "Sync this extension") : g("do not sync", "Do not sync this extension"),
            void 0,
            !0,
            () => this.extensionsWorkbenchService.toggleExtensionIgnoredToSync(this.extension)
          )
        ]
      ],
      disposeActionsOnHide: !0
    });
  }
}, bt.IGNORED_SYNC_CLASS = `${ne.ICON_ACTION_CLASS} extension-sync ${re.asClassName(Uh)}`, bt.SYNC_CLASS = `${bt.ICON_ACTION_CLASS} extension-sync ${re.asClassName(Gh)}`;
var lt;
lt = class extends ne {
  get status() {
    return this._status;
  }
  constructor(e, t, i, s, c, l, n, r, a, f, m) {
    super("extensions.status", "", `${lt.CLASS} hide`, !1), this.extensionManagementServerService = e, this.labelService = t, this.commandService = i, this.workspaceTrustEnablementService = s, this.workspaceTrustService = c, this.extensionsWorkbenchService = l, this.extensionService = n, this.extensionManifestPropertiesService = r, this.contextService = a, this.productService = f, this.workbenchExtensionEnablementService = m, this.updateWhenCounterExtensionChanges = !0, this._onDidChangeStatus = this._register(new V()), this.onDidChangeStatus = this._onDidChangeStatus.event, this.updateThrottler = new Kr(), this._register(this.labelService.onDidChangeFormatters(() => this.update(), this)), this._register(this.extensionService.onDidChangeExtensions(() => this.update())), this.update();
  }
  update() {
    this.updateThrottler.queue(() => this.computeAndUpdateStatus());
  }
  async computeAndUpdateStatus() {
    var i, s, c, l;
    if (this.updateStatus(void 0, !0), this.enabled = !1, !this.extension)
      return;
    if (this.extension.isMalicious) {
      this.updateStatus({ icon: Ne, message: new de(
        g("malicious tooltip", "This extension was reported to be problematic.")
      ) }, !0);
      return;
    }
    if (this.extension.deprecationInfo) {
      if (this.extension.deprecationInfo.extension) {
        const n = `[${this.extension.deprecationInfo.extension.displayName}](${oe.parse(
          `command:extension.open?${encodeURIComponent(JSON.stringify([this.extension.deprecationInfo.extension.id]))}`
        )})`;
        this.updateStatus({ icon: Ne, message: new de(g(
          "deprecated with alternate extension tooltip",
          "This extension is deprecated. Use the {0} extension instead.",
          n
        )) }, !0);
      } else if (this.extension.deprecationInfo.settings) {
        const n = `[${g("settings", "settings")}](${oe.parse(
          `command:workbench.action.openSettings?${encodeURIComponent(JSON.stringify([this.extension.deprecationInfo.settings.map((r) => `@id:${r}`).join(" ")]))}`
        )})`;
        this.updateStatus({ icon: Ne, message: new de(g(
          "deprecated with alternate settings tooltip",
          "This extension is deprecated as this functionality is now built-in to VS Code. Configure these {0} to use this functionality.",
          n
        )) }, !0);
      } else {
        const n = new de(g(
          "deprecated tooltip",
          "This extension is deprecated as it is no longer being maintained."
        ));
        this.extension.deprecationInfo.additionalInfo && n.appendMarkdown(` ${this.extension.deprecationInfo.additionalInfo}`), this.updateStatus({ icon: Ne, message: n }, !0);
      }
      return;
    }
    if (this.extensionsWorkbenchService.canSetLanguage(this.extension))
      return;
    if (this.extension.gallery && this.extension.state === 3 && !await this.extensionsWorkbenchService.canInstall(this.extension)) {
      if (this.extensionManagementServerService.localExtensionManagementServer || this.extensionManagementServerService.remoteExtensionManagementServer) {
        const n = await (this.extensionManagementServerService.localExtensionManagementServer ? this.extensionManagementServerService.localExtensionManagementServer.extensionManagementService.getTargetPlatform() : this.extensionManagementServerService.remoteExtensionManagementServer.extensionManagementService.getTargetPlatform()), r = new de(`${g(
          "incompatible platform",
          "The '{0}' extension is not available in {1} for {2}.",
          this.extension.displayName || this.extension.identifier.id,
          this.productService.nameLong,
          pc(n)
        )} [${g("learn more", "Learn More")}](https://aka.ms/vscode-platform-specific-extensions)`);
        this.updateStatus({ icon: Ne, message: r }, !0);
        return;
      }
      if (this.extensionManagementServerService.webExtensionManagementServer) {
        const n = g("VS Code for Web", "{0} for the Web", this.productService.nameLong), r = new de(`${g(
          "not web tooltip",
          "The '{0}' extension is not available in {1}.",
          this.extension.displayName || this.extension.identifier.id,
          n
        )} [${g("learn why", "Learn Why")}](https://aka.ms/vscode-web-extensions-guide)`);
        this.updateStatus({ icon: Ne, message: r }, !0);
        return;
      }
    }
    if (!this.extension.local || !this.extension.server || this.extension.state !== 1)
      return;
    if (this.extension.enablementState === 2) {
      this.updateStatus({ message: new de(g(
        "disabled by environment",
        "This extension is disabled by the environment."
      )) }, !0);
      return;
    }
    if (this.extension.enablementState === 3) {
      this.updateStatus({ message: new de(g(
        "enabled by environment",
        "This extension is enabled because it is required in the current environment."
      )) }, !0);
      return;
    }
    if (this.extension.enablementState === 4) {
      const n = cn((i = this.extension.local.manifest.capabilities) == null ? void 0 : i.virtualWorkspaces);
      this.updateStatus({ icon: gt, message: new de(n ? ln(n) : g(
        "disabled because of virtual workspace",
        "This extension has been disabled because it does not support virtual workspaces."
      )) }, !0);
      return;
    }
    if (vc(this.contextService.getWorkspace())) {
      const n = this.extensionManifestPropertiesService.getExtensionVirtualWorkspaceSupportType(this.extension.local.manifest), r = cn((s = this.extension.local.manifest.capabilities) == null ? void 0 : s.virtualWorkspaces);
      if (n === "limited" || r) {
        this.updateStatus({ icon: Ne, message: new de(r ? ln(r) : g(
          "extension limited because of virtual workspace",
          "This extension has limited features because the current workspace is virtual."
        )) }, !0);
        return;
      }
    }
    if (this.extension.enablementState === 0 || this.extension.enablementState === 5 && this.workbenchExtensionEnablementService.getDependenciesEnablementStates(this.extension.local).every(([, n]) => this.workbenchExtensionEnablementService.isEnabledEnablementState(n) || n === 0)) {
      this.enabled = !0;
      const n = cn((c = this.extension.local.manifest.capabilities) == null ? void 0 : c.untrustedWorkspaces);
      this.updateStatus({ icon: Vi, message: new de(
        n ? ln(n) : g(
          "extension disabled because of trust requirement",
          "This extension has been disabled because the current workspace is not trusted."
        )
      ) }, !0);
      return;
    }
    if (this.workspaceTrustEnablementService.isWorkspaceTrustEnabled() && !this.workspaceTrustService.isWorkspaceTrusted()) {
      const n = this.extensionManifestPropertiesService.getExtensionUntrustedWorkspaceSupportType(this.extension.local.manifest), r = cn((l = this.extension.local.manifest.capabilities) == null ? void 0 : l.untrustedWorkspaces);
      if (n === "limited" || r) {
        this.enabled = !0, this.updateStatus({ icon: Vi, message: new de(
          r ? ln(r) : g(
            "extension limited because of trust requirement",
            "This extension has limited features because the current workspace is not trusted."
          )
        ) }, !0);
        return;
      }
    }
    if (this.extension.enablementState === 1 && !this.extensionsWorkbenchService.installed.some(
      (n) => ht(n.identifier, this.extension.identifier) && n.server !== this.extension.server
    )) {
      let n;
      this.extensionManagementServerService.localExtensionManagementServer === this.extension.server ? this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(this.extension.local.manifest) && this.extensionManagementServerService.remoteExtensionManagementServer && (n = new de(`${g(
        "Install in remote server to enable",
        "This extension is disabled in this workspace because it is defined to run in the Remote Extension Host. Please install the extension in '{0}' to enable.",
        this.extensionManagementServerService.remoteExtensionManagementServer.label
      )} [${g("learn more", "Learn More")}](https://aka.ms/vscode-remote/developing-extensions/architecture)`)) : this.extensionManagementServerService.remoteExtensionManagementServer === this.extension.server ? this.extensionManifestPropertiesService.prefersExecuteOnUI(this.extension.local.manifest) && (this.extensionManagementServerService.localExtensionManagementServer ? n = new de(`${g(
        "Install in local server to enable",
        "This extension is disabled in this workspace because it is defined to run in the Local Extension Host. Please install the extension locally to enable.",
        this.extensionManagementServerService.remoteExtensionManagementServer.label
      )} [${g("learn more", "Learn More")}](https://aka.ms/vscode-remote/developing-extensions/architecture)`) : ki && (n = new de(`${g(
        "Defined to run in desktop",
        "This extension is disabled because it is defined to run only in {0} for the Desktop.",
        this.productService.nameLong
      )} [${g("learn more", "Learn More")}](https://aka.ms/vscode-remote/developing-extensions/architecture)`))) : this.extensionManagementServerService.webExtensionManagementServer === this.extension.server && (n = new de(`${g(
        "Cannot be enabled",
        "This extension is disabled because it is not supported in {0} for the Web.",
        this.productService.nameLong
      )} [${g("learn more", "Learn More")}](https://aka.ms/vscode-remote/developing-extensions/architecture)`)), n && this.updateStatus({ icon: Ne, message: n }, !0);
      return;
    }
    if (this.extensionManagementServerService.remoteExtensionManagementServer) {
      if (Ko(this.extension.local.manifest)) {
        if (!this.extensionsWorkbenchService.installed.some(
          (a) => ht(a.identifier, this.extension.identifier) && a.server !== this.extension.server
        )) {
          const a = this.extension.server === this.extensionManagementServerService.localExtensionManagementServer ? new de(g(
            "Install language pack also in remote server",
            "Install the language pack extension on '{0}' to enable it there also.",
            this.extensionManagementServerService.remoteExtensionManagementServer.label
          )) : new de(g(
            "Install language pack also locally",
            "Install the language pack extension locally to enable it there also."
          ));
          this.updateStatus({ icon: gt, message: a }, !0);
        }
        return;
      }
      const n = this.extensionService.extensions.filter((a) => ht({ id: a.identifier.value, uuid: a.uuid }, this.extension.identifier))[0], r = n ? this.extensionManagementServerService.getExtensionManagementServer(jo(n)) : null;
      if (this.extension.server === this.extensionManagementServerService.localExtensionManagementServer && r === this.extensionManagementServerService.remoteExtensionManagementServer) {
        this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(this.extension.local.manifest) && this.updateStatus({ icon: gt, message: new de(`${g(
          "enabled remotely",
          "This extension is enabled in the Remote Extension Host because it prefers to run there."
        )} [${g("learn more", "Learn More")}](https://aka.ms/vscode-remote/developing-extensions/architecture)`) }, !0);
        return;
      }
      if (this.extension.server === this.extensionManagementServerService.remoteExtensionManagementServer && r === this.extensionManagementServerService.localExtensionManagementServer) {
        this.extensionManifestPropertiesService.prefersExecuteOnUI(this.extension.local.manifest) && this.updateStatus({ icon: gt, message: new de(`${g(
          "enabled locally",
          "This extension is enabled in the Local Extension Host because it prefers to run there."
        )} [${g("learn more", "Learn More")}](https://aka.ms/vscode-remote/developing-extensions/architecture)`) }, !0);
        return;
      }
      if (this.extension.server === this.extensionManagementServerService.remoteExtensionManagementServer && r === this.extensionManagementServerService.webExtensionManagementServer) {
        this.extensionManifestPropertiesService.canExecuteOnWeb(this.extension.local.manifest) && this.updateStatus({ icon: gt, message: new de(`${g(
          "enabled in web worker",
          "This extension is enabled in the Web Worker Extension Host because it prefers to run there."
        )} [${g("learn more", "Learn More")}](https://aka.ms/vscode-remote/developing-extensions/architecture)`) }, !0);
        return;
      }
    }
    if (this.extension.enablementState === 5) {
      this.updateStatus({ icon: Ne, message: new de(g(
        "extension disabled because of dependency",
        "This extension has been disabled because it depends on an extension that is disabled."
      )) }, !0);
      return;
    }
    const e = this.workbenchExtensionEnablementService.isEnabled(this.extension.local), t = this.extensionService.extensions.some(
      (n) => ht({ id: n.identifier.value, uuid: n.uuid }, this.extension.identifier)
    );
    if (e && t) {
      if (this.extensionManagementServerService.localExtensionManagementServer && this.extensionManagementServerService.remoteExtensionManagementServer && this.extension.server === this.extensionManagementServerService.remoteExtensionManagementServer) {
        this.updateStatus({ message: new de(g(
          "extension enabled on remote",
          "Extension is enabled on '{0}'",
          this.extension.server.label
        )) }, !0);
        return;
      }
      if (this.extension.enablementState === 8) {
        this.updateStatus({ message: new de(
          g("globally enabled", "This extension is enabled globally.")
        ) }, !0);
        return;
      }
      if (this.extension.enablementState === 9) {
        this.updateStatus({ message: new de(g(
          "workspace enabled",
          "This extension is enabled for this workspace by the user."
        )) }, !0);
        return;
      }
    }
    if (!e && !t) {
      if (this.extension.enablementState === 6) {
        this.updateStatus({ message: new de(
          g("globally disabled", "This extension is disabled globally by the user.")
        ) }, !0);
        return;
      }
      if (this.extension.enablementState === 7) {
        this.updateStatus({ message: new de(g(
          "workspace disabled",
          "This extension is disabled for this workspace by the user."
        )) }, !0);
        return;
      }
    }
    if (e && !t && !this.extension.local.isValid) {
      const n = this.extension.local.validations.filter(([r]) => r === Te.Error).map(([, r]) => r);
      this.updateStatus({ icon: Ci, message: new de(n.join(" ").trim()) }, !0);
    }
  }
  updateStatus(e, t) {
    var i, s, c, l, n, r;
    this._status !== e && (this._status && e && this._status.message === e.message && ((i = this._status.icon) == null ? void 0 : i.id) === ((s = e.icon) == null ? void 0 : s.id) || (this._status = e, t && (((c = this._status) == null ? void 0 : c.icon) === Ci ? this.class = `${lt.CLASS} extension-status-error ${re.asClassName(Ci)}` : ((l = this._status) == null ? void 0 : l.icon) === Ne ? this.class = `${lt.CLASS} extension-status-warning ${re.asClassName(Ne)}` : ((n = this._status) == null ? void 0 : n.icon) === gt ? this.class = `${lt.CLASS} extension-status-info ${re.asClassName(gt)}` : ((r = this._status) == null ? void 0 : r.icon) === Vi ? this.class = `${lt.CLASS} ${re.asClassName(Vi)}` : this.class = `${lt.CLASS} hide`), this._onDidChangeStatus.fire()));
  }
  async run() {
    var e;
    if (((e = this._status) == null ? void 0 : e.icon) === Vi)
      return this.commandService.executeCommand("workbench.trust.manage");
  }
}, lt.CLASS = `${ne.ICON_ACTION_CLASS} extension-status`;
var Yt;
Yt = class extends ve {
  constructor(e = Yt.ID, t = Yt.LABEL, i, s, c, l, n, r, a) {
    super(e, t), this.extensionsWorkbenchService = i, this.extensionManagementServerService = s, this.quickInputService = c, this.notificationService = l, this.hostService = n, this.instantiationService = r, this.extensionService = a;
  }
  get enabled() {
    return this.extensionsWorkbenchService.local.filter((e) => !e.isBuiltin && e.local).length > 0;
  }
  run() {
    return this.quickInputService.pick(this.getEntries(), { placeHolder: g("selectExtensionToReinstall", "Select Extension to Reinstall") }).then((e) => e && this.reinstallExtension(e.extension));
  }
  getEntries() {
    return this.extensionsWorkbenchService.queryLocal().then((e) => e.filter((i) => !i.isBuiltin && i.server !== this.extensionManagementServerService.webExtensionManagementServer).map((i) => ({
      id: i.identifier.id,
      label: i.displayName,
      description: i.identifier.id,
      extension: i
    })));
  }
  reinstallExtension(e) {
    return this.instantiationService.createInstance(Bn, "@installed ").run().then(() => this.extensionsWorkbenchService.reinstall(e).then((t) => {
      const i = !(t.local && this.extensionService.canAddExtension(yn(t.local))), s = i ? g(
        "ReinstallAction.successReload",
        "Please reload Visual Studio Code to complete reinstalling the extension {0}.",
        t.identifier.id
      ) : g(
        "ReinstallAction.success",
        "Reinstalling the extension {0} is completed.",
        t.identifier.id
      ), c = i ? [{
        label: g("InstallVSIXAction.reloadNow", "Reload Now"),
        run: () => this.hostService.reload()
      }] : [];
      this.notificationService.prompt(Te.Info, s, c, { sticky: !0 });
    }, (t) => this.notificationService.error(t)));
  }
}, Yt.ID = "workbench.extensions.action.reinstall", Yt.LABEL = g("reinstall", "Reinstall Extension...");
var Qt;
Qt = class extends ve {
  constructor(e = Qt.ID, t = Qt.LABEL, i, s, c, l) {
    super(e, t), this.extensionsWorkbenchService = i, this.quickInputService = s, this.instantiationService = c, this.extensionEnablementService = l;
  }
  get enabled() {
    return this.extensionsWorkbenchService.local.some((e) => this.isEnabled(e));
  }
  async run() {
    const e = await this.quickInputService.pick(this.getExtensionEntries(), { placeHolder: g("selectExtension", "Select Extension"), matchOnDetail: !0 });
    if (e && e.extension) {
      const t = this.instantiationService.createInstance(Ji);
      t.extension = e.extension, await t.run(), await this.instantiationService.createInstance(Bn, e.extension.identifier.id).run();
    }
  }
  isEnabled(e) {
    const t = this.instantiationService.createInstance(Ji);
    return t.extension = e, t.enabled && !!e.local && this.extensionEnablementService.isEnabled(e.local);
  }
  async getExtensionEntries() {
    const e = await this.extensionsWorkbenchService.queryLocal(), t = [];
    for (const i of e)
      this.isEnabled(i) && t.push({
        id: i.identifier.id,
        label: i.displayName || i.identifier.id,
        description: i.identifier.id,
        extension: i
      });
    return t.sort((i, s) => i.extension.displayName.localeCompare(s.extension.displayName));
  }
}, Qt.ID = "workbench.extensions.action.install.specificVersion", Qt.LABEL = g("install previous version", "Install Specific Version of Extension...");
Jn.registerCommand("workbench.extensions.action.showExtensionsForLanguage", function(h, e) {
  return h.get(Qn).openPaneComposite(rn, 0, !0).then((i) => i == null ? void 0 : i.getViewPaneContainer()).then((i) => {
    i.search(`ext:${e.replace(/^\./, "")}`), i.focus();
  });
});
Jn.registerCommand("workbench.extensions.action.showExtensionsWithIds", function(h, e) {
  return h.get(Qn).openPaneComposite(rn, 0, !0).then((i) => i == null ? void 0 : i.getViewPaneContainer()).then((i) => {
    const s = e.map((c) => `@id:${c}`).join(" ");
    i.search(s), i.focus();
  });
});
pi("extensionButton.background", {
  dark: xn,
  light: xn,
  hcDark: null,
  hcLight: null
}, g(
  "extensionButtonBackground",
  "Button background color for extension actions."
));
pi("extensionButton.foreground", {
  dark: kn,
  light: kn,
  hcDark: null,
  hcLight: null
}, g(
  "extensionButtonForeground",
  "Button foreground color for extension actions."
));
pi("extensionButton.hoverBackground", {
  dark: In,
  light: In,
  hcDark: null,
  hcLight: null
}, g(
  "extensionButtonHoverBackground",
  "Button background hover color for extension actions."
));
pi("extensionButton.separator", {
  dark: hn,
  light: hn,
  hcDark: hn,
  hcLight: hn
}, g("extensionButtonSeparator", "Button separator color for extension actions"));
pi("extensionButton.prominentBackground", {
  dark: xn,
  light: xn,
  hcDark: null,
  hcLight: null
}, g(
  "extensionButtonProminentBackground",
  "Button background color for extension actions that stand out (e.g. install button)."
));
pi("extensionButton.prominentForeground", {
  dark: kn,
  light: kn,
  hcDark: null,
  hcLight: null
}, g(
  "extensionButtonProminentForeground",
  "Button foreground color for extension actions that stand out (e.g. install button)."
));
pi("extensionButton.prominentHoverBackground", {
  dark: In,
  light: In,
  hcDark: null,
  hcLight: null
}, g(
  "extensionButtonProminentHoverBackground",
  "Button background hover color for extension actions that stand out (e.g. install button)."
));
Sc((h, e) => {
  const t = h.getColor(bc);
  t && (e.addRule(`.extension-editor .header .actions-status-container > .status ${re.asCSSSelector(Ci)} { color: ${t}; }`), e.addRule(`.extension-editor .body .subcontent .runtime-status ${re.asCSSSelector(Ci)} { color: ${t}; }`), e.addRule(`.monaco-hover.extension-hover .markdown-hover .hover-contents ${re.asCSSSelector(Ci)} { color: ${t}; }`));
  const i = h.getColor(wc);
  i && (e.addRule(`.extension-editor .header .actions-status-container > .status ${re.asCSSSelector(Ne)} { color: ${i}; }`), e.addRule(`.extension-editor .body .subcontent .runtime-status ${re.asCSSSelector(Ne)} { color: ${i}; }`), e.addRule(`.monaco-hover.extension-hover .markdown-hover .hover-contents ${re.asCSSSelector(Ne)} { color: ${i}; }`));
  const s = h.getColor(Cc);
  s && (e.addRule(`.extension-editor .header .actions-status-container > .status ${re.asCSSSelector(gt)} { color: ${s}; }`), e.addRule(`.extension-editor .body .subcontent .runtime-status ${re.asCSSSelector(gt)} { color: ${s}; }`), e.addRule(`.monaco-hover.extension-hover .markdown-hover .hover-contents ${re.asCSSSelector(gt)} { color: ${s}; }`));
});
let Fn = class {
  get onConfigChanged() {
    return this._onConfigChanged.event;
  }
  constructor(e, t, i, s, c) {
    this._configurationService = e, this._extensionManagementService = t, this._notificationService = i, this._instantiationService = s, this._productService = c, this._linuxDistro = 1, this._onConfigChanged = new V(), this._recommendationsShown = !1, this._updateConfig(), this._configurationService.onDidChangeConfiguration((l) => {
      l.affectsConfiguration(ro) && this._updateConfig();
    }), zn && (navigator.userAgent.includes("Ubuntu") ? this._linuxDistro = 3 : navigator.userAgent.includes("Fedora") && (this._linuxDistro = 2));
  }
  _updateConfig() {
    const e = this._configurationService.getValue(ro);
    e.fontWeight = this._normalizeFontWeight(e.fontWeight, Rc), e.fontWeightBold = this._normalizeFontWeight(e.fontWeightBold, Mc), this.config = e, this._onConfigChanged.fire();
  }
  configFontIsMonospace() {
    const t = this.config.fontFamily || this._configurationService.getValue("editor").fontFamily || dn.fontFamily, i = this._getBoundingRectFor("i", t, 15), s = this._getBoundingRectFor("w", t, 15);
    return !i || !s || !i.width || !s.width ? !0 : i.width === s.width;
  }
  _createCharMeasureElementIfNecessary() {
    if (!this.panelContainer)
      throw new Error("Cannot measure element when terminal is not attached");
    return (!this._charMeasureElement || !this._charMeasureElement.parentElement) && (this._charMeasureElement = document.createElement("div"), this.panelContainer.appendChild(this._charMeasureElement)), this._charMeasureElement;
  }
  _getBoundingRectFor(e, t, i) {
    let s;
    try {
      s = this._createCharMeasureElementIfNecessary();
    } catch {
      return;
    }
    const c = s.style;
    c.display = "inline-block", c.fontFamily = t, c.fontSize = i + "px", c.lineHeight = "normal", s.innerText = e;
    const l = s.getBoundingClientRect();
    return c.display = "none", l;
  }
  _measureFont(e, t, i, s) {
    const c = this._getBoundingRectFor("X", e, t);
    if (this._lastFontMeasurement && (!c || !c.width || !c.height))
      return this._lastFontMeasurement;
    if (this._lastFontMeasurement = {
      fontFamily: e,
      fontSize: t,
      letterSpacing: i,
      lineHeight: s,
      charWidth: 0,
      charHeight: 0
    }, c && c.width && c.height)
      if (this._lastFontMeasurement.charHeight = Math.ceil(c.height), this.config.gpuAcceleration === "off")
        this._lastFontMeasurement.charWidth = c.width;
      else {
        const r = (Math.floor(c.width * window.devicePixelRatio) + Math.round(i)) / window.devicePixelRatio;
        this._lastFontMeasurement.charWidth = r - Math.round(i) / window.devicePixelRatio;
      }
    return this._lastFontMeasurement;
  }
  getFont(e, t) {
    var r, a;
    const i = this._configurationService.getValue("editor");
    let s = this.config.fontFamily || i.fontFamily || dn.fontFamily, c = this._clampInt(this.config.fontSize, 6, 100, dn.fontSize);
    this.config.fontFamily || (this._linuxDistro === 2 && (s = "'DejaVu Sans Mono'"), this._linuxDistro === 3 && (s = "'Ubuntu Mono'", c = this._clampInt(c + 2, 6, 100, dn.fontSize))), s += ", monospace";
    const l = this.config.letterSpacing ? Math.max(Math.floor(this.config.letterSpacing), Bc) : Zo, n = this.config.lineHeight ? Math.max(this.config.lineHeight, 1) : ea;
    return t ? {
      fontFamily: s,
      fontSize: c,
      letterSpacing: l,
      lineHeight: n
    } : e && e._renderService && (r = e._renderService.dimensions) != null && r.css.cell.width && (a = e._renderService.dimensions) != null && a.css.cell.height ? {
      fontFamily: s,
      fontSize: c,
      letterSpacing: l,
      lineHeight: n,
      charHeight: e._renderService.dimensions.css.cell.height / n,
      charWidth: e._renderService.dimensions.css.cell.width - Math.round(l) / window.devicePixelRatio
    } : this._measureFont(s, c, l, n);
  }
  _clampInt(e, t, i, s) {
    let c = parseInt(e, 10);
    return isNaN(c) ? s : (typeof t == "number" && (c = Math.max(t, c)), typeof i == "number" && (c = Math.min(i, c)), c);
  }
  async showRecommendations(e) {
    if (!this._recommendationsShown && (this._recommendationsShown = !0, Le && e.executable && Ii(e.executable).toLowerCase() === "wsl.exe")) {
      const t = this._productService.exeBasedExtensionTips;
      if (!t || !t.wsl)
        return;
      const i = Object.keys(t.wsl.recommendations).find((s) => t.wsl.recommendations[s].important);
      i && !await this._isExtensionInstalled(i) && this._notificationService.prompt(wt.Info, g(
        "useWslExtension.title",
        "The '{0}' extension is recommended for opening a terminal in WSL.",
        t.wsl.friendlyName
      ), [
        {
          label: g("install", "Install"),
          run: () => {
            this._instantiationService.createInstance(Js, i).run();
          }
        }
      ], {
        sticky: !0,
        neverShowAgain: { id: "terminalConfigHelper/launchRecommendationsIgnore", scope: Oc.APPLICATION },
        onCancel: () => {
        }
      });
    }
  }
  async _isExtensionInstalled(e) {
    return (await this._extensionManagementService.getInstalled()).some((i) => i.identifier.id === e);
  }
  _normalizeFontWeight(e, t) {
    return e === "normal" || e === "bold" ? e : this._clampInt(e, Ds, Es, t);
  }
};
Fn = X([
  D(0, Se),
  D(1, Pc),
  D(2, Ee),
  D(3, le),
  D(4, Xn)
], Fn);
let Zs = class {
  constructor(e, t, i, s, c, l) {
    this._terminalProfileService = e, this._terminalProfileResolverService = t, this._configurationService = i, this._quickInputService = s, this._themeService = c, this._notificationService = l;
  }
  async showAndGetResult(e) {
    const t = await this._terminalProfileService.getPlatformKey(), i = "terminal.integrated.profiles." + t, s = await this._createAndShow(e), c = `terminal.integrated.defaultProfile.${t}`;
    if (s) {
      if (e === "setDefault") {
        if ("command" in s.profile)
          return;
        if ("id" in s.profile)
          return await this._configurationService.updateValue(c, s.profile.title, 2), {
            config: {
              extensionIdentifier: s.profile.extensionIdentifier,
              id: s.profile.id,
              title: s.profile.title,
              options: {
                color: s.profile.color,
                icon: s.profile.icon
              }
            },
            keyMods: s.keyMods
          };
        if ("isAutoDetected" in s.profile) {
          const l = await this._configurationService.getValue(i);
          if (typeof l == "object") {
            const n = {
              path: s.profile.path
            };
            s.profile.args && (n.args = s.profile.args), l[s.profile.profileName] = n;
          }
          await this._configurationService.updateValue(i, l, 2);
        }
        await this._configurationService.updateValue(c, s.profileName, 2);
      } else if (e === "createInstance")
        return "id" in s.profile ? {
          config: {
            extensionIdentifier: s.profile.extensionIdentifier,
            id: s.profile.id,
            title: s.profile.title,
            options: {
              icon: s.profile.icon,
              color: s.profile.color
            }
          },
          keyMods: s.keyMods
        } : { config: s.profile, keyMods: s.keyMods };
      return "profileName" in s.profile ? s.profile.profileName : s.profile.title;
    }
  }
  async _createAndShow(e) {
    const t = await this._terminalProfileService.getPlatformKey(), i = this._terminalProfileService.availableProfiles, s = "terminal.integrated.profiles." + t, c = this._terminalProfileService.getDefaultProfileName();
    let l;
    const n = {
      placeHolder: e === "createInstance" ? g(
        "terminal.integrated.selectProfileToCreate",
        "Select the terminal profile to create"
      ) : g(
        "terminal.integrated.chooseDefaultProfile",
        "Select your default terminal profile"
      ),
      onDidTriggerItemButton: async (p) => {
        if (!await this._isProfileSafe(p.item.profile) || "command" in p.item.profile || "id" in p.item.profile)
          return;
        const S = this._configurationService.getValue("terminal.integrated.profiles." + t), o = S ? Object.keys(S) : [], _ = await this._quickInputService.input({
          prompt: g("enterTerminalProfileName", "Enter terminal profile name"),
          value: p.item.profile.profileName,
          validateInput: async (d) => {
            if (o.includes(d))
              return g(
                "terminalProfileAlreadyExists",
                "A terminal profile already exists with that name"
              );
          }
        });
        if (!_)
          return;
        const u = { ...S };
        u[_] = {
          path: p.item.profile.path,
          args: p.item.profile.args
        }, await this._configurationService.updateValue(s, u, 2);
      },
      onKeyMods: (p) => l = p
    }, r = [], a = i.filter((p) => !p.isAutoDetected), f = i.filter((p) => p.isAutoDetected);
    a.length > 0 && (r.push({ type: "separator", label: g("terminalProfiles", "profiles") }), r.push(...this._sortProfileQuickPickItems(a.map((p) => this._createProfileQuickPickItem(p)), c))), r.push({ type: "separator", label: g("ICreateContributedTerminalProfileOptions", "contributed") });
    const m = [];
    for (const p of this._terminalProfileService.contributedProfiles) {
      let S;
      typeof p.icon == "string" && (p.icon.startsWith("$(") ? S = re.fromString(p.icon) : S = re.fromId(p.icon)), (!S || !ts().getIcon(S.id)) && (S = this._terminalProfileResolverService.getDefaultIcon());
      const o = fi(p, this._themeService.getColorTheme().type, !0), _ = Jt(p), u = [];
      o && u.push(...o), _ && u.push(_), m.push({
        label: `$(${S.id}) ${p.title}`,
        profile: {
          extensionIdentifier: p.extensionIdentifier,
          title: p.title,
          icon: p.icon,
          id: p.id,
          color: p.color
        },
        profileName: p.title,
        iconClasses: u
      });
    }
    m.length > 0 && r.push(...this._sortProfileQuickPickItems(m, c)), f.length > 0 && (r.push({ type: "separator", label: g("terminalProfiles.detected", "detected") }), r.push(...this._sortProfileQuickPickItems(f.map((p) => this._createProfileQuickPickItem(p)), c)));
    const C = ta(this._themeService.getColorTheme());
    document.body.appendChild(C);
    const b = await this._quickInputService.pick(r, n);
    if (document.body.removeChild(C), !!b && await this._isProfileSafe(b.profile))
      return l && (b.keyMods = l), b;
  }
  async _isProfileSafe(e) {
    const t = "isUnsafePath" in e && e.isUnsafePath, i = "requiresUnsafePath" in e && e.requiresUnsafePath;
    return !t && !i ? !0 : await new Promise((s) => {
      const c = [];
      t && c.push(e.path), i && c.push(i), this._notificationService.prompt(Te.Warning, g(
        "unsafePathWarning",
        "This terminal profile uses a potentially unsafe path that can be modified by another user: {0}. Are you sure you want to use it?",
        `"${c.join(",")}"`
      ), [{
        label: g("yes", "Yes"),
        run: () => s(!0)
      }, {
        label: g("cancel", "Cancel"),
        run: () => s(!1)
      }]).onDidClose(() => s(!1));
    });
  }
  _createProfileQuickPickItem(e) {
    const t = [{
      iconClass: re.asClassName(Yh),
      tooltip: g("createQuickLaunchProfile", "Configure Terminal Profile")
    }], s = `$(${(e.icon && re.isThemeIcon(e.icon) ? e.icon : te.terminal).id}) ${e.profileName}`, c = e.isFromPath ? Ii(e.path) : e.path, l = Jt(e), n = [];
    if (l && n.push(l), e.args) {
      if (typeof e.args == "string")
        return { label: s, description: `${e.path} ${e.args}`, profile: e, profileName: e.profileName, buttons: t, iconClasses: n };
      const r = e.args.map((a) => a.includes(" ") ? `"${a.replace(/"/g, '\\"')}"` : a).join(" ");
      return { label: s, description: `${c} ${r}`, profile: e, profileName: e.profileName, buttons: t, iconClasses: n };
    }
    return { label: s, description: c, profile: e, profileName: e.profileName, buttons: t, iconClasses: n };
  }
  _sortProfileQuickPickItems(e, t) {
    return e.sort((i, s) => s.profileName === t ? 1 : i.profileName === t ? -1 : i.profileName.localeCompare(s.profileName));
  }
};
Zs = X([
  D(0, Bt),
  D(1, ii),
  D(2, Se),
  D(3, qe),
  D(4, Me),
  D(5, Ee)
], Zs);
function eo(h) {
  const [, e, t] = h.path.split("/");
  if (!e || !Number.parseInt(t))
    throw new Error(`Could not parse terminal uri for resource ${h}`);
  return { workspaceId: e, instanceId: Number.parseInt(t) };
}
function Oa(h, e, t) {
  return oe.from({
    scheme: me.vscodeTerminal,
    path: `/${h}/${e}`,
    fragment: t || void 0
  });
}
function Fa(h) {
  var t;
  const e = (t = h.dataTransfer) == null ? void 0 : t.getData("Terminals");
  if (e) {
    const i = JSON.parse(e), s = [];
    for (const c of i)
      s.push(oe.parse(c));
    return s.length === 0 ? void 0 : s;
  }
}
function to(h, e) {
  if (e) {
    for (const t of h)
      if (t.resource.path === e.path)
        return t;
  }
}
var _e;
(function(h) {
  h[h.Top = 0] = "Top", h[h.Bottom = 1] = "Bottom";
})(_e || (_e = {}));
let er = class extends ue {
  activate(e) {
    this._terminal = e, this._register(this._terminal.onData(() => {
      this._currentMarker = _e.Bottom;
    }));
  }
  constructor(e, t) {
    super(), this._capabilities = e, this._themeService = t, this._currentMarker = _e.Bottom, this._selectionStart = null, this._isDisposable = !1;
  }
  _getMarkers(e) {
    var l, n;
    const t = this._capabilities.get(2), i = this._capabilities.get(3), s = this._capabilities.get(4);
    let c = [];
    if (t ? c = Fc(t.commands.map((r) => r.marker)) : i && c.push(...i.commands), s && !e) {
      let r = (l = s.markers().next()) == null ? void 0 : l.value;
      const a = [];
      for (; r; )
        a.push(r), r = (n = s.markers().next()) == null ? void 0 : n.value;
      c = a;
    }
    return c;
  }
  clearMarker() {
    this._currentMarker = _e.Bottom, this._resetNavigationDecorations(), this._selectionStart = null;
  }
  _resetNavigationDecorations() {
    this._navigationDecorations && ye(this._navigationDecorations), this._navigationDecorations = [];
  }
  _isEmptyCommand(e) {
    return e === _e.Bottom ? !0 : e === _e.Top ? !this._getMarkers(!0).map((t) => t.line).includes(0) : !this._getMarkers(!0).includes(e);
  }
  scrollToPreviousMark(e = 1, t = !1, i = !1) {
    if (!this._terminal)
      return;
    t || (this._selectionStart = null);
    let s;
    const c = typeof this._currentMarker == "object" ? this._getTargetScrollLine(this._terminal, this._currentMarker, e) : Math.min(qi(this._terminal, this._currentMarker), this._terminal.buffer.active.baseY), l = this._terminal.buffer.active.viewportY;
    if (typeof this._currentMarker == "object" ? !this._isMarkerInViewport(this._terminal, this._currentMarker) : c !== l) {
      const n = this._getMarkers(i).filter((r) => r.line >= l).length;
      s = this._getMarkers(i).length - n - 1;
    } else
      this._currentMarker === _e.Bottom ? s = this._getMarkers(i).length - 1 : this._currentMarker === _e.Top ? s = -1 : this._isDisposable ? (s = this._findPreviousMarker(this._terminal, i), this._currentMarker.dispose(), this._isDisposable = !1) : i && this._isEmptyCommand(this._currentMarker) ? s = this._findPreviousMarker(this._terminal, !0) : s = this._getMarkers(i).indexOf(this._currentMarker) - 1;
    if (s < 0) {
      this._currentMarker = _e.Top, this._terminal.scrollToTop(), this._resetNavigationDecorations();
      return;
    }
    this._currentMarker = this._getMarkers(i)[s], this._scrollToMarker(this._currentMarker, e);
  }
  scrollToNextMark(e = 1, t = !1, i = !0) {
    if (!this._terminal)
      return;
    t || (this._selectionStart = null);
    let s;
    const c = typeof this._currentMarker == "object" ? this._getTargetScrollLine(this._terminal, this._currentMarker, e) : Math.min(qi(this._terminal, this._currentMarker), this._terminal.buffer.active.baseY), l = this._terminal.buffer.active.viewportY;
    if ((typeof this._currentMarker == "object" ? !this._isMarkerInViewport(this._terminal, this._currentMarker) : c !== l) ? s = this._getMarkers(i).filter((r) => r.line <= l).length : this._currentMarker === _e.Bottom ? s = this._getMarkers(i).length : this._currentMarker === _e.Top ? s = 0 : this._isDisposable ? (s = this._findNextMarker(this._terminal, i), this._currentMarker.dispose(), this._isDisposable = !1) : i && this._isEmptyCommand(this._currentMarker) ? s = this._findNextMarker(this._terminal, !0) : s = this._getMarkers(i).indexOf(this._currentMarker) + 1, s >= this._getMarkers(i).length) {
      this._currentMarker = _e.Bottom, this._terminal.scrollToBottom(), this._resetNavigationDecorations();
      return;
    }
    this._currentMarker = this._getMarkers(i)[s], this._scrollToMarker(this._currentMarker, e);
  }
  _scrollToMarker(e, t, i, s) {
    if (this._terminal) {
      if (!this._isMarkerInViewport(this._terminal, e)) {
        const c = this._getTargetScrollLine(this._terminal, e, t);
        this._terminal.scrollToLine(c);
      }
      s || this._registerTemporaryDecoration(e, i);
    }
  }
  _createMarkerForOffset(e, t) {
    var i;
    if (t === 0)
      return e;
    {
      const s = (i = this._terminal) == null ? void 0 : i.registerMarker(-this._terminal.buffer.active.cursorY + e.line - this._terminal.buffer.active.baseY + t);
      if (s)
        return s;
      throw new Error(`Could not register marker with offset ${e.line}, ${t}`);
    }
  }
  _registerTemporaryDecoration(e, t) {
    var l;
    if (!this._terminal)
      return;
    this._resetNavigationDecorations();
    const i = this._themeService.getColorTheme().getColor(ia), s = e.line, c = t ? t.line - s + 1 : 1;
    for (let n = 0; n < c; n++) {
      const r = this._terminal.registerDecoration({
        marker: this._createMarkerForOffset(e, n),
        width: this._terminal.cols,
        overviewRulerOptions: {
          color: (i == null ? void 0 : i.toString()) || "#a0a0a0cc"
        }
      });
      if (r) {
        (l = this._navigationDecorations) == null || l.push(r);
        let a;
        r.onRender((f) => {
          var m;
          a || (a = f, c > 1 ? f.classList.add("terminal-scroll-highlight") : f.classList.add("terminal-scroll-highlight", "terminal-scroll-highlight-outline"), (m = this._terminal) != null && m.element && (f.style.marginLeft = `-${getComputedStyle(this._terminal.element).paddingLeft}`));
        }), r.onDispose(() => {
          var f;
          this._navigationDecorations = (f = this._navigationDecorations) == null ? void 0 : f.filter((m) => m !== r);
        }), di(350).then(() => {
          a && a.classList.remove("terminal-scroll-highlight-outline");
        });
      }
    }
  }
  _getTargetScrollLine(e, t, i) {
    return i === 1 ? Math.max(t.line - Math.floor(e.rows / 4), 0) : t.line;
  }
  _isMarkerInViewport(e, t) {
    const i = e.buffer.active.viewportY;
    return t.line >= i && t.line < i + e.rows;
  }
  scrollToClosestMarker(e, t, i) {
    const s = this._capabilities.get(4);
    if (!s)
      return;
    const c = s.getMark(e);
    if (!c)
      return;
    const l = t ? s.getMark(t) : c;
    this._scrollToMarker(c, 0, l, !i);
  }
  selectToPreviousMark() {
    this._terminal && (this._selectionStart === null && (this._selectionStart = this._currentMarker), this._capabilities.has(2) ? this.scrollToPreviousMark(1, !0, !0) : this.scrollToPreviousMark(1, !0, !1), gn(this._terminal, this._currentMarker, this._selectionStart));
  }
  selectToNextMark() {
    this._terminal && (this._selectionStart === null && (this._selectionStart = this._currentMarker), this._capabilities.has(2) ? this.scrollToNextMark(1, !0, !0) : this.scrollToNextMark(1, !0, !1), gn(this._terminal, this._currentMarker, this._selectionStart));
  }
  selectToPreviousLine() {
    this._terminal && (this._selectionStart === null && (this._selectionStart = this._currentMarker), this.scrollToPreviousLine(this._terminal, 1, !0), gn(this._terminal, this._currentMarker, this._selectionStart));
  }
  selectToNextLine() {
    this._terminal && (this._selectionStart === null && (this._selectionStart = this._currentMarker), this.scrollToNextLine(this._terminal, 1, !0), gn(this._terminal, this._currentMarker, this._selectionStart));
  }
  scrollToPreviousLine(e, t = 1, i = !1) {
    if (i || (this._selectionStart = null), this._currentMarker === _e.Top) {
      e.scrollToTop();
      return;
    }
    if (this._currentMarker === _e.Bottom)
      this._currentMarker = this._registerMarkerOrThrow(e, this._getOffset(e) - 1);
    else {
      const s = this._getOffset(e);
      this._isDisposable && this._currentMarker.dispose(), this._currentMarker = this._registerMarkerOrThrow(e, s - 1);
    }
    this._isDisposable = !0, this._scrollToMarker(this._currentMarker, t);
  }
  scrollToNextLine(e, t = 1, i = !1) {
    if (i || (this._selectionStart = null), this._currentMarker === _e.Bottom) {
      e.scrollToBottom();
      return;
    }
    if (this._currentMarker === _e.Top)
      this._currentMarker = this._registerMarkerOrThrow(e, this._getOffset(e) + 1);
    else {
      const s = this._getOffset(e);
      this._isDisposable && this._currentMarker.dispose(), this._currentMarker = this._registerMarkerOrThrow(e, s + 1);
    }
    this._isDisposable = !0, this._scrollToMarker(this._currentMarker, t);
  }
  _registerMarkerOrThrow(e, t) {
    const i = e.registerMarker(t);
    if (!i)
      throw new Error(`Could not create marker for ${t}`);
    return i;
  }
  _getOffset(e) {
    if (this._currentMarker === _e.Bottom)
      return 0;
    if (this._currentMarker === _e.Top)
      return 0 - (e.buffer.active.baseY + e.buffer.active.cursorY);
    {
      let t = qi(e, this._currentMarker);
      return t -= e.buffer.active.baseY + e.buffer.active.cursorY, t;
    }
  }
  _findPreviousMarker(e, t = !1) {
    if (this._currentMarker === _e.Top)
      return 0;
    if (this._currentMarker === _e.Bottom)
      return this._getMarkers(t).length - 1;
    let i;
    for (i = this._getMarkers(t).length - 1; i >= 0; i--)
      if (this._getMarkers(t)[i].line < this._currentMarker.line)
        return i;
    return -1;
  }
  _findNextMarker(e, t = !1) {
    if (this._currentMarker === _e.Top)
      return 0;
    if (this._currentMarker === _e.Bottom)
      return this._getMarkers(t).length - 1;
    let i;
    for (i = 0; i < this._getMarkers(t).length; i++)
      if (this._getMarkers(t)[i].line > this._currentMarker.line)
        return i;
    return this._getMarkers(t).length;
  }
};
er = X([
  D(1, Me)
], er);
function qi(h, e) {
  return e === _e.Bottom ? h.buffer.active.baseY + h.rows - 1 : e === _e.Top ? 0 : e.line;
}
function gn(h, e, t) {
  t === null && (t = _e.Bottom);
  let i = qi(h, e), s = qi(h, t);
  if (i > s) {
    const c = i;
    i = s, s = c;
  }
  s -= 1, h.selectLines(i, s);
}
class io extends ue {
  constructor() {
    super(...arguments), this._map = /* @__PURE__ */ new Map(), this._onDidRemoveCapability = this._register(new V()), this.onDidRemoveCapability = this._onDidRemoveCapability.event, this._onDidAddCapability = this._register(new V()), this.onDidAddCapability = this._onDidAddCapability.event;
  }
  get items() {
    return this._map.keys();
  }
  add(e, t) {
    this._map.set(e, t), this._onDidAddCapability.fire(e);
  }
  get(e) {
    return this._map.get(e);
  }
  remove(e) {
    this._map.has(e) && (this._map.delete(e), this._onDidRemoveCapability.fire(e));
  }
  has(e) {
    return this._map.has(e);
  }
}
class xd extends ue {
  constructor() {
    super(...arguments), this._stores = [], this._onDidRemoveCapability = this._register(new V()), this.onDidRemoveCapability = this._onDidRemoveCapability.event, this._onDidAddCapability = this._register(new V()), this.onDidAddCapability = this._onDidAddCapability.event;
  }
  get items() {
    return this._items();
  }
  *_items() {
    for (const e of this._stores)
      for (const t of e.items)
        yield t;
  }
  has(e) {
    for (const t of this._stores)
      for (const i of t.items)
        if (i === e)
          return !0;
    return !1;
  }
  get(e) {
    for (const t of this._stores) {
      const i = t.get(e);
      if (i)
        return i;
    }
  }
  add(e) {
    this._stores.push(e);
    for (const t of e.items)
      this._onDidAddCapability.fire(t);
    e.onDidAddCapability((t) => this._onDidAddCapability.fire(t)), e.onDidRemoveCapability((t) => this._onDidRemoveCapability.fire(t));
  }
}
class tr {
  get commands() {
    return this._commands;
  }
  get executingCommand() {
    return this._currentCommand.command;
  }
  get executingCommandObject() {
    if (this._currentCommand.commandStartMarker)
      return { marker: this._currentCommand.commandStartMarker };
  }
  get cwd() {
    return this._cwd;
  }
  get _isInputting() {
    return !!(this._currentCommand.commandStartMarker && !this._currentCommand.commandExecutedMarker);
  }
  get hasInput() {
    var e, t, i;
    if (!(!this._isInputting || !((e = this._currentCommand) != null && e.commandStartMarker))) {
      if (this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY === ((t = this._currentCommand.commandStartMarker) == null ? void 0 : t.line)) {
        const s = (i = this._terminal.buffer.active.getLine(this._terminal.buffer.active.cursorY)) == null ? void 0 : i.translateToString(!0, this._currentCommand.commandStartX);
        return s === void 0 ? void 0 : s.length > 0;
      }
      return !0;
    }
  }
  constructor(e, t) {
    this._terminal = e, this._logService = t, this.type = 2, this._commands = [], this._currentCommand = {}, this._isWindowsPty = !1, this._commandMarkers = [], this.__isCommandStorageDisabled = !1, this._onCommandStarted = new V(), this.onCommandStarted = this._onCommandStarted.event, this._onBeforeCommandFinished = new V(), this.onBeforeCommandFinished = this._onBeforeCommandFinished.event, this._onCommandFinished = new V(), this.onCommandFinished = this._onCommandFinished.event, this._onCommandExecuted = new V(), this.onCommandExecuted = this._onCommandExecuted.event, this._onCommandInvalidated = new V(), this.onCommandInvalidated = this._onCommandInvalidated.event, this._onCurrentCommandInvalidated = new V(), this.onCurrentCommandInvalidated = this._onCurrentCommandInvalidated.event, this._dimensions = {
      cols: this._terminal.cols,
      rows: this._terminal.rows
    }, this._terminal.onResize((i) => this._handleResize(i)), this._terminal.onCursorMove(() => this._handleCursorMove()), this._setupClearListeners();
  }
  _handleResize(e) {
    this._isWindowsPty && this._preHandleResizeWindows(e), this._dimensions.cols = e.cols, this._dimensions.rows = e.rows;
  }
  _handleCursorMove() {
    this._terminal.buffer.active === this._terminal.buffer.normal && this._currentCommand.commandStartMarker && this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY < this._currentCommand.commandStartMarker.line && (this._clearCommandsInViewport(), this._currentCommand.isInvalid = !0, this._onCurrentCommandInvalidated.fire({ reason: "windows" }));
  }
  _setupClearListeners() {
    this.onBeforeCommandFinished((e) => {
      this._isWindowsPty && (e.command.trim().toLowerCase() === "clear" || e.command.trim().toLowerCase() === "cls") && (this._clearCommandsInViewport(), this._currentCommand.isInvalid = !0, this._onCurrentCommandInvalidated.fire({ reason: "windows" }));
    }), this._terminal.parser.registerCsiHandler({ final: "J" }, (e) => (this._isWindowsPty || e.length >= 1 && (e[0] === 2 || e[0] === 3) && this._clearCommandsInViewport(), !1));
  }
  _preHandleResizeWindows(e) {
    const t = this._terminal.buffer.active.baseY, i = e.rows - this._dimensions.rows;
    i > 0 && this._waitForCursorMove().then(() => {
      const s = Math.min(i, t);
      for (let c = this.commands.length - 1; c >= 0; c--) {
        const l = this.commands[c];
        if (!l.marker || l.marker.line < t || l.commandStartLineContent === void 0)
          break;
        const n = this._terminal.buffer.active.getLine(l.marker.line);
        if (!n || n.translateToString(!0) === l.commandStartLineContent)
          continue;
        const r = l.marker.line - s, a = this._terminal.buffer.active.getLine(r);
        (a == null ? void 0 : a.translateToString(!0)) === l.commandStartLineContent && this._terminal._core._bufferService.buffer.lines.onDeleteEmitter.fire({
          index: this._terminal.buffer.active.baseY,
          amount: s
        });
      }
    });
  }
  _clearCommandsInViewport() {
    var t;
    let e = 0;
    for (let i = this._commands.length - 1; i >= 0; i--) {
      const s = (t = this._commands[i].marker) == null ? void 0 : t.line;
      if (s && s < this._terminal.buffer.active.baseY)
        break;
      e++;
    }
    e > 0 && this._onCommandInvalidated.fire(this._commands.splice(this._commands.length - e, e));
  }
  _waitForCursorMove() {
    const e = this._terminal.buffer.active.cursorX, t = this._terminal.buffer.active.cursorY;
    let i = 0;
    return new Promise((s, c) => {
      const l = setInterval(() => {
        if (e !== this._terminal.buffer.active.cursorX || t !== this._terminal.buffer.active.cursorY) {
          s(), clearInterval(l);
          return;
        }
        i += 10, i > 1e3 && (clearInterval(l), s());
      }, 10);
    });
  }
  setCwd(e) {
    this._cwd = e;
  }
  setIsWindowsPty(e) {
    this._isWindowsPty = e;
  }
  setIsCommandStorageDisabled() {
    this.__isCommandStorageDisabled = !0;
  }
  getCwdForLine(e) {
    var i, s;
    return this._currentCommand.promptStartMarker && e >= ((i = this._currentCommand.promptStartMarker) == null ? void 0 : i.line) ? this._cwd : (s = [...this._commands].reverse().find((c) => c.marker.line <= e - 1)) == null ? void 0 : s.cwd;
  }
  handlePromptStart(e) {
    var t;
    this._currentCommand.promptStartMarker = (e == null ? void 0 : e.marker) || this._terminal.registerMarker(0), this._logService.debug("CommandDetectionCapability#handlePromptStart", this._terminal.buffer.active.cursorX, (t = this._currentCommand.promptStartMarker) == null ? void 0 : t.line);
  }
  handleContinuationStart() {
    this._currentCommand.currentContinuationMarker = this._terminal.registerMarker(0), this._logService.debug("CommandDetectionCapability#handleContinuationStart", this._currentCommand.currentContinuationMarker);
  }
  handleContinuationEnd() {
    if (!this._currentCommand.currentContinuationMarker) {
      this._logService.warn("CommandDetectionCapability#handleContinuationEnd Received continuation end without start");
      return;
    }
    this._currentCommand.continuations || (this._currentCommand.continuations = []), this._currentCommand.continuations.push({
      marker: this._currentCommand.currentContinuationMarker,
      end: this._terminal.buffer.active.cursorX
    }), this._currentCommand.currentContinuationMarker = void 0, this._logService.debug("CommandDetectionCapability#handleContinuationEnd", this._currentCommand.continuations[this._currentCommand.continuations.length - 1]);
  }
  handleRightPromptStart() {
    this._currentCommand.commandRightPromptStartX = this._terminal.buffer.active.cursorX, this._logService.debug("CommandDetectionCapability#handleRightPromptStart", this._currentCommand.commandRightPromptStartX);
  }
  handleRightPromptEnd() {
    this._currentCommand.commandRightPromptEndX = this._terminal.buffer.active.cursorX, this._logService.debug("CommandDetectionCapability#handleRightPromptEnd", this._currentCommand.commandRightPromptEndX);
  }
  handleCommandStart(e) {
    var t, i, s, c;
    if (this._handleCommandStartOptions = e, this._currentCommand.commandStartMarker = (e == null ? void 0 : e.marker) || this._currentCommand.commandStartMarker, ((t = this._currentCommand.commandStartMarker) == null ? void 0 : t.line) === this._terminal.buffer.active.cursorY) {
      this._currentCommand.commandStartX = this._terminal.buffer.active.cursorX, this._logService.debug("CommandDetectionCapability#handleCommandStart", this._currentCommand.commandStartX, (i = this._currentCommand.commandStartMarker) == null ? void 0 : i.line);
      return;
    }
    if (this._isWindowsPty) {
      this._handleCommandStartWindows();
      return;
    }
    this._currentCommand.commandStartX = this._terminal.buffer.active.cursorX, this._currentCommand.commandStartMarker = (e == null ? void 0 : e.marker) || this._terminal.registerMarker(0), (s = this._currentCommand.commandExecutedMarker) == null || s.dispose(), this._currentCommand.commandExecutedMarker = void 0, this._currentCommand.commandExecutedX = void 0;
    for (const l of this._commandMarkers)
      l.dispose();
    this._commandMarkers.length = 0, this._onCommandStarted.fire({ marker: (e == null ? void 0 : e.marker) || this._currentCommand.commandStartMarker, markProperties: e == null ? void 0 : e.markProperties }), this._logService.debug("CommandDetectionCapability#handleCommandStart", this._currentCommand.commandStartX, (c = this._currentCommand.commandStartMarker) == null ? void 0 : c.line);
  }
  _handleCommandStartWindows() {
    this._currentCommand.commandStartX = this._terminal.buffer.active.cursorX, this._commandMarkers.length = 0, di(0).then(() => {
      var e;
      if (this._currentCommand.commandExecutedMarker || (this._onCursorMoveListener = this._terminal.onCursorMove(() => {
        if (this._commandMarkers.length === 0 || this._commandMarkers[this._commandMarkers.length - 1].line !== this._terminal.buffer.active.cursorY) {
          const t = this._terminal.registerMarker(0);
          t && this._commandMarkers.push(t);
        }
      })), this._currentCommand.commandStartMarker = this._terminal.registerMarker(0), this._currentCommand.commandStartMarker) {
        const t = this._terminal.buffer.active.getLine(this._currentCommand.commandStartMarker.line);
        t && (this._currentCommand.commandStartLineContent = t.translateToString(!0));
      }
      this._onCommandStarted.fire({ marker: this._currentCommand.commandStartMarker }), this._logService.debug("CommandDetectionCapability#_handleCommandStartWindows", this._currentCommand.commandStartX, (e = this._currentCommand.commandStartMarker) == null ? void 0 : e.line);
    });
  }
  handleGenericCommand(e) {
    var t;
    (t = e == null ? void 0 : e.markProperties) != null && t.disableCommandStorage && this.setIsCommandStorageDisabled(), this.handlePromptStart(e), this.handleCommandStart(e), this.handleCommandExecuted(e), this.handleCommandFinished(void 0, e);
  }
  handleCommandExecuted(e) {
    var s, c, l, n;
    if (this._isWindowsPty) {
      this._handleCommandExecutedWindows();
      return;
    }
    if (this._currentCommand.commandExecutedMarker = (e == null ? void 0 : e.marker) || this._terminal.registerMarker(0), this._currentCommand.commandExecutedX = this._terminal.buffer.active.cursorX, this._logService.debug("CommandDetectionCapability#handleCommandExecuted", this._currentCommand.commandExecutedX, (s = this._currentCommand.commandExecutedMarker) == null ? void 0 : s.line), !this._currentCommand.commandStartMarker || !this._currentCommand.commandExecutedMarker || this._currentCommand.commandStartX === void 0)
      return;
    this._currentCommand.command = this.__isCommandStorageDisabled ? "" : (c = this._terminal.buffer.active.getLine(this._currentCommand.commandStartMarker.line)) == null ? void 0 : c.translateToString(!0, this._currentCommand.commandStartX, this._currentCommand.commandRightPromptStartX).trim();
    let t = this._currentCommand.commandStartMarker.line + 1;
    const i = this._currentCommand.commandExecutedMarker.line;
    for (; t < i; t++) {
      const r = this._terminal.buffer.active.getLine(t);
      if (r) {
        const a = (l = this._currentCommand.continuations) == null ? void 0 : l.find((m) => m.marker.line === t);
        a && (this._currentCommand.command += `
`);
        const f = (a == null ? void 0 : a.end) ?? 0;
        this._currentCommand.command += r.translateToString(!0, f);
      }
    }
    t === i && (this._currentCommand.command += ((n = this._terminal.buffer.active.getLine(i)) == null ? void 0 : n.translateToString(!0, void 0, this._currentCommand.commandExecutedX)) || ""), this._onCommandExecuted.fire();
  }
  _handleCommandExecutedWindows() {
    var e, t;
    (e = this._onCursorMoveListener) == null || e.dispose(), this._onCursorMoveListener = void 0, this._evaluateCommandMarkersWindows(), this._currentCommand.commandExecutedX = this._terminal.buffer.active.cursorX, this._onCommandExecuted.fire(), this._logService.debug("CommandDetectionCapability#handleCommandExecuted", this._currentCommand.commandExecutedX, (t = this._currentCommand.commandExecutedMarker) == null ? void 0 : t.line);
  }
  invalidateCurrentCommand(e) {
    this._currentCommand.isInvalid = !0, this._onCurrentCommandInvalidated.fire(e);
  }
  handleCommandFinished(e, t) {
    var s, c, l;
    this._isWindowsPty && this._preHandleCommandFinishedWindows(), this._currentCommand.commandFinishedMarker = (t == null ? void 0 : t.marker) || this._terminal.registerMarker(0);
    let i = this._currentCommand.command;
    if (this._logService.debug("CommandDetectionCapability#handleCommandFinished", this._terminal.buffer.active.cursorX, (s = this._currentCommand.commandFinishedMarker) == null ? void 0 : s.line, this._currentCommand.command, this._currentCommand), this._exitCode = e, this._exitCode === void 0) {
      const n = this.commands.length > 0 ? this.commands[this.commands.length - 1] : void 0;
      i && i.length > 0 && (n == null ? void 0 : n.command) === i && (this._exitCode = n.exitCode);
    }
    if (!(this._currentCommand.commandStartMarker === void 0 || !this._terminal.buffer.active)) {
      if (this._exitCode === void 0 && i === void 0 && (i = ""), i !== void 0 && !i.startsWith("\\") || (c = this._handleCommandStartOptions) != null && c.ignoreCommandLine) {
        const n = this._terminal.buffer.active, r = Date.now(), a = this._currentCommand.commandExecutedMarker, f = this._currentCommand.commandFinishedMarker, m = {
          command: (l = this._handleCommandStartOptions) != null && l.ignoreCommandLine ? "" : i || "",
          isTrusted: !!this._currentCommand.isTrusted,
          marker: this._currentCommand.commandStartMarker,
          endMarker: f,
          executedMarker: a,
          timestamp: r,
          cwd: this._cwd,
          exitCode: this._exitCode,
          commandStartLineContent: this._currentCommand.commandStartLineContent,
          hasOutput: () => !(a != null && a.isDisposed) && !(f != null && f.isDisposed) && !!(a && f && (a == null ? void 0 : a.line) < f.line),
          getOutput: () => So(a, f, n),
          getOutputMatch: (C) => bo(this._isWindowsPty && (a == null ? void 0 : a.line) === (f == null ? void 0 : f.line) ? this._currentCommand.commandStartMarker : a, f, n, this._terminal.cols, C),
          markProperties: t == null ? void 0 : t.markProperties
        };
        this._commands.push(m), this._logService.debug("CommandDetectionCapability#onCommandFinished", m), this._onBeforeCommandFinished.fire(m), this._currentCommand.isInvalid || this._onCommandFinished.fire(m);
      }
      this._currentCommand.previousCommandMarker = this._currentCommand.commandStartMarker, this._currentCommand = {}, this._handleCommandStartOptions = void 0;
    }
  }
  _preHandleCommandFinishedWindows() {
    this._currentCommand.commandExecutedMarker || (this._commandMarkers.length === 0 && (this._currentCommand.commandStartMarker || (this._currentCommand.commandStartMarker = this._terminal.registerMarker(0)), this._currentCommand.commandStartMarker && this._commandMarkers.push(this._currentCommand.commandStartMarker)), this._evaluateCommandMarkersWindows());
  }
  _evaluateCommandMarkersWindows() {
    if (this._commandMarkers.length !== 0) {
      if (this._commandMarkers = this._commandMarkers.sort((e, t) => e.line - t.line), this._currentCommand.commandStartMarker = this._commandMarkers[0], this._currentCommand.commandStartMarker) {
        const e = this._terminal.buffer.active.getLine(this._currentCommand.commandStartMarker.line);
        e && (this._currentCommand.commandStartLineContent = e.translateToString(!0));
      }
      this._currentCommand.commandExecutedMarker = this._commandMarkers[this._commandMarkers.length - 1];
    }
  }
  setCommandLine(e, t) {
    this._logService.debug("CommandDetectionCapability#setCommandLine", e, t), this._currentCommand.command = e, this._currentCommand.isTrusted = t;
  }
  serialize() {
    const e = this.commands.map((t) => {
      var i, s, c;
      return {
        startLine: (i = t.marker) == null ? void 0 : i.line,
        startX: void 0,
        endLine: (s = t.endMarker) == null ? void 0 : s.line,
        executedLine: (c = t.executedMarker) == null ? void 0 : c.line,
        command: this.__isCommandStorageDisabled ? "" : t.command,
        isTrusted: t.isTrusted,
        cwd: t.cwd,
        exitCode: t.exitCode,
        commandStartLineContent: t.commandStartLineContent,
        timestamp: t.timestamp,
        markProperties: t.markProperties,
        aliases: t.aliases
      };
    });
    return this._currentCommand.commandStartMarker && e.push({
      startLine: this._currentCommand.commandStartMarker.line,
      startX: this._currentCommand.commandStartX,
      endLine: void 0,
      executedLine: void 0,
      command: "",
      isTrusted: !0,
      cwd: this._cwd,
      exitCode: void 0,
      commandStartLineContent: void 0,
      timestamp: 0,
      markProperties: void 0
    }), {
      isWindowsPty: this._isWindowsPty,
      commands: e
    };
  }
  deserialize(e) {
    e.isWindowsPty && this.setIsWindowsPty(e.isWindowsPty);
    const t = this._terminal.buffer.normal;
    for (const i of e.commands) {
      const s = i.startLine !== void 0 ? this._terminal.registerMarker(i.startLine - (t.baseY + t.cursorY)) : void 0;
      if (!s)
        continue;
      if (!i.endLine) {
        this._currentCommand.commandStartMarker = s, this._currentCommand.commandStartX = i.startX, this._cwd = i.cwd, this._onCommandStarted.fire({ marker: s });
        continue;
      }
      const c = i.endLine !== void 0 ? this._terminal.registerMarker(i.endLine - (t.baseY + t.cursorY)) : void 0, l = i.executedLine !== void 0 ? this._terminal.registerMarker(i.executedLine - (t.baseY + t.cursorY)) : void 0, n = {
        command: this.__isCommandStorageDisabled ? "" : i.command,
        isTrusted: i.isTrusted,
        marker: s,
        endMarker: c,
        executedMarker: l,
        timestamp: i.timestamp,
        cwd: i.cwd,
        commandStartLineContent: i.commandStartLineContent,
        exitCode: i.exitCode,
        hasOutput: () => !(l != null && l.isDisposed) && !(c != null && c.isDisposed) && !!(l && c && l.line < c.line),
        getOutput: () => So(l, c, t),
        getOutputMatch: (r) => bo(this._isWindowsPty && (l == null ? void 0 : l.line) === (c == null ? void 0 : c.line) ? s : l, c, t, this._terminal.cols, r),
        markProperties: i.markProperties,
        wasReplayed: !0
      };
      this._commands.push(n), this._logService.debug("CommandDetectionCapability#onCommandFinished", n), this._onCommandFinished.fire(n);
    }
  }
}
tr.__decorator = X([
  ft(500)
], tr.prototype, "_handleCursorMove", null);
function So(h, e, t) {
  if (!h || !e)
    return;
  const i = h.line, s = e.line;
  if (i === s)
    return;
  let c = "", l;
  for (let n = i; n < s; n++)
    l = t.getLine(n), l && (c += l.translateToString(!l.isWrapped) + (l.isWrapped ? "" : `
`));
  return c === "" ? void 0 : c;
}
function bo(h, e, t, i, s) {
  var m, C;
  if (!h || !e)
    return;
  const c = e.line;
  if (c === -1)
    return;
  const l = Math.max(h.line, 0), n = s.lineMatcher, r = typeof n == "string" ? 1 : s.length || kd(n), a = [];
  let f;
  if (s.anchor === "bottom")
    for (let b = c - (s.offset || 0); b >= l; b--) {
      let p = b;
      const S = b;
      for (; p >= l && ((m = t.getLine(p)) != null && m.isWrapped); )
        p--;
      if (b = p, a.unshift(wo(t, p, S, i)), f || (f = a[0].match(n)), a.length >= r)
        break;
    }
  else
    for (let b = l + (s.offset || 0); b < c; b++) {
      const p = b;
      let S = b;
      for (; S + 1 < c && ((C = t.getLine(S + 1)) != null && C.isWrapped); )
        S++;
      if (b = S, a.push(wo(t, p, S, i)), f || (f = a[a.length - 1].match(n)), a.length >= r)
        break;
    }
  return f ? { regexMatch: f, outputLines: a } : void 0;
}
function wo(h, e, t, i) {
  const s = Math.max(2048 / i * 2);
  t = Math.min(t, e + s);
  let c = "";
  for (let l = e; l <= t; l++) {
    const n = h.getLine(l);
    n && (c += n.translateToString(!0, 0, i));
  }
  return c;
}
function kd(h) {
  if (!h.multiline)
    return 1;
  const e = h.source;
  let t = 1, i = e.indexOf("\\n");
  for (; i !== -1; )
    t++, i = e.indexOf("\\n", i + 1);
  return t;
}
class Id {
  constructor() {
    this.type = 0, this._cwd = "", this._cwds = /* @__PURE__ */ new Map(), this._onDidChangeCwd = new V(), this.onDidChangeCwd = this._onDidChangeCwd.event;
  }
  get cwds() {
    return Array.from(this._cwds.keys());
  }
  getCwd() {
    return this._cwd;
  }
  updateCwd(e) {
    const t = this._cwd !== e;
    this._cwd = e;
    const i = this._cwds.get(this._cwd) || 0;
    this._cwds.delete(this._cwd), this._cwds.set(this._cwd, i + 1), t && this._onDidChangeCwd.fire(e);
  }
}
class Td {
  get commands() {
    return this._commands;
  }
  constructor(e) {
    this._terminal = e, this.type = 3, this._commands = [], this._onCommandFinished = new V(), this.onCommandFinished = this._onCommandFinished.event, this._terminal.onData((t) => this._onData(t)), this._terminal.parser.registerCsiHandler({ final: "J" }, (t) => (t.length >= 1 && (t[0] === 2 || t[0] === 3) && this._clearCommandsInViewport(), !1));
  }
  _onData(e) {
    e === "\r" && this._onEnter();
  }
  _onEnter() {
    if (this._terminal && this._terminal.buffer.active.cursorX >= 2) {
      const e = this._terminal.registerMarker(0);
      e && (this._commands.push(e), this._onCommandFinished.fire(e));
    }
  }
  _clearCommandsInViewport() {
    let e = 0;
    for (let t = this._commands.length - 1; t >= 0 && !(this._commands[t].line < this._terminal.buffer.active.baseY); t--)
      e++;
    this._commands.splice(this._commands.length - e, e);
  }
}
class Dd {
  constructor(e) {
    this._terminal = e, this.type = 4, this._idToMarkerMap = /* @__PURE__ */ new Map(), this._anonymousMarkers = /* @__PURE__ */ new Map(), this._onMarkAdded = new V(), this.onMarkAdded = this._onMarkAdded.event;
  }
  *markers() {
    for (const e of this._idToMarkerMap.values())
      yield e;
    for (const e of this._anonymousMarkers.values())
      yield e;
  }
  addMark(e) {
    const t = (e == null ? void 0 : e.marker) || this._terminal.registerMarker(), i = e == null ? void 0 : e.id;
    t && (i ? (this._idToMarkerMap.set(i, t), t.onDispose(() => this._idToMarkerMap.delete(i))) : (this._anonymousMarkers.set(t.id, t), t.onDispose(() => this._anonymousMarkers.delete(t.id))), this._onMarkAdded.fire({ marker: t, id: i, hidden: e == null ? void 0 : e.hidden, hoverMessage: e == null ? void 0 : e.hoverMessage }));
  }
  getMark(e) {
    return this._idToMarkerMap.get(e);
  }
}
function Co(h) {
  let e = h;
  e.includes("\\") && (e = e.replace(/\\/g, "\\\\"));
  const t = /[\`\$\|\&\>\~\#\!\^\*\;\<\"\']/g;
  return e = e.replace(t, ""), `'${e}'`;
}
function Ed(h, e, t) {
  if (!h)
    return "";
  if (!e)
    return h;
  e.match(/[\/\\]$/) && (e = e.slice(0, e.length - 1));
  const i = h.replace(/\\/g, "/").toLowerCase(), s = e.replace(/\\/g, "/").toLowerCase();
  return i.includes(s) ? `~${t}${h.slice(e.length + 1)}` : h;
}
function ir(h) {
  return h.match(/^['"].*['"]$/) && (h = h.substring(1, h.length - 1)), Lt === 1 && h && h[1] === ":" ? h[0].toUpperCase() + h.substring(1) : h;
}
class Ad extends ue {
  get status() {
    return this._status;
  }
  constructor(e, t, i, s) {
    super(), this._nonce = e, this._disableTelemetry = t, this._telemetryService = i, this._logService = s, this.capabilities = new io(), this._hasUpdatedTelemetry = !1, this._commonProtocolDisposables = [], this._status = 0, this._onDidChangeStatus = new V(), this.onDidChangeStatus = this._onDidChangeStatus.event, this._register(je(() => {
      this._clearActivationTimeout(), this._disposeCommonProtocol();
    }));
  }
  _disposeCommonProtocol() {
    ye(this._commonProtocolDisposables), this._commonProtocolDisposables.length = 0;
  }
  activate(e) {
    this._terminal = e, this.capabilities.add(3, new Td(this._terminal)), this._register(e.parser.registerOscHandler(633, (t) => this._handleVSCodeSequence(t))), this._register(e.parser.registerOscHandler(1337, (t) => this._doHandleITermSequence(t))), this._commonProtocolDisposables.push(e.parser.registerOscHandler(133, (t) => this._handleFinalTermSequence(t))), this._register(e.parser.registerOscHandler(7, (t) => this._doHandleSetCwd(t))), this._register(e.parser.registerOscHandler(9, (t) => this._doHandleSetWindowsFriendlyCwd(t))), this._ensureCapabilitiesOrAddFailureTelemetry();
  }
  _handleFinalTermSequence(e) {
    const t = this._doHandleFinalTermSequence(e);
    return this._status === 0 && (this._status = 1, this._onDidChangeStatus.fire(this._status)), t;
  }
  _doHandleFinalTermSequence(e) {
    if (!this._terminal)
      return !1;
    const [t, ...i] = e.split(";");
    switch (t) {
      case "A":
        return this._createOrGetCommandDetection(this._terminal).handlePromptStart(), !0;
      case "B":
        return this._createOrGetCommandDetection(this._terminal).handleCommandStart({ ignoreCommandLine: !0 }), !0;
      case "C":
        return this._createOrGetCommandDetection(this._terminal).handleCommandExecuted(), !0;
      case "D": {
        const s = i.length === 1 ? parseInt(i[0]) : void 0;
        return this._createOrGetCommandDetection(this._terminal).handleCommandFinished(s), !0;
      }
    }
    return !1;
  }
  _handleVSCodeSequence(e) {
    var i;
    const t = this._doHandleVSCodeSequence(e);
    return !this._hasUpdatedTelemetry && t && ((i = this._telemetryService) == null || i.publicLog2("terminal/shellIntegrationActivationSucceeded"), this._hasUpdatedTelemetry = !0, this._clearActivationTimeout()), this._status !== 2 && (this._status = 2, this._onDidChangeStatus.fire(this._status)), t;
  }
  async _ensureCapabilitiesOrAddFailureTelemetry() {
    !this._telemetryService || this._disableTelemetry || (this._activationTimeout = setTimeout(() => {
      var e;
      !this.capabilities.get(2) && !this.capabilities.get(0) && ((e = this._telemetryService) == null || e.publicLog2("terminal/shellIntegrationActivationTimeout"), this._logService.warn("Shell integration failed to add capabilities within 10 seconds")), this._hasUpdatedTelemetry = !0;
    }, 1e4));
  }
  _clearActivationTimeout() {
    this._activationTimeout !== void 0 && (clearTimeout(this._activationTimeout), this._activationTimeout = void 0);
  }
  _doHandleVSCodeSequence(e) {
    var c;
    if (!this._terminal)
      return !1;
    const t = e.indexOf(";"), i = t === -1 ? e : e.substring(0, t), s = t === -1 ? [] : e.substring(t + 1).split(";");
    switch (i) {
      case "A":
        return this._createOrGetCommandDetection(this._terminal).handlePromptStart(), !0;
      case "B":
        return this._createOrGetCommandDetection(this._terminal).handleCommandStart(), !0;
      case "C":
        return this._createOrGetCommandDetection(this._terminal).handleCommandExecuted(), !0;
      case "D": {
        const l = s[0], n = l !== void 0 ? parseInt(l) : void 0;
        return this._createOrGetCommandDetection(this._terminal).handleCommandFinished(n), !0;
      }
      case "E": {
        const l = s[0], n = s[1];
        let r;
        return l !== void 0 ? r = yo(l) : r = "", this._createOrGetCommandDetection(this._terminal).setCommandLine(r, n === this._nonce), !0;
      }
      case "F":
        return this._createOrGetCommandDetection(this._terminal).handleContinuationStart(), !0;
      case "G":
        return this._createOrGetCommandDetection(this._terminal).handleContinuationEnd(), !0;
      case "H":
        return this._createOrGetCommandDetection(this._terminal).handleRightPromptStart(), !0;
      case "I":
        return this._createOrGetCommandDetection(this._terminal).handleRightPromptEnd(), !0;
      case "P": {
        const l = s[0], n = l !== void 0 ? yo(l) : "", { key: r, value: a } = xo(n);
        if (a === void 0)
          return !0;
        switch (r) {
          case "Cwd":
            return this._updateCwd(a), !0;
          case "IsWindows":
            return this._createOrGetCommandDetection(this._terminal).setIsWindowsPty(a === "True"), !0;
          case "Task":
            return this._createOrGetBufferMarkDetection(this._terminal), (c = this.capabilities.get(2)) == null || c.setIsCommandStorageDisabled(), !0;
        }
      }
      case "SetMark":
        return this._createOrGetBufferMarkDetection(this._terminal).addMark(Ld(s)), !0;
    }
    return !1;
  }
  _updateCwd(e) {
    e = ir(e), this._createOrGetCwdDetection().updateCwd(e);
    const t = this.capabilities.get(2);
    t == null || t.setCwd(e);
  }
  _doHandleITermSequence(e) {
    if (!this._terminal)
      return !1;
    const [t] = e.split(";");
    switch (t) {
      case "SetMark":
        this._createOrGetBufferMarkDetection(this._terminal).addMark();
      default: {
        const { key: i, value: s } = xo(t);
        if (s === void 0)
          return !0;
        switch (i) {
          case "CurrentDir":
            return this._updateCwd(s), !0;
        }
      }
    }
    return !1;
  }
  _doHandleSetWindowsFriendlyCwd(e) {
    if (!this._terminal)
      return !1;
    const [t, ...i] = e.split(";");
    switch (t) {
      case "9":
        return i.length && this._updateCwd(i[0]), !0;
    }
    return !1;
  }
  _doHandleSetCwd(e) {
    if (!this._terminal)
      return !1;
    const [t] = e.split(";");
    if (t.match(/^file:\/\/.*\//)) {
      const i = oe.parse(t);
      if (i.path && i.path.length > 0)
        return this._updateCwd(i.path), !0;
    }
    return !1;
  }
  serialize() {
    return !this._terminal || !this.capabilities.has(2) ? {
      isWindowsPty: !1,
      commands: []
    } : this._createOrGetCommandDetection(this._terminal).serialize();
  }
  deserialize(e) {
    if (!this._terminal)
      throw new Error("Cannot restore commands before addon is activated");
    this._createOrGetCommandDetection(this._terminal).deserialize(e);
  }
  _createOrGetCwdDetection() {
    let e = this.capabilities.get(0);
    return e || (e = new Id(), this.capabilities.add(0, e)), e;
  }
  _createOrGetCommandDetection(e) {
    let t = this.capabilities.get(2);
    return t || (t = new tr(e, this._logService), this.capabilities.add(2, t)), t;
  }
  _createOrGetBufferMarkDetection(e) {
    let t = this.capabilities.get(4);
    return t || (t = new Dd(e), this.capabilities.add(4, t)), t;
  }
}
function yo(h) {
  return h.replaceAll(
    /\\(\\|x([0-9a-f]{2}))/gi,
    (e, t, i) => i ? String.fromCharCode(parseInt(i, 16)) : t
  );
}
function xo(h) {
  const e = h.indexOf("=");
  return e === -1 ? { key: h, value: void 0 } : {
    key: h.substring(0, e),
    value: h.substring(1 + e)
  };
}
function Ld(h) {
  let e, t = !1;
  for (const i of h)
    i !== void 0 && (i === "Hidden" && (t = !0), i.startsWith("Id=") && (e = i.substring(3)));
  return { id: e, hidden: t };
}
let nr = class extends ue {
  constructor(e, t, i) {
    super(), this._hoverService = e, this._contextMenuVisible = !1, this._register(i.onDidShowContextMenu(() => this._contextMenuVisible = !0)), this._register(i.onDidHideContextMenu(() => this._contextMenuVisible = !1)), this._hoverDelayer = this._register(new es(t.getValue("workbench.hover.delay")));
  }
  hideHover() {
    this._hoverDelayer.cancel(), this._hoverService.hideHover();
  }
  createHover(e, t, i) {
    return Hc(he(e, et.MOUSE_ENTER, () => {
      this._contextMenuVisible || this._hoverDelayer.trigger(() => {
        var c, l;
        let s = `${g("terminalPromptContextMenu", "Show Command Actions")}`;
        if (s += `

---

`, t)
          if (t.markProperties || i)
            if ((c = t.markProperties) != null && c.hoverMessage || i)
              s = ((l = t.markProperties) == null ? void 0 : l.hoverMessage) || i || "";
            else
              return;
          else
            t.exitCode ? t.exitCode === -1 ? s += g(
              "terminalPromptCommandFailed",
              "Command executed {0} and failed",
              Gi(t.timestamp, !0)
            ) : s += g(
              "terminalPromptCommandFailedWithExitCode",
              "Command executed {0} and failed (Exit Code {1})",
              Gi(t.timestamp, !0),
              t.exitCode
            ) : s += g(
              "terminalPromptCommandSuccess",
              "Command executed {0}",
              Gi(t.timestamp, !0)
            );
        else if (i)
          s = i;
        else
          return;
        this._hoverService.showHover({ content: new de(s), target: e });
      });
    }), he(e, et.MOUSE_LEAVE, () => this.hideHover()), he(e, et.MOUSE_OUT, () => this.hideHover()));
  }
};
nr = X([
  D(0, on),
  D(1, Se),
  D(2, _i)
], nr);
function ds(h, e) {
  if (!e)
    return;
  const t = h.inspect("terminal.integrated.fontSize").value, i = h.inspect("terminal.integrated.fontSize").defaultValue, s = h.inspect("terminal.integrated.lineHeight").value;
  if (typeof t == "number" && typeof i == "number" && typeof s == "number") {
    const c = t / i <= 1 ? t / i : 1;
    e.style.width = `${c * 16}px`, e.style.height = `${c * 16 * s}px`, e.style.fontSize = `${c * 16}px`, e.style.marginLeft = `${c * -17}px`;
  }
}
let sr = class extends ue {
  constructor(e, t, i, s, c, l, n, r, a, f, m, C) {
    super(), this._capabilities = e, this._clipboardService = t, this._contextMenuService = i, this._configurationService = s, this._themeService = c, this._openerService = l, this._quickInputService = n, this._commandService = a, this._audioCueService = m, this._notificationService = C, this._capabilityDisposables = /* @__PURE__ */ new Map(), this._decorations = /* @__PURE__ */ new Map(), this._onDidRequestRunCommand = this._register(new V()), this.onDidRequestRunCommand = this._onDidRequestRunCommand.event, this._register(je(() => this._dispose())), this._register(this._configurationService.onDidChangeConfiguration((b) => {
      b.affectsConfiguration("terminal.integrated.fontSize") || b.affectsConfiguration("terminal.integrated.lineHeight") ? this.refreshLayouts() : b.affectsConfiguration("workbench.colorCustomizations") ? this._refreshStyles(!0) : b.affectsConfiguration("terminal.integrated.shellIntegration.decorationsEnabled") && (this._removeCapabilityDisposables(2), this._updateDecorationVisibility());
    })), this._register(this._themeService.onDidColorThemeChange(() => this._refreshStyles(!0))), this._updateDecorationVisibility(), this._register(this._capabilities.onDidAddCapability((b) => this._createCapabilityDisposables(b))), this._register(this._capabilities.onDidRemoveCapability((b) => this._removeCapabilityDisposables(b))), this._register(r.onWillShutdown(() => this._disposeAllDecorations())), this._terminalDecorationHoverService = f.createInstance(nr);
  }
  _removeCapabilityDisposables(e) {
    const t = this._capabilityDisposables.get(e);
    t && ye(t), this._capabilityDisposables.delete(e);
  }
  _createCapabilityDisposables(e) {
    let t = [];
    const i = this._capabilities.get(e);
    if (!(!i || this._capabilityDisposables.has(e))) {
      switch (i.type) {
        case 4:
          t = [i.onMarkAdded((s) => this.registerMarkDecoration(s))];
          break;
        case 2:
          t = this._getCommandDetectionListeners(i);
          break;
      }
      this._capabilityDisposables.set(e, t);
    }
  }
  registerMarkDecoration(e) {
    if (!(!this._terminal || !this._showGutterDecorations && !this._showOverviewRulerDecorations) && !e.hidden)
      return this.registerCommandDecoration(void 0, void 0, e);
  }
  _updateDecorationVisibility() {
    var i;
    const e = this._configurationService.getValue("terminal.integrated.shellIntegration.decorationsEnabled");
    this._showGutterDecorations = e === "both" || e === "gutter", this._showOverviewRulerDecorations = e === "both" || e === "overviewRuler", this._disposeAllDecorations(), (this._showGutterDecorations || this._showOverviewRulerDecorations) && (this._attachToCommandCapability(), this._updateGutterDecorationVisibility());
    const t = (i = this._capabilities.get(2)) == null ? void 0 : i.executingCommandObject;
    t && this.registerCommandDecoration(t, !0);
  }
  _disposeAllDecorations() {
    var e;
    (e = this._placeholderDecoration) == null || e.dispose();
    for (const t of this._decorations.values())
      t.decoration.dispose(), ye(t.disposables);
  }
  _updateGutterDecorationVisibility() {
    const e = document.querySelectorAll("terminal-command-decoration");
    for (const t of e)
      this._updateCommandDecorationVisibility(t);
  }
  _updateCommandDecorationVisibility(e) {
    this._showGutterDecorations ? e.classList.remove("hide") : e.classList.add("hide");
  }
  refreshLayouts() {
    var e;
    ds(this._configurationService, (e = this._placeholderDecoration) == null ? void 0 : e.element);
    for (const t of this._decorations)
      ds(this._configurationService, t[1].decoration.element);
  }
  _refreshStyles(e) {
    var t, i, s;
    if (e)
      for (const c of this._decorations.values()) {
        const l = ((t = this._getDecorationCssColor(c)) == null ? void 0 : t.toString()) ?? "";
        (i = c.decoration.options) != null && i.overviewRulerOptions ? c.decoration.options.overviewRulerOptions.color = l : c.decoration.options && (c.decoration.options.overviewRulerOptions = { color: l });
      }
    this._updateClasses((s = this._placeholderDecoration) == null ? void 0 : s.element);
    for (const c of this._decorations.values())
      this._updateClasses(c.decoration.element, c.exitCode, c.markProperties);
  }
  _dispose() {
    this._terminalDecorationHoverService.dispose();
    for (const e of this._capabilityDisposables.values())
      ye(e);
    this.clearDecorations();
  }
  _clearPlaceholder() {
    var e;
    (e = this._placeholderDecoration) == null || e.dispose(), this._placeholderDecoration = void 0;
  }
  clearDecorations() {
    var e;
    (e = this._placeholderDecoration) == null || e.marker.dispose(), this._clearPlaceholder(), this._disposeAllDecorations(), this._decorations.clear();
  }
  _attachToCommandCapability() {
    this._capabilities.has(2) && this._getCommandDetectionListeners(this._capabilities.get(2));
  }
  _getCommandDetectionListeners(e) {
    var i;
    if (this._capabilityDisposables.has(2)) {
      const s = this._capabilityDisposables.get(2);
      ye(s), this._capabilityDisposables.delete(e.type);
    }
    const t = [];
    (i = e.executingCommandObject) != null && i.marker && this.registerCommandDecoration(e.executingCommandObject, !0), t.push(e.onCommandStarted((s) => this.registerCommandDecoration(s, !0)));
    for (const s of e.commands)
      this.registerCommandDecoration(s);
    return t.push(e.onCommandFinished((s) => {
      this.registerCommandDecoration(s), s.exitCode && this._audioCueService.playAudioCue(Xr.terminalCommandFailed);
    })), t.push(e.onCommandInvalidated((s) => {
      var c;
      for (const l of s) {
        const n = (c = l.marker) == null ? void 0 : c.id;
        if (n) {
          const r = this._decorations.get(n);
          r && (r.decoration.dispose(), ye(r.disposables));
        }
      }
    })), t.push(e.onCurrentCommandInvalidated((s) => {
      if (s.reason === "noProblemsReported") {
        const c = Array.from(this._decorations.entries())[this._decorations.size - 1];
        c == null || c[1].decoration.dispose();
      } else
        s.reason === "windows" && this._clearPlaceholder();
    })), t;
  }
  activate(e) {
    this._terminal = e, this._attachToCommandCapability();
  }
  registerCommandDecoration(e, t, i) {
    var n;
    if (!this._terminal || t && !e || !this._showGutterDecorations && !this._showOverviewRulerDecorations)
      return;
    const s = (e == null ? void 0 : e.marker) || (i == null ? void 0 : i.marker);
    if (!s)
      throw new Error(`cannot add a decoration for a command ${JSON.stringify(e)} with no marker`);
    this._clearPlaceholder();
    const c = ((n = this._getDecorationCssColor(e)) == null ? void 0 : n.toString()) ?? "", l = this._terminal.registerDecoration({
      marker: s,
      overviewRulerOptions: this._showOverviewRulerDecorations ? t ? { color: c, position: "left" } : { color: c, position: e != null && e.exitCode ? "right" : "left" } : void 0
    });
    if (l)
      return t && (this._placeholderDecoration = l), l.onRender((r) => {
        var a;
        r.classList.contains(".xterm-decoration-overview-ruler") || (this._decorations.get(l.marker.id) || (l.onDispose(() => this._decorations.delete(l.marker.id)), this._decorations.set(l.marker.id, {
          decoration: l,
          disposables: this._createDisposables(r, e, i),
          exitCode: e == null ? void 0 : e.exitCode,
          markProperties: e == null ? void 0 : e.markProperties
        })), (!r.classList.contains("codicon") || ((a = e == null ? void 0 : e.marker) == null ? void 0 : a.line) === 0) && (ds(this._configurationService, r), this._updateClasses(r, e == null ? void 0 : e.exitCode, (e == null ? void 0 : e.markProperties) || i)));
      }), l;
  }
  _createDisposables(e, t, i) {
    return (t == null ? void 0 : t.exitCode) === void 0 && !(t != null && t.markProperties) ? [] : t != null && t.markProperties || i ? [this._terminalDecorationHoverService.createHover(e, t || i, i == null ? void 0 : i.hoverMessage)] : [this._createContextMenu(e, t), this._terminalDecorationHoverService.createHover(e, t)];
  }
  _updateClasses(e, t, i) {
    if (e) {
      for (const s of e.classList)
        e.classList.remove(s);
      e.classList.add("terminal-command-decoration", "codicon", "xterm-decoration"), i ? (e.classList.add("default-color", ...re.asClassNameArray(Qh)), i.hoverMessage || e.classList.add("default")) : (this._updateCommandDecorationVisibility(e), t === void 0 ? (e.classList.add("default-color", "default"), e.classList.add(...re.asClassNameArray(Jh))) : t ? (e.classList.add("error"), e.classList.add(...re.asClassNameArray(Zh))) : e.classList.add(...re.asClassNameArray(ed)));
    }
  }
  _createContextMenu(e, t) {
    return he(e, et.CLICK, async () => {
      this._terminalDecorationHoverService.hideHover();
      const i = await this._getCommandActions(t);
      this._contextMenuService.showContextMenu({ getAnchor: () => e, getActions: () => i });
    });
  }
  async _getCommandActions(e) {
    const t = [];
    if (e.command !== "") {
      const n = g("terminal.rerunCommand", "Rerun Command");
      t.push({
        class: void 0,
        tooltip: n,
        id: "terminal.rerunCommand",
        label: n,
        enabled: !0,
        run: async () => {
          e.command !== "" && (!e.isTrusted && !await new Promise((f) => {
            this._notificationService.prompt(Te.Info, g("rerun", "Do you want to run the command: {0}", e.command), [{
              label: g("yes", "Yes"),
              run: () => f(!0)
            }, {
              label: g("no", "No"),
              run: () => f(!1)
            }]);
          }) || this._onDidRequestRunCommand.fire({ command: e }));
        }
      });
      const r = g("terminal.copyCommand", "Copy Command");
      t.push({
        class: void 0,
        tooltip: r,
        id: "terminal.copyCommand",
        label: r,
        enabled: !0,
        run: () => this._clipboardService.writeText(e.command)
      });
    }
    if (e.hasOutput()) {
      t.length > 0 && t.push(new ci());
      const n = g("terminal.copyOutput", "Copy Output");
      t.push({
        class: void 0,
        tooltip: n,
        id: "terminal.copyOutput",
        label: n,
        enabled: !0,
        run: () => {
          const a = e.getOutput();
          typeof a == "string" && this._clipboardService.writeText(a);
        }
      });
      const r = g("terminal.copyOutputAsHtml", "Copy Output as HTML");
      t.push({
        class: void 0,
        tooltip: r,
        id: "terminal.copyOutputAsHtml",
        label: r,
        enabled: !0,
        run: () => this._onDidRequestRunCommand.fire({ command: e, copyAsHtml: !0 })
      });
    }
    t.length > 0 && t.push(new ci());
    const i = g("workbench.action.terminal.runRecentCommand", "Run Recent Command");
    t.push({
      class: void 0,
      tooltip: i,
      id: "workbench.action.terminal.runRecentCommand",
      label: i,
      enabled: !0,
      run: () => this._commandService.executeCommand("workbench.action.terminal.runRecentCommand")
    });
    const s = g("workbench.action.terminal.goToRecentDirectory", "Go To Recent Directory");
    t.push({
      class: void 0,
      tooltip: i,
      id: "workbench.action.terminal.goToRecentDirectory",
      label: s,
      enabled: !0,
      run: () => this._commandService.executeCommand("workbench.action.terminal.goToRecentDirectory")
    }), t.push(new ci());
    const c = g("terminal.configureCommandDecorations", "Configure Command Decorations");
    t.push({
      class: void 0,
      tooltip: c,
      id: "terminal.configureCommandDecorations",
      label: c,
      enabled: !0,
      run: () => this._showConfigureCommandDecorationsQuickPick()
    });
    const l = g("terminal.learnShellIntegration", "Learn About Shell Integration");
    return t.push({
      class: void 0,
      tooltip: l,
      id: "terminal.learnShellIntegration",
      label: l,
      enabled: !0,
      run: () => this._openerService.open("https://code.visualstudio.com/docs/terminal/shell-integration")
    }), t;
  }
  async _showConfigureCommandDecorationsQuickPick() {
    const e = this._quickInputService.createQuickPick();
    e.items = [
      { id: "a", label: g("toggleVisibility", "Toggle visibility") }
    ], e.canSelectMany = !1, e.onDidAccept(async (t) => {
      switch (e.hide(), e.activeItems[0].id) {
        case "a":
          this._showToggleVisibilityQuickPick();
          break;
      }
    }), e.show();
  }
  _showToggleVisibilityQuickPick() {
    const e = this._quickInputService.createQuickPick();
    e.hideInput = !0, e.hideCheckAll = !0, e.canSelectMany = !0, e.title = g("toggleVisibility", "Toggle visibility");
    const t = this._configurationService.getValue("terminal.integrated.shellIntegration.decorationsEnabled"), i = {
      label: g("gutter", "Gutter command decorations"),
      picked: t !== "never" && t !== "overviewRuler"
    }, s = {
      label: g("overviewRuler", "Overview ruler command decorations"),
      picked: t !== "never" && t !== "gutter"
    };
    e.items = [i, s];
    const c = [];
    t !== "never" && (t !== "gutter" && c.push(i), t !== "overviewRuler" && c.push(s)), e.selectedItems = c, e.onDidChangeSelection(async (l) => {
      let n = "never";
      l.includes(i) ? l.includes(s) ? n = "both" : n = "gutter" : l.includes(s) && (n = "overviewRuler"), await this._configurationService.updateValue("terminal.integrated.shellIntegration.decorationsEnabled", n);
    }), e.ok = !1, e.show();
  }
  _getDecorationCssColor(e) {
    var i;
    let t;
    return (e == null ? void 0 : e.exitCode) === void 0 ? t = Vc : t = e.exitCode ? Wc : Nc, (i = this._themeService.getColorTheme().getColor(t)) == null ? void 0 : i.toString();
  }
};
sr = X([
  D(1, $n),
  D(2, _i),
  D(3, Se),
  D(4, Me),
  D(5, tn),
  D(6, qe),
  D(7, is),
  D(8, dt),
  D(9, le),
  D(10, jr),
  D(11, Ee)
], sr);
class us {
  constructor(e) {
    this.completion = e, this.score = As.Default, this.distance = 0, this.labelLow = this.completion.label.toLowerCase();
  }
}
class ms {
  constructor(e, t) {
    this.leadingLineContent = e, this.characterCountDelta = t;
  }
}
class ko {
  constructor(e, t, i, s) {
    this._items = e, this._lineContext = t, this.replacementIndex = i, this.replacementLength = s, this._refilterKind = 1, this._fuzzyScoreOptions = $c.default, this._options = {};
  }
  get items() {
    return this._ensureCachedState(), this._filteredItems;
  }
  get stats() {
    return this._ensureCachedState(), this._stats;
  }
  get lineContext() {
    return this._lineContext;
  }
  set lineContext(e) {
    (this._lineContext.leadingLineContent !== e.leadingLineContent || this._lineContext.characterCountDelta !== e.characterCountDelta) && (this._refilterKind = this._lineContext.characterCountDelta < e.characterCountDelta && this._filteredItems ? 2 : 1, this._lineContext = e);
  }
  _ensureCachedState() {
    this._refilterKind !== 0 && this._createCachedState();
  }
  _createCachedState() {
    const e = [], { leadingLineContent: t, characterCountDelta: i } = this._lineContext;
    let s = "", c = "";
    const l = this._refilterKind === 1 ? this._items : this._filteredItems, n = [], r = !this._options.filterGraceful || l.length > 2e3 ? Uc : Gc;
    for (let a = 0; a < l.length; a++) {
      const f = l[a], m = this.replacementLength, C = m + i;
      if (s.length !== C && (s = C === 0 ? "" : t.slice(-C), c = s.toLowerCase()), f.word = s, C === 0)
        f.score = As.Default;
      else {
        let b = 0;
        for (; b < m; ) {
          const p = s.charCodeAt(b);
          if (p === 32 || p === 9)
            b += 1;
          else
            break;
        }
        if (b >= C)
          f.score = As.Default;
        else {
          const p = r(s, c, b, f.completion.label, f.labelLow, 0, this._fuzzyScoreOptions);
          if (!p)
            continue;
          f.score = p;
        }
      }
      f.idx = a, f.distance = 1, n.push(f), e.push(f.completion.label.length);
    }
    this._filteredItems = n, this._refilterKind = 0, this._stats = {
      pLabelLen: e.length ? zc(e.length - 0.85, e, (a, f) => a - f) : 0
    };
  }
}
var Pd = '.workbench-suggest-widget{display:flex;flex-direction:column;left:0;position:absolute;top:0;width:430px;z-index:40}.workbench-suggest-widget.message{align-items:center;flex-direction:row}.monaco-workbench .workbench-suggest-details,.workbench-suggest-widget{background-color:var(--vscode-editorSuggestWidget-background);border-color:var(--vscode-editorSuggestWidget-border);border-style:solid;border-width:1px;flex:0 1 auto;width:100%}.monaco-workbench.hc-black .workbench-suggest-details,.monaco-workbench.hc-black .workbench-suggest-widget,.monaco-workbench.hc-light .workbench-suggest-details,.monaco-workbench.hc-light .workbench-suggest-widget{border-width:2px}.monaco-workbench .workbench-suggest-widget.with-status-bar .suggest-status-bar{display:flex}.monaco-workbench .workbench-suggest-widget .suggest-status-bar .left{padding-right:8px}.monaco-workbench .workbench-suggest-widget.with-status-bar .suggest-status-bar .action-label{color:var(--vscode-editorSuggestWidgetStatus-foreground)}.monaco-workbench .workbench-suggest-widget.with-status-bar .suggest-status-bar .action-item:not(:last-of-type) .action-label{margin-right:0}.monaco-workbench .workbench-suggest-widget.with-status-bar .suggest-status-bar .action-item:not(:last-of-type) .action-label:after{content:", ";margin-right:.3em}.monaco-workbench .workbench-suggest-widget.with-status-bar .monaco-list .monaco-list-row.focused.string-label>.contents>.main>.right>.readMore,.monaco-workbench .workbench-suggest-widget.with-status-bar .monaco-list .monaco-list-row>.contents>.main>.right>.readMore{display:none}.workbench-suggest-widget .monaco-list .monaco-list-row{background-position:2px 2px;background-repeat:no-repeat;-mox-box-sizing:border-box;box-sizing:border-box;cursor:pointer;display:flex;padding-right:10px;touch-action:none;white-space:nowrap}.workbench-suggest-widget .monaco-list .monaco-list-row.focused{color:var(--vscode-editorSuggestWidget-selectedForeground)}.workbench-suggest-widget .monaco-list .monaco-list-row.focused .codicon{color:var(--vscode-editorSuggestWidget-selectedIconForeground)}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents{flex:1;height:100%;overflow:hidden;padding-left:2px}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main{display:flex;justify-content:space-between;overflow:hidden;text-overflow:ellipsis;white-space:pre}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left,.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right{display:flex}.workbench-suggest-widget .monaco-list .monaco-list-row:not(.focused)>.contents>.main .monaco-icon-label{color:var(--vscode-editorSuggestWidget-foreground)}.workbench-suggest-widget:not(.frozen) .monaco-highlighted-label .highlight{font-weight:700}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main .monaco-highlighted-label .highlight{color:var(--vscode-editorSuggestWidget-highlightForeground)}.workbench-suggest-widget .monaco-list .monaco-list-row.focused>.contents>.main .monaco-highlighted-label .highlight{color:var(--vscode-editorSuggestWidget-focusHighlightForeground)}.workbench-suggest-widget .monaco-list .monaco-list-row .monaco-icon-label.deprecated{opacity:.66;text-decoration:unset}.workbench-suggest-widget .monaco-list .monaco-list-row .monaco-icon-label.deprecated>.monaco-icon-label-container>.monaco-icon-name-container{text-decoration:line-through}.workbench-suggest-widget .monaco-list .monaco-list-row .monaco-icon-label:before{height:100%}.workbench-suggest-widget .monaco-list .monaco-list-row .icon{background-position:50%;background-repeat:no-repeat;background-size:80%;display:block;height:16px;margin-left:2px;width:16px}.workbench-suggest-widget .monaco-list .monaco-list-row .icon.hide{display:none}.workbench-suggest-widget .monaco-list .monaco-list-row .suggest-icon{align-items:center;display:flex;margin-right:4px}.workbench-suggest-widget.no-icons .monaco-list .monaco-list-row .icon,.workbench-suggest-widget.no-icons .monaco-list .monaco-list-row .suggest-icon:before{display:none}.workbench-suggest-widget .monaco-list .monaco-list-row .icon.customcolor .colorspan{border:.1em solid #000;display:inline-block;height:.7em;margin:0 0 0 .3em;width:.7em}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label{opacity:.7}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left>.signature-label{opacity:.6;overflow:hidden;text-overflow:ellipsis}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left>.qualifier-label{align-self:center;font-size:85%;line-height:normal;margin-left:12px;opacity:.4;overflow:hidden;text-overflow:ellipsis}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label{font-size:85%;margin-left:1.1em;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label>.monaco-tokenized-source{display:inline}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label{display:none}.workbench-suggest-widget .monaco-list .monaco-list-row:not(.string-label)>.contents>.main>.right>.details-label,.workbench-suggest-widget.docs-side .monaco-list .monaco-list-row.focused:not(.string-label)>.contents>.main>.right>.details-label,.workbench-suggest-widget:not(.shows-details) .monaco-list .monaco-list-row.focused>.contents>.main>.right>.details-label{display:inline}.workbench-suggest-widget:not(.docs-side) .monaco-list .monaco-list-row.focused:hover>.contents>.main>.right.can-expand-details>.details-label{width:calc(100% - 26px)}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left{flex-grow:1;flex-shrink:1;overflow:hidden}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left>.monaco-icon-label{flex-shrink:0}.workbench-suggest-widget .monaco-list .monaco-list-row:not(.string-label)>.contents>.main>.left>.monaco-icon-label{max-width:100%}.workbench-suggest-widget .monaco-list .monaco-list-row.string-label>.contents>.main>.left>.monaco-icon-label{flex-shrink:1}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right{flex-shrink:4;max-width:70%;overflow:hidden}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.readMore{display:inline-block;height:18px;position:absolute;right:10px;visibility:hidden;width:18px}';
Wi(Pd, {});
function Rd(h) {
  return `simple-suggest-aria-id:${h}`;
}
class Md {
  constructor() {
    this._onDidToggleDetails = new V(), this.onDidToggleDetails = this._onDidToggleDetails.event, this.templateId = "suggestion";
  }
  dispose() {
    this._onDidToggleDetails.dispose();
  }
  renderTemplate(e) {
    const t = new Zt(), i = e;
    i.classList.add("show-file-icons");
    const s = Qe(e, Ve(".icon")), c = Qe(s, Ve("span.colorspan")), l = Qe(e, Ve(".contents")), n = Qe(l, Ve(".main")), r = Qe(n, Ve(".icon-label.codicon")), a = Qe(n, Ve("span.left")), f = Qe(n, Ve("span.right")), m = new Kc(a, { supportHighlights: !0, supportIcons: !0 });
    t.add(m);
    const C = Qe(a, Ve("span.signature-label")), b = Qe(a, Ve("span.qualifier-label")), p = Qe(f, Ve("span.details-label"));
    return (() => {
      const o = "Hack", _ = "", u = "12", d = "20", v = "normal", w = "0", x = `${u}px`, k = `${d}px`, y = `${w}px`;
      i.style.fontSize = x, i.style.fontWeight = v, i.style.letterSpacing = y, n.style.fontFamily = o, n.style.fontFeatureSettings = _, n.style.lineHeight = k, s.style.height = k, s.style.width = k;
    })(), { root: i, left: a, right: f, icon: s, colorspan: c, iconLabel: m, iconContainer: r, parametersLabel: C, qualifierLabel: b, detailsLabel: p, disposables: t };
  }
  renderElement(e, t, i) {
    const { completion: s } = e;
    i.root.id = Rd(t), i.colorspan.style.backgroundColor = "";
    const c = {
      labelEscapeNewLines: !0,
      matches: qc(e.score)
    };
    i.icon.className = "icon hide", i.iconContainer.className = "", i.iconContainer.classList.add("suggest-icon", ...re.asClassNameArray(s.icon || te.symbolText)), i.iconLabel.setLabel(s.label, void 0, c), i.parametersLabel.textContent = "", i.detailsLabel.textContent = Bd(s.detail || ""), i.root.classList.add("string-label"), Ft(i.detailsLabel), i.right.classList.remove("can-expand-details");
  }
  disposeTemplate(e) {
    e.disposables.dispose();
  }
}
function Bd(h) {
  return h.replace(/\r\n|\r|\n/g, "");
}
const Od = Ve;
let rr = class {
  get list() {
    return this._list;
  }
  constructor(e, t, i, s) {
    this._container = e, this._persistedSize = t, this._state = 0, this._forceRenderingAbove = !1, this._pendingLayout = new jc(), this._showTimeout = new Xc(), this._disposables = new Zt(), this._onDidSelect = new V(), this.onDidSelect = this._onDidSelect.event, this._onDidHide = new V(), this.onDidHide = this._onDidHide.event, this._onDidShow = new V(), this.onDidShow = this._onDidShow.event, this.element = new Yc(), this.element.domNode.classList.add("workbench-suggest-widget"), this._container.appendChild(this.element.domNode);
    class c {
      constructor(a, f, m = !1, C = !1) {
        this.persistedSize = a, this.currentSize = f, this.persistHeight = m, this.persistWidth = C;
      }
    }
    let l;
    this._disposables.add(this.element.onDidWillResize(() => {
      l = new c(this._persistedSize.restore(), this.element.size);
    })), this._disposables.add(this.element.onDidResize((r) => {
      var a, f;
      if (this._resize(r.dimension.width, r.dimension.height), l && (l.persistHeight = l.persistHeight || !!r.north || !!r.south, l.persistWidth = l.persistWidth || !!r.east || !!r.west), !!r.done) {
        if (l) {
          const { itemHeight: m, defaultSize: C } = this._getLayoutInfo(), b = Math.round(m / 2);
          let { width: p, height: S } = this.element.size;
          (!l.persistHeight || Math.abs(l.currentSize.height - S) <= b) && (S = ((a = l.persistedSize) == null ? void 0 : a.height) ?? C.height), (!l.persistWidth || Math.abs(l.currentSize.width - p) <= b) && (p = ((f = l.persistedSize) == null ? void 0 : f.width) ?? C.width), this._persistedSize.store(new Nt(p, S));
        }
        l = void 0;
      }
    }));
    const n = new Md();
    this._disposables.add(n), this._listElement = Qe(this.element.domNode, Od(".tree")), this._list = new Qc("SuggestWidget", this._listElement, {
      getHeight: (r) => this._getLayoutInfo().itemHeight,
      getTemplateId: (r) => "suggestion"
    }, [n], {
      alwaysConsumeMouseWheel: !0,
      useShadows: !1,
      mouseSupport: !1,
      multipleSelectionSupport: !1,
      accessibilityProvider: {
        getRole: () => "option",
        getWidgetAriaLabel: () => g("suggest", "Suggest"),
        getWidgetRole: () => "listbox",
        getAriaLabel: (r) => {
          let a = r.completion.label;
          if (typeof r.completion.label != "string") {
            const { detail: m, description: C } = r.completion.label;
            m && C ? a = g("label.full", "{0}{1}, {2}", a, m, C) : m ? a = g("label.detail", "{0}{1}", a, m) : C && (a = g("label.desc", "{0}, {1}", a, C));
          }
          const { detail: f } = r.completion;
          return g("ariaCurrenttSuggestionReadDetails", "{0}, docs: {1}", a, f);
        }
      }
    }), i.statusBarMenuId && (this._status = s.createInstance(Jc, this.element.domNode, i.statusBarMenuId), this.element.domNode.classList.toggle("with-status-bar", !0)), this._disposables.add(this._list.onMouseDown((r) => this._onListMouseDownOrTap(r))), this._disposables.add(this._list.onTap((r) => this._onListMouseDownOrTap(r))), this._disposables.add(this._list.onDidChangeSelection((r) => this._onListSelection(r)));
  }
  dispose() {
    var e;
    this._disposables.dispose(), (e = this._status) == null || e.dispose(), this.element.dispose();
  }
  showSuggestions(e, t, i, s, c) {
    if (this._cursorPosition = c, this._completionModel !== e && (this._completionModel = e), i && this._state !== 2 && this._state !== 0) {
      this._setState(4);
      return;
    }
    if (this._completionModel.items.length === 0) {
      this._setState(s ? 0 : 2), this._completionModel = void 0;
      return;
    }
    try {
      this._list.splice(0, this._list.length, this._completionModel.items), this._setState(i ? 4 : 3), this._list.reveal(t, 0), this._list.setFocus([t]);
    } finally {
    }
    this._pendingLayout.value = Zc(() => {
      this._pendingLayout.clear(), this._layout(this.element.size);
    });
  }
  setLineContext(e) {
    this._completionModel && (this._completionModel.lineContext = e);
  }
  _setState(e) {
    var t, i, s, c, l, n, r;
    if (this._state !== e)
      switch (this._state = e, this.element.domNode.classList.toggle("frozen", e === 4), this.element.domNode.classList.remove("message"), e) {
        case 0:
          si(this._listElement), this._status && si((t = this._status) == null ? void 0 : t.element), (i = this._status) == null || i.hide(), this._showTimeout.cancel(), this.element.domNode.classList.remove("visible"), this._list.splice(0, this._list.length), this._cappedHeight = void 0;
          break;
        case 1:
          this.element.domNode.classList.add("message"), si(this._listElement), this._status && si((s = this._status) == null ? void 0 : s.element), this._show();
          break;
        case 2:
          this.element.domNode.classList.add("message"), si(this._listElement), this._status && si((c = this._status) == null ? void 0 : c.element), this._show();
          break;
        case 3:
          Ft(this._listElement), this._status && Ft((l = this._status) == null ? void 0 : l.element), this._show();
          break;
        case 4:
          Ft(this._listElement), this._status && Ft((n = this._status) == null ? void 0 : n.element), this._show();
          break;
        case 5:
          Ft(this._listElement), this._status && Ft((r = this._status) == null ? void 0 : r.element), this._show();
          break;
      }
  }
  _show() {
    var e;
    (e = this._status) == null || e.show(), Ft(this.element.domNode), this._layout(this._persistedSize.restore()), this._showTimeout.cancelAndSet(() => {
      this.element.domNode.classList.add("visible"), this._onDidShow.fire(this);
    }, 100);
  }
  hide() {
    this._pendingLayout.clear(), this._setState(0), this._onDidHide.fire(this), si(this.element.domNode), this.element.clearSashHoverState();
    const e = this._persistedSize.restore(), t = Math.ceil(this._getLayoutInfo().itemHeight * 4.3);
    e && e.height < t && this._persistedSize.store(e.with(void 0, t));
  }
  _layout(e) {
    var u, d;
    if (!this._cursorPosition)
      return;
    const t = el(document.body), i = this._getLayoutInfo();
    e || (e = i.defaultSize);
    let s = e.height, c = e.width;
    this._status && (this._status.element.style.lineHeight = `${i.itemHeight}px`);
    const l = t.width - i.borderHeight - 2 * i.horizontalPadding;
    c > l && (c = l);
    const n = this._completionModel ? this._completionModel.stats.pLabelLen * i.typicalHalfwidthCharacterWidth : c, r = i.statusBarHeight + this._list.contentHeight + i.borderHeight, a = i.itemHeight + i.statusBarHeight, f = Qo(this._container), m = this._cursorPosition, C = f.top + m.top + m.height, b = Math.min(t.height - C - i.verticalPadding, r), p = f.top + m.top - i.verticalPadding, S = Math.min(p, r);
    let o = Math.min(Math.max(S, b) + i.borderHeight, r);
    s === ((u = this._cappedHeight) == null ? void 0 : u.capped) && (s = this._cappedHeight.wanted), s < a && (s = a), s > o && (s = o);
    const _ = 150;
    s > b || this._forceRenderingAbove && p > _ ? (this._preference = 0, this.element.enableSashes(!0, !0, !1, !1), o = S) : (this._preference = 1, this.element.enableSashes(!1, !0, !0, !1), o = b), this.element.preferredSize = new Nt(n, i.defaultSize.height), this.element.maxSize = new Nt(l, o), this.element.minSize = new Nt(220, a), this._cappedHeight = s === r ? { wanted: ((d = this._cappedHeight) == null ? void 0 : d.wanted) ?? e.height, capped: s } : void 0, this.element.domNode.style.left = `${this._cursorPosition.left}px`, this._preference === 0 ? this.element.domNode.style.top = `${this._cursorPosition.top - s - i.borderHeight}px` : this.element.domNode.style.top = `${this._cursorPosition.top + this._cursorPosition.height}px`, this._resize(c, s);
  }
  _resize(e, t) {
    const { width: i, height: s } = this.element.maxSize;
    e = Math.min(i, e), s && (t = Math.min(s, t));
    const { statusBarHeight: c } = this._getLayoutInfo();
    this._list.layout(t - c, e), this._listElement.style.height = `${t - c}px`, this._listElement.style.width = `${e}px`, this._listElement.style.height = `${t}px`, this.element.layout(t, e);
  }
  _getLayoutInfo() {
    const e = {
      lineHeight: 20,
      typicalHalfwidthCharacterWidth: 10
    }, t = tl(e.lineHeight, 8, 1e3), i = 0, s = 1, c = 2 * s;
    return {
      itemHeight: t,
      statusBarHeight: i,
      borderWidth: s,
      borderHeight: c,
      typicalHalfwidthCharacterWidth: e.typicalHalfwidthCharacterWidth,
      verticalPadding: 22,
      horizontalPadding: 14,
      defaultSize: new Nt(430, i + 12 * t + c)
    };
  }
  _onListMouseDownOrTap(e) {
    typeof e.element > "u" || typeof e.index > "u" || (e.browserEvent.preventDefault(), e.browserEvent.stopPropagation(), this._select(e.element, e.index));
  }
  _onListSelection(e) {
    e.elements.length && this._select(e.elements[0], e.indexes[0]);
  }
  _select(e, t) {
    const i = this._completionModel;
    i && this._onDidSelect.fire({ item: e, index: t, model: i });
  }
  selectNext() {
    this._list.focusNext(1, !0);
    const e = this._list.getFocus();
    return e.length > 0 && this._list.reveal(e[0]), !0;
  }
  selectNextPage() {
    this._list.focusNextPage();
    const e = this._list.getFocus();
    return e.length > 0 && this._list.reveal(e[0]), !0;
  }
  selectPrevious() {
    this._list.focusPrevious(1, !0);
    const e = this._list.getFocus();
    return e.length > 0 && this._list.reveal(e[0]), !0;
  }
  selectPreviousPage() {
    this._list.focusPreviousPage();
    const e = this._list.getFocus();
    return e.length > 0 && this._list.reveal(e[0]), !0;
  }
  getFocusedItem() {
    if (this._completionModel)
      return {
        item: this._list.getFocusedElements()[0],
        index: this._list.getFocus()[0],
        model: this._completionModel
      };
  }
  forceRenderingAbove() {
    this._forceRenderingAbove || (this._forceRenderingAbove = !0, this._layout(this._persistedSize.restore()));
  }
  stopForceRenderingAbove() {
    this._forceRenderingAbove = !1;
  }
};
rr = X([
  D(3, le)
], rr);
const Fd = {
  0: te.symbolText,
  1: te.history,
  2: te.symbolMethod,
  3: te.symbolFile,
  4: te.folder,
  5: te.symbolProperty,
  6: te.symbolMethod,
  7: te.symbolVariable,
  8: te.symbolValue,
  9: te.symbolVariable,
  10: te.symbolNamespace,
  11: te.symbolInterface,
  12: te.symbolKeyword,
  13: te.symbolKeyword
};
let or = class extends ue {
  constructor(e, t) {
    super(), this._terminalSuggestWidgetVisibleContextKey = e, this._instantiationService = t, this._enableWidget = !0, this._cursorIndexStart = 0, this._cursorIndexDelta = 0, this._onBell = new V(), this.onBell = this._onBell.event, this._onAcceptedCompletion = new V(), this.onAcceptedCompletion = this._onAcceptedCompletion.event, this._cachedBashAliases = /* @__PURE__ */ new Set(), this._cachedBashBuiltins = /* @__PURE__ */ new Set(), this._cachedBashCommands = /* @__PURE__ */ new Set(), this._cachedBashKeywords = /* @__PURE__ */ new Set();
  }
  activate(e) {
    this._terminal = e, this._register(e.parser.registerOscHandler(633, (t) => this._handleVSCodeSequence(t))), this._register(e.onData((t) => {
      this._handleTerminalInput(t);
    }));
  }
  setContainer(e) {
    this._container = e;
  }
  _handleVSCodeSequence(e) {
    if (!this._terminal)
      return !1;
    const [t, ...i] = e.split(";");
    switch (t) {
      case "Completions":
        return this._handleCompletionsSequence(this._terminal, e, t, i), !0;
      case "CompletionsBash":
        return this._handleCompletionsBashSequence(this._terminal, e, t, i), !0;
      case "CompletionsBashFirstWord":
        return this._handleCompletionsBashFirstWordSequence(this._terminal, e, t, i);
    }
    return !1;
  }
  _handleCompletionsSequence(e, t, i, s) {
    if (!e.element || !this._enableWidget)
      return;
    const c = parseInt(s[0]), l = parseInt(s[1]);
    if (this._cursorIndexStart = parseInt(s[2]), !s[3]) {
      this._onBell.fire();
      return;
    }
    let n = JSON.parse(t.slice(i.length + s[0].length + s[1].length + s[2].length + 4));
    Array.isArray(n) || (n = [n]);
    const r = n.map((f) => new us({
      label: f.CompletionText,
      icon: Fd[f.ResultType],
      detail: f.ToolTip
    }));
    this._leadingLineContent = r[0].completion.label.slice(0, l), this._cursorIndexDelta = 0;
    const a = new ko(r, new ms(this._leadingLineContent, c), c, l);
    if (r.length === 1 && r[0].completion.label.substring(l).length === 0) {
      this._onBell.fire();
      return;
    }
    this._handleCompletionModel(a);
  }
  _handleCompletionsBashFirstWordSequence(e, t, i, s) {
    const c = s[0], l = t.slice(i.length + c.length + 2).split(";");
    let n;
    switch (c) {
      case "alias":
        n = this._cachedBashAliases;
        break;
      case "builtin":
        n = this._cachedBashBuiltins;
        break;
      case "command":
        n = this._cachedBashCommands;
        break;
      case "keyword":
        n = this._cachedBashKeywords;
        break;
      default:
        return !1;
    }
    n.clear();
    const r = /* @__PURE__ */ new Set();
    for (const a of l)
      r.add(a);
    for (const a of r)
      n.add(new us({
        label: a,
        icon: te.symbolString,
        detail: c
      }));
    return this._cachedFirstWord = void 0, !0;
  }
  _handleCompletionsBashSequence(e, t, i, s) {
    if (!e.element)
      return;
    let c = parseInt(s[0]);
    const l = parseInt(s[1]);
    if (!s[2]) {
      this._onBell.fire();
      return;
    }
    const n = t.slice(i.length + s[0].length + s[1].length + s[2].length + 4).split(";");
    let r;
    if (c !== 100 && n.length > 0 ? r = n.map((f) => new us({
      label: f,
      icon: te.symbolProperty
    })) : (c = 0, this._cachedFirstWord || (this._cachedFirstWord = [
      ...this._cachedBashAliases,
      ...this._cachedBashBuiltins,
      ...this._cachedBashCommands,
      ...this._cachedBashKeywords
    ], this._cachedFirstWord.sort((f, m) => {
      const C = f.completion.label.charCodeAt(0), b = m.completion.label.charCodeAt(0), p = C < 65 || C > 90 && C < 97 || C > 122 ? 1 : 0, S = b < 65 || b > 90 && b < 97 || b > 122 ? 1 : 0;
      return p !== S ? p - S : f.completion.label.localeCompare(m.completion.label);
    })), r = this._cachedFirstWord), r.length === 0)
      return;
    this._leadingLineContent = r[0].completion.label.slice(0, l);
    const a = new ko(r, new ms(this._leadingLineContent, c), c, l);
    if (r.length === 1 && r[0].completion.label.substring(l).length === 0) {
      this._onBell.fire();
      return;
    }
    this._handleCompletionModel(a);
  }
  _handleCompletionModel(e) {
    var n;
    if (e.items.length === 0 || !((n = this._terminal) != null && n.element))
      return;
    if (e.items.length === 1) {
      this.acceptSelectedSuggestion({
        item: e.items[0],
        model: e
      });
      return;
    }
    const t = this._ensureSuggestWidget(this._terminal);
    this._additionalInput = void 0;
    const i = {
      width: this._terminal._core._renderService.dimensions.device.cell.width,
      height: this._terminal._core._renderService.dimensions.device.cell.height
    };
    if (!i.width || !i.height)
      return;
    const s = this._terminal.element.getBoundingClientRect(), l = as(this._container, "panel").offsetParent.getBoundingClientRect();
    if (t.showSuggestions(e, 0, !1, !1, {
      left: s.left - l.left + this._terminal.buffer.active.cursorX * i.width,
      top: s.top - l.top + this._terminal.buffer.active.cursorY * i.height,
      height: i.height
    }), this._inputQueue) {
      const r = this._inputQueue;
      this._inputQueue = void 0;
      for (const a of r)
        this._handleTerminalInput(a);
    }
  }
  _ensureSuggestWidget(e) {
    return this._terminalSuggestWidgetVisibleContextKey.set(!0), this._suggestWidget || (this._suggestWidget = this._register(this._instantiationService.createInstance(rr, as(this._container, "panel"), this._instantiationService.createInstance(ar), {})), this._suggestWidget.list.style(il({
      listInactiveFocusBackground: nl,
      listInactiveFocusOutline: sl
    })), this._suggestWidget.onDidSelect(async (t) => this.acceptSelectedSuggestion(t)), this._suggestWidget.onDidHide(() => this._terminalSuggestWidgetVisibleContextKey.set(!1)), this._suggestWidget.onDidShow(() => this._terminalSuggestWidgetVisibleContextKey.set(!0))), this._suggestWidget;
  }
  selectPreviousSuggestion() {
    var e;
    (e = this._suggestWidget) == null || e.selectPrevious();
  }
  selectPreviousPageSuggestion() {
    var e;
    (e = this._suggestWidget) == null || e.selectPreviousPage();
  }
  selectNextSuggestion() {
    var e;
    (e = this._suggestWidget) == null || e.selectNext();
  }
  selectNextPageSuggestion() {
    var e;
    (e = this._suggestWidget) == null || e.selectNextPage();
  }
  acceptSelectedSuggestion(e) {
    var t, i, s;
    e || (e = (t = this._suggestWidget) == null ? void 0 : t.getFocusedItem()), e && this._leadingLineContent && ((i = this._suggestWidget) == null || i.hide(), this._onAcceptedCompletion.fire([
      "\x1B[D".repeat(Math.max(e.model.replacementLength - this._cursorIndexStart + this._cursorIndexDelta, 0)),
      "\x1B[3~".repeat(((s = this._additionalInput) == null ? void 0 : s.length) ?? 0),
      "".repeat(e.model.replacementLength),
      e.item.completion.label
    ].join("")), this._enableWidget = !1, di(100).then((c) => this._enableWidget = !0));
  }
  hideSuggestWidget() {
    var e;
    (e = this._suggestWidget) == null || e.hide();
  }
  handleNonXtermData(e) {
    this._handleTerminalInput(e);
  }
  _handleTerminalInput(e) {
    var i, s, c, l, n;
    if (!this._terminal || !this._enableWidget || !this._terminalSuggestWidgetVisibleContextKey.get()) {
      e === "-" ? this._inputQueue = [] : (i = this._inputQueue) == null || i.push(e);
      return;
    }
    let t = !1;
    if (e === "" && this._additionalInput && this._additionalInput.length > 0 && this._cursorIndexDelta > 0 && (t = !0, this._additionalInput = this._additionalInput.substring(0, this._cursorIndexDelta-- - 1) + this._additionalInput.substring(this._cursorIndexDelta)), e === "\x1B[3~" && this._additionalInput && this._additionalInput.length > 0 && this._cursorIndexDelta < this._additionalInput.length - 1 && (t = !0, this._additionalInput = this._additionalInput.substring(0, this._cursorIndexDelta) + this._additionalInput.substring(this._cursorIndexDelta + 1)), e === "\x1B[D" && this._cursorIndexDelta > 0 && (t = !0, this._cursorIndexDelta--), e === "\x1B[C" && (t = !0, this._cursorIndexDelta += 1), e.match(/^[a-z0-9]$/i) && (t = !0, this._additionalInput === void 0 && (this._additionalInput = ""), this._additionalInput += e, this._cursorIndexDelta++), t) {
      if (this._terminalSuggestWidgetVisibleContextKey.get() && ((c = this._suggestWidget) == null || c.setLineContext(new ms(
        this._leadingLineContent + (this._additionalInput ?? ""),
        ((s = this._additionalInput) == null ? void 0 : s.length) ?? 0
      ))), ((l = this._suggestWidget._completionModel) == null ? void 0 : l.items.length) === 0) {
        this._additionalInput = void 0, this.hideSuggestWidget();
        return;
      }
      const r = {
        width: this._terminal._core._renderService.dimensions.device.cell.width,
        height: this._terminal._core._renderService.dimensions.device.cell.height
      };
      if (!r.width || !r.height)
        return;
      const a = this._terminal.element.getBoundingClientRect(), m = as(this._container, "panel").offsetParent.getBoundingClientRect();
      (n = this._suggestWidget) == null || n.showSuggestions(this._suggestWidget._completionModel, 0, !1, !1, {
        left: a.left - m.left + this._terminal.buffer.active.cursorX * r.width,
        top: a.top - m.top + this._terminal.buffer.active.cursorY * r.height,
        height: r.height
      });
    } else
      this._additionalInput = void 0, this.hideSuggestWidget();
  }
};
or = X([
  D(1, le)
], or);
let ar = class {
  constructor(e) {
    this._storageService = e, this._key = "terminal.integrated.suggestSize";
  }
  restore() {
    const e = this._storageService.get(this._key, 0) ?? "";
    try {
      const t = JSON.parse(e);
      if (Nt.is(t))
        return Nt.lift(t);
    } catch {
    }
  }
  store(e) {
    this._storageService.store(this._key, JSON.stringify(e), 0, 1);
  }
  reset() {
    this._storageService.remove(this._key, 0);
  }
};
ar = X([
  D(0, ti)
], ar);
let fs, _s, gs, ps, vs, Ss;
function Hd(h, e) {
  let t = e.getLine(h);
  if (!t)
    return { lineData: void 0, lineIndex: h };
  let i = t.translateToString(!0);
  for (; h > 0 && t.isWrapped && (t = e.getLine(--h), !!t); )
    i = t.translateToString(!1) + i;
  return { lineData: i, lineIndex: h };
}
var st;
let Di = (st = class extends Zt {
  get findResult() {
    return this._lastFindResult;
  }
  get isStdinDisabled() {
    return !!this.raw.options.disableStdin;
  }
  get markTracker() {
    return this._markNavigationAddon;
  }
  get shellIntegration() {
    return this._shellIntegrationAddon;
  }
  get suggestController() {
    return this._suggestAddon;
  }
  get textureAtlas() {
    var t, i;
    const e = ((t = this._webglAddon) == null ? void 0 : t.textureAtlas) || ((i = this._canvasAddon) == null ? void 0 : i.textureAtlas);
    if (e)
      return createImageBitmap(e);
  }
  get isFocused() {
    var e;
    return !!((e = this.raw.element) != null && e.contains(document.activeElement));
  }
  constructor(e, t, i, s, c, l, n, r, a, f, m, C, b, p, S, o, _, u) {
    super(), this._configHelper = t, this._backgroundColorProvider = c, this._capabilities = l, this._terminalSuggestWidgetVisibleContextKey = r, this._configurationService = f, this._instantiationService = m, this._logService = C, this._notificationService = b, this._storageService = p, this._themeService = S, this._telemetryService = o, this._clipboardService = _, this._attachedDisposables = this.add(new Zt()), this._onDidRequestRunCommand = new V(), this.onDidRequestRunCommand = this._onDidRequestRunCommand.event, this._onDidRequestFocus = new V(), this.onDidRequestFocus = this._onDidRequestFocus.event, this._onDidRequestSendText = new V(), this.onDidRequestSendText = this._onDidRequestSendText.event, this._onDidRequestFreePort = new V(), this.onDidRequestFreePort = this._onDidRequestFreePort.event, this._onDidChangeFindResults = new V(), this.onDidChangeFindResults = this._onDidChangeFindResults.event, this._onDidChangeSelection = new V(), this.onDidChangeSelection = this._onDidChangeSelection.event, this._onDidChangeFocus = new V(), this.onDidChangeFocus = this._onDidChangeFocus.event, this._onDidDispose = new V(), this.onDidDispose = this._onDidDispose.event;
    const d = this._configHelper.getFont(void 0, !0), v = this._configHelper.config, w = this._configurationService.getValue("editor");
    this.raw = this.add(new e({
      allowProposedApi: !0,
      cols: i,
      rows: s,
      altClickMovesCursor: v.altClickMovesCursor && w.multiCursorModifier === "alt",
      scrollback: v.scrollback,
      theme: this._getXtermTheme(),
      drawBoldTextInBrightColors: v.drawBoldTextInBrightColors,
      fontFamily: d.fontFamily,
      fontWeight: v.fontWeight,
      fontWeightBold: v.fontWeightBold,
      fontSize: d.fontSize,
      letterSpacing: d.letterSpacing,
      lineHeight: d.lineHeight,
      logLevel: Io(this._logService.getLevel()),
      logger: this._logService,
      minimumContrastRatio: v.minimumContrastRatio,
      tabStopWidth: v.tabStopWidth,
      cursorBlink: v.cursorBlinking,
      cursorStyle: v.cursorStyle === "line" ? "bar" : v.cursorStyle,
      cursorWidth: v.cursorWidth,
      macOptionIsMeta: v.macOptionIsMeta,
      macOptionClickForcesSelection: v.macOptionClickForcesSelection,
      rightClickSelectsWord: v.rightClickBehavior === "selectWord",
      fastScrollModifier: "alt",
      fastScrollSensitivity: v.fastScrollSensitivity,
      scrollSensitivity: v.mouseWheelScrollSensitivity,
      wordSeparator: v.wordSeparators,
      overviewRulerWidth: 10,
      smoothScrollDuration: v.smoothScrolling ? 125 : 0
    })), this._core = this.raw._core, this.add(this._configurationService.onDidChangeConfiguration(async (x) => {
      x.affectsConfiguration("terminal.integrated.gpuAcceleration") && (st._suggestedRendererType = void 0), (x.affectsConfiguration("terminal.integrated") || x.affectsConfiguration("editor.fastScrollSensitivity") || x.affectsConfiguration("editor.mouseWheelScrollSensitivity") || x.affectsConfiguration("editor.multiCursorModifier")) && this.updateConfig(), x.affectsConfiguration("terminal.integrated.unicodeVersion") && this._updateUnicodeVersion();
    })), this.add(this._themeService.onDidColorThemeChange((x) => this._updateTheme(x))), this.add(this._logService.onDidChangeLogLevel((x) => this.raw.options.logLevel = Io(x))), this.add(this.raw.onSelectionChange(() => {
      this._onDidChangeSelection.fire(), this.isFocused && this._anyFocusedTerminalHasSelection.set(this.raw.hasSelection());
    })), this._updateUnicodeVersion(), this._markNavigationAddon = this._instantiationService.createInstance(er, l), this.raw.loadAddon(this._markNavigationAddon), this._decorationAddon = this._instantiationService.createInstance(sr, this._capabilities), this._decorationAddon.onDidRequestRunCommand((x) => this._onDidRequestRunCommand.fire(x)), this.raw.loadAddon(this._decorationAddon), this._shellIntegrationAddon = new Ad(
      n,
      a,
      this._telemetryService,
      this._logService
    ), this.raw.loadAddon(this._shellIntegrationAddon), this._anyTerminalFocusContextKey = E.focusInAny.bindTo(u), this._anyFocusedTerminalHasSelection = E.textSelectedInFocused.bindTo(u), this._terminalSuggestWidgetVisibleContextKey && (this._suggestAddon = this._instantiationService.createInstance(or, this._terminalSuggestWidgetVisibleContextKey), this.raw.loadAddon(this._suggestAddon), this._suggestAddon.onAcceptedCompletion(async (x) => {
      this._onDidRequestFocus.fire(), this._onDidRequestSendText.fire(x);
    }));
  }
  *getBufferReverseIterator() {
    for (let e = this.raw.buffer.active.length; e >= 0; e--) {
      const { lineData: t, lineIndex: i } = Hd(e, this.raw.buffer.active);
      t && (e = i, yield t);
    }
  }
  async getContentsAsHtml() {
    if (!this._serializeAddon) {
      const e = await this._getSerializeAddonConstructor();
      this._serializeAddon = new e(), this.raw.loadAddon(this._serializeAddon);
    }
    return this._serializeAddon.serializeAsHTML();
  }
  async getSelectionAsHtml(e) {
    var i, s;
    if (!this._serializeAddon) {
      const c = await this._getSerializeAddonConstructor();
      this._serializeAddon = new c(), this.raw.loadAddon(this._serializeAddon);
    }
    if (e) {
      const c = (i = e.getOutput()) == null ? void 0 : i.length, l = (s = e.marker) == null ? void 0 : s.line;
      if (!c || !l)
        throw new Error(`No row ${l} or output length ${c} for command ${e}`);
      this.raw.select(0, l + 1, c - Math.floor(c / this.raw.cols));
    }
    const t = this._serializeAddon.serializeAsHTML({ onlySelection: !0 });
    return e && this.raw.clearSelection(), t;
  }
  attachToElement(e, t) {
    var c, l;
    const i = { enableGpu: !0, ...t };
    if (this._attached || this.raw.open(e), i.enableGpu && (this._shouldLoadWebgl() ? this._enableWebglRenderer() : this._shouldLoadCanvas() && this._enableCanvasRenderer()), !this.raw.element || !this.raw.textarea)
      throw new Error("xterm elements not set after open");
    const s = this._attachedDisposables;
    return s.clear(), s.add(he(this.raw.textarea, "focus", () => this._setFocused(!0))), s.add(he(this.raw.textarea, "blur", () => this._setFocused(!1))), s.add(he(this.raw.textarea, "focusout", () => this._setFocused(!1))), (c = this._suggestAddon) == null || c.setContainer(e), this._attached = { container: e, options: i }, (l = this._attached) == null ? void 0 : l.container.querySelector(".xterm-screen");
  }
  _setFocused(e) {
    this._onDidChangeFocus.fire(e), this._anyTerminalFocusContextKey.set(e), this._anyFocusedTerminalHasSelection.set(e && this.raw.hasSelection());
  }
  write(e) {
    this.raw.write(e);
  }
  resize(e, t) {
    this.raw.resize(e, t);
  }
  updateConfig() {
    var i;
    const e = this._configHelper.config;
    this.raw.options.altClickMovesCursor = e.altClickMovesCursor, this._setCursorBlink(e.cursorBlinking), this._setCursorStyle(e.cursorStyle), this._setCursorWidth(e.cursorWidth), this.raw.options.scrollback = e.scrollback, this.raw.options.drawBoldTextInBrightColors = e.drawBoldTextInBrightColors, this.raw.options.minimumContrastRatio = e.minimumContrastRatio, this.raw.options.tabStopWidth = e.tabStopWidth, this.raw.options.fastScrollSensitivity = e.fastScrollSensitivity, this.raw.options.scrollSensitivity = e.mouseWheelScrollSensitivity, this.raw.options.macOptionIsMeta = e.macOptionIsMeta;
    const t = this._configurationService.getValue("editor");
    this.raw.options.altClickMovesCursor = e.altClickMovesCursor && t.multiCursorModifier === "alt", this.raw.options.macOptionClickForcesSelection = e.macOptionClickForcesSelection, this.raw.options.rightClickSelectsWord = e.rightClickBehavior === "selectWord", this.raw.options.wordSeparator = e.wordSeparators, this.raw.options.customGlyphs = e.customGlyphs, this.raw.options.smoothScrollDuration = e.smoothScrolling ? 125 : 0, (i = this._attached) != null && i.options.enableGpu && (this._shouldLoadWebgl() ? this._enableWebglRenderer() : (this._disposeOfWebglRenderer(), this._shouldLoadCanvas() ? this._enableCanvasRenderer() : this._disposeOfCanvasRenderer()));
  }
  _shouldLoadWebgl() {
    return !rl && this._configHelper.config.gpuAcceleration === "auto" && st._suggestedRendererType === void 0 || this._configHelper.config.gpuAcceleration === "on";
  }
  _shouldLoadCanvas() {
    return this._configHelper.config.gpuAcceleration === "auto" && (st._suggestedRendererType === void 0 || st._suggestedRendererType === "canvas") || this._configHelper.config.gpuAcceleration === "canvas";
  }
  forceRedraw() {
    this.raw.clearTextureAtlas();
  }
  clearDecorations() {
    var e;
    (e = this._decorationAddon) == null || e.clearDecorations();
  }
  forceRefresh() {
    var e;
    (e = this._core.viewport) == null || e._innerRefresh();
  }
  forceUnpause() {
    var e;
    this._canvasAddon && ((e = this._core._renderService) == null || e._handleIntersectionChange({ intersectionRatio: 1 }), this.raw.refresh(0, this.raw.rows - 1));
  }
  async findNext(e, t) {
    return this._updateFindColors(t), (await this._getSearchAddon()).findNext(e, t);
  }
  async findPrevious(e, t) {
    return this._updateFindColors(t), (await this._getSearchAddon()).findPrevious(e, t);
  }
  _updateFindColors(e) {
    const t = this._themeService.getColorTheme(), i = t.getColor(na) || t.getColor(sa), s = t.getColor(ol), c = t.getColor(al), l = t.getColor(ia), n = t.getColor(cl), r = t.getColor(ll), a = t.getColor(hl);
    e.decorations = {
      activeMatchBackground: s == null ? void 0 : s.toString(),
      activeMatchBorder: (c == null ? void 0 : c.toString()) || "transparent",
      activeMatchColorOverviewRuler: (l == null ? void 0 : l.toString()) || "transparent",
      matchBackground: i ? n == null ? void 0 : n.blend(i).toString() : void 0,
      matchBorder: (r == null ? void 0 : r.toString()) || "transparent",
      matchOverviewRuler: (a == null ? void 0 : a.toString()) || "transparent"
    };
  }
  _getSearchAddon() {
    return this._searchAddonPromise || (this._searchAddonPromise = this._getSearchAddonConstructor().then((e) => (this._searchAddon = new e({ highlightLimit: 1e3 }), this.raw.loadAddon(this._searchAddon), this._searchAddon.onDidChangeResults((t) => {
      this._lastFindResult = t, this._onDidChangeFindResults.fire(t);
    }), this._searchAddon))), this._searchAddonPromise;
  }
  clearSearchDecorations() {
    var e;
    (e = this._searchAddon) == null || e.clearDecorations();
  }
  clearActiveSearchDecoration() {
    var e;
    (e = this._searchAddon) == null || e.clearActiveDecoration();
  }
  getFont() {
    return this._configHelper.getFont(this._core);
  }
  getLongestViewportWrappedLineLength() {
    let e = 0;
    for (let t = this.raw.buffer.active.length - 1; t >= this.raw.buffer.active.viewportY; t--) {
      const i = this._getWrappedLineCount(t, this.raw.buffer.active);
      e = Math.max(e, i.lineCount * this.raw.cols - i.endSpaces || 0), t = i.currentIndex;
    }
    return e;
  }
  _getWrappedLineCount(e, t) {
    var l;
    let i = t.getLine(e);
    if (!i)
      throw new Error("Could not get line");
    let s = e, c = 0;
    for (let n = Math.min(i.length, this.raw.cols) - 1; n >= 0 && !((l = i == null ? void 0 : i.getCell(n)) != null && l.getChars()); n--)
      c++;
    for (; i != null && i.isWrapped && s > 0; )
      s--, i = t.getLine(s);
    return { lineCount: e - s + 1, currentIndex: s, endSpaces: c };
  }
  scrollDownLine() {
    this.raw.scrollLines(1);
  }
  scrollDownPage() {
    this.raw.scrollPages(1);
  }
  scrollToBottom() {
    this.raw.scrollToBottom();
  }
  scrollUpLine() {
    this.raw.scrollLines(-1);
  }
  scrollUpPage() {
    this.raw.scrollPages(-1);
  }
  scrollToTop() {
    this.raw.scrollToTop();
  }
  clearBuffer() {
    var e, t;
    this.raw.clear(), (e = this._capabilities.get(2)) == null || e.handlePromptStart(), (t = this._capabilities.get(2)) == null || t.handleCommandStart();
  }
  hasSelection() {
    return this.raw.hasSelection();
  }
  clearSelection() {
    this.raw.clearSelection();
  }
  selectAll() {
    this.raw.focus(), this.raw.selectAll();
  }
  focus() {
    this.raw.focus();
  }
  async copySelection(e, t) {
    if (this.hasSelection() || e && t)
      if (e) {
        let s = function(c) {
          c.clipboardData.types.includes("text/plain") || c.clipboardData.setData("text/plain", (t == null ? void 0 : t.getOutput()) ?? ""), c.clipboardData.setData("text/html", i), c.preventDefault();
        };
        const i = await this.getSelectionAsHtml(t);
        document.addEventListener("copy", s), document.execCommand("copy"), document.removeEventListener("copy", s);
      } else
        await this._clipboardService.writeText(this.raw.getSelection());
    else
      this._notificationService.warn(g(
        "terminal.integrated.copySelection.noSelection",
        "The terminal has no selection to copy"
      ));
  }
  _setCursorBlink(e) {
    this.raw.options.cursorBlink !== e && (this.raw.options.cursorBlink = e, this.raw.refresh(0, this.raw.rows - 1));
  }
  _setCursorStyle(e) {
    this.raw.options.cursorStyle !== e && (this.raw.options.cursorStyle = e === "line" ? "bar" : e);
  }
  _setCursorWidth(e) {
    this.raw.options.cursorWidth !== e && (this.raw.options.cursorWidth = e);
  }
  async _enableWebglRenderer() {
    if (!this.raw.element || this._webglAddon)
      return;
    const e = await this._getWebglAddonConstructor();
    this._webglAddon = new e(), this._disposeOfCanvasRenderer();
    try {
      this.raw.loadAddon(this._webglAddon), this._logService.trace("Webgl was loaded"), this._webglAddon.onContextLoss(() => {
        this._logService.info("Webgl lost context, disposing of webgl renderer"), this._disposeOfWebglRenderer();
      }), this._refreshImageAddon();
    } catch (t) {
      this._logService.warn("Webgl could not be loaded. Falling back to the canvas renderer type.", t), !this._storageService.getBoolean("terminal.integrated.neverMeasureRenderTime", -1, !1) && this._configHelper.config.gpuAcceleration !== "off" && this._measureRenderTime(), st._suggestedRendererType = "canvas", this._disposeOfWebglRenderer(), this._enableCanvasRenderer();
    }
  }
  async _enableCanvasRenderer() {
    if (!this.raw.element || this._canvasAddon)
      return;
    const e = await this._getCanvasAddonConstructor();
    this._canvasAddon = new e(), this._disposeOfWebglRenderer();
    try {
      this.raw.loadAddon(this._canvasAddon), this._logService.trace("Canvas renderer was loaded");
    } catch (t) {
      this._logService.warn("Canvas renderer could not be loaded, falling back to dom renderer", t), !this._storageService.getBoolean("terminal.integrated.neverMeasureRenderTime", -1, !1) && this._configHelper.config.gpuAcceleration !== "off" && this._measureRenderTime(), st._suggestedRendererType = "dom", this._disposeOfCanvasRenderer();
    }
    this._refreshImageAddon();
  }
  async _getCanvasAddonConstructor() {
    return fs || (fs = (await import("./xterm-addon-canvas-4ff1ed60.js").then((e) => e.x).then((e) => e.default ?? e)).CanvasAddon), fs;
  }
  async _refreshImageAddon() {
    var e;
    if (this._configHelper.config.enableImages && (this._canvasAddon || this._webglAddon)) {
      if (!this._imageAddon) {
        const t = await this._getImageAddonConstructor();
        this._imageAddon = new t(), this.raw.loadAddon(this._imageAddon);
      }
    } else {
      try {
        (e = this._imageAddon) == null || e.dispose();
      } catch {
      }
      this._imageAddon = void 0;
    }
  }
  async _getImageAddonConstructor() {
    return _s || (_s = (await import("./xterm-addon-image-e19d7d98.js").then((e) => e.x).then((e) => e.default ?? e)).ImageAddon), _s;
  }
  async _getSearchAddonConstructor() {
    return gs || (gs = (await import("./xterm-addon-search-5c06b497.js").then((e) => e.x).then((e) => e.default ?? e)).SearchAddon), gs;
  }
  async _getUnicode11Constructor() {
    return vs || (vs = (await import("./xterm-addon-unicode11-2f062d3b.js").then((e) => e.x).then((e) => e.default ?? e)).Unicode11Addon), vs;
  }
  async _getWebglAddonConstructor() {
    return Ss || (Ss = (await import("./xterm-addon-webgl-1de9bb7a.js").then((e) => e.x).then((e) => e.default ?? e)).WebglAddon), Ss;
  }
  async _getSerializeAddonConstructor() {
    return ps || (ps = (await import("./xterm-addon-serialize-640fd937.js").then((e) => e.x).then((e) => e.default ?? e)).SerializeAddon), ps;
  }
  _disposeOfCanvasRenderer() {
    var e;
    try {
      (e = this._canvasAddon) == null || e.dispose();
    } catch {
    }
    this._canvasAddon = void 0, this._refreshImageAddon();
  }
  _disposeOfWebglRenderer() {
    var e;
    try {
      (e = this._webglAddon) == null || e.dispose();
    } catch {
    }
    this._webglAddon = void 0, this._refreshImageAddon();
  }
  async _measureRenderTime() {
    var c;
    const e = [];
    if (!((c = this._core._renderService) != null && c._renderer._renderLayers))
      return;
    const t = this._core._renderService._renderer._renderLayers[0], i = t == null ? void 0 : t.onGridChanged, s = () => {
      if (e.shift(), e.sort((n, r) => n - r)[Math.floor(e.length / 2)] > 50)
        if (this._configHelper.config.gpuAcceleration === "auto")
          st._suggestedRendererType = "dom", this.updateConfig();
        else {
          const n = [
            {
              label: g("yes", "Yes"),
              run: () => this._configurationService.updateValue("terminal.integrated.gpuAcceleration", "off", 2)
            },
            {
              label: g("no", "No"),
              run: () => {
              }
            },
            {
              label: g("dontShowAgain", "Don't Show Again"),
              isSecondary: !0,
              run: () => this._storageService.store("terminal.integrated.neverMeasureRenderTime", !0, -1, 1)
            }
          ];
          this._notificationService.prompt(Te.Warning, g(
            "terminal.slowRendering",
            "Terminal GPU acceleration appears to be slow on your computer. Would you like to switch to disable it which may improve performance? [Read more about terminal settings](https://code.visualstudio.com/docs/editor/integrated-terminal#_changing-how-the-terminal-is-rendered)."
          ), n);
        }
    };
    t.onGridChanged = (l, n, r) => {
      const a = performance.now();
      i.call(t, l, n, r), e.push(performance.now() - a), e.length === 20 && (s(), t.onGridChanged = i);
    };
  }
  _getXtermTheme(e) {
    var a, f, m, C, b, p, S, o, _, u, d, v, w, x, k, y;
    e || (e = this._themeService.getColorTheme());
    const t = e.getColor(dl), i = this._backgroundColorProvider.getBackgroundColor(e), s = e.getColor(ul) || t, c = e.getColor(ml) || i, l = e.getColor(fl), n = e.getColor(_l), r = e.getColor(gl) || void 0;
    return {
      background: i == null ? void 0 : i.toString(),
      foreground: t == null ? void 0 : t.toString(),
      cursor: s == null ? void 0 : s.toString(),
      cursorAccent: c == null ? void 0 : c.toString(),
      selectionBackground: l == null ? void 0 : l.toString(),
      selectionInactiveBackground: n == null ? void 0 : n.toString(),
      selectionForeground: r == null ? void 0 : r.toString(),
      black: (a = e.getColor(Re[0])) == null ? void 0 : a.toString(),
      red: (f = e.getColor(Re[1])) == null ? void 0 : f.toString(),
      green: (m = e.getColor(Re[2])) == null ? void 0 : m.toString(),
      yellow: (C = e.getColor(Re[3])) == null ? void 0 : C.toString(),
      blue: (b = e.getColor(Re[4])) == null ? void 0 : b.toString(),
      magenta: (p = e.getColor(Re[5])) == null ? void 0 : p.toString(),
      cyan: (S = e.getColor(Re[6])) == null ? void 0 : S.toString(),
      white: (o = e.getColor(Re[7])) == null ? void 0 : o.toString(),
      brightBlack: (_ = e.getColor(Re[8])) == null ? void 0 : _.toString(),
      brightRed: (u = e.getColor(Re[9])) == null ? void 0 : u.toString(),
      brightGreen: (d = e.getColor(Re[10])) == null ? void 0 : d.toString(),
      brightYellow: (v = e.getColor(Re[11])) == null ? void 0 : v.toString(),
      brightBlue: (w = e.getColor(Re[12])) == null ? void 0 : w.toString(),
      brightMagenta: (x = e.getColor(Re[13])) == null ? void 0 : x.toString(),
      brightCyan: (k = e.getColor(Re[14])) == null ? void 0 : k.toString(),
      brightWhite: (y = e.getColor(Re[15])) == null ? void 0 : y.toString()
    };
  }
  _updateTheme(e) {
    this.raw.options.theme = this._getXtermTheme(e);
  }
  refresh() {
    this._updateTheme(), this._decorationAddon.refreshLayouts();
  }
  async _updateUnicodeVersion() {
    if (!this._unicode11Addon && this._configHelper.config.unicodeVersion === "11") {
      const e = await this._getUnicode11Constructor();
      this._unicode11Addon = new e(), this.raw.loadAddon(this._unicode11Addon);
    }
    this.raw.unicode.activeVersion !== this._configHelper.config.unicodeVersion && (this.raw.unicode.activeVersion = this._configHelper.config.unicodeVersion);
  }
  _writeText(e) {
    this.raw.write(e);
  }
  dispose() {
    this._anyTerminalFocusContextKey.reset(), this._anyFocusedTerminalHasSelection.reset(), this._onDidDispose.fire(), super.dispose();
  }
}, st._suggestedRendererType = void 0, st);
Di.__decorator = X([
  ft(100)
], Di.prototype, "_refreshImageAddon", null);
Di = X([
  D(9, Se),
  D(10, le),
  D(11, Ot),
  D(12, Ee),
  D(13, ti),
  D(14, Me),
  D(15, Ni),
  D(16, $n),
  D(17, Fe)
], Di);
function Wd(h, e, t) {
  if (!h.charWidth || !h.charHeight)
    return null;
  const i = e * window.devicePixelRatio, s = h.charWidth * window.devicePixelRatio + h.letterSpacing, c = Math.max(Math.floor(i / s), 1), l = t * window.devicePixelRatio, n = Math.ceil(h.charHeight * window.devicePixelRatio), r = Math.floor(n * h.lineHeight);
  return { rows: Math.max(Math.floor(l / r), 1), cols: c };
}
function Io(h) {
  switch (h) {
    case vi.Trace:
    case vi.Debug:
      return "debug";
    case vi.Info:
      return "info";
    case vi.Warning:
      return "warn";
    case vi.Error:
      return "error";
    default:
      return "off";
  }
}
function Ha(h, e) {
  Zi.INSTANCE.registerTerminalContribution(h, e);
}
var cr;
(function(h) {
  function e() {
    return Zi.INSTANCE.getTerminalContributions();
  }
  h.getTerminalContributions = e;
})(cr || (cr = {}));
const Nn = class Nn {
  constructor() {
    this._terminalContributions = [];
  }
  registerTerminalContribution(e, t) {
    this._terminalContributions.push({ id: e, ctor: t });
  }
  getTerminalContributions() {
    return this._terminalContributions.slice(0);
  }
};
Nn.INSTANCE = new Nn();
let Zi = Nn;
Oe.add("terminal.contributions", Zi.INSTANCE);
class Nd {
  constructor(e) {
    this._process = e, this.type = 1, this._cwd = "", this._onDidChangeCwd = new V(), this.onDidChangeCwd = this._onDidChangeCwd.event;
  }
  async getCwd() {
    if (!this._process)
      return Promise.resolve("");
    const e = await this._process.getCwd();
    return e !== this._cwd && this._onDidChangeCwd.fire(e), this._cwd = e, this._cwd;
  }
}
class Vd {
  constructor(e, t) {
    this._totalDataLength = 0, this._entries = [{ cols: e, rows: t, data: [] }];
  }
  handleResize(e, t) {
    if (this._entries.length > 0 && this._entries[this._entries.length - 1].data.length === 0 && this._entries.pop(), this._entries.length > 0) {
      const i = this._entries[this._entries.length - 1];
      if (i.cols === e && i.rows === t)
        return;
      if (i.cols === 0 && i.rows === 0) {
        i.cols = e, i.rows = t;
        return;
      }
    }
    this._entries.push({ cols: e, rows: t, data: [] });
  }
  handleData(e) {
    for (this._entries[this._entries.length - 1].data.push(e), this._totalDataLength += e.length; this._totalDataLength > 1048576; ) {
      const i = this._entries[0], s = this._totalDataLength - 1048576;
      s >= i.data[0].length ? (this._totalDataLength -= i.data[0].length, i.data.shift(), i.data.length === 0 && this._entries.shift()) : (i.data[0] = i.data[0].substr(s), this._totalDataLength -= s);
    }
  }
  generateReplayEventSync() {
    return this._entries.forEach((e) => {
      e.data.length > 0 && (e.data = [e.data.join("")]);
    }), {
      events: this._entries.map(
        (e) => ({ cols: e.cols, rows: e.rows, data: e.data[0] ?? "" })
      ),
      commands: {
        isWindowsPty: !1,
        commands: []
      }
    };
  }
  async generateReplayEvent() {
    return this.generateReplayEventSync();
  }
}
let Hn = class {
  constructor(e, t, i, s, c) {
    this._diff = e, this._terminalId = t, this._collection = i, this._terminalService = s, this._extensionService = c, this.requiresAction = !0;
  }
  _getInfo(e) {
    const t = /* @__PURE__ */ new Set();
    wn(t, this._diff.added.values()), wn(t, this._diff.removed.values()), wn(t, this._diff.changed.values());
    let i = g(
      "extensionEnvironmentContributionInfoStale",
      "The following extensions want to relaunch the terminal to contribute to its environment:"
    );
    return i += Wa(this._collection, e, this._extensionService, t), i;
  }
  _getActions() {
    return [{
      label: g("relaunchTerminalLabel", "Relaunch terminal"),
      run: () => {
        var e;
        return (e = this._terminalService.getInstanceFromId(this._terminalId)) == null ? void 0 : e.relaunch();
      },
      commandId: "workbench.action.terminal.relaunch"
    }];
  }
  getStatus(e) {
    return {
      id: "relaunch-needed",
      severity: wt.Warning,
      icon: te.warning,
      tooltip: this._getInfo(e),
      hoverActions: this._getActions()
    };
  }
};
Hn = X([
  D(3, we),
  D(4, mt)
], Hn);
let ji = class {
  constructor(e, t, i) {
    this._collection = e, this._commandService = t, this._extensionService = i, this.requiresAction = !1;
  }
  _getInfo(e) {
    const t = /* @__PURE__ */ new Set();
    wn(t, this._collection.getVariableMap(e).values());
    let i = g(
      "extensionEnvironmentContributionInfoActive",
      "The following extensions have contributed to this terminal's environment:"
    );
    return i += Wa(this._collection, e, this._extensionService, t), i;
  }
  _getActions(e) {
    return [{
      label: g("showEnvironmentContributions", "Show environment contributions"),
      run: () => this._commandService.executeCommand("workbench.action.terminal.showEnvironmentContributions", e),
      commandId: "workbench.action.terminal.showEnvironmentContributions"
    }];
  }
  getStatus(e) {
    return {
      id: "env-var-info-changes-active",
      severity: wt.Info,
      tooltip: this._getInfo(e),
      hoverActions: this._getActions(e)
    };
  }
};
ji = X([
  D(1, dt),
  D(2, mt)
], ji);
function Wa(h, e, t, i) {
  const s = [`
`], c = h.getDescriptionMap(void 0), l = h.getDescriptionMap(e);
  for (const n of i) {
    const r = c.get(n);
    r && (s.push(`
- \`${bs(n, t)}\``), s.push(`: ${r}`));
    const a = l.get(n);
    if (a) {
      const f = r ? ` (${g("ScopedEnvironmentContributionInfo", "workspace")})` : "";
      s.push(`
- \`${bs(n, t)}${f}\``), s.push(`: ${a}`);
    }
    !r && !a && s.push(`
- \`${bs(n, t)}\``);
  }
  return s.join("");
}
function wn(h, e) {
  for (const t of e)
    for (const i of t)
      h.add(i.extensionIdentifier);
}
function bs(h, e) {
  var t;
  return ((t = e.extensions.find((i) => i.id === h)) == null ? void 0 : t.displayName) || h;
}
var At;
(function(h) {
  h[h.Replace = 1] = "Replace", h[h.Append = 2] = "Append", h[h.Prepend = 3] = "Prepend";
})(At || (At = {}));
const $d = /* @__PURE__ */ new Map([
  [At.Append, "APPEND"],
  [At.Prepend, "PREPEND"],
  [At.Replace, "REPLACE"]
]);
class Na {
  constructor(e) {
    this.collections = e, this.map = /* @__PURE__ */ new Map(), this.descriptionMap = /* @__PURE__ */ new Map(), e.forEach((t, i) => {
      this.populateDescriptionMap(t, i);
      const s = t.map.entries();
      let c = s.next();
      for (; !c.done; ) {
        const l = c.value[1], n = c.value[0];
        let r = this.map.get(n);
        if (r || (r = [], this.map.set(n, r)), r.length > 0 && r[0].type === At.Replace) {
          c = s.next();
          continue;
        }
        const a = {
          extensionIdentifier: i,
          value: l.value,
          type: l.type,
          scope: l.scope,
          variable: l.variable,
          options: l.options
        };
        a.scope || delete a.scope, r.unshift(a), c = s.next();
      }
    });
  }
  async applyToProcessEnvironment(e, t, i) {
    var c, l;
    let s;
    Le && (s = {}, Object.keys(e).forEach((n) => s[n.toLowerCase()] = n));
    for (const [n, r] of this.getVariableMap(t)) {
      const a = Le && s[n.toLowerCase()] || n;
      for (const f of r) {
        const m = i ? await i(f.value) : f.value;
        if (((c = f.options) == null ? void 0 : c.applyAtProcessCreation) ?? !0)
          switch (f.type) {
            case At.Append:
              e[a] = (e[a] || "") + m;
              break;
            case At.Prepend:
              e[a] = m + (e[a] || "");
              break;
            case At.Replace:
              e[a] = m;
              break;
          }
        if (((l = f.options) == null ? void 0 : l.applyAtShellIntegration) ?? !1) {
          const C = `VSCODE_ENV_${$d.get(f.type)}`;
          e[C] = (e[C] ? e[C] + ":" : "") + n + "=" + this._encodeColons(m);
        }
      }
    }
  }
  _encodeColons(e) {
    return e.replaceAll(":", "\\x3a");
  }
  diff(e, t) {
    const i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
    if (e.getVariableMap(t).forEach((l, n) => {
      const r = this.getVariableMap(t).get(n), a = Do(l, r);
      a && i.set(n, a);
    }), this.getVariableMap(t).forEach((l, n) => {
      const r = e.getVariableMap(t).get(n), a = Do(l, r);
      a && c.set(n, a);
    }), this.getVariableMap(t).forEach((l, n) => {
      const r = e.getVariableMap(t).get(n), a = Ud(l, r);
      a && s.set(n, a);
    }), !(i.size === 0 && s.size === 0 && c.size === 0))
      return { added: i, changed: s, removed: c };
  }
  getVariableMap(e) {
    const t = /* @__PURE__ */ new Map();
    for (const i of this.map.values()) {
      const s = i.filter((c) => To(c, e));
      s.length > 0 && t.set(s[0].variable, s);
    }
    return t;
  }
  getDescriptionMap(e) {
    const t = /* @__PURE__ */ new Map();
    for (const i of this.descriptionMap.values()) {
      const s = i.filter((c) => To(c, e, !0));
      for (const c of s)
        t.set(c.extensionIdentifier, c.description);
    }
    return t;
  }
  populateDescriptionMap(e, t) {
    if (!e.descriptionMap)
      return;
    const i = e.descriptionMap.entries();
    let s = i.next();
    for (; !s.done; ) {
      const c = s.value[1], l = s.value[0];
      let n = this.descriptionMap.get(l);
      n || (n = [], this.descriptionMap.set(l, n));
      const r = {
        extensionIdentifier: t,
        scope: c.scope,
        description: c.description
      };
      r.scope || delete r.scope, n.push(r), s = i.next();
    }
  }
}
function To(h, e, t = !1) {
  return h.scope ? !!(h.scope.workspaceFolder && (e != null && e.workspaceFolder) && h.scope.workspaceFolder.index === e.workspaceFolder.index) : t ? e === h.scope : !0;
}
function Do(h, e) {
  if (!e)
    return h;
  const t = /* @__PURE__ */ new Set();
  e.forEach((s) => t.add(s.extensionIdentifier));
  const i = [];
  return h.forEach((s) => {
    t.has(s.extensionIdentifier) || i.push(s);
  }), i.length === 0 ? void 0 : i;
}
function Ud(h, e) {
  if (!e)
    return;
  const t = /* @__PURE__ */ new Map();
  e.forEach((s) => t.set(s.extensionIdentifier, s));
  const i = [];
  return h.forEach((s) => {
    var l, n, r, a;
    const c = t.get(s.extensionIdentifier);
    c && (s.type !== c.type || s.value !== c.value || ((n = (l = s.scope) == null ? void 0 : l.workspaceFolder) == null ? void 0 : n.index) !== ((a = (r = c.scope) == null ? void 0 : r.workspaceFolder) == null ? void 0 : a.index)) && i.push(c);
  }), i.length === 0 ? void 0 : i;
}
function Gd(h, ...e) {
  const t = e.reduce((c, l) => (c[l] = !0, c), {}), i = [
    /^ELECTRON_.+$/,
    /^VSCODE_(?!(PORTABLE|SHELL_LOGIN|ENV_REPLACE|ENV_APPEND|ENV_PREPEND)).+$/,
    /^SNAP(|_.*)$/,
    /^GDK_PIXBUF_.+$/
  ];
  Object.keys(h).filter((c) => !t[c]).forEach((c) => {
    for (let l = 0; l < i.length; l++)
      if (c.search(i[l]) !== -1) {
        delete h[c];
        break;
      }
  });
}
function Eo(h, e) {
  if (e)
    if (Le)
      for (const t in e) {
        let i = t;
        for (const c in h)
          if (t.toLowerCase() === c.toLowerCase()) {
            i = c;
            break;
          }
        const s = e[t];
        s !== void 0 && Ao(h, i, s);
      }
    else
      Object.keys(e).forEach((t) => {
        const i = e[t];
        i !== void 0 && Ao(h, t, i);
      });
}
function Ao(h, e, t) {
  typeof t == "string" ? h[e] = t : delete h[e];
}
function zd(h, e, t, i) {
  h.TERM_PROGRAM = "vscode", e && (h.TERM_PROGRAM_VERSION = e), Kd(h, i) && (h.LANG = qd(t)), h.COLORTERM = "truecolor";
}
function Lo(h, e) {
  if (e)
    for (const t of Object.keys(e)) {
      const i = e[t];
      i != null && (h[t] = i);
    }
}
async function Po(h, e) {
  return await Promise.all(Object.entries(e).map(async ([t, i]) => {
    if (typeof i == "string")
      try {
        e[t] = await h(i);
      } catch {
        e[t] = i;
      }
  })), e;
}
function Kd(h, e) {
  if (e === "on")
    return !0;
  if (e === "auto") {
    const t = h.LANG;
    return !t || t.search(/\.UTF\-8$/) === -1 && t.search(/\.utf8$/) === -1 && t.search(/\.euc.+/) === -1;
  }
  return !1;
}
function qd(h) {
  const e = h ? h.split("-") : [], t = e.length;
  if (t === 0)
    return "en_US.UTF-8";
  if (t === 1) {
    const i = {
      af: "ZA",
      am: "ET",
      be: "BY",
      bg: "BG",
      ca: "ES",
      cs: "CZ",
      da: "DK",
      de: "DE",
      el: "GR",
      en: "US",
      es: "ES",
      et: "EE",
      eu: "ES",
      fi: "FI",
      fr: "FR",
      he: "IL",
      hr: "HR",
      hu: "HU",
      hy: "AM",
      is: "IS",
      it: "IT",
      ja: "JP",
      kk: "KZ",
      ko: "KR",
      lt: "LT",
      nl: "NL",
      no: "NO",
      pl: "PL",
      pt: "BR",
      ro: "RO",
      ru: "RU",
      sk: "SK",
      sl: "SI",
      sr: "YU",
      sv: "SE",
      tr: "TR",
      uk: "UA",
      zh: "CN"
    };
    e[0] in i && e.push(i[e[0]]);
  } else
    e[1] = e[1].toUpperCase();
  return e.join("_") + ".UTF-8";
}
async function jd(h, e, t, i, s, c) {
  if (h.cwd) {
    const n = typeof h.cwd == "object" ? h.cwd.fsPath : h.cwd, r = await Ro(n, t);
    return ir(r || n);
  }
  let l;
  return !h.ignoreConfigurationCwd && s && (t && (s = await Ro(s, t, c)), s && (Uo(s) ? l = s : i && (l = Ls(i.fsPath, s)))), l || (l = i ? i.fsPath : e || ""), ir(l);
}
async function Ro(h, e, t) {
  if (e)
    try {
      return await e(h);
    } catch (i) {
      t == null || t.error("Could not resolve terminal cwd", i);
      return;
    }
  return h;
}
function Xd(h, e, t) {
  if (t)
    return (i) => t.resolveWithEnvironment(e, h, i);
}
async function Yd(h, e, t, i, s, c) {
  const l = {};
  if (h.strictEnv)
    Lo(l, h.env);
  else {
    Lo(l, c);
    const n = { ...e };
    t && (n && await Po(t, n), h.env && await Po(t, h.env)), Gd(l, "VSCODE_IPC_HOOK_CLI"), Eo(l, n), Eo(l, h.env), zd(l, i, Yn, s);
  }
  return l;
}
async function Qd(h, e, t, i, s, c, l = Le) {
  let n;
  if (xi(h) ? n = h : (n = h.fsPath, l && c !== 1 ? n = n.replace(/\\/g, "/") : !l && c === 1 && (n = n.replace(/\//g, "\\"))), !e)
    return n;
  const r = n.includes(" "), a = n.includes("(") || n.includes(")"), f = Ii(e, ".exe"), m = f === "pwsh" || t === "pwsh" || f === "powershell" || t === "powershell";
  if (m && (r || n.includes("'")))
    return `& '${n.replace(/'/g, "''")}'`;
  if (a && m)
    return `& '${n}'`;
  if (c === 1) {
    if (i !== void 0)
      return i === "gitbash" ? Co(n.replace(/\\/g, "/")) : i === "wsl" ? (s == null ? void 0 : s.getWslPath(n, "win-to-unix")) || n : r ? `"${n}"` : n;
    const C = e.toLowerCase();
    return C.includes("wsl") || C.includes("bash.exe") && !C.toLowerCase().includes("git") ? (s == null ? void 0 : s.getWslPath(n, "win-to-unix")) || n : r ? `"${n}"` : n;
  }
  return Co(n);
}
function lr(h, e, t) {
  const i = typeof h == "string" ? oe.parse(h) : h;
  let s = i ? Pt(e.getWorkspaceFolder(i)) : void 0;
  if (!s) {
    const c = t.getLastActiveWorkspaceRoot();
    s = c ? Pt(e.getWorkspaceFolder(c)) : void 0;
  }
  return s;
}
let hr = class extends ue {
  get persistentProcessId() {
    var e;
    return (e = this._process) == null ? void 0 : e.id;
  }
  get shouldPersist() {
    return !!this.reconnectionProperties || (this._process ? this._process.shouldPersist : !1);
  }
  get hasWrittenData() {
    return this._hasWrittenData;
  }
  get hasChildProcesses() {
    return this._hasChildProcesses;
  }
  get reconnectionProperties() {
    var e, t, i;
    return ((t = (e = this._shellLaunchConfig) == null ? void 0 : e.attachPersistentProcess) == null ? void 0 : t.reconnectionProperties) || ((i = this._shellLaunchConfig) == null ? void 0 : i.reconnectionProperties) || void 0;
  }
  get extEnvironmentVariableCollection() {
    return this._extEnvironmentVariableCollection;
  }
  constructor(e, t, i, s, c, l, n, r, a, f, m, C, b, p, S, o, _, u, d, v) {
    super(), this._instanceId = e, this._configHelper = t, this._historyService = l, this._instantiationService = n, this._logService = r, this._workspaceContextService = a, this._configurationResolverService = f, this._workbenchEnvironmentService = m, this._productService = C, this._remoteAgentService = b, this._pathService = p, this._environmentVariableService = S, this._terminalProfileResolverService = o, this._configurationService = _, this._terminalInstanceService = u, this._telemetryService = d, this._notificationService = v, this.processState = 1, this.capabilities = new io(), this._isDisposed = !1, this._process = null, this._processType = 0, this._preLaunchInputQueue = [], this._hasWrittenData = !1, this._hasChildProcesses = !1, this._ptyListenersAttached = !1, this._isDisconnected = !1, this._dimensions = { cols: 0, rows: 0 }, this._onPtyDisconnect = this._register(new V()), this.onPtyDisconnect = this._onPtyDisconnect.event, this._onPtyReconnect = this._register(new V()), this.onPtyReconnect = this._onPtyReconnect.event, this._onProcessReady = this._register(new V()), this.onProcessReady = this._onProcessReady.event, this._onProcessStateChange = this._register(new V()), this.onProcessStateChange = this._onProcessStateChange.event, this._onBeforeProcessData = this._register(new V()), this.onBeforeProcessData = this._onBeforeProcessData.event, this._onProcessData = this._register(new V()), this.onProcessData = this._onProcessData.event, this._onProcessReplayComplete = this._register(new V()), this.onProcessReplayComplete = this._onProcessReplayComplete.event, this._onDidChangeProperty = this._register(new V()), this.onDidChangeProperty = this._onDidChangeProperty.event, this._onEnvironmentVariableInfoChange = this._register(new V()), this.onEnvironmentVariableInfoChanged = this._onEnvironmentVariableInfoChange.event, this._onProcessExit = this._register(new V()), this.onProcessExit = this._onProcessExit.event, this._onRestoreCommands = this._register(new V()), this.onRestoreCommands = this._onRestoreCommands.event, this._cwdWorkspaceFolder = lr(i, this._workspaceContextService, this._historyService), this.ptyProcessReady = this._createPtyProcessReadyPromise(), this._ackDataBufferer = new Jd((w) => {
      var x;
      return (x = this._process) == null ? void 0 : x.acknowledgeDataEvent(w);
    }), this._dataFilter = this._instantiationService.createInstance(dr), this._dataFilter.onProcessData((w) => {
      const k = { data: typeof w == "string" ? w : w.data };
      this._onBeforeProcessData.fire(k), k.data && k.data.length > 0 && (typeof w != "string" && (w.data = k.data), this._onProcessData.fire(typeof w != "string" ? w : { data: k.data, trackCommit: !1 }));
    }), i && typeof i == "object" ? this.remoteAuthority = pl(i) : this.remoteAuthority = this._workbenchEnvironmentService.remoteAuthority, s && (this._extEnvironmentVariableCollection = new Na(s), this._register(this._environmentVariableService.onDidChangeCollections((w) => this._onEnvironmentVariableCollectionChange(w))), this.environmentVariableInfo = this._instantiationService.createInstance(ji, this._extEnvironmentVariableCollection), this._onEnvironmentVariableInfoChange.fire(this.environmentVariableInfo)), this.shellIntegrationNonce = c ?? vl();
  }
  async freePortKillProcess(e) {
    var t, i;
    try {
      (t = this._process) != null && t.freePortKillProcess && await ((i = this._process) == null ? void 0 : i.freePortKillProcess(e));
    } catch (s) {
      this._notificationService.notify({ message: g(
        "killportfailure",
        "Could not kill process listening on port {0}, command exited with error {1}",
        e,
        s
      ), severity: wt.Warning });
    }
  }
  dispose(e = !1) {
    this._isDisposed = !0, this._process && (this._setProcessState(5), this._process.shutdown(e), this._process = null), super.dispose();
  }
  _createPtyProcessReadyPromise() {
    return new Promise((e) => {
      const t = this.onProcessReady(() => {
        this._logService.debug(`Terminal process ready (shellProcessId: ${this.shellProcessId})`), t.dispose(), e(void 0);
      });
    });
  }
  async detachFromProcess(e) {
    var t, i;
    await ((i = (t = this._process) == null ? void 0 : t.detach) == null ? void 0 : i.call(t, e)), this._process = null;
  }
  async createProcess(e, t, i, s = !0) {
    var n, r;
    this._shellLaunchConfig = e, this._dimensions.cols = t, this._dimensions.rows = i;
    let c;
    if (e.customPtyImplementation)
      this._processType = 1, c = e.customPtyImplementation(this._instanceId, t, i);
    else {
      const a = await this._terminalInstanceService.getBackend(this.remoteAuthority);
      if (!a)
        throw new Error(`No terminal backend registered for remote authority '${this.remoteAuthority}'`);
      this.backend = a;
      const f = Xd(this._cwdWorkspaceFolder, await this._terminalProfileResolverService.getEnvironment(this.remoteAuthority), this._configurationResolverService);
      if (this.userHome = (n = this._pathService.resolvedUserHome) == null ? void 0 : n.fsPath, this.os = Lt, this.remoteAuthority) {
        const m = await this._pathService.userHome();
        this.userHome = m.path;
        const C = await this._remoteAgentService.getEnvironment();
        if (!C)
          throw new Error(`Failed to get remote environment for remote authority "${this.remoteAuthority}"`);
        this.userHome = C.userHome.path, this.os = C.os;
        const b = await this._resolveEnvironment(a, f, e), p = (this._configurationService.getValue("task.reconnection") && e.reconnectionProperties || !e.isFeatureTerminal) && this._configHelper.config.enablePersistentSessions && !e.isTransient;
        if (e.attachPersistentProcess) {
          const S = await a.attachToProcess(e.attachPersistentProcess.id);
          S ? c = S : (this._logService.warn("Attach to process failed for terminal", e.attachPersistentProcess), e.attachPersistentProcess = void 0);
        }
        if (!c) {
          await this._terminalProfileResolverService.resolveShellLaunchConfig(e, {
            remoteAuthority: this.remoteAuthority,
            os: this.os
          });
          const S = {
            shellIntegration: {
              enabled: this._configurationService.getValue("terminal.integrated.shellIntegration.enabled"),
              suggestEnabled: this._configurationService.getValue("terminal.integrated.shellIntegration.suggestEnabled"),
              nonce: this.shellIntegrationNonce
            },
            windowsEnableConpty: this._configHelper.config.windowsEnableConpty,
            environmentVariableCollections: (r = this._extEnvironmentVariableCollection) != null && r.collections ? oo(this._extEnvironmentVariableCollection.collections) : void 0,
            workspaceFolder: this._cwdWorkspaceFolder
          };
          try {
            c = await a.createProcess(
              e,
              "",
              t,
              i,
              this._configHelper.config.unicodeVersion,
              b,
              S,
              p
            );
          } catch (o) {
            if ((o == null ? void 0 : o.message) === "Could not fetch remote environment") {
              this._logService.trace("Could not fetch remote environment, silently failing");
              return;
            }
            throw o;
          }
        }
        this._isDisposed || this._setupPtyHostListeners(a);
      } else {
        if (e.attachPersistentProcess) {
          const m = e.attachPersistentProcess.findRevivedId ? await a.attachToRevivedProcess(e.attachPersistentProcess.id) : await a.attachToProcess(e.attachPersistentProcess.id);
          m ? c = m : (this._logService.warn("Attach to process failed for terminal", e.attachPersistentProcess), e.attachPersistentProcess = void 0);
        }
        c || (c = await this._launchLocalProcess(a, e, t, i, this.userHome, f)), this._isDisposed || this._setupPtyHostListeners(a);
      }
    }
    if (this._isDisposed) {
      c.shutdown(!1);
      return;
    }
    this._process = c, this._setProcessState(2), (this.os === 3 || this.os === 2) && this.capabilities.add(1, new Nd(this._process)), this._dataFilter.newProcess(this._process, s), this._processListeners && ye(this._processListeners), this._processListeners = [
      c.onProcessReady((a) => {
        this.shellProcessId = a.pid, this._initialCwd = a.cwd, this._onDidChangeProperty.fire({ type: "initialCwd", value: this._initialCwd }), this._onProcessReady.fire(a), this._preLaunchInputQueue.length > 0 && this._process && (c.input(this._preLaunchInputQueue.join("")), this._preLaunchInputQueue.length = 0);
      }),
      c.onProcessExit((a) => this._onExit(a)),
      c.onDidChangeProperty(({ type: a, value: f }) => {
        var m;
        switch (a) {
          case "hasChildProcesses":
            this._hasChildProcesses = f;
            break;
          case "failedShellIntegrationActivation":
            (m = this._telemetryService) == null || m.publicLog2("terminal/shellIntegrationActivationFailureCustomArgs");
            break;
        }
        this._onDidChangeProperty.fire({ type: a, value: f });
      })
    ], c.onProcessReplayComplete && this._processListeners.push(c.onProcessReplayComplete(() => this._onProcessReplayComplete.fire())), c.onRestoreCommands && this._processListeners.push(c.onRestoreCommands((a) => this._onRestoreCommands.fire(a))), setTimeout(() => {
      this.processState === 2 && this._setProcessState(3);
    }, 500);
    const l = await c.start();
    if (l)
      return l;
    Sl(() => {
      var a;
      (a = this.backend) == null || a.getLatency().then((f) => {
        this._logService.info(`Latency measurements for ${this.remoteAuthority ?? "local"} backend
${f.map((m) => `${m.label}: ${m.latency.toFixed(2)}ms`).join(`
`)}`);
      });
    });
  }
  async relaunch(e, t, i, s) {
    return this.ptyProcessReady = this._createPtyProcessReadyPromise(), this._logService.trace(`Relaunching terminal instance ${this._instanceId}`), this._isDisconnected && (this._isDisconnected = !1, this._onPtyReconnect.fire()), this._hasWrittenData = !1, this.createProcess(e, t, i, s);
  }
  async _resolveEnvironment(e, t, i) {
    const s = lr(i.cwd, this._workspaceContextService, this._historyService), c = Le ? "windows" : rt ? "osx" : "linux", l = this._configurationService.getValue(`terminal.integrated.env.${c}`);
    this._configHelper.showRecommendations(i);
    let n;
    i.useShellEnvironment ? n = await e.getShellEnvironment() : n = await this._terminalProfileResolverService.getEnvironment(this.remoteAuthority);
    const r = await Yd(i, l, t, this._productService.version, this._configHelper.config.detectLocale, n);
    return !this._isDisposed && !i.strictEnv && !i.hideFromUser && (this._extEnvironmentVariableCollection = this._environmentVariableService.mergedCollection, this._register(this._environmentVariableService.onDidChangeCollections((a) => this._onEnvironmentVariableCollectionChange(a))), await this._extEnvironmentVariableCollection.applyToProcessEnvironment(r, { workspaceFolder: s }, t), this._extEnvironmentVariableCollection.getVariableMap({ workspaceFolder: s }).size && (this.environmentVariableInfo = this._instantiationService.createInstance(ji, this._extEnvironmentVariableCollection), this._onEnvironmentVariableInfoChange.fire(this.environmentVariableInfo))), r;
  }
  async _launchLocalProcess(e, t, i, s, c, l) {
    await this._terminalProfileResolverService.resolveShellLaunchConfig(t, {
      remoteAuthority: void 0,
      os: Lt
    });
    const n = this._historyService.getLastActiveWorkspaceRoot(me.file), r = await jd(t, c, l, n, this._configHelper.config.cwd, this._logService), a = await this._resolveEnvironment(e, l, t), f = {
      shellIntegration: {
        enabled: this._configurationService.getValue("terminal.integrated.shellIntegration.enabled"),
        suggestEnabled: this._configurationService.getValue("terminal.integrated.shellIntegration.suggestEnabled"),
        nonce: this.shellIntegrationNonce
      },
      windowsEnableConpty: this._configHelper.config.windowsEnableConpty,
      environmentVariableCollections: this._extEnvironmentVariableCollection ? oo(this._extEnvironmentVariableCollection.collections) : void 0,
      workspaceFolder: this._cwdWorkspaceFolder
    }, m = (this._configurationService.getValue("task.reconnection") && t.reconnectionProperties || !t.isFeatureTerminal) && this._configHelper.config.enablePersistentSessions && !t.isTransient;
    return await e.createProcess(t, r, i, s, this._configHelper.config.unicodeVersion, a, f, m);
  }
  _setupPtyHostListeners(e) {
    this._ptyListenersAttached || (this._ptyListenersAttached = !0, this._register(e.onPtyHostUnresponsive(() => {
      this._isDisconnected = !0, this._onPtyDisconnect.fire();
    })), this._ptyResponsiveListener = e.onPtyHostResponsive(() => {
      this._isDisconnected = !1, this._onPtyReconnect.fire();
    }), this._register(je(() => {
      var t;
      return (t = this._ptyResponsiveListener) == null ? void 0 : t.dispose();
    })), this._register(e.onPtyHostRestart(async () => {
      var t;
      if (this._isDisconnected || (this._isDisconnected = !0, this._onPtyDisconnect.fire()), (t = this._ptyResponsiveListener) == null || t.dispose(), this._ptyResponsiveListener = void 0, this._shellLaunchConfig)
        if (this._shellLaunchConfig.isFeatureTerminal && !this.reconnectionProperties)
          this._onExit(-1);
        else {
          const i = g(
            "ptyHostRelaunch",
            "Restarting the terminal because the connection to the shell process was lost..."
          );
          this._onProcessData.fire({ data: yi(i, { loudFormatting: !0 }), trackCommit: !1 }), await this.relaunch(this._shellLaunchConfig, this._dimensions.cols, this._dimensions.rows, !1);
        }
    })));
  }
  async getBackendOS() {
    let e = Lt;
    if (this.remoteAuthority) {
      const t = await this._remoteAgentService.getEnvironment();
      if (!t)
        throw new Error(`Failed to get remote environment for remote authority "${this.remoteAuthority}"`);
      e = t.os;
    }
    return e;
  }
  setDimensions(e, t, i) {
    if (i) {
      this._resize(e, t);
      return;
    }
    return this.ptyProcessReady.then(() => this._resize(e, t));
  }
  async setUnicodeVersion(e) {
    var t;
    return (t = this._process) == null ? void 0 : t.setUnicodeVersion(e);
  }
  _resize(e, t) {
    if (this._process) {
      try {
        this._process.resize(e, t);
      } catch (i) {
        if (i.code !== "EPIPE" && i.code !== "ERR_IPC_CHANNEL_CLOSED")
          throw i;
      }
      this._dimensions.cols = e, this._dimensions.rows = t;
    }
  }
  async write(e) {
    await this.ptyProcessReady, this._dataFilter.disableSeamlessRelaunch(), this._hasWrittenData = !0, this.shellProcessId || this._processType === 1 ? this._process && this._process.input(e) : this._preLaunchInputQueue.push(e);
  }
  async processBinary(e) {
    var t;
    await this.ptyProcessReady, this._dataFilter.disableSeamlessRelaunch(), this._hasWrittenData = !0, (t = this._process) == null || t.processBinary(e);
  }
  get initialCwd() {
    return this._initialCwd ?? "";
  }
  async refreshProperty(e) {
    if (!this._process)
      throw new Error("Cannot refresh property when process is not set");
    return this._process.refreshProperty(e);
  }
  async updateProperty(e, t) {
    var i;
    return (i = this._process) == null ? void 0 : i.updateProperty(e, t);
  }
  acknowledgeDataEvent(e) {
    this._ackDataBufferer.ack(e);
  }
  _onExit(e) {
    this._process = null, this.processState === 2 && this._setProcessState(4), this.processState === 3 && this._setProcessState(6), this._onProcessExit.fire(e);
  }
  _setProcessState(e) {
    this.processState = e, this._onProcessStateChange.fire();
  }
  _onEnvironmentVariableCollectionChange(e) {
    const t = this._extEnvironmentVariableCollection.diff(e, { workspaceFolder: this._cwdWorkspaceFolder });
    if (t === void 0) {
      this.environmentVariableInfo instanceof Hn && (this.environmentVariableInfo = this._instantiationService.createInstance(ji, this._extEnvironmentVariableCollection), this._onEnvironmentVariableInfoChange.fire(this.environmentVariableInfo));
      return;
    }
    this.environmentVariableInfo = this._instantiationService.createInstance(Hn, t, this._instanceId, e), this._onEnvironmentVariableInfoChange.fire(this.environmentVariableInfo);
  }
  async clearBuffer() {
    var e, t;
    (t = (e = this._process) == null ? void 0 : e.clearBuffer) == null || t.call(e);
  }
};
hr = X([
  D(5, jn),
  D(6, le),
  D(7, Ot),
  D(8, tt),
  D(9, qn),
  D(10, Fi),
  D(11, Xn),
  D(12, Mt),
  D(13, ra),
  D(14, oa),
  D(15, ii),
  D(16, Se),
  D(17, yt),
  D(18, Ni),
  D(19, Ee)
], hr);
class Jd {
  constructor(e) {
    this._callback = e, this._unsentCharCount = 0;
  }
  ack(e) {
    for (this._unsentCharCount += e; this._unsentCharCount > 5e3; )
      this._unsentCharCount -= 5e3, this._callback(5e3);
  }
}
let dr = class extends ue {
  get onProcessData() {
    return this._onProcessData.event;
  }
  constructor(e) {
    super(), this._logService = e, this._disableSeamlessRelaunch = !1, this._onProcessData = this._register(new V());
  }
  newProcess(e, t) {
    var s, c, l, n, r;
    if ((s = this._dataListener) == null || s.dispose(), (c = this._activeProcess) == null || c.shutdown(!1), this._activeProcess = e, !this._firstRecorder || !t || this._disableSeamlessRelaunch) {
      (l = this._firstDisposable) == null || l.dispose(), [this._firstRecorder, this._firstDisposable] = this._createRecorder(e), this._disableSeamlessRelaunch && t && this._onProcessData.fire("\x1Bc"), this._dataListener = e.onProcessData((a) => this._onProcessData.fire(a)), this._disableSeamlessRelaunch = !1;
      return;
    }
    this._secondRecorder && this.triggerSwap(), this._swapTimeout = window.setTimeout(() => this.triggerSwap(), 3e3), (n = this._dataListener) == null || n.dispose(), (r = this._firstDisposable) == null || r.dispose();
    const i = this._createRecorder(e);
    [this._secondRecorder, this._secondDisposable] = i;
  }
  disableSeamlessRelaunch() {
    this._disableSeamlessRelaunch = !0, this._stopRecording(), this.triggerSwap();
  }
  triggerSwap() {
    var i, s, c;
    if (this._swapTimeout && (window.clearTimeout(this._swapTimeout), this._swapTimeout = void 0), !this._firstRecorder)
      return;
    if (!this._secondRecorder) {
      this._firstRecorder = void 0, (i = this._firstDisposable) == null || i.dispose();
      return;
    }
    const e = this._getDataFromRecorder(this._firstRecorder), t = this._getDataFromRecorder(this._secondRecorder);
    e === t ? this._logService.trace("Seamless terminal relaunch - identical content") : (this._logService.trace("Seamless terminal relaunch - resetting content"), this._onProcessData.fire({ data: `\x1Bc${t}`, trackCommit: !1 })), (s = this._dataListener) == null || s.dispose(), this._dataListener = this._activeProcess.onProcessData((l) => this._onProcessData.fire(l)), this._firstRecorder = this._secondRecorder, (c = this._firstDisposable) == null || c.dispose(), this._firstDisposable = this._secondDisposable, this._secondRecorder = void 0;
  }
  _stopRecording() {
    var e, t;
    this._swapTimeout || (this._firstRecorder = void 0, (e = this._firstDisposable) == null || e.dispose(), this._secondRecorder = void 0, (t = this._secondDisposable) == null || t.dispose());
  }
  _createRecorder(e) {
    const t = new Vd(0, 0), i = e.onProcessData((s) => t.handleData(typeof s == "string" ? s : s.data));
    return [t, i];
  }
  _getDataFromRecorder(e) {
    return e.generateReplayEventSync().events.filter((t) => !!t.data).map((t) => t.data).join("");
  }
};
dr = X([
  D(0, Ot)
], dr);
async function Cn(h, e, t, i, s, c) {
  var v;
  if (!e.xterm)
    return;
  const l = h.get(Bi), n = h.get(le), r = h.get(qe), a = h.get(ti), f = `terminal.pinnedRecentCommands.${e.shellType}`;
  let m, C = [];
  const b = /* @__PURE__ */ new Set(), p = {
    iconClass: re.asClassName(td),
    tooltip: g("removeCommand", "Remove from Command History")
  }, S = {
    iconClass: re.asClassName(id),
    tooltip: g("viewCommandOutput", "View Command Output"),
    alwaysVisible: !1
  };
  if (i === "command") {
    let y = function(O) {
      return O.replace(/\r?\n/g, "⏎").replace(/\s\s\s+/g, "⋯");
    };
    m = rt ? g(
      "selectRecentCommandMac",
      "Select a command to run (hold Option-key to edit the command)"
    ) : g(
      "selectRecentCommand",
      "Select a command to run (hold Alt-key to edit the command)"
    );
    const w = e.capabilities.get(2), x = w == null ? void 0 : w.commands, k = w == null ? void 0 : w.executingCommand;
    if (k && b.add(k), x && x.length > 0) {
      for (const O of x) {
        const U = O.command.trim();
        if (U.length === 0 || b.has(U))
          continue;
        let j = Ed(O.cwd, e.userHome, e.os === 1 ? "\\" : "/");
        O.exitCode && (O.exitCode === -1 ? j += " failed" : j += ` exitCode: ${O.exitCode}`), j = j.trim();
        const K = [S], T = C.length > 0 ? C[C.length - 1] : void 0;
        if ((T == null ? void 0 : T.type) !== "separator" && (T == null ? void 0 : T.label) === U) {
          T.id = O.timestamp.toString(), T.description = j;
          continue;
        }
        C.push({
          label: y(U),
          rawLabel: U,
          description: j,
          id: O.timestamp.toString(),
          command: O,
          buttons: O.hasOutput() ? K : void 0
        }), b.add(U);
      }
      C = C.reverse();
    }
    k && C.unshift({
      label: y(k),
      rawLabel: k,
      description: w.cwd
    }), C.length > 0 && C.unshift({ type: "separator", label: Q.currentSessionCategory });
    const I = n.invokeFunction(Ln), A = [];
    for (const [O, U] of I.entries)
      !b.has(O) && U.shellType === e.shellType && (A.unshift({
        label: y(O),
        rawLabel: O,
        buttons: [p]
      }), b.add(O));
    A.length > 0 && C.push({ type: "separator", label: Q.previousSessionCategory }, ...A);
    const M = await n.invokeFunction(ad, e.shellType), L = [];
    for (const O of M)
      b.has(O) || L.unshift({
        label: y(O),
        rawLabel: O
      });
    L.length > 0 && C.push({ type: "separator", label: g("shellFileHistoryCategory", "{0} history", e.shellType) }, ...L);
  } else {
    m = rt ? g(
      "selectRecentDirectoryMac",
      "Select a directory to go to (hold Option-key to edit the command)"
    ) : g(
      "selectRecentDirectory",
      "Select a directory to go to (hold Alt-key to edit the command)"
    );
    const w = ((v = e.capabilities.get(0)) == null ? void 0 : v.cwds) || [];
    if (w && w.length > 0) {
      for (const y of w)
        C.push({ label: y, rawLabel: y });
      C = C.reverse(), C.unshift({ type: "separator", label: Q.currentSessionCategory });
    }
    const x = n.invokeFunction(Os), k = [];
    for (const [y, I] of x.entries)
      (I === null || I.remoteAuthority === e.remoteAuthority) && !w.includes(y) && k.unshift({
        label: y,
        rawLabel: y,
        buttons: [p]
      });
    k.length > 0 && C.push({ type: "separator", label: Q.previousSessionCategory }, ...k);
  }
  if (C.length === 0)
    return;
  const o = new bl({
    title: "Fuzzy search",
    icon: nd,
    isChecked: s === "fuzzy",
    inputActiveOptionBorder: vn(wl),
    inputActiveOptionForeground: vn(Cl),
    inputActiveOptionBackground: vn(yl)
  });
  o.onChange(() => {
    n.invokeFunction(Cn, e, t, i, o.checked ? "fuzzy" : "contiguous", u.value);
  });
  const _ = n.createInstance(Wn), u = r.createQuickPick(), d = C;
  return u.items = [...d], u.sortByLabel = !1, u.placeholder = m, u.matchOnLabelMode = s || "contiguous", u.toggles = [o], u.onDidTriggerItemButton(async (w) => {
    var x, k;
    if (w.button === p)
      i === "command" ? (x = n.invokeFunction(Ln)) == null || x.remove(w.item.label) : (k = n.invokeFunction(Os)) == null || k.remove(w.item.label);
    else if (w.button === S) {
      const y = w.item.command, I = y == null ? void 0 : y.getOutput();
      if (I && (y != null && y.command)) {
        const A = await _.provideTextContent(oe.from({
          scheme: Wn.scheme,
          path: `${y.command}... ${Gi(y.timestamp, !0)}`,
          fragment: I,
          query: `terminal-output-${y.timestamp}-${e.instanceId}`
        }));
        A && await l.openEditor({
          resource: A.uri
        });
      }
    }
    await n.invokeFunction(Cn, e, t, i, s, c);
  }), u.onDidChangeValue(async (w) => {
    w || await n.invokeFunction(Cn, e, t, i, s, w);
  }), u.onDidAccept(async () => {
    const w = u.activeItems[0];
    let x;
    i === "cwd" ? x = `cd ${await e.preparePathForShell(w.rawLabel)}` : x = w.rawLabel, u.hide(), e.runCommand(x, !u.keyMods.alt), u.keyMods.alt && e.focus();
  }), c && (u.value = c), new Promise((w) => {
    t.set(!0), zh(a, f, u, !0), u.onDidHide(() => {
      t.set(!1), w();
    });
  });
}
var Ri;
let Wn = (Ri = class {
  constructor(e, t) {
    this._modelService = t, e.registerTextModelContentProvider(Ri.scheme, this);
  }
  async provideTextContent(e) {
    const t = this._modelService.getModel(e);
    return t && !t.isDisposed() ? t : this._modelService.createModel(e.fragment, null, e, !1);
  }
}, Ri.scheme = "TERMINAL_OUTPUT", Ri);
Wn = X([
  D(0, qo),
  D(1, Kn)
], Wn);
let ur = class extends ue {
  get onDidAddStatus() {
    return this._onDidAddStatus.event;
  }
  get onDidRemoveStatus() {
    return this._onDidRemoveStatus.event;
  }
  get onDidChangePrimaryStatus() {
    return this._onDidChangePrimaryStatus.event;
  }
  constructor(e) {
    super(), this._configurationService = e, this._statuses = /* @__PURE__ */ new Map(), this._statusTimeouts = /* @__PURE__ */ new Map(), this._onDidAddStatus = this._register(new V()), this._onDidRemoveStatus = this._register(new V()), this._onDidChangePrimaryStatus = this._register(new V());
  }
  get primary() {
    let e;
    for (const t of this._statuses.values())
      (!e || t.severity >= e.severity) && (e = t);
    return e;
  }
  get statuses() {
    return Array.from(this._statuses.values());
  }
  add(e, t) {
    e = this._applyAnimationSetting(e);
    const i = this._statusTimeouts.get(e.id);
    if (i && (window.clearTimeout(i), this._statusTimeouts.delete(e.id)), t && t > 0) {
      const c = window.setTimeout(() => this.remove(e), t);
      this._statusTimeouts.set(e.id, c);
    }
    const s = this._statuses.get(e.id);
    if (s && s !== e && (this._onDidRemoveStatus.fire(s), this._statuses.delete(s.id)), !this._statuses.has(e.id)) {
      const c = this.primary;
      this._statuses.set(e.id, e), this._onDidAddStatus.fire(e);
      const l = this.primary;
      c !== l && this._onDidChangePrimaryStatus.fire(l);
    }
  }
  remove(e) {
    var i;
    const t = typeof e == "string" ? this._statuses.get(e) : e;
    if (t && this._statuses.get(t.id)) {
      const s = ((i = this.primary) == null ? void 0 : i.id) === t.id;
      this._statuses.delete(t.id), this._onDidRemoveStatus.fire(t), s && this._onDidChangePrimaryStatus.fire(this.primary);
    }
  }
  toggle(e, t) {
    t ? this.add(e) : this.remove(e);
  }
  _applyAnimationSetting(e) {
    if (!e.icon || re.getModifier(e.icon) !== "spin" || this._configurationService.getValue("terminal.integrated.tabs.enableAnimation"))
      return e;
    let t;
    return e.icon.id === xl.id ? t = te.play : t = re.modify(e.icon, void 0), {
      ...e,
      icon: t
    };
  }
};
ur = X([
  D(0, Se)
], ur);
function Va(h) {
  switch (h) {
    case wt.Error:
      return Il;
    case wt.Warning:
      return kl;
    default:
      return "";
  }
}
class Zd {
  constructor() {
    this._attached = /* @__PURE__ */ new Map();
  }
  attachToElement(e) {
    this._container || (this._container = document.createElement("div"), this._container.classList.add("terminal-widget-container"), e.appendChild(this._container));
  }
  dispose() {
    this._container && this._container.parentElement && (this._container.parentElement.removeChild(this._container), this._container = void 0);
  }
  attachWidget(e) {
    var t;
    if (this._container)
      return (t = this._attached.get(e.id)) == null || t.dispose(), e.attach(this._container), this._attached.set(e.id, e), {
        dispose: () => {
          this._attached.get(e.id) === e && (this._attached.delete(e.id), e.dispose());
        }
      };
  }
}
class eu extends ue {
  constructor(e) {
    super(), this._initializationPromise = e, this._isOsSet = !1, this._onLineData = this._register(new V()), this.onLineData = this._onLineData.event;
  }
  async activate(e) {
    this._xterm = e, await this._initializationPromise, this._register(e.onLineFeed(() => {
      const t = e.buffer, i = t.active.getLine(t.active.baseY + t.active.cursorY);
      i && !i.isWrapped && this._sendLineData(t.active, t.active.baseY + t.active.cursorY - 1);
    })), this._register(je(() => {
      const t = e.buffer;
      this._sendLineData(t.active, t.active.baseY + t.active.cursorY);
    }));
  }
  setOperatingSystem(e) {
    if (!(this._isOsSet || !this._xterm) && (this._isOsSet = !0, e === 1)) {
      const t = this._xterm;
      this._register(t.parser.registerCsiHandler({ final: "H" }, () => {
        const i = t.buffer;
        return this._sendLineData(i.active, i.active.baseY + i.active.cursorY), !1;
      }));
    }
  }
  _sendLineData(e, t) {
    let i = e.getLine(t);
    if (!i)
      return;
    let s = i.translateToString(!0);
    for (; t > 0 && i.isWrapped && (i = e.getLine(--t), !!i); )
      s = i.translateToString(!1) + s;
    this._onLineData.fire(s);
  }
}
var ws = { exports: {} }, Mo;
function tu() {
  return Mo || (Mo = 1, function(h, e) {
    (function(t, i) {
      h.exports = i();
    })(self, () => (() => {
      var t = { 4567: function(l, n, r) {
        var a = this && this.__decorate || function(d, v, w, x) {
          var k, y = arguments.length, I = y < 3 ? v : x === null ? x = Object.getOwnPropertyDescriptor(v, w) : x;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            I = Reflect.decorate(d, v, w, x);
          else
            for (var A = d.length - 1; A >= 0; A--)
              (k = d[A]) && (I = (y < 3 ? k(I) : y > 3 ? k(v, w, I) : k(v, w)) || I);
          return y > 3 && I && Object.defineProperty(v, w, I), I;
        }, f = this && this.__param || function(d, v) {
          return function(w, x) {
            v(w, x, d);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.AccessibilityManager = void 0;
        const m = r(9042), C = r(6114), b = r(9924), p = r(844), S = r(5596), o = r(4725), _ = r(3656);
        let u = class extends p.Disposable {
          constructor(d, v) {
            super(), this._terminal = d, this._renderService = v, this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = document.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = document.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = [];
            for (let w = 0; w < this._terminal.rows; w++)
              this._rowElements[w] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[w]);
            if (this._topBoundaryFocusListener = (w) => this._handleBoundaryFocus(w, 0), this._bottomBoundaryFocusListener = (w) => this._handleBoundaryFocus(w, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = document.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new b.TimeBasedDebouncer(this._announceCharacters.bind(this))), !this._terminal.element)
              throw new Error("Cannot enable accessibility before Terminal.open");
            this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._liveRegionDebouncer), this.register(this._terminal.onResize((w) => this._handleResize(w.rows))), this.register(this._terminal.onRender((w) => this._refreshRows(w.start, w.end))), this.register(this._terminal.onScroll(() => this._refreshRows())), this.register(this._terminal.onA11yChar((w) => this._handleChar(w))), this.register(this._terminal.onLineFeed(() => this._handleChar(`
`))), this.register(this._terminal.onA11yTab((w) => this._handleTab(w))), this.register(this._terminal.onKey((w) => this._handleKey(w.key))), this.register(this._terminal.onBlur(() => this._clearLiveRegion())), this.register(this._renderService.onDimensionsChange(() => this._refreshRowsDimensions())), this._screenDprMonitor = new S.ScreenDprMonitor(window), this.register(this._screenDprMonitor), this._screenDprMonitor.setListener(() => this._refreshRowsDimensions()), this.register((0, _.addDisposableDomListener)(window, "resize", () => this._refreshRowsDimensions())), this._refreshRows(), this.register((0, p.toDisposable)(() => {
              this._accessibilityContainer.remove(), this._rowElements.length = 0;
            }));
          }
          _handleTab(d) {
            for (let v = 0; v < d; v++)
              this._handleChar(" ");
          }
          _handleChar(d) {
            this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== d && (this._charsToAnnounce += d) : this._charsToAnnounce += d, d === `
` && (this._liveRegionLineCount++, this._liveRegionLineCount === 21 && (this._liveRegion.textContent += m.tooMuchOutput)), C.isMac && this._liveRegion.textContent && this._liveRegion.textContent.length > 0 && !this._liveRegion.parentNode && setTimeout(() => {
              this._accessibilityContainer.appendChild(this._liveRegion);
            }, 0));
          }
          _clearLiveRegion() {
            this._liveRegion.textContent = "", this._liveRegionLineCount = 0, C.isMac && this._liveRegion.remove();
          }
          _handleKey(d) {
            this._clearLiveRegion(), /\p{Control}/u.test(d) || this._charsToConsume.push(d);
          }
          _refreshRows(d, v) {
            this._liveRegionDebouncer.refresh(d, v, this._terminal.rows);
          }
          _announceCharacters() {
            this._charsToAnnounce.length !== 0 && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "");
          }
          _handleBoundaryFocus(d, v) {
            const w = d.target, x = this._rowElements[v === 0 ? 1 : this._rowElements.length - 2];
            if (w.getAttribute("aria-posinset") === (v === 0 ? "1" : `${this._terminal.buffer.lines.length}`) || d.relatedTarget !== x)
              return;
            let k, y;
            if (v === 0 ? (k = w, y = this._rowElements.pop(), this._rowContainer.removeChild(y)) : (k = this._rowElements.shift(), y = w, this._rowContainer.removeChild(k)), k.removeEventListener("focus", this._topBoundaryFocusListener), y.removeEventListener("focus", this._bottomBoundaryFocusListener), v === 0) {
              const I = this._createAccessibilityTreeNode();
              this._rowElements.unshift(I), this._rowContainer.insertAdjacentElement("afterbegin", I);
            } else {
              const I = this._createAccessibilityTreeNode();
              this._rowElements.push(I), this._rowContainer.appendChild(I);
            }
            this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(v === 0 ? -1 : 1), this._rowElements[v === 0 ? 1 : this._rowElements.length - 2].focus(), d.preventDefault(), d.stopImmediatePropagation();
          }
          _handleResize(d) {
            this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
            for (let v = this._rowContainer.children.length; v < this._terminal.rows; v++)
              this._rowElements[v] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[v]);
            for (; this._rowElements.length > d; )
              this._rowContainer.removeChild(this._rowElements.pop());
            this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();
          }
          _createAccessibilityTreeNode() {
            const d = document.createElement("div");
            return d.setAttribute("role", "listitem"), d.tabIndex = -1, this._refreshRowDimensions(d), d;
          }
          _refreshRowsDimensions() {
            if (this._renderService.dimensions.css.cell.height) {
              this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
              for (let d = 0; d < this._terminal.rows; d++)
                this._refreshRowDimensions(this._rowElements[d]);
            }
          }
          _refreshRowDimensions(d) {
            d.style.height = `${this._renderService.dimensions.css.cell.height}px`;
          }
        };
        u = a([f(1, o.IRenderService)], u), n.AccessibilityManager = u;
      }, 3614: (l, n) => {
        function r(C) {
          return C.replace(/\r?\n/g, "\r");
        }
        function a(C, b) {
          return b ? "\x1B[200~" + C + "\x1B[201~" : C;
        }
        function f(C, b, p) {
          C = a(C = r(C), p.decPrivateModes.bracketedPasteMode), p.triggerDataEvent(C, !0), b.value = "";
        }
        function m(C, b, p) {
          const S = p.getBoundingClientRect(), o = C.clientX - S.left - 10, _ = C.clientY - S.top - 10;
          b.style.width = "20px", b.style.height = "20px", b.style.left = `${o}px`, b.style.top = `${_}px`, b.style.zIndex = "1000", b.focus();
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.rightClickHandler = n.moveTextAreaUnderMouseCursor = n.paste = n.handlePasteEvent = n.copyHandler = n.bracketTextForPaste = n.prepareTextForTerminal = void 0, n.prepareTextForTerminal = r, n.bracketTextForPaste = a, n.copyHandler = function(C, b) {
          C.clipboardData && C.clipboardData.setData("text/plain", b.selectionText), C.preventDefault();
        }, n.handlePasteEvent = function(C, b, p) {
          C.stopPropagation(), C.clipboardData && f(C.clipboardData.getData("text/plain"), b, p);
        }, n.paste = f, n.moveTextAreaUnderMouseCursor = m, n.rightClickHandler = function(C, b, p, S, o) {
          m(C, b, p), o && S.rightClickSelect(C), b.value = S.selectionText, b.select();
        };
      }, 7239: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.ColorContrastCache = void 0;
        const a = r(1505);
        n.ColorContrastCache = class {
          constructor() {
            this._color = new a.TwoKeyMap(), this._css = new a.TwoKeyMap();
          }
          setCss(f, m, C) {
            this._css.set(f, m, C);
          }
          getCss(f, m) {
            return this._css.get(f, m);
          }
          setColor(f, m, C) {
            this._color.set(f, m, C);
          }
          getColor(f, m) {
            return this._color.get(f, m);
          }
          clear() {
            this._color.clear(), this._css.clear();
          }
        };
      }, 3656: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.addDisposableDomListener = void 0, n.addDisposableDomListener = function(r, a, f, m) {
          r.addEventListener(a, f, m);
          let C = !1;
          return { dispose: () => {
            C || (C = !0, r.removeEventListener(a, f, m));
          } };
        };
      }, 6465: function(l, n, r) {
        var a = this && this.__decorate || function(o, _, u, d) {
          var v, w = arguments.length, x = w < 3 ? _ : d === null ? d = Object.getOwnPropertyDescriptor(_, u) : d;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            x = Reflect.decorate(o, _, u, d);
          else
            for (var k = o.length - 1; k >= 0; k--)
              (v = o[k]) && (x = (w < 3 ? v(x) : w > 3 ? v(_, u, x) : v(_, u)) || x);
          return w > 3 && x && Object.defineProperty(_, u, x), x;
        }, f = this && this.__param || function(o, _) {
          return function(u, d) {
            _(u, d, o);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.Linkifier2 = void 0;
        const m = r(2585), C = r(8460), b = r(844), p = r(3656);
        let S = class extends b.Disposable {
          constructor(o) {
            super(), this._bufferService = o, this._linkProviders = [], this._linkCacheDisposables = [], this._isMouseOut = !0, this._wasResized = !1, this._activeLine = -1, this._onShowLinkUnderline = this.register(new C.EventEmitter()), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new C.EventEmitter()), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, b.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, b.toDisposable)(() => {
              this._lastMouseEvent = void 0;
            })), this.register(this._bufferService.onResize(() => {
              this._clearCurrentLink(), this._wasResized = !0;
            }));
          }
          get currentLink() {
            return this._currentLink;
          }
          registerLinkProvider(o) {
            return this._linkProviders.push(o), { dispose: () => {
              const _ = this._linkProviders.indexOf(o);
              _ !== -1 && this._linkProviders.splice(_, 1);
            } };
          }
          attachToDom(o, _, u) {
            this._element = o, this._mouseService = _, this._renderService = u, this.register((0, p.addDisposableDomListener)(this._element, "mouseleave", () => {
              this._isMouseOut = !0, this._clearCurrentLink();
            })), this.register((0, p.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, p.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, p.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)));
          }
          _handleMouseMove(o) {
            if (this._lastMouseEvent = o, !this._element || !this._mouseService)
              return;
            const _ = this._positionFromMouseEvent(o, this._element, this._mouseService);
            if (!_)
              return;
            this._isMouseOut = !1;
            const u = o.composedPath();
            for (let d = 0; d < u.length; d++) {
              const v = u[d];
              if (v.classList.contains("xterm"))
                break;
              if (v.classList.contains("xterm-hover"))
                return;
            }
            this._lastBufferCell && _.x === this._lastBufferCell.x && _.y === this._lastBufferCell.y || (this._handleHover(_), this._lastBufferCell = _);
          }
          _handleHover(o) {
            if (this._activeLine !== o.y || this._wasResized)
              return this._clearCurrentLink(), this._askForLink(o, !1), void (this._wasResized = !1);
            this._currentLink && this._linkAtPosition(this._currentLink.link, o) || (this._clearCurrentLink(), this._askForLink(o, !0));
          }
          _askForLink(o, _) {
            var u, d;
            this._activeProviderReplies && _ || ((u = this._activeProviderReplies) === null || u === void 0 || u.forEach((w) => {
              w == null || w.forEach((x) => {
                x.link.dispose && x.link.dispose();
              });
            }), this._activeProviderReplies = /* @__PURE__ */ new Map(), this._activeLine = o.y);
            let v = !1;
            for (const [w, x] of this._linkProviders.entries())
              _ ? !((d = this._activeProviderReplies) === null || d === void 0) && d.get(w) && (v = this._checkLinkProviderResult(w, o, v)) : x.provideLinks(o.y, (k) => {
                var y, I;
                if (this._isMouseOut)
                  return;
                const A = k == null ? void 0 : k.map((M) => ({ link: M }));
                (y = this._activeProviderReplies) === null || y === void 0 || y.set(w, A), v = this._checkLinkProviderResult(w, o, v), ((I = this._activeProviderReplies) === null || I === void 0 ? void 0 : I.size) === this._linkProviders.length && this._removeIntersectingLinks(o.y, this._activeProviderReplies);
              });
          }
          _removeIntersectingLinks(o, _) {
            const u = /* @__PURE__ */ new Set();
            for (let d = 0; d < _.size; d++) {
              const v = _.get(d);
              if (v)
                for (let w = 0; w < v.length; w++) {
                  const x = v[w], k = x.link.range.start.y < o ? 0 : x.link.range.start.x, y = x.link.range.end.y > o ? this._bufferService.cols : x.link.range.end.x;
                  for (let I = k; I <= y; I++) {
                    if (u.has(I)) {
                      v.splice(w--, 1);
                      break;
                    }
                    u.add(I);
                  }
                }
            }
          }
          _checkLinkProviderResult(o, _, u) {
            var d;
            if (!this._activeProviderReplies)
              return u;
            const v = this._activeProviderReplies.get(o);
            let w = !1;
            for (let x = 0; x < o; x++)
              this._activeProviderReplies.has(x) && !this._activeProviderReplies.get(x) || (w = !0);
            if (!w && v) {
              const x = v.find((k) => this._linkAtPosition(k.link, _));
              x && (u = !0, this._handleNewLink(x));
            }
            if (this._activeProviderReplies.size === this._linkProviders.length && !u)
              for (let x = 0; x < this._activeProviderReplies.size; x++) {
                const k = (d = this._activeProviderReplies.get(x)) === null || d === void 0 ? void 0 : d.find((y) => this._linkAtPosition(y.link, _));
                if (k) {
                  u = !0, this._handleNewLink(k);
                  break;
                }
              }
            return u;
          }
          _handleMouseDown() {
            this._mouseDownLink = this._currentLink;
          }
          _handleMouseUp(o) {
            if (!this._element || !this._mouseService || !this._currentLink)
              return;
            const _ = this._positionFromMouseEvent(o, this._element, this._mouseService);
            _ && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, _) && this._currentLink.link.activate(o, this._currentLink.link.text);
          }
          _clearCurrentLink(o, _) {
            this._element && this._currentLink && this._lastMouseEvent && (!o || !_ || this._currentLink.link.range.start.y >= o && this._currentLink.link.range.end.y <= _) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, b.disposeArray)(this._linkCacheDisposables));
          }
          _handleNewLink(o) {
            if (!this._element || !this._lastMouseEvent || !this._mouseService)
              return;
            const _ = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
            _ && this._linkAtPosition(o.link, _) && (this._currentLink = o, this._currentLink.state = { decorations: { underline: o.link.decorations === void 0 || o.link.decorations.underline, pointerCursor: o.link.decorations === void 0 || o.link.decorations.pointerCursor }, isHovered: !0 }, this._linkHover(this._element, o.link, this._lastMouseEvent), o.link.decorations = {}, Object.defineProperties(o.link.decorations, { pointerCursor: { get: () => {
              var u, d;
              return (d = (u = this._currentLink) === null || u === void 0 ? void 0 : u.state) === null || d === void 0 ? void 0 : d.decorations.pointerCursor;
            }, set: (u) => {
              var d, v;
              !((d = this._currentLink) === null || d === void 0) && d.state && this._currentLink.state.decorations.pointerCursor !== u && (this._currentLink.state.decorations.pointerCursor = u, this._currentLink.state.isHovered && ((v = this._element) === null || v === void 0 || v.classList.toggle("xterm-cursor-pointer", u)));
            } }, underline: { get: () => {
              var u, d;
              return (d = (u = this._currentLink) === null || u === void 0 ? void 0 : u.state) === null || d === void 0 ? void 0 : d.decorations.underline;
            }, set: (u) => {
              var d, v, w;
              !((d = this._currentLink) === null || d === void 0) && d.state && ((w = (v = this._currentLink) === null || v === void 0 ? void 0 : v.state) === null || w === void 0 ? void 0 : w.decorations.underline) !== u && (this._currentLink.state.decorations.underline = u, this._currentLink.state.isHovered && this._fireUnderlineEvent(o.link, u));
            } } }), this._renderService && this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange((u) => {
              if (!this._currentLink)
                return;
              const d = u.start === 0 ? 0 : u.start + 1 + this._bufferService.buffer.ydisp, v = this._bufferService.buffer.ydisp + 1 + u.end;
              if (this._currentLink.link.range.start.y >= d && this._currentLink.link.range.end.y <= v && (this._clearCurrentLink(d, v), this._lastMouseEvent && this._element)) {
                const w = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
                w && this._askForLink(w, !1);
              }
            })));
          }
          _linkHover(o, _, u) {
            var d;
            !((d = this._currentLink) === null || d === void 0) && d.state && (this._currentLink.state.isHovered = !0, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(_, !0), this._currentLink.state.decorations.pointerCursor && o.classList.add("xterm-cursor-pointer")), _.hover && _.hover(u, _.text);
          }
          _fireUnderlineEvent(o, _) {
            const u = o.range, d = this._bufferService.buffer.ydisp, v = this._createLinkUnderlineEvent(u.start.x - 1, u.start.y - d - 1, u.end.x, u.end.y - d - 1, void 0);
            (_ ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(v);
          }
          _linkLeave(o, _, u) {
            var d;
            !((d = this._currentLink) === null || d === void 0) && d.state && (this._currentLink.state.isHovered = !1, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(_, !1), this._currentLink.state.decorations.pointerCursor && o.classList.remove("xterm-cursor-pointer")), _.leave && _.leave(u, _.text);
          }
          _linkAtPosition(o, _) {
            const u = o.range.start.y * this._bufferService.cols + o.range.start.x, d = o.range.end.y * this._bufferService.cols + o.range.end.x, v = _.y * this._bufferService.cols + _.x;
            return u <= v && v <= d;
          }
          _positionFromMouseEvent(o, _, u) {
            const d = u.getCoords(o, _, this._bufferService.cols, this._bufferService.rows);
            if (d)
              return { x: d[0], y: d[1] + this._bufferService.buffer.ydisp };
          }
          _createLinkUnderlineEvent(o, _, u, d, v) {
            return { x1: o, y1: _, x2: u, y2: d, cols: this._bufferService.cols, fg: v };
          }
        };
        S = a([f(0, m.IBufferService)], S), n.Linkifier2 = S;
      }, 9042: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.tooMuchOutput = n.promptLabel = void 0, n.promptLabel = "Terminal input", n.tooMuchOutput = "Too much output to announce, navigate to rows manually to read";
      }, 3730: function(l, n, r) {
        var a = this && this.__decorate || function(S, o, _, u) {
          var d, v = arguments.length, w = v < 3 ? o : u === null ? u = Object.getOwnPropertyDescriptor(o, _) : u;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            w = Reflect.decorate(S, o, _, u);
          else
            for (var x = S.length - 1; x >= 0; x--)
              (d = S[x]) && (w = (v < 3 ? d(w) : v > 3 ? d(o, _, w) : d(o, _)) || w);
          return v > 3 && w && Object.defineProperty(o, _, w), w;
        }, f = this && this.__param || function(S, o) {
          return function(_, u) {
            o(_, u, S);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.OscLinkProvider = void 0;
        const m = r(511), C = r(2585);
        let b = class {
          constructor(S, o, _) {
            this._bufferService = S, this._optionsService = o, this._oscLinkService = _;
          }
          provideLinks(S, o) {
            var _;
            const u = this._bufferService.buffer.lines.get(S - 1);
            if (!u)
              return void o(void 0);
            const d = [], v = this._optionsService.rawOptions.linkHandler, w = new m.CellData(), x = u.getTrimmedLength();
            let k = -1, y = -1, I = !1;
            for (let A = 0; A < x; A++)
              if (y !== -1 || u.hasContent(A)) {
                if (u.loadCell(A, w), w.hasExtendedAttrs() && w.extended.urlId) {
                  if (y === -1) {
                    y = A, k = w.extended.urlId;
                    continue;
                  }
                  I = w.extended.urlId !== k;
                } else
                  y !== -1 && (I = !0);
                if (I || y !== -1 && A === x - 1) {
                  const M = (_ = this._oscLinkService.getLinkData(k)) === null || _ === void 0 ? void 0 : _.uri;
                  if (M) {
                    const L = { start: { x: y + 1, y: S }, end: { x: A + (I || A !== x - 1 ? 0 : 1), y: S } };
                    let O = !1;
                    if (!(v != null && v.allowNonHttpProtocols))
                      try {
                        const U = new URL(M);
                        ["http:", "https:"].includes(U.protocol) || (O = !0);
                      } catch {
                        O = !0;
                      }
                    O || d.push({ text: M, range: L, activate: (U, j) => v ? v.activate(U, j, L) : p(0, j), hover: (U, j) => {
                      var K;
                      return (K = v == null ? void 0 : v.hover) === null || K === void 0 ? void 0 : K.call(v, U, j, L);
                    }, leave: (U, j) => {
                      var K;
                      return (K = v == null ? void 0 : v.leave) === null || K === void 0 ? void 0 : K.call(v, U, j, L);
                    } });
                  }
                  I = !1, w.hasExtendedAttrs() && w.extended.urlId ? (y = A, k = w.extended.urlId) : (y = -1, k = -1);
                }
              }
            o(d);
          }
        };
        function p(S, o) {
          if (confirm(`Do you want to navigate to ${o}?

WARNING: This link could potentially be dangerous`)) {
            const _ = window.open();
            if (_) {
              try {
                _.opener = null;
              } catch {
              }
              _.location.href = o;
            } else
              console.warn("Opening link blocked as opener could not be cleared");
          }
        }
        b = a([f(0, C.IBufferService), f(1, C.IOptionsService), f(2, C.IOscLinkService)], b), n.OscLinkProvider = b;
      }, 6193: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.RenderDebouncer = void 0, n.RenderDebouncer = class {
          constructor(r, a) {
            this._parentWindow = r, this._renderCallback = a, this._refreshCallbacks = [];
          }
          dispose() {
            this._animationFrame && (this._parentWindow.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
          }
          addRefreshCallback(r) {
            return this._refreshCallbacks.push(r), this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh())), this._animationFrame;
          }
          refresh(r, a, f) {
            this._rowCount = f, r = r !== void 0 ? r : 0, a = a !== void 0 ? a : this._rowCount - 1, this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, r) : r, this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, a) : a, this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh()));
          }
          _innerRefresh() {
            if (this._animationFrame = void 0, this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0)
              return void this._runRefreshCallbacks();
            const r = Math.max(this._rowStart, 0), a = Math.min(this._rowEnd, this._rowCount - 1);
            this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(r, a), this._runRefreshCallbacks();
          }
          _runRefreshCallbacks() {
            for (const r of this._refreshCallbacks)
              r(0);
            this._refreshCallbacks = [];
          }
        };
      }, 5596: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.ScreenDprMonitor = void 0;
        const a = r(844);
        class f extends a.Disposable {
          constructor(C) {
            super(), this._parentWindow = C, this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this.register((0, a.toDisposable)(() => {
              this.clearListener();
            }));
          }
          setListener(C) {
            this._listener && this.clearListener(), this._listener = C, this._outerListener = () => {
              this._listener && (this._listener(this._parentWindow.devicePixelRatio, this._currentDevicePixelRatio), this._updateDpr());
            }, this._updateDpr();
          }
          _updateDpr() {
            var C;
            this._outerListener && ((C = this._resolutionMediaMatchList) === null || C === void 0 || C.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));
          }
          clearListener() {
            this._resolutionMediaMatchList && this._listener && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._listener = void 0, this._outerListener = void 0);
          }
        }
        n.ScreenDprMonitor = f;
      }, 3236: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.Terminal = void 0;
        const a = r(2950), f = r(1680), m = r(3614), C = r(2584), b = r(5435), p = r(9312), S = r(6114), o = r(3656), _ = r(9042), u = r(4567), d = r(1296), v = r(7399), w = r(8460), x = r(8437), k = r(3230), y = r(4725), I = r(428), A = r(8934), M = r(6465), L = r(5114), O = r(8969), U = r(8055), j = r(4269), K = r(5941), T = r(3107), P = r(5744), H = r(9074), N = r(2585), G = r(3730), Z = r(844), ae = r(6731), q = typeof window < "u" ? window.document : null;
        class ee extends O.CoreTerminal {
          constructor(F = {}) {
            super(F), this.browser = S, this._keyDownHandled = !1, this._keyDownSeen = !1, this._keyPressHandled = !1, this._unprocessedDeadKey = !1, this._onCursorMove = this.register(new w.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new w.EventEmitter()), this.onKey = this._onKey.event, this._onRender = this.register(new w.EventEmitter()), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new w.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new w.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new w.EventEmitter()), this.onBell = this._onBell.event, this._onFocus = this.register(new w.EventEmitter()), this._onBlur = this.register(new w.EventEmitter()), this._onA11yCharEmitter = this.register(new w.EventEmitter()), this._onA11yTabEmitter = this.register(new w.EventEmitter()), this._onWillOpen = this.register(new w.EventEmitter()), this._setup(), this.linkifier2 = this.register(this._instantiationService.createInstance(M.Linkifier2)), this.linkifier2.registerLinkProvider(this._instantiationService.createInstance(G.OscLinkProvider)), this._decorationService = this._instantiationService.createInstance(H.DecorationService), this._instantiationService.setService(N.IDecorationService, this._decorationService), this.register(this._inputHandler.onRequestBell(() => this._onBell.fire())), this.register(this._inputHandler.onRequestRefreshRows((B, $) => this.refresh(B, $))), this.register(this._inputHandler.onRequestSendFocus(() => this._reportFocus())), this.register(this._inputHandler.onRequestReset(() => this.reset())), this.register(this._inputHandler.onRequestWindowsOptionsReport((B) => this._reportWindowsOptions(B))), this.register(this._inputHandler.onColor((B) => this._handleColorEvent(B))), this.register((0, w.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, w.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, w.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, w.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize((B) => this._afterResize(B.cols, B.rows))), this.register((0, Z.toDisposable)(() => {
              var B, $;
              this._customKeyEventHandler = void 0, ($ = (B = this.element) === null || B === void 0 ? void 0 : B.parentNode) === null || $ === void 0 || $.removeChild(this.element);
            }));
          }
          get onFocus() {
            return this._onFocus.event;
          }
          get onBlur() {
            return this._onBlur.event;
          }
          get onA11yChar() {
            return this._onA11yCharEmitter.event;
          }
          get onA11yTab() {
            return this._onA11yTabEmitter.event;
          }
          get onWillOpen() {
            return this._onWillOpen.event;
          }
          _handleColorEvent(F) {
            if (this._themeService)
              for (const B of F) {
                let $, z = "";
                switch (B.index) {
                  case 256:
                    $ = "foreground", z = "10";
                    break;
                  case 257:
                    $ = "background", z = "11";
                    break;
                  case 258:
                    $ = "cursor", z = "12";
                    break;
                  default:
                    $ = "ansi", z = "4;" + B.index;
                }
                switch (B.type) {
                  case 0:
                    const ce = U.color.toColorRGB($ === "ansi" ? this._themeService.colors.ansi[B.index] : this._themeService.colors[$]);
                    this.coreService.triggerDataEvent(`${C.C0.ESC}]${z};${(0, K.toRgbString)(ce)}${C.C1_ESCAPED.ST}`);
                    break;
                  case 1:
                    if ($ === "ansi")
                      this._themeService.modifyColors((Y) => Y.ansi[B.index] = U.rgba.toColor(...B.color));
                    else {
                      const Y = $;
                      this._themeService.modifyColors((ke) => ke[Y] = U.rgba.toColor(...B.color));
                    }
                    break;
                  case 2:
                    this._themeService.restoreColor(B.index);
                }
              }
          }
          _setup() {
            super._setup(), this._customKeyEventHandler = void 0;
          }
          get buffer() {
            return this.buffers.active;
          }
          focus() {
            this.textarea && this.textarea.focus({ preventScroll: !0 });
          }
          _handleScreenReaderModeOptionChange(F) {
            var B;
            F ? !this._accessibilityManager && this._renderService && (this._accessibilityManager = this._instantiationService.createInstance(u.AccessibilityManager, this)) : ((B = this._accessibilityManager) === null || B === void 0 || B.dispose(), this._accessibilityManager = void 0);
          }
          _handleTextAreaFocus(F) {
            this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(C.C0.ESC + "[I"), this.updateCursorStyle(F), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire();
          }
          blur() {
            var F;
            return (F = this.textarea) === null || F === void 0 ? void 0 : F.blur();
          }
          _handleTextAreaBlur() {
            this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(C.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire();
          }
          _syncTextArea() {
            if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService)
              return;
            const F = this.buffer.ybase + this.buffer.y, B = this.buffer.lines.get(F);
            if (!B)
              return;
            const $ = Math.min(this.buffer.x, this.cols - 1), z = this._renderService.dimensions.css.cell.height, ce = B.getWidth($), Y = this._renderService.dimensions.css.cell.width * ce, ke = this.buffer.y * this._renderService.dimensions.css.cell.height, Pe = $ * this._renderService.dimensions.css.cell.width;
            this.textarea.style.left = Pe + "px", this.textarea.style.top = ke + "px", this.textarea.style.width = Y + "px", this.textarea.style.height = z + "px", this.textarea.style.lineHeight = z + "px", this.textarea.style.zIndex = "-5";
          }
          _initGlobal() {
            this._bindKeys(), this.register((0, o.addDisposableDomListener)(this.element, "copy", (B) => {
              this.hasSelection() && (0, m.copyHandler)(B, this._selectionService);
            }));
            const F = (B) => (0, m.handlePasteEvent)(B, this.textarea, this.coreService);
            this.register((0, o.addDisposableDomListener)(this.textarea, "paste", F)), this.register((0, o.addDisposableDomListener)(this.element, "paste", F)), S.isFirefox ? this.register((0, o.addDisposableDomListener)(this.element, "mousedown", (B) => {
              B.button === 2 && (0, m.rightClickHandler)(B, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
            })) : this.register((0, o.addDisposableDomListener)(this.element, "contextmenu", (B) => {
              (0, m.rightClickHandler)(B, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
            })), S.isLinux && this.register((0, o.addDisposableDomListener)(this.element, "auxclick", (B) => {
              B.button === 1 && (0, m.moveTextAreaUnderMouseCursor)(B, this.textarea, this.screenElement);
            }));
          }
          _bindKeys() {
            this.register((0, o.addDisposableDomListener)(this.textarea, "keyup", (F) => this._keyUp(F), !0)), this.register((0, o.addDisposableDomListener)(this.textarea, "keydown", (F) => this._keyDown(F), !0)), this.register((0, o.addDisposableDomListener)(this.textarea, "keypress", (F) => this._keyPress(F), !0)), this.register((0, o.addDisposableDomListener)(this.textarea, "compositionstart", () => this._compositionHelper.compositionstart())), this.register((0, o.addDisposableDomListener)(this.textarea, "compositionupdate", (F) => this._compositionHelper.compositionupdate(F))), this.register((0, o.addDisposableDomListener)(this.textarea, "compositionend", () => this._compositionHelper.compositionend())), this.register((0, o.addDisposableDomListener)(this.textarea, "input", (F) => this._inputEvent(F), !0)), this.register(this.onRender(() => this._compositionHelper.updateCompositionElements()));
          }
          open(F) {
            var B;
            if (!F)
              throw new Error("Terminal requires a parent element.");
            F.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), this._document = F.ownerDocument, this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), F.appendChild(this.element);
            const $ = q.createDocumentFragment();
            this._viewportElement = q.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), $.appendChild(this._viewportElement), this._viewportScrollArea = q.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = q.createElement("div"), this.screenElement.classList.add("xterm-screen"), this._helperContainer = q.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), $.appendChild(this.screenElement), this.textarea = q.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", _.promptLabel), S.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this._instantiationService.createInstance(L.CoreBrowserService, this.textarea, (B = this._document.defaultView) !== null && B !== void 0 ? B : window), this._instantiationService.setService(y.ICoreBrowserService, this._coreBrowserService), this.register((0, o.addDisposableDomListener)(this.textarea, "focus", (z) => this._handleTextAreaFocus(z))), this.register((0, o.addDisposableDomListener)(this.textarea, "blur", () => this._handleTextAreaBlur())), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(I.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(y.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance(ae.ThemeService), this._instantiationService.setService(y.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(j.CharacterJoinerService), this._instantiationService.setService(y.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(k.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(y.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange((z) => this._onRender.fire(z))), this.onResize((z) => this._renderService.resize(z.cols, z.rows)), this._compositionView = q.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(a.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this.element.appendChild($);
            try {
              this._onWillOpen.fire(this.element);
            } catch {
            }
            this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this._mouseService = this._instantiationService.createInstance(A.MouseService), this._instantiationService.setService(y.IMouseService, this._mouseService), this.viewport = this._instantiationService.createInstance(f.Viewport, (z) => this.scrollLines(z, !0, 1), this._viewportElement, this._viewportScrollArea), this.register(this._inputHandler.onRequestSyncScrollBar(() => this.viewport.syncScrollArea())), this.register(this.viewport), this.register(this.onCursorMove(() => {
              this._renderService.handleCursorMove(), this._syncTextArea();
            })), this.register(this.onResize(() => this._renderService.handleResize(this.cols, this.rows))), this.register(this.onBlur(() => this._renderService.handleBlur())), this.register(this.onFocus(() => this._renderService.handleFocus())), this.register(this._renderService.onDimensionsChange(() => this.viewport.syncScrollArea())), this._selectionService = this.register(this._instantiationService.createInstance(p.SelectionService, this.element, this.screenElement, this.linkifier2)), this._instantiationService.setService(y.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines((z) => this.scrollLines(z.amount, z.suppressScrollEvent))), this.register(this._selectionService.onSelectionChange(() => this._onSelectionChange.fire())), this.register(this._selectionService.onRequestRedraw((z) => this._renderService.handleSelectionChanged(z.start, z.end, z.columnSelectMode))), this.register(this._selectionService.onLinuxMouseSelection((z) => {
              this.textarea.value = z, this.textarea.focus(), this.textarea.select();
            })), this.register(this._onScroll.event((z) => {
              this.viewport.syncScrollArea(), this._selectionService.refresh();
            })), this.register((0, o.addDisposableDomListener)(this._viewportElement, "scroll", () => this._selectionService.refresh())), this.linkifier2.attachToDom(this.screenElement, this._mouseService, this._renderService), this.register(this._instantiationService.createInstance(T.BufferDecorationRenderer, this.screenElement)), this.register((0, o.addDisposableDomListener)(this.element, "mousedown", (z) => this._selectionService.handleMouseDown(z))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager = this._instantiationService.createInstance(u.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", (z) => this._handleScreenReaderModeOptionChange(z))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(P.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", (z) => {
              !this._overviewRulerRenderer && z && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(P.OverviewRulerRenderer, this._viewportElement, this.screenElement)));
            }), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();
          }
          _createRenderer() {
            return this._instantiationService.createInstance(d.DomRenderer, this.element, this.screenElement, this._viewportElement, this.linkifier2);
          }
          bindMouse() {
            const F = this, B = this.element;
            function $(Y) {
              const ke = F._mouseService.getMouseReportCoords(Y, F.screenElement);
              if (!ke)
                return !1;
              let Pe, Ie;
              switch (Y.overrideType || Y.type) {
                case "mousemove":
                  Ie = 32, Y.buttons === void 0 ? (Pe = 3, Y.button !== void 0 && (Pe = Y.button < 3 ? Y.button : 3)) : Pe = 1 & Y.buttons ? 0 : 4 & Y.buttons ? 1 : 2 & Y.buttons ? 2 : 3;
                  break;
                case "mouseup":
                  Ie = 0, Pe = Y.button < 3 ? Y.button : 3;
                  break;
                case "mousedown":
                  Ie = 1, Pe = Y.button < 3 ? Y.button : 3;
                  break;
                case "wheel":
                  if (F.viewport.getLinesScrolled(Y) === 0)
                    return !1;
                  Ie = Y.deltaY < 0 ? 0 : 1, Pe = 4;
                  break;
                default:
                  return !1;
              }
              return !(Ie === void 0 || Pe === void 0 || Pe > 4) && F.coreMouseService.triggerMouseEvent({ col: ke.col, row: ke.row, x: ke.x, y: ke.y, button: Pe, action: Ie, ctrl: Y.ctrlKey, alt: Y.altKey, shift: Y.shiftKey });
            }
            const z = { mouseup: null, wheel: null, mousedrag: null, mousemove: null }, ce = { mouseup: (Y) => ($(Y), Y.buttons || (this._document.removeEventListener("mouseup", z.mouseup), z.mousedrag && this._document.removeEventListener("mousemove", z.mousedrag)), this.cancel(Y)), wheel: (Y) => ($(Y), this.cancel(Y, !0)), mousedrag: (Y) => {
              Y.buttons && $(Y);
            }, mousemove: (Y) => {
              Y.buttons || $(Y);
            } };
            this.register(this.coreMouseService.onProtocolChange((Y) => {
              Y ? (this.optionsService.rawOptions.logLevel === "debug" && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(Y)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & Y ? z.mousemove || (B.addEventListener("mousemove", ce.mousemove), z.mousemove = ce.mousemove) : (B.removeEventListener("mousemove", z.mousemove), z.mousemove = null), 16 & Y ? z.wheel || (B.addEventListener("wheel", ce.wheel, { passive: !1 }), z.wheel = ce.wheel) : (B.removeEventListener("wheel", z.wheel), z.wheel = null), 2 & Y ? z.mouseup || (z.mouseup = ce.mouseup) : (this._document.removeEventListener("mouseup", z.mouseup), z.mouseup = null), 4 & Y ? z.mousedrag || (z.mousedrag = ce.mousedrag) : (this._document.removeEventListener("mousemove", z.mousedrag), z.mousedrag = null);
            })), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, o.addDisposableDomListener)(B, "mousedown", (Y) => {
              if (Y.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(Y))
                return $(Y), z.mouseup && this._document.addEventListener("mouseup", z.mouseup), z.mousedrag && this._document.addEventListener("mousemove", z.mousedrag), this.cancel(Y);
            })), this.register((0, o.addDisposableDomListener)(B, "wheel", (Y) => {
              if (!z.wheel) {
                if (!this.buffer.hasScrollback) {
                  const ke = this.viewport.getLinesScrolled(Y);
                  if (ke === 0)
                    return;
                  const Pe = C.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (Y.deltaY < 0 ? "A" : "B");
                  let Ie = "";
                  for (let ge = 0; ge < Math.abs(ke); ge++)
                    Ie += Pe;
                  return this.coreService.triggerDataEvent(Ie, !0), this.cancel(Y, !0);
                }
                return this.viewport.handleWheel(Y) ? this.cancel(Y) : void 0;
              }
            }, { passive: !1 })), this.register((0, o.addDisposableDomListener)(B, "touchstart", (Y) => {
              if (!this.coreMouseService.areMouseEventsActive)
                return this.viewport.handleTouchStart(Y), this.cancel(Y);
            }, { passive: !0 })), this.register((0, o.addDisposableDomListener)(B, "touchmove", (Y) => {
              if (!this.coreMouseService.areMouseEventsActive)
                return this.viewport.handleTouchMove(Y) ? void 0 : this.cancel(Y);
            }, { passive: !1 }));
          }
          refresh(F, B) {
            var $;
            ($ = this._renderService) === null || $ === void 0 || $.refreshRows(F, B);
          }
          updateCursorStyle(F) {
            var B;
            !((B = this._selectionService) === null || B === void 0) && B.shouldColumnSelect(F) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select");
          }
          _showCursor() {
            this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = !0, this.refresh(this.buffer.y, this.buffer.y));
          }
          scrollLines(F, B, $ = 0) {
            super.scrollLines(F, B, $), this.refresh(0, this.rows - 1);
          }
          paste(F) {
            (0, m.paste)(F, this.textarea, this.coreService);
          }
          attachCustomKeyEventHandler(F) {
            this._customKeyEventHandler = F;
          }
          registerLinkProvider(F) {
            return this.linkifier2.registerLinkProvider(F);
          }
          registerCharacterJoiner(F) {
            if (!this._characterJoinerService)
              throw new Error("Terminal must be opened first");
            const B = this._characterJoinerService.register(F);
            return this.refresh(0, this.rows - 1), B;
          }
          deregisterCharacterJoiner(F) {
            if (!this._characterJoinerService)
              throw new Error("Terminal must be opened first");
            this._characterJoinerService.deregister(F) && this.refresh(0, this.rows - 1);
          }
          get markers() {
            return this.buffer.markers;
          }
          addMarker(F) {
            return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + F);
          }
          registerDecoration(F) {
            return this._decorationService.registerDecoration(F);
          }
          hasSelection() {
            return !!this._selectionService && this._selectionService.hasSelection;
          }
          select(F, B, $) {
            this._selectionService.setSelection(F, B, $);
          }
          getSelection() {
            return this._selectionService ? this._selectionService.selectionText : "";
          }
          getSelectionPosition() {
            if (this._selectionService && this._selectionService.hasSelection)
              return { start: { x: this._selectionService.selectionStart[0], y: this._selectionService.selectionStart[1] }, end: { x: this._selectionService.selectionEnd[0], y: this._selectionService.selectionEnd[1] } };
          }
          clearSelection() {
            var F;
            (F = this._selectionService) === null || F === void 0 || F.clearSelection();
          }
          selectAll() {
            var F;
            (F = this._selectionService) === null || F === void 0 || F.selectAll();
          }
          selectLines(F, B) {
            var $;
            ($ = this._selectionService) === null || $ === void 0 || $.selectLines(F, B);
          }
          _keyDown(F) {
            if (this._keyDownHandled = !1, this._keyDownSeen = !0, this._customKeyEventHandler && this._customKeyEventHandler(F) === !1)
              return !1;
            const B = this.browser.isMac && this.options.macOptionIsMeta && F.altKey;
            if (!B && !this._compositionHelper.keydown(F))
              return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this._bufferService.scrollToBottom(), !1;
            B || F.key !== "Dead" && F.key !== "AltGraph" || (this._unprocessedDeadKey = !0);
            const $ = (0, v.evaluateKeyboardEvent)(F, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
            if (this.updateCursorStyle(F), $.type === 3 || $.type === 2) {
              const z = this.rows - 1;
              return this.scrollLines($.type === 2 ? -z : z), this.cancel(F, !0);
            }
            return $.type === 1 && this.selectAll(), !!this._isThirdLevelShift(this.browser, F) || ($.cancel && this.cancel(F, !0), !$.key || !!(F.key && !F.ctrlKey && !F.altKey && !F.metaKey && F.key.length === 1 && F.key.charCodeAt(0) >= 65 && F.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = !1, !0) : ($.key !== C.C0.ETX && $.key !== C.C0.CR || (this.textarea.value = ""), this._onKey.fire({ key: $.key, domEvent: F }), this._showCursor(), this.coreService.triggerDataEvent($.key, !0), !this.optionsService.rawOptions.screenReaderMode || F.altKey || F.ctrlKey ? this.cancel(F, !0) : void (this._keyDownHandled = !0))));
          }
          _isThirdLevelShift(F, B) {
            const $ = F.isMac && !this.options.macOptionIsMeta && B.altKey && !B.ctrlKey && !B.metaKey || F.isWindows && B.altKey && B.ctrlKey && !B.metaKey || F.isWindows && B.getModifierState("AltGraph");
            return B.type === "keypress" ? $ : $ && (!B.keyCode || B.keyCode > 47);
          }
          _keyUp(F) {
            this._keyDownSeen = !1, this._customKeyEventHandler && this._customKeyEventHandler(F) === !1 || (function(B) {
              return B.keyCode === 16 || B.keyCode === 17 || B.keyCode === 18;
            }(F) || this.focus(), this.updateCursorStyle(F), this._keyPressHandled = !1);
          }
          _keyPress(F) {
            let B;
            if (this._keyPressHandled = !1, this._keyDownHandled || this._customKeyEventHandler && this._customKeyEventHandler(F) === !1)
              return !1;
            if (this.cancel(F), F.charCode)
              B = F.charCode;
            else if (F.which === null || F.which === void 0)
              B = F.keyCode;
            else {
              if (F.which === 0 || F.charCode === 0)
                return !1;
              B = F.which;
            }
            return !(!B || (F.altKey || F.ctrlKey || F.metaKey) && !this._isThirdLevelShift(this.browser, F) || (B = String.fromCharCode(B), this._onKey.fire({ key: B, domEvent: F }), this._showCursor(), this.coreService.triggerDataEvent(B, !0), this._keyPressHandled = !0, this._unprocessedDeadKey = !1, 0));
          }
          _inputEvent(F) {
            if (F.data && F.inputType === "insertText" && (!F.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
              if (this._keyPressHandled)
                return !1;
              this._unprocessedDeadKey = !1;
              const B = F.data;
              return this.coreService.triggerDataEvent(B, !0), this.cancel(F), !0;
            }
            return !1;
          }
          resize(F, B) {
            F !== this.cols || B !== this.rows ? super.resize(F, B) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();
          }
          _afterResize(F, B) {
            var $, z;
            ($ = this._charSizeService) === null || $ === void 0 || $.measure(), (z = this.viewport) === null || z === void 0 || z.syncScrollArea(!0);
          }
          clear() {
            if (this.buffer.ybase !== 0 || this.buffer.y !== 0) {
              this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
              for (let F = 1; F < this.rows; F++)
                this.buffer.lines.push(this.buffer.getBlankLine(x.DEFAULT_ATTR_DATA));
              this.refresh(0, this.rows - 1), this._onScroll.fire({ position: this.buffer.ydisp, source: 0 });
            }
          }
          reset() {
            var F, B;
            this.options.rows = this.rows, this.options.cols = this.cols;
            const $ = this._customKeyEventHandler;
            this._setup(), super.reset(), (F = this._selectionService) === null || F === void 0 || F.reset(), this._decorationService.reset(), this._customKeyEventHandler = $, this.refresh(0, this.rows - 1), (B = this.viewport) === null || B === void 0 || B.syncScrollArea();
          }
          clearTextureAtlas() {
            var F;
            (F = this._renderService) === null || F === void 0 || F.clearTextureAtlas();
          }
          _reportFocus() {
            var F;
            !((F = this.element) === null || F === void 0) && F.classList.contains("focus") ? this.coreService.triggerDataEvent(C.C0.ESC + "[I") : this.coreService.triggerDataEvent(C.C0.ESC + "[O");
          }
          _reportWindowsOptions(F) {
            if (this._renderService)
              switch (F) {
                case b.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
                  const B = this._renderService.dimensions.css.canvas.width.toFixed(0), $ = this._renderService.dimensions.css.canvas.height.toFixed(0);
                  this.coreService.triggerDataEvent(`${C.C0.ESC}[4;${$};${B}t`);
                  break;
                case b.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
                  const z = this._renderService.dimensions.css.cell.width.toFixed(0), ce = this._renderService.dimensions.css.cell.height.toFixed(0);
                  this.coreService.triggerDataEvent(`${C.C0.ESC}[6;${ce};${z}t`);
              }
          }
          cancel(F, B) {
            if (this.options.cancelEvents || B)
              return F.preventDefault(), F.stopPropagation(), !1;
          }
        }
        n.Terminal = ee;
      }, 9924: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.TimeBasedDebouncer = void 0, n.TimeBasedDebouncer = class {
          constructor(r, a = 1e3) {
            this._renderCallback = r, this._debounceThresholdMS = a, this._lastRefreshMs = 0, this._additionalRefreshRequested = !1;
          }
          dispose() {
            this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);
          }
          refresh(r, a, f) {
            this._rowCount = f, r = r !== void 0 ? r : 0, a = a !== void 0 ? a : this._rowCount - 1, this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, r) : r, this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, a) : a;
            const m = Date.now();
            if (m - this._lastRefreshMs >= this._debounceThresholdMS)
              this._lastRefreshMs = m, this._innerRefresh();
            else if (!this._additionalRefreshRequested) {
              const C = m - this._lastRefreshMs, b = this._debounceThresholdMS - C;
              this._additionalRefreshRequested = !0, this._refreshTimeoutID = window.setTimeout(() => {
                this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = !1, this._refreshTimeoutID = void 0;
              }, b);
            }
          }
          _innerRefresh() {
            if (this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0)
              return;
            const r = Math.max(this._rowStart, 0), a = Math.min(this._rowEnd, this._rowCount - 1);
            this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(r, a);
          }
        };
      }, 1680: function(l, n, r) {
        var a = this && this.__decorate || function(o, _, u, d) {
          var v, w = arguments.length, x = w < 3 ? _ : d === null ? d = Object.getOwnPropertyDescriptor(_, u) : d;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            x = Reflect.decorate(o, _, u, d);
          else
            for (var k = o.length - 1; k >= 0; k--)
              (v = o[k]) && (x = (w < 3 ? v(x) : w > 3 ? v(_, u, x) : v(_, u)) || x);
          return w > 3 && x && Object.defineProperty(_, u, x), x;
        }, f = this && this.__param || function(o, _) {
          return function(u, d) {
            _(u, d, o);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.Viewport = void 0;
        const m = r(844), C = r(3656), b = r(4725), p = r(2585);
        let S = class extends m.Disposable {
          constructor(o, _, u, d, v, w, x, k, y) {
            super(), this._scrollLines = o, this._viewportElement = _, this._scrollArea = u, this._bufferService = d, this._optionsService = v, this._charSizeService = w, this._renderService = x, this._coreBrowserService = k, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = !1, this._smoothScrollState = { startTime: 0, origin: -1, target: -1 }, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, C.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((I) => this._activeBuffer = I.activeBuffer)), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange((I) => this._renderDimensions = I)), this._handleThemeChange(y.colors), this.register(y.onChangeColors((I) => this._handleThemeChange(I))), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.syncScrollArea())), setTimeout(() => this.syncScrollArea(), 0);
          }
          _handleThemeChange(o) {
            this._viewportElement.style.backgroundColor = o.background.css;
          }
          _refresh(o) {
            if (o)
              return this._innerRefresh(), void (this._refreshAnimationFrame !== null && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
            this._refreshAnimationFrame === null && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));
          }
          _innerRefresh() {
            if (this._charSizeService.height > 0) {
              this._currentRowHeight = this._renderService.dimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderService.dimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
              const _ = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderService.dimensions.css.canvas.height);
              this._lastRecordedBufferHeight !== _ && (this._lastRecordedBufferHeight = _, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px");
            }
            const o = this._bufferService.buffer.ydisp * this._currentRowHeight;
            this._viewportElement.scrollTop !== o && (this._ignoreNextScrollEvent = !0, this._viewportElement.scrollTop = o), this._refreshAnimationFrame = null;
          }
          syncScrollArea(o = !1) {
            if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length)
              return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(o);
            this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(o);
          }
          _handleScroll(o) {
            if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent)
              return;
            if (this._ignoreNextScrollEvent)
              return this._ignoreNextScrollEvent = !1, void this._scrollLines(0);
            const _ = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
            this._scrollLines(_);
          }
          _smoothScroll() {
            if (this._isDisposed || this._smoothScrollState.origin === -1 || this._smoothScrollState.target === -1)
              return;
            const o = this._smoothScrollPercent();
            this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(o * (this._smoothScrollState.target - this._smoothScrollState.origin)), o < 1 ? this._coreBrowserService.window.requestAnimationFrame(() => this._smoothScroll()) : this._clearSmoothScrollState();
          }
          _smoothScrollPercent() {
            return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;
          }
          _clearSmoothScrollState() {
            this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;
          }
          _bubbleScroll(o, _) {
            const u = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
            return !(_ < 0 && this._viewportElement.scrollTop !== 0 || _ > 0 && u < this._lastRecordedBufferHeight) || (o.cancelable && o.preventDefault(), !1);
          }
          handleWheel(o) {
            const _ = this._getPixelsScrolled(o);
            return _ !== 0 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target === -1 ? this._smoothScrollState.target = this._viewportElement.scrollTop + _ : this._smoothScrollState.target += _, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += _, this._bubbleScroll(o, _));
          }
          _getPixelsScrolled(o) {
            if (o.deltaY === 0 || o.shiftKey)
              return 0;
            let _ = this._applyScrollModifier(o.deltaY, o);
            return o.deltaMode === WheelEvent.DOM_DELTA_LINE ? _ *= this._currentRowHeight : o.deltaMode === WheelEvent.DOM_DELTA_PAGE && (_ *= this._currentRowHeight * this._bufferService.rows), _;
          }
          getBufferElements(o, _) {
            var u;
            let d, v = "";
            const w = [], x = _ ?? this._bufferService.buffer.lines.length, k = this._bufferService.buffer.lines;
            for (let y = o; y < x; y++) {
              const I = k.get(y);
              if (!I)
                continue;
              const A = (u = k.get(y + 1)) === null || u === void 0 ? void 0 : u.isWrapped;
              if (v += I.translateToString(!A), !A || y === k.length - 1) {
                const M = document.createElement("div");
                M.textContent = v, w.push(M), v.length > 0 && (d = M), v = "";
              }
            }
            return { bufferElements: w, cursorElement: d };
          }
          getLinesScrolled(o) {
            if (o.deltaY === 0 || o.shiftKey)
              return 0;
            let _ = this._applyScrollModifier(o.deltaY, o);
            return o.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (_ /= this._currentRowHeight + 0, this._wheelPartialScroll += _, _ = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : o.deltaMode === WheelEvent.DOM_DELTA_PAGE && (_ *= this._bufferService.rows), _;
          }
          _applyScrollModifier(o, _) {
            const u = this._optionsService.rawOptions.fastScrollModifier;
            return u === "alt" && _.altKey || u === "ctrl" && _.ctrlKey || u === "shift" && _.shiftKey ? o * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : o * this._optionsService.rawOptions.scrollSensitivity;
          }
          handleTouchStart(o) {
            this._lastTouchY = o.touches[0].pageY;
          }
          handleTouchMove(o) {
            const _ = this._lastTouchY - o.touches[0].pageY;
            return this._lastTouchY = o.touches[0].pageY, _ !== 0 && (this._viewportElement.scrollTop += _, this._bubbleScroll(o, _));
          }
        };
        S = a([f(3, p.IBufferService), f(4, p.IOptionsService), f(5, b.ICharSizeService), f(6, b.IRenderService), f(7, b.ICoreBrowserService), f(8, b.IThemeService)], S), n.Viewport = S;
      }, 3107: function(l, n, r) {
        var a = this && this.__decorate || function(o, _, u, d) {
          var v, w = arguments.length, x = w < 3 ? _ : d === null ? d = Object.getOwnPropertyDescriptor(_, u) : d;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            x = Reflect.decorate(o, _, u, d);
          else
            for (var k = o.length - 1; k >= 0; k--)
              (v = o[k]) && (x = (w < 3 ? v(x) : w > 3 ? v(_, u, x) : v(_, u)) || x);
          return w > 3 && x && Object.defineProperty(_, u, x), x;
        }, f = this && this.__param || function(o, _) {
          return function(u, d) {
            _(u, d, o);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.BufferDecorationRenderer = void 0;
        const m = r(3656), C = r(4725), b = r(844), p = r(2585);
        let S = class extends b.Disposable {
          constructor(o, _, u, d) {
            super(), this._screenElement = o, this._bufferService = _, this._decorationService = u, this._renderService = d, this._decorationElements = /* @__PURE__ */ new Map(), this._altBufferIsActive = !1, this._dimensionsChanged = !1, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange(() => this._doRefreshDecorations())), this.register(this._renderService.onDimensionsChange(() => {
              this._dimensionsChanged = !0, this._queueRefresh();
            })), this.register((0, m.addDisposableDomListener)(window, "resize", () => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
              this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;
            })), this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh())), this.register(this._decorationService.onDecorationRemoved((v) => this._removeDecoration(v))), this.register((0, b.toDisposable)(() => {
              this._container.remove(), this._decorationElements.clear();
            }));
          }
          _queueRefresh() {
            this._animationFrame === void 0 && (this._animationFrame = this._renderService.addRefreshCallback(() => {
              this._doRefreshDecorations(), this._animationFrame = void 0;
            }));
          }
          _doRefreshDecorations() {
            for (const o of this._decorationService.decorations)
              this._renderDecoration(o);
            this._dimensionsChanged = !1;
          }
          _renderDecoration(o) {
            this._refreshStyle(o), this._dimensionsChanged && this._refreshXPosition(o);
          }
          _createElement(o) {
            var _, u;
            const d = document.createElement("div");
            d.classList.add("xterm-decoration"), d.classList.toggle("xterm-decoration-top-layer", ((_ = o == null ? void 0 : o.options) === null || _ === void 0 ? void 0 : _.layer) === "top"), d.style.width = `${Math.round((o.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, d.style.height = (o.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", d.style.top = (o.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", d.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
            const v = (u = o.options.x) !== null && u !== void 0 ? u : 0;
            return v && v > this._bufferService.cols && (d.style.display = "none"), this._refreshXPosition(o, d), d;
          }
          _refreshStyle(o) {
            const _ = o.marker.line - this._bufferService.buffers.active.ydisp;
            if (_ < 0 || _ >= this._bufferService.rows)
              o.element && (o.element.style.display = "none", o.onRenderEmitter.fire(o.element));
            else {
              let u = this._decorationElements.get(o);
              u || (u = this._createElement(o), o.element = u, this._decorationElements.set(o, u), this._container.appendChild(u)), u.style.top = _ * this._renderService.dimensions.css.cell.height + "px", u.style.display = this._altBufferIsActive ? "none" : "block", o.onRenderEmitter.fire(u);
            }
          }
          _refreshXPosition(o, _ = o.element) {
            var u;
            if (!_)
              return;
            const d = (u = o.options.x) !== null && u !== void 0 ? u : 0;
            (o.options.anchor || "left") === "right" ? _.style.right = d ? d * this._renderService.dimensions.css.cell.width + "px" : "" : _.style.left = d ? d * this._renderService.dimensions.css.cell.width + "px" : "";
          }
          _removeDecoration(o) {
            var _;
            (_ = this._decorationElements.get(o)) === null || _ === void 0 || _.remove(), this._decorationElements.delete(o), o.dispose();
          }
        };
        S = a([f(1, p.IBufferService), f(2, p.IDecorationService), f(3, C.IRenderService)], S), n.BufferDecorationRenderer = S;
      }, 5871: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.ColorZoneStore = void 0, n.ColorZoneStore = class {
          constructor() {
            this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = { full: 0, left: 0, center: 0, right: 0 };
          }
          get zones() {
            return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;
          }
          clear() {
            this._zones.length = 0, this._zonePoolIndex = 0;
          }
          addDecoration(r) {
            if (r.options.overviewRulerOptions) {
              for (const a of this._zones)
                if (a.color === r.options.overviewRulerOptions.color && a.position === r.options.overviewRulerOptions.position) {
                  if (this._lineIntersectsZone(a, r.marker.line))
                    return;
                  if (this._lineAdjacentToZone(a, r.marker.line, r.options.overviewRulerOptions.position))
                    return void this._addLineToZone(a, r.marker.line);
                }
              if (this._zonePoolIndex < this._zonePool.length)
                return this._zonePool[this._zonePoolIndex].color = r.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = r.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = r.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = r.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);
              this._zones.push({ color: r.options.overviewRulerOptions.color, position: r.options.overviewRulerOptions.position, startBufferLine: r.marker.line, endBufferLine: r.marker.line }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;
            }
          }
          setPadding(r) {
            this._linePadding = r;
          }
          _lineIntersectsZone(r, a) {
            return a >= r.startBufferLine && a <= r.endBufferLine;
          }
          _lineAdjacentToZone(r, a, f) {
            return a >= r.startBufferLine - this._linePadding[f || "full"] && a <= r.endBufferLine + this._linePadding[f || "full"];
          }
          _addLineToZone(r, a) {
            r.startBufferLine = Math.min(r.startBufferLine, a), r.endBufferLine = Math.max(r.endBufferLine, a);
          }
        };
      }, 5744: function(l, n, r) {
        var a = this && this.__decorate || function(v, w, x, k) {
          var y, I = arguments.length, A = I < 3 ? w : k === null ? k = Object.getOwnPropertyDescriptor(w, x) : k;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            A = Reflect.decorate(v, w, x, k);
          else
            for (var M = v.length - 1; M >= 0; M--)
              (y = v[M]) && (A = (I < 3 ? y(A) : I > 3 ? y(w, x, A) : y(w, x)) || A);
          return I > 3 && A && Object.defineProperty(w, x, A), A;
        }, f = this && this.__param || function(v, w) {
          return function(x, k) {
            w(x, k, v);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.OverviewRulerRenderer = void 0;
        const m = r(5871), C = r(3656), b = r(4725), p = r(844), S = r(2585), o = { full: 0, left: 0, center: 0, right: 0 }, _ = { full: 0, left: 0, center: 0, right: 0 }, u = { full: 0, left: 0, center: 0, right: 0 };
        let d = class extends p.Disposable {
          constructor(v, w, x, k, y, I, A) {
            var M;
            super(), this._viewportElement = v, this._screenElement = w, this._bufferService = x, this._decorationService = k, this._renderService = y, this._optionsService = I, this._coreBrowseService = A, this._colorZoneStore = new m.ColorZoneStore(), this._shouldUpdateDimensions = !0, this._shouldUpdateAnchor = !0, this._lastKnownBufferLength = 0, this._canvas = document.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), (M = this._viewportElement.parentElement) === null || M === void 0 || M.insertBefore(this._canvas, this._viewportElement);
            const L = this._canvas.getContext("2d");
            if (!L)
              throw new Error("Ctx cannot be null");
            this._ctx = L, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, p.toDisposable)(() => {
              var O;
              (O = this._canvas) === null || O === void 0 || O.remove();
            }));
          }
          get _width() {
            return this._optionsService.options.overviewRulerWidth || 0;
          }
          _registerDecorationListeners() {
            this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh(void 0, !0))), this.register(this._decorationService.onDecorationRemoved(() => this._queueRefresh(void 0, !0)));
          }
          _registerBufferChangeListeners() {
            this.register(this._renderService.onRenderedViewportChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
              this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block";
            })), this.register(this._bufferService.onScroll(() => {
              this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());
            }));
          }
          _registerDimensionChangeListeners() {
            this.register(this._renderService.onRender(() => {
              this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(!0), this._containerHeight = this._screenElement.clientHeight);
            })), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", () => this._queueRefresh(!0))), this.register((0, C.addDisposableDomListener)(this._coreBrowseService.window, "resize", () => this._queueRefresh(!0))), this._queueRefresh(!0);
          }
          _refreshDrawConstants() {
            const v = Math.floor(this._canvas.width / 3), w = Math.ceil(this._canvas.width / 3);
            _.full = this._canvas.width, _.left = v, _.center = w, _.right = v, this._refreshDrawHeightConstants(), u.full = 0, u.left = 0, u.center = _.left, u.right = _.left + _.center;
          }
          _refreshDrawHeightConstants() {
            o.full = Math.round(2 * this._coreBrowseService.dpr);
            const v = this._canvas.height / this._bufferService.buffer.lines.length, w = Math.round(Math.max(Math.min(v, 12), 6) * this._coreBrowseService.dpr);
            o.left = w, o.center = w, o.right = w;
          }
          _refreshColorZonePadding() {
            this._colorZoneStore.setPadding({ full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * o.full), left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * o.left), center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * o.center), right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * o.right) }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;
          }
          _refreshCanvasDimensions() {
            this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowseService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowseService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();
          }
          _refreshDecorations() {
            this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();
            for (const w of this._decorationService.decorations)
              this._colorZoneStore.addDecoration(w);
            this._ctx.lineWidth = 1;
            const v = this._colorZoneStore.zones;
            for (const w of v)
              w.position !== "full" && this._renderColorZone(w);
            for (const w of v)
              w.position === "full" && this._renderColorZone(w);
            this._shouldUpdateDimensions = !1, this._shouldUpdateAnchor = !1;
          }
          _renderColorZone(v) {
            this._ctx.fillStyle = v.color, this._ctx.fillRect(u[v.position || "full"], Math.round((this._canvas.height - 1) * (v.startBufferLine / this._bufferService.buffers.active.lines.length) - o[v.position || "full"] / 2), _[v.position || "full"], Math.round((this._canvas.height - 1) * ((v.endBufferLine - v.startBufferLine) / this._bufferService.buffers.active.lines.length) + o[v.position || "full"]));
          }
          _queueRefresh(v, w) {
            this._shouldUpdateDimensions = v || this._shouldUpdateDimensions, this._shouldUpdateAnchor = w || this._shouldUpdateAnchor, this._animationFrame === void 0 && (this._animationFrame = this._coreBrowseService.window.requestAnimationFrame(() => {
              this._refreshDecorations(), this._animationFrame = void 0;
            }));
          }
        };
        d = a([f(2, S.IBufferService), f(3, S.IDecorationService), f(4, b.IRenderService), f(5, S.IOptionsService), f(6, b.ICoreBrowserService)], d), n.OverviewRulerRenderer = d;
      }, 2950: function(l, n, r) {
        var a = this && this.__decorate || function(S, o, _, u) {
          var d, v = arguments.length, w = v < 3 ? o : u === null ? u = Object.getOwnPropertyDescriptor(o, _) : u;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            w = Reflect.decorate(S, o, _, u);
          else
            for (var x = S.length - 1; x >= 0; x--)
              (d = S[x]) && (w = (v < 3 ? d(w) : v > 3 ? d(o, _, w) : d(o, _)) || w);
          return v > 3 && w && Object.defineProperty(o, _, w), w;
        }, f = this && this.__param || function(S, o) {
          return function(_, u) {
            o(_, u, S);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.CompositionHelper = void 0;
        const m = r(4725), C = r(2585), b = r(2584);
        let p = class {
          constructor(S, o, _, u, d, v) {
            this._textarea = S, this._compositionView = o, this._bufferService = _, this._optionsService = u, this._coreService = d, this._renderService = v, this._isComposing = !1, this._isSendingComposition = !1, this._compositionPosition = { start: 0, end: 0 }, this._dataAlreadySent = "";
          }
          get isComposing() {
            return this._isComposing;
          }
          compositionstart() {
            this._isComposing = !0, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active");
          }
          compositionupdate(S) {
            this._compositionView.textContent = S.data, this.updateCompositionElements(), setTimeout(() => {
              this._compositionPosition.end = this._textarea.value.length;
            }, 0);
          }
          compositionend() {
            this._finalizeComposition(!0);
          }
          keydown(S) {
            if (this._isComposing || this._isSendingComposition) {
              if (S.keyCode === 229 || S.keyCode === 16 || S.keyCode === 17 || S.keyCode === 18)
                return !1;
              this._finalizeComposition(!1);
            }
            return S.keyCode !== 229 || (this._handleAnyTextareaChanges(), !1);
          }
          _finalizeComposition(S) {
            if (this._compositionView.classList.remove("active"), this._isComposing = !1, S) {
              const o = { start: this._compositionPosition.start, end: this._compositionPosition.end };
              this._isSendingComposition = !0, setTimeout(() => {
                if (this._isSendingComposition) {
                  let _;
                  this._isSendingComposition = !1, o.start += this._dataAlreadySent.length, _ = this._isComposing ? this._textarea.value.substring(o.start, o.end) : this._textarea.value.substring(o.start), _.length > 0 && this._coreService.triggerDataEvent(_, !0);
                }
              }, 0);
            } else {
              this._isSendingComposition = !1;
              const o = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
              this._coreService.triggerDataEvent(o, !0);
            }
          }
          _handleAnyTextareaChanges() {
            const S = this._textarea.value;
            setTimeout(() => {
              if (!this._isComposing) {
                const o = this._textarea.value, _ = o.replace(S, "");
                this._dataAlreadySent = _, o.length > S.length ? this._coreService.triggerDataEvent(_, !0) : o.length < S.length ? this._coreService.triggerDataEvent(`${b.C0.DEL}`, !0) : o.length === S.length && o !== S && this._coreService.triggerDataEvent(o, !0);
              }
            }, 0);
          }
          updateCompositionElements(S) {
            if (this._isComposing) {
              if (this._bufferService.buffer.isCursorInViewport) {
                const o = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), _ = this._renderService.dimensions.css.cell.height, u = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, d = o * this._renderService.dimensions.css.cell.width;
                this._compositionView.style.left = d + "px", this._compositionView.style.top = u + "px", this._compositionView.style.height = _ + "px", this._compositionView.style.lineHeight = _ + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
                const v = this._compositionView.getBoundingClientRect();
                this._textarea.style.left = d + "px", this._textarea.style.top = u + "px", this._textarea.style.width = Math.max(v.width, 1) + "px", this._textarea.style.height = Math.max(v.height, 1) + "px", this._textarea.style.lineHeight = v.height + "px";
              }
              S || setTimeout(() => this.updateCompositionElements(!0), 0);
            }
          }
        };
        p = a([f(2, C.IBufferService), f(3, C.IOptionsService), f(4, C.ICoreService), f(5, m.IRenderService)], p), n.CompositionHelper = p;
      }, 9806: (l, n) => {
        function r(a, f, m) {
          const C = m.getBoundingClientRect(), b = a.getComputedStyle(m), p = parseInt(b.getPropertyValue("padding-left")), S = parseInt(b.getPropertyValue("padding-top"));
          return [f.clientX - C.left - p, f.clientY - C.top - S];
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.getCoords = n.getCoordsRelativeToElement = void 0, n.getCoordsRelativeToElement = r, n.getCoords = function(a, f, m, C, b, p, S, o, _) {
          if (!p)
            return;
          const u = r(a, f, m);
          return u ? (u[0] = Math.ceil((u[0] + (_ ? S / 2 : 0)) / S), u[1] = Math.ceil(u[1] / o), u[0] = Math.min(Math.max(u[0], 1), C + (_ ? 1 : 0)), u[1] = Math.min(Math.max(u[1], 1), b), u) : void 0;
        };
      }, 9504: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.moveToCellSequence = void 0;
        const a = r(2584);
        function f(o, _, u, d) {
          const v = o - m(o, u), w = _ - m(_, u), x = Math.abs(v - w) - function(k, y, I) {
            let A = 0;
            const M = k - m(k, I), L = y - m(y, I);
            for (let O = 0; O < Math.abs(M - L); O++) {
              const U = C(k, y) === "A" ? -1 : 1, j = I.buffer.lines.get(M + U * O);
              j != null && j.isWrapped && A++;
            }
            return A;
          }(o, _, u);
          return S(x, p(C(o, _), d));
        }
        function m(o, _) {
          let u = 0, d = _.buffer.lines.get(o), v = d == null ? void 0 : d.isWrapped;
          for (; v && o >= 0 && o < _.rows; )
            u++, d = _.buffer.lines.get(--o), v = d == null ? void 0 : d.isWrapped;
          return u;
        }
        function C(o, _) {
          return o > _ ? "A" : "B";
        }
        function b(o, _, u, d, v, w) {
          let x = o, k = _, y = "";
          for (; x !== u || k !== d; )
            x += v ? 1 : -1, v && x > w.cols - 1 ? (y += w.buffer.translateBufferLineToString(k, !1, o, x), x = 0, o = 0, k++) : !v && x < 0 && (y += w.buffer.translateBufferLineToString(k, !1, 0, o + 1), x = w.cols - 1, o = x, k--);
          return y + w.buffer.translateBufferLineToString(k, !1, o, x);
        }
        function p(o, _) {
          const u = _ ? "O" : "[";
          return a.C0.ESC + u + o;
        }
        function S(o, _) {
          o = Math.floor(o);
          let u = "";
          for (let d = 0; d < o; d++)
            u += _;
          return u;
        }
        n.moveToCellSequence = function(o, _, u, d) {
          const v = u.buffer.x, w = u.buffer.y;
          if (!u.buffer.hasScrollback)
            return function(y, I, A, M, L, O) {
              return f(I, M, L, O).length === 0 ? "" : S(b(y, I, y, I - m(I, L), !1, L).length, p("D", O));
            }(v, w, 0, _, u, d) + f(w, _, u, d) + function(y, I, A, M, L, O) {
              let U;
              U = f(I, M, L, O).length > 0 ? M - m(M, L) : I;
              const j = M, K = function(T, P, H, N, G, Z) {
                let ae;
                return ae = f(H, N, G, Z).length > 0 ? N - m(N, G) : P, T < H && ae <= N || T >= H && ae < N ? "C" : "D";
              }(y, I, A, M, L, O);
              return S(b(y, U, A, j, K === "C", L).length, p(K, O));
            }(v, w, o, _, u, d);
          let x;
          if (w === _)
            return x = v > o ? "D" : "C", S(Math.abs(v - o), p(x, d));
          x = w > _ ? "D" : "C";
          const k = Math.abs(w - _);
          return S(function(y, I) {
            return I.cols - y;
          }(w > _ ? o : v, u) + (k - 1) * u.cols + 1 + ((w > _ ? v : o) - 1), p(x, d));
        };
      }, 1296: function(l, n, r) {
        var a = this && this.__decorate || function(k, y, I, A) {
          var M, L = arguments.length, O = L < 3 ? y : A === null ? A = Object.getOwnPropertyDescriptor(y, I) : A;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            O = Reflect.decorate(k, y, I, A);
          else
            for (var U = k.length - 1; U >= 0; U--)
              (M = k[U]) && (O = (L < 3 ? M(O) : L > 3 ? M(y, I, O) : M(y, I)) || O);
          return L > 3 && O && Object.defineProperty(y, I, O), O;
        }, f = this && this.__param || function(k, y) {
          return function(I, A) {
            y(I, A, k);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.DomRenderer = void 0;
        const m = r(3787), C = r(2223), b = r(6171), p = r(4725), S = r(8055), o = r(8460), _ = r(844), u = r(2585), d = "xterm-dom-renderer-owner-", v = "xterm-focus";
        let w = 1, x = class extends _.Disposable {
          constructor(k, y, I, A, M, L, O, U, j, K) {
            super(), this._element = k, this._screenElement = y, this._viewportElement = I, this._linkifier2 = A, this._charSizeService = L, this._optionsService = O, this._bufferService = U, this._coreBrowserService = j, this._themeService = K, this._terminalClass = w++, this._rowElements = [], this._cellToRowElements = [], this.onRequestRedraw = this.register(new o.EventEmitter()).event, this._rowContainer = document.createElement("div"), this._rowContainer.classList.add("xterm-rows"), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = document.createElement("div"), this._selectionContainer.classList.add("xterm-selection"), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, b.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange(() => this._handleOptionsChanged())), this.register(this._themeService.onChangeColors((T) => this._injectCss(T))), this._injectCss(this._themeService.colors), this._rowFactory = M.createInstance(m.DomRendererRowFactory, document), this._element.classList.add(d + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline((T) => this._handleLinkHover(T))), this.register(this._linkifier2.onHideLinkUnderline((T) => this._handleLinkLeave(T))), this.register((0, _.toDisposable)(() => {
              this._element.classList.remove(d + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove();
            }));
          }
          _updateDimensions() {
            const k = this._coreBrowserService.dpr;
            this.dimensions.device.char.width = this._charSizeService.width * k, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * k), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / k), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / k), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
            for (const I of this._rowElements)
              I.style.width = `${this.dimensions.css.canvas.width}px`, I.style.height = `${this.dimensions.css.cell.height}px`, I.style.lineHeight = `${this.dimensions.css.cell.height}px`, I.style.overflow = "hidden";
            this._dimensionsStyleElement || (this._dimensionsStyleElement = document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement));
            const y = `${this._terminalSelector} .xterm-rows span { display: inline-block; height: 100%; vertical-align: top; width: ${this.dimensions.css.cell.width}px}`;
            this._dimensionsStyleElement.textContent = y, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
          }
          _injectCss(k) {
            this._themeStyleElement || (this._themeStyleElement = document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement));
            let y = `${this._terminalSelector} .xterm-rows { color: ${k.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px;}`;
            y += `${this._terminalSelector} .xterm-rows .xterm-dim { color: ${S.color.multiplyOpacity(k.foreground, 0.5).css};}`, y += `${this._terminalSelector} span:not(.${m.BOLD_CLASS}) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.${m.BOLD_CLASS} { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.${m.ITALIC_CLASS} { font-style: italic;}`, y += "@keyframes blink_box_shadow_" + this._terminalClass + " { 50% {  box-shadow: none; }}", y += "@keyframes blink_block_" + this._terminalClass + ` { 0% {  background-color: ${k.cursor.css};  color: ${k.cursorAccent.css}; } 50% {  background-color: ${k.cursorAccent.css};  color: ${k.cursor.css}; }}`, y += `${this._terminalSelector} .xterm-rows:not(.xterm-focus) .${m.CURSOR_CLASS}.${m.CURSOR_STYLE_BLOCK_CLASS} ,${this._terminalSelector} .xterm-rows:not(.xterm-focus) .${m.CURSOR_CLASS}.${m.CURSOR_STYLE_BAR_CLASS} ,${this._terminalSelector} .xterm-rows:not(.xterm-focus) .${m.CURSOR_CLASS}.${m.CURSOR_STYLE_UNDERLINE_CLASS} { outline: 1px solid ${k.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .xterm-rows.xterm-focus .${m.CURSOR_CLASS}.${m.CURSOR_BLINK_CLASS}:not(.${m.CURSOR_STYLE_BLOCK_CLASS}) { animation: blink_box_shadow_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .xterm-rows.xterm-focus .${m.CURSOR_CLASS}.${m.CURSOR_BLINK_CLASS}.${m.CURSOR_STYLE_BLOCK_CLASS} { animation: blink_block_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .xterm-rows.xterm-focus .${m.CURSOR_CLASS}.${m.CURSOR_STYLE_BLOCK_CLASS} { background-color: ${k.cursor.css}; color: ${k.cursorAccent.css};}${this._terminalSelector} .xterm-rows .${m.CURSOR_CLASS}.${m.CURSOR_STYLE_BAR_CLASS} { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${k.cursor.css} inset;}${this._terminalSelector} .xterm-rows .${m.CURSOR_CLASS}.${m.CURSOR_STYLE_UNDERLINE_CLASS} { box-shadow: 0 -1px 0 ${k.cursor.css} inset;}`, y += `${this._terminalSelector} .xterm-selection { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .xterm-selection div { position: absolute; background-color: ${k.selectionBackgroundOpaque.css};}${this._terminalSelector} .xterm-selection div { position: absolute; background-color: ${k.selectionInactiveBackgroundOpaque.css};}`;
            for (const [I, A] of k.ansi.entries())
              y += `${this._terminalSelector} .xterm-fg-${I} { color: ${A.css}; }${this._terminalSelector} .xterm-fg-${I}.${m.DIM_CLASS} { color: ${S.color.multiplyOpacity(A, 0.5).css}; }${this._terminalSelector} .xterm-bg-${I} { background-color: ${A.css}; }`;
            y += `${this._terminalSelector} .xterm-fg-${C.INVERTED_DEFAULT_COLOR} { color: ${S.color.opaque(k.background).css}; }${this._terminalSelector} .xterm-fg-${C.INVERTED_DEFAULT_COLOR}.${m.DIM_CLASS} { color: ${S.color.multiplyOpacity(S.color.opaque(k.background), 0.5).css}; }${this._terminalSelector} .xterm-bg-${C.INVERTED_DEFAULT_COLOR} { background-color: ${k.foreground.css}; }`, this._themeStyleElement.textContent = y;
          }
          handleDevicePixelRatioChange() {
            this._updateDimensions();
          }
          _refreshRowElements(k, y) {
            for (let I = this._rowElements.length; I <= y; I++) {
              const A = document.createElement("div");
              this._rowContainer.appendChild(A), this._rowElements.push(A);
            }
            for (; this._rowElements.length > y; )
              this._rowContainer.removeChild(this._rowElements.pop());
          }
          handleResize(k, y) {
            this._refreshRowElements(k, y), this._updateDimensions();
          }
          handleCharSizeChanged() {
            this._updateDimensions();
          }
          handleBlur() {
            this._rowContainer.classList.remove(v);
          }
          handleFocus() {
            this._rowContainer.classList.add(v);
          }
          handleSelectionChanged(k, y, I) {
            for (; this._selectionContainer.children.length; )
              this._selectionContainer.removeChild(this._selectionContainer.children[0]);
            if (this._rowFactory.handleSelectionChanged(k, y, I), this.renderRows(0, this._bufferService.rows - 1), !k || !y)
              return;
            const A = k[1] - this._bufferService.buffer.ydisp, M = y[1] - this._bufferService.buffer.ydisp, L = Math.max(A, 0), O = Math.min(M, this._bufferService.rows - 1);
            if (L >= this._bufferService.rows || O < 0)
              return;
            const U = document.createDocumentFragment();
            if (I) {
              const j = k[0] > y[0];
              U.appendChild(this._createSelectionElement(L, j ? y[0] : k[0], j ? k[0] : y[0], O - L + 1));
            } else {
              const j = A === L ? k[0] : 0, K = L === M ? y[0] : this._bufferService.cols;
              U.appendChild(this._createSelectionElement(L, j, K));
              const T = O - L - 1;
              if (U.appendChild(this._createSelectionElement(L + 1, 0, this._bufferService.cols, T)), L !== O) {
                const P = M === O ? y[0] : this._bufferService.cols;
                U.appendChild(this._createSelectionElement(O, 0, P));
              }
            }
            this._selectionContainer.appendChild(U);
          }
          _createSelectionElement(k, y, I, A = 1) {
            const M = document.createElement("div");
            return M.style.height = A * this.dimensions.css.cell.height + "px", M.style.top = k * this.dimensions.css.cell.height + "px", M.style.left = y * this.dimensions.css.cell.width + "px", M.style.width = this.dimensions.css.cell.width * (I - y) + "px", M;
          }
          handleCursorMove() {
          }
          _handleOptionsChanged() {
            this._updateDimensions(), this._injectCss(this._themeService.colors);
          }
          clear() {
            for (const k of this._rowElements)
              k.replaceChildren();
          }
          renderRows(k, y) {
            const I = this._bufferService.buffer.ybase + this._bufferService.buffer.y, A = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), M = this._optionsService.rawOptions.cursorBlink;
            for (let L = k; L <= y; L++) {
              const O = this._rowElements[L], U = L + this._bufferService.buffer.ydisp, j = this._bufferService.buffer.lines.get(U), K = this._optionsService.rawOptions.cursorStyle;
              this._cellToRowElements[L] && this._cellToRowElements[L].length === this._bufferService.cols || (this._cellToRowElements[L] = new Int16Array(this._bufferService.cols)), O.replaceChildren(this._rowFactory.createRow(j, U, U === I, K, A, M, this.dimensions.css.cell.width, this._bufferService.cols, this._cellToRowElements[L]));
            }
          }
          get _terminalSelector() {
            return `.${d}${this._terminalClass}`;
          }
          _handleLinkHover(k) {
            this._setCellUnderline(k.x1, k.x2, k.y1, k.y2, k.cols, !0);
          }
          _handleLinkLeave(k) {
            this._setCellUnderline(k.x1, k.x2, k.y1, k.y2, k.cols, !1);
          }
          _setCellUnderline(k, y, I, A, M, L) {
            I < 0 && (k = 0), A < 0 && (y = 0);
            const O = this._cellToRowElements.length - 1;
            I = Math.max(Math.min(I, O), 0), A = Math.max(Math.min(A, O), 0);
            const U = this._cellToRowElements[I], j = this._cellToRowElements[A];
            if (!(k >= U.length || y >= j.length) && (k = U[k], y = j[y], k !== -1 && y !== -1))
              for (; k !== y || I !== A; ) {
                const K = this._rowElements[I];
                if (!K)
                  return;
                const T = K.children[k];
                T && (T.style.textDecoration = L ? "underline" : "none"), ++k >= M && (k = 0, I++);
              }
          }
        };
        x = a([f(4, u.IInstantiationService), f(5, p.ICharSizeService), f(6, u.IOptionsService), f(7, u.IBufferService), f(8, p.ICoreBrowserService), f(9, p.IThemeService)], x), n.DomRenderer = x;
      }, 3787: function(l, n, r) {
        var a = this && this.__decorate || function(x, k, y, I) {
          var A, M = arguments.length, L = M < 3 ? k : I === null ? I = Object.getOwnPropertyDescriptor(k, y) : I;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            L = Reflect.decorate(x, k, y, I);
          else
            for (var O = x.length - 1; O >= 0; O--)
              (A = x[O]) && (L = (M < 3 ? A(L) : M > 3 ? A(k, y, L) : A(k, y)) || L);
          return M > 3 && L && Object.defineProperty(k, y, L), L;
        }, f = this && this.__param || function(x, k) {
          return function(y, I) {
            k(y, I, x);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.DomRendererRowFactory = n.CURSOR_STYLE_UNDERLINE_CLASS = n.CURSOR_STYLE_BAR_CLASS = n.CURSOR_STYLE_BLOCK_CLASS = n.CURSOR_BLINK_CLASS = n.CURSOR_CLASS = n.STRIKETHROUGH_CLASS = n.OVERLINE_CLASS = n.UNDERLINE_CLASS = n.ITALIC_CLASS = n.DIM_CLASS = n.BOLD_CLASS = void 0;
        const m = r(2223), C = r(643), b = r(511), p = r(2585), S = r(8055), o = r(4725), _ = r(4269), u = r(6171), d = r(3734);
        n.BOLD_CLASS = "xterm-bold", n.DIM_CLASS = "xterm-dim", n.ITALIC_CLASS = "xterm-italic", n.UNDERLINE_CLASS = "xterm-underline", n.OVERLINE_CLASS = "xterm-overline", n.STRIKETHROUGH_CLASS = "xterm-strikethrough", n.CURSOR_CLASS = "xterm-cursor", n.CURSOR_BLINK_CLASS = "xterm-cursor-blink", n.CURSOR_STYLE_BLOCK_CLASS = "xterm-cursor-block", n.CURSOR_STYLE_BAR_CLASS = "xterm-cursor-bar", n.CURSOR_STYLE_UNDERLINE_CLASS = "xterm-cursor-underline";
        let v = class {
          constructor(x, k, y, I, A, M, L) {
            this._document = x, this._characterJoinerService = k, this._optionsService = y, this._coreBrowserService = I, this._coreService = A, this._decorationService = M, this._themeService = L, this._workCell = new b.CellData(), this._columnSelectMode = !1;
          }
          handleSelectionChanged(x, k, y) {
            this._selectionStart = x, this._selectionEnd = k, this._columnSelectMode = y;
          }
          createRow(x, k, y, I, A, M, L, O, U) {
            const j = this._document.createDocumentFragment(), K = this._characterJoinerService.getJoinedCharacters(k);
            let T = 0;
            for (let G = Math.min(x.length, O) - 1; G >= 0; G--)
              if (x.loadCell(G, this._workCell).getCode() !== C.NULL_CELL_CODE || y && G === A) {
                T = G + 1;
                break;
              }
            const P = this._themeService.colors;
            let H = -1, N = 0;
            for (; N < T; N++) {
              x.loadCell(N, this._workCell);
              let G = this._workCell.getWidth();
              if (G === 0) {
                U[N] = H;
                continue;
              }
              let Z = !1, ae = N, q = this._workCell;
              if (K.length > 0 && N === K[0][0]) {
                Z = !0;
                const ge = K.shift();
                q = new _.JoinedCellData(this._workCell, x.translateToString(!0, ge[0], ge[1]), ge[1] - ge[0]), ae = ge[1] - 1, G = q.getWidth();
              }
              const ee = this._document.createElement("span");
              if (G > 1 && (ee.style.width = L * G + "px"), Z && (ee.style.display = "inline", A >= N && A <= ae && (A = N)), !this._coreService.isCursorHidden && y && N === A)
                switch (ee.classList.add(n.CURSOR_CLASS), M && ee.classList.add(n.CURSOR_BLINK_CLASS), I) {
                  case "bar":
                    ee.classList.add(n.CURSOR_STYLE_BAR_CLASS);
                    break;
                  case "underline":
                    ee.classList.add(n.CURSOR_STYLE_UNDERLINE_CLASS);
                    break;
                  default:
                    ee.classList.add(n.CURSOR_STYLE_BLOCK_CLASS);
                }
              if (q.isBold() && ee.classList.add(n.BOLD_CLASS), q.isItalic() && ee.classList.add(n.ITALIC_CLASS), q.isDim() && ee.classList.add(n.DIM_CLASS), q.isInvisible() ? ee.textContent = C.WHITESPACE_CELL_CHAR : ee.textContent = q.getChars() || C.WHITESPACE_CELL_CHAR, q.isUnderline() && (ee.classList.add(`${n.UNDERLINE_CLASS}-${q.extended.underlineStyle}`), ee.textContent === " " && (ee.textContent = " "), !q.isUnderlineColorDefault()))
                if (q.isUnderlineColorRGB())
                  ee.style.textDecorationColor = `rgb(${d.AttributeData.toColorRGB(q.getUnderlineColor()).join(",")})`;
                else {
                  let ge = q.getUnderlineColor();
                  this._optionsService.rawOptions.drawBoldTextInBrightColors && q.isBold() && ge < 8 && (ge += 8), ee.style.textDecorationColor = P.ansi[ge].css;
                }
              q.isOverline() && (ee.classList.add(n.OVERLINE_CLASS), ee.textContent === " " && (ee.textContent = " ")), q.isStrikethrough() && ee.classList.add(n.STRIKETHROUGH_CLASS);
              let W = q.getFgColor(), F = q.getFgColorMode(), B = q.getBgColor(), $ = q.getBgColorMode();
              const z = !!q.isInverse();
              if (z) {
                const ge = W;
                W = B, B = ge;
                const Xa = F;
                F = $, $ = Xa;
              }
              let ce, Y, ke = !1;
              this._decorationService.forEachDecorationAtCell(N, k, void 0, (ge) => {
                ge.options.layer !== "top" && ke || (ge.backgroundColorRGB && ($ = 50331648, B = ge.backgroundColorRGB.rgba >> 8 & 16777215, ce = ge.backgroundColorRGB), ge.foregroundColorRGB && (F = 50331648, W = ge.foregroundColorRGB.rgba >> 8 & 16777215, Y = ge.foregroundColorRGB), ke = ge.options.layer === "top");
              });
              const Pe = this._isCellInSelection(N, k);
              let Ie;
              switch (ke || P.selectionForeground && Pe && (F = 50331648, W = P.selectionForeground.rgba >> 8 & 16777215, Y = P.selectionForeground), Pe && (ce = this._coreBrowserService.isFocused ? P.selectionBackgroundOpaque : P.selectionInactiveBackgroundOpaque, ke = !0), ke && ee.classList.add("xterm-decoration-top"), $) {
                case 16777216:
                case 33554432:
                  Ie = P.ansi[B], ee.classList.add(`xterm-bg-${B}`);
                  break;
                case 50331648:
                  Ie = S.rgba.toColor(B >> 16, B >> 8 & 255, 255 & B), this._addStyle(ee, `background-color:#${w((B >>> 0).toString(16), "0", 6)}`);
                  break;
                default:
                  z ? (Ie = P.foreground, ee.classList.add(`xterm-bg-${m.INVERTED_DEFAULT_COLOR}`)) : Ie = P.background;
              }
              switch (ce || q.isDim() && (ce = S.color.multiplyOpacity(Ie, 0.5)), F) {
                case 16777216:
                case 33554432:
                  q.isBold() && W < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && (W += 8), this._applyMinimumContrast(ee, Ie, P.ansi[W], q, ce, void 0) || ee.classList.add(`xterm-fg-${W}`);
                  break;
                case 50331648:
                  const ge = S.rgba.toColor(W >> 16 & 255, W >> 8 & 255, 255 & W);
                  this._applyMinimumContrast(ee, Ie, ge, q, ce, Y) || this._addStyle(ee, `color:#${w(W.toString(16), "0", 6)}`);
                  break;
                default:
                  this._applyMinimumContrast(ee, Ie, P.foreground, q, ce, void 0) || z && ee.classList.add(`xterm-fg-${m.INVERTED_DEFAULT_COLOR}`);
              }
              j.appendChild(ee), U[N] = ++H, N = ae;
            }
            return N < O - 1 && U.subarray(N).fill(++H), j;
          }
          _applyMinimumContrast(x, k, y, I, A, M) {
            if (this._optionsService.rawOptions.minimumContrastRatio === 1 || (0, u.excludeFromContrastRatioDemands)(I.getCode()))
              return !1;
            let L;
            return A || M || (L = this._themeService.colors.contrastCache.getColor(k.rgba, y.rgba)), L === void 0 && (L = S.color.ensureContrastRatio(A || k, M || y, this._optionsService.rawOptions.minimumContrastRatio), this._themeService.colors.contrastCache.setColor((A || k).rgba, (M || y).rgba, L ?? null)), !!L && (this._addStyle(x, `color:${L.css}`), !0);
          }
          _addStyle(x, k) {
            x.setAttribute("style", `${x.getAttribute("style") || ""}${k};`);
          }
          _isCellInSelection(x, k) {
            const y = this._selectionStart, I = this._selectionEnd;
            return !(!y || !I) && (this._columnSelectMode ? y[0] <= I[0] ? x >= y[0] && k >= y[1] && x < I[0] && k <= I[1] : x < y[0] && k >= y[1] && x >= I[0] && k <= I[1] : k > y[1] && k < I[1] || y[1] === I[1] && k === y[1] && x >= y[0] && x < I[0] || y[1] < I[1] && k === I[1] && x < I[0] || y[1] < I[1] && k === y[1] && x >= y[0]);
          }
        };
        function w(x, k, y) {
          for (; x.length < y; )
            x = k + x;
          return x;
        }
        v = a([f(1, o.ICharacterJoinerService), f(2, p.IOptionsService), f(3, o.ICoreBrowserService), f(4, p.ICoreService), f(5, p.IDecorationService), f(6, o.IThemeService)], v), n.DomRendererRowFactory = v;
      }, 2223: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.TEXT_BASELINE = n.DIM_OPACITY = n.INVERTED_DEFAULT_COLOR = void 0;
        const a = r(6114);
        n.INVERTED_DEFAULT_COLOR = 257, n.DIM_OPACITY = 0.5, n.TEXT_BASELINE = a.isFirefox || a.isLegacyEdge ? "bottom" : "ideographic";
      }, 6171: (l, n) => {
        function r(a) {
          return 57508 <= a && a <= 57558;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.createRenderDimensions = n.excludeFromContrastRatioDemands = n.isRestrictedPowerlineGlyph = n.isPowerlineGlyph = n.throwIfFalsy = void 0, n.throwIfFalsy = function(a) {
          if (!a)
            throw new Error("value must not be falsy");
          return a;
        }, n.isPowerlineGlyph = r, n.isRestrictedPowerlineGlyph = function(a) {
          return 57520 <= a && a <= 57527;
        }, n.excludeFromContrastRatioDemands = function(a) {
          return r(a) || function(f) {
            return 9472 <= f && f <= 9631;
          }(a);
        }, n.createRenderDimensions = function() {
          return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } };
        };
      }, 456: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.SelectionModel = void 0, n.SelectionModel = class {
          constructor(r) {
            this._bufferService = r, this.isSelectAllActive = !1, this.selectionStartLength = 0;
          }
          clearSelection() {
            this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = !1, this.selectionStartLength = 0;
          }
          get finalSelectionStart() {
            return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
          }
          get finalSelectionEnd() {
            if (this.isSelectAllActive)
              return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1];
            if (this.selectionStart) {
              if (!this.selectionEnd || this.areSelectionValuesReversed()) {
                const r = this.selectionStart[0] + this.selectionStartLength;
                return r > this._bufferService.cols ? r % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(r / this._bufferService.cols) - 1] : [r % this._bufferService.cols, this.selectionStart[1] + Math.floor(r / this._bufferService.cols)] : [r, this.selectionStart[1]];
              }
              if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
                const r = this.selectionStart[0] + this.selectionStartLength;
                return r > this._bufferService.cols ? [r % this._bufferService.cols, this.selectionStart[1] + Math.floor(r / this._bufferService.cols)] : [Math.max(r, this.selectionEnd[0]), this.selectionEnd[1]];
              }
              return this.selectionEnd;
            }
          }
          areSelectionValuesReversed() {
            const r = this.selectionStart, a = this.selectionEnd;
            return !(!r || !a) && (r[1] > a[1] || r[1] === a[1] && r[0] > a[0]);
          }
          handleTrim(r) {
            return this.selectionStart && (this.selectionStart[1] -= r), this.selectionEnd && (this.selectionEnd[1] -= r), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), !0) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), !1);
          }
        };
      }, 428: function(l, n, r) {
        var a = this && this.__decorate || function(o, _, u, d) {
          var v, w = arguments.length, x = w < 3 ? _ : d === null ? d = Object.getOwnPropertyDescriptor(_, u) : d;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            x = Reflect.decorate(o, _, u, d);
          else
            for (var k = o.length - 1; k >= 0; k--)
              (v = o[k]) && (x = (w < 3 ? v(x) : w > 3 ? v(_, u, x) : v(_, u)) || x);
          return w > 3 && x && Object.defineProperty(_, u, x), x;
        }, f = this && this.__param || function(o, _) {
          return function(u, d) {
            _(u, d, o);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.CharSizeService = void 0;
        const m = r(2585), C = r(8460), b = r(844);
        let p = class extends b.Disposable {
          constructor(o, _, u) {
            super(), this._optionsService = u, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new C.EventEmitter()), this.onCharSizeChange = this._onCharSizeChange.event, this._measureStrategy = new S(o, _, this._optionsService), this.register(this._optionsService.onMultipleOptionChange(["fontFamily", "fontSize"], () => this.measure()));
          }
          get hasValidSize() {
            return this.width > 0 && this.height > 0;
          }
          measure() {
            const o = this._measureStrategy.measure();
            o.width === this.width && o.height === this.height || (this.width = o.width, this.height = o.height, this._onCharSizeChange.fire());
          }
        };
        p = a([f(2, m.IOptionsService)], p), n.CharSizeService = p;
        class S {
          constructor(_, u, d) {
            this._document = _, this._parentElement = u, this._optionsService = d, this._result = { width: 0, height: 0 }, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W", this._measureElement.setAttribute("aria-hidden", "true"), this._parentElement.appendChild(this._measureElement);
          }
          measure() {
            this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`;
            const _ = this._measureElement.getBoundingClientRect();
            return _.width !== 0 && _.height !== 0 && (this._result.width = _.width, this._result.height = Math.ceil(_.height)), this._result;
          }
        }
      }, 4269: function(l, n, r) {
        var a = this && this.__decorate || function(_, u, d, v) {
          var w, x = arguments.length, k = x < 3 ? u : v === null ? v = Object.getOwnPropertyDescriptor(u, d) : v;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            k = Reflect.decorate(_, u, d, v);
          else
            for (var y = _.length - 1; y >= 0; y--)
              (w = _[y]) && (k = (x < 3 ? w(k) : x > 3 ? w(u, d, k) : w(u, d)) || k);
          return x > 3 && k && Object.defineProperty(u, d, k), k;
        }, f = this && this.__param || function(_, u) {
          return function(d, v) {
            u(d, v, _);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.CharacterJoinerService = n.JoinedCellData = void 0;
        const m = r(3734), C = r(643), b = r(511), p = r(2585);
        class S extends m.AttributeData {
          constructor(u, d, v) {
            super(), this.content = 0, this.combinedData = "", this.fg = u.fg, this.bg = u.bg, this.combinedData = d, this._width = v;
          }
          isCombined() {
            return 2097152;
          }
          getWidth() {
            return this._width;
          }
          getChars() {
            return this.combinedData;
          }
          getCode() {
            return 2097151;
          }
          setFromCharData(u) {
            throw new Error("not implemented");
          }
          getAsCharData() {
            return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
          }
        }
        n.JoinedCellData = S;
        let o = class $a {
          constructor(u) {
            this._bufferService = u, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new b.CellData();
          }
          register(u) {
            const d = { id: this._nextCharacterJoinerId++, handler: u };
            return this._characterJoiners.push(d), d.id;
          }
          deregister(u) {
            for (let d = 0; d < this._characterJoiners.length; d++)
              if (this._characterJoiners[d].id === u)
                return this._characterJoiners.splice(d, 1), !0;
            return !1;
          }
          getJoinedCharacters(u) {
            if (this._characterJoiners.length === 0)
              return [];
            const d = this._bufferService.buffer.lines.get(u);
            if (!d || d.length === 0)
              return [];
            const v = [], w = d.translateToString(!0);
            let x = 0, k = 0, y = 0, I = d.getFg(0), A = d.getBg(0);
            for (let M = 0; M < d.getTrimmedLength(); M++)
              if (d.loadCell(M, this._workCell), this._workCell.getWidth() !== 0) {
                if (this._workCell.fg !== I || this._workCell.bg !== A) {
                  if (M - x > 1) {
                    const L = this._getJoinedRanges(w, y, k, d, x);
                    for (let O = 0; O < L.length; O++)
                      v.push(L[O]);
                  }
                  x = M, y = k, I = this._workCell.fg, A = this._workCell.bg;
                }
                k += this._workCell.getChars().length || C.WHITESPACE_CELL_CHAR.length;
              }
            if (this._bufferService.cols - x > 1) {
              const M = this._getJoinedRanges(w, y, k, d, x);
              for (let L = 0; L < M.length; L++)
                v.push(M[L]);
            }
            return v;
          }
          _getJoinedRanges(u, d, v, w, x) {
            const k = u.substring(d, v);
            let y = [];
            try {
              y = this._characterJoiners[0].handler(k);
            } catch (I) {
              console.error(I);
            }
            for (let I = 1; I < this._characterJoiners.length; I++)
              try {
                const A = this._characterJoiners[I].handler(k);
                for (let M = 0; M < A.length; M++)
                  $a._mergeRanges(y, A[M]);
              } catch (A) {
                console.error(A);
              }
            return this._stringRangesToCellRanges(y, w, x), y;
          }
          _stringRangesToCellRanges(u, d, v) {
            let w = 0, x = !1, k = 0, y = u[w];
            if (y) {
              for (let I = v; I < this._bufferService.cols; I++) {
                const A = d.getWidth(I), M = d.getString(I).length || C.WHITESPACE_CELL_CHAR.length;
                if (A !== 0) {
                  if (!x && y[0] <= k && (y[0] = I, x = !0), y[1] <= k) {
                    if (y[1] = I, y = u[++w], !y)
                      break;
                    y[0] <= k ? (y[0] = I, x = !0) : x = !1;
                  }
                  k += M;
                }
              }
              y && (y[1] = this._bufferService.cols);
            }
          }
          static _mergeRanges(u, d) {
            let v = !1;
            for (let w = 0; w < u.length; w++) {
              const x = u[w];
              if (v) {
                if (d[1] <= x[0])
                  return u[w - 1][1] = d[1], u;
                if (d[1] <= x[1])
                  return u[w - 1][1] = Math.max(d[1], x[1]), u.splice(w, 1), u;
                u.splice(w, 1), w--;
              } else {
                if (d[1] <= x[0])
                  return u.splice(w, 0, d), u;
                if (d[1] <= x[1])
                  return x[0] = Math.min(d[0], x[0]), u;
                d[0] < x[1] && (x[0] = Math.min(d[0], x[0]), v = !0);
              }
            }
            return v ? u[u.length - 1][1] = d[1] : u.push(d), u;
          }
        };
        o = a([f(0, p.IBufferService)], o), n.CharacterJoinerService = o;
      }, 5114: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.CoreBrowserService = void 0, n.CoreBrowserService = class {
          constructor(r, a) {
            this._textarea = r, this.window = a, this._isFocused = !1, this._cachedIsFocused = void 0, this._textarea.addEventListener("focus", () => this._isFocused = !0), this._textarea.addEventListener("blur", () => this._isFocused = !1);
          }
          get dpr() {
            return this.window.devicePixelRatio;
          }
          get isFocused() {
            return this._cachedIsFocused === void 0 && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask(() => this._cachedIsFocused = void 0)), this._cachedIsFocused;
          }
        };
      }, 8934: function(l, n, r) {
        var a = this && this.__decorate || function(p, S, o, _) {
          var u, d = arguments.length, v = d < 3 ? S : _ === null ? _ = Object.getOwnPropertyDescriptor(S, o) : _;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            v = Reflect.decorate(p, S, o, _);
          else
            for (var w = p.length - 1; w >= 0; w--)
              (u = p[w]) && (v = (d < 3 ? u(v) : d > 3 ? u(S, o, v) : u(S, o)) || v);
          return d > 3 && v && Object.defineProperty(S, o, v), v;
        }, f = this && this.__param || function(p, S) {
          return function(o, _) {
            S(o, _, p);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.MouseService = void 0;
        const m = r(4725), C = r(9806);
        let b = class {
          constructor(p, S) {
            this._renderService = p, this._charSizeService = S;
          }
          getCoords(p, S, o, _, u) {
            return (0, C.getCoords)(window, p, S, o, _, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, u);
          }
          getMouseReportCoords(p, S) {
            const o = (0, C.getCoordsRelativeToElement)(window, p, S);
            if (!(!this._charSizeService.hasValidSize || o[0] < 0 || o[1] < 0 || o[0] >= this._renderService.dimensions.css.canvas.width || o[1] >= this._renderService.dimensions.css.canvas.height))
              return { col: Math.floor(o[0] / this._renderService.dimensions.css.cell.width), row: Math.floor(o[1] / this._renderService.dimensions.css.cell.height), x: Math.floor(o[0]), y: Math.floor(o[1]) };
          }
        };
        b = a([f(0, m.IRenderService), f(1, m.ICharSizeService)], b), n.MouseService = b;
      }, 3230: function(l, n, r) {
        var a = this && this.__decorate || function(v, w, x, k) {
          var y, I = arguments.length, A = I < 3 ? w : k === null ? k = Object.getOwnPropertyDescriptor(w, x) : k;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            A = Reflect.decorate(v, w, x, k);
          else
            for (var M = v.length - 1; M >= 0; M--)
              (y = v[M]) && (A = (I < 3 ? y(A) : I > 3 ? y(w, x, A) : y(w, x)) || A);
          return I > 3 && A && Object.defineProperty(w, x, A), A;
        }, f = this && this.__param || function(v, w) {
          return function(x, k) {
            w(x, k, v);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.RenderService = void 0;
        const m = r(6193), C = r(8460), b = r(844), p = r(5596), S = r(3656), o = r(2585), _ = r(4725), u = r(7226);
        let d = class extends b.Disposable {
          constructor(v, w, x, k, y, I, A, M) {
            if (super(), this._rowCount = v, this._charSizeService = k, this._pausedResizeTask = new u.DebouncedIdleTask(), this._isPaused = !1, this._needsFullRefresh = !1, this._isNextRenderRedrawOnly = !0, this._needsSelectionRefresh = !1, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = { start: void 0, end: void 0, columnSelectMode: !1 }, this._onDimensionsChange = this.register(new C.EventEmitter()), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new C.EventEmitter()), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new C.EventEmitter()), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new C.EventEmitter()), this.onRefreshRequest = this._onRefreshRequest.event, this.register({ dispose: () => {
              var L;
              return (L = this._renderer) === null || L === void 0 ? void 0 : L.dispose();
            } }), this._renderDebouncer = new m.RenderDebouncer(A.window, (L, O) => this._renderRows(L, O)), this.register(this._renderDebouncer), this._screenDprMonitor = new p.ScreenDprMonitor(A.window), this._screenDprMonitor.setListener(() => this.handleDevicePixelRatioChange()), this.register(this._screenDprMonitor), this.register(I.onResize(() => this._fullRefresh())), this.register(I.buffers.onBufferActivate(() => {
              var L;
              return (L = this._renderer) === null || L === void 0 ? void 0 : L.clear();
            })), this.register(x.onOptionChange(() => this._handleOptionsChanged())), this.register(this._charSizeService.onCharSizeChange(() => this.handleCharSizeChanged())), this.register(y.onDecorationRegistered(() => this._fullRefresh())), this.register(y.onDecorationRemoved(() => this._fullRefresh())), this.register(x.onMultipleOptionChange(["customGlyphs", "drawBoldTextInBrightColors", "letterSpacing", "lineHeight", "fontFamily", "fontSize", "fontWeight", "fontWeightBold", "minimumContrastRatio"], () => {
              this.clear(), this.handleResize(I.cols, I.rows), this._fullRefresh();
            })), this.register(x.onMultipleOptionChange(["cursorBlink", "cursorStyle"], () => this.refreshRows(I.buffer.y, I.buffer.y, !0))), this.register((0, S.addDisposableDomListener)(A.window, "resize", () => this.handleDevicePixelRatioChange())), this.register(M.onChangeColors(() => this._fullRefresh())), "IntersectionObserver" in A.window) {
              const L = new A.window.IntersectionObserver((O) => this._handleIntersectionChange(O[O.length - 1]), { threshold: 0 });
              L.observe(w), this.register({ dispose: () => L.disconnect() });
            }
          }
          get dimensions() {
            return this._renderer.dimensions;
          }
          _handleIntersectionChange(v) {
            this._isPaused = v.isIntersecting === void 0 ? v.intersectionRatio === 0 : !v.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = !1);
          }
          refreshRows(v, w, x = !1) {
            this._isPaused ? this._needsFullRefresh = !0 : (x || (this._isNextRenderRedrawOnly = !1), this._renderDebouncer.refresh(v, w, this._rowCount));
          }
          _renderRows(v, w) {
            this._renderer && (v = Math.min(v, this._rowCount - 1), w = Math.min(w, this._rowCount - 1), this._renderer.renderRows(v, w), this._needsSelectionRefresh && (this._renderer.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = !1), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({ start: v, end: w }), this._onRender.fire({ start: v, end: w }), this._isNextRenderRedrawOnly = !0);
          }
          resize(v, w) {
            this._rowCount = w, this._fireOnCanvasResize();
          }
          _handleOptionsChanged() {
            this._renderer && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize());
          }
          _fireOnCanvasResize() {
            this._renderer && (this._renderer.dimensions.css.canvas.width === this._canvasWidth && this._renderer.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.dimensions));
          }
          hasRenderer() {
            return !!this._renderer;
          }
          setRenderer(v) {
            var w;
            (w = this._renderer) === null || w === void 0 || w.dispose(), this._renderer = v, this._renderer.onRequestRedraw((x) => this.refreshRows(x.start, x.end, !0)), this._needsSelectionRefresh = !0, this._fullRefresh();
          }
          addRefreshCallback(v) {
            return this._renderDebouncer.addRefreshCallback(v);
          }
          _fullRefresh() {
            this._isPaused ? this._needsFullRefresh = !0 : this.refreshRows(0, this._rowCount - 1);
          }
          clearTextureAtlas() {
            var v, w;
            this._renderer && ((w = (v = this._renderer).clearTextureAtlas) === null || w === void 0 || w.call(v), this._fullRefresh());
          }
          handleDevicePixelRatioChange() {
            this._charSizeService.measure(), this._renderer && (this._renderer.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1));
          }
          handleResize(v, w) {
            this._renderer && (this._isPaused ? this._pausedResizeTask.set(() => this._renderer.handleResize(v, w)) : this._renderer.handleResize(v, w), this._fullRefresh());
          }
          handleCharSizeChanged() {
            var v;
            (v = this._renderer) === null || v === void 0 || v.handleCharSizeChanged();
          }
          handleBlur() {
            var v;
            (v = this._renderer) === null || v === void 0 || v.handleBlur();
          }
          handleFocus() {
            var v;
            (v = this._renderer) === null || v === void 0 || v.handleFocus();
          }
          handleSelectionChanged(v, w, x) {
            var k;
            this._selectionState.start = v, this._selectionState.end = w, this._selectionState.columnSelectMode = x, (k = this._renderer) === null || k === void 0 || k.handleSelectionChanged(v, w, x);
          }
          handleCursorMove() {
            var v;
            (v = this._renderer) === null || v === void 0 || v.handleCursorMove();
          }
          clear() {
            var v;
            (v = this._renderer) === null || v === void 0 || v.clear();
          }
        };
        d = a([f(2, o.IOptionsService), f(3, _.ICharSizeService), f(4, o.IDecorationService), f(5, o.IBufferService), f(6, _.ICoreBrowserService), f(7, _.IThemeService)], d), n.RenderService = d;
      }, 9312: function(l, n, r) {
        var a = this && this.__decorate || function(y, I, A, M) {
          var L, O = arguments.length, U = O < 3 ? I : M === null ? M = Object.getOwnPropertyDescriptor(I, A) : M;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            U = Reflect.decorate(y, I, A, M);
          else
            for (var j = y.length - 1; j >= 0; j--)
              (L = y[j]) && (U = (O < 3 ? L(U) : O > 3 ? L(I, A, U) : L(I, A)) || U);
          return O > 3 && U && Object.defineProperty(I, A, U), U;
        }, f = this && this.__param || function(y, I) {
          return function(A, M) {
            I(A, M, y);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.SelectionService = void 0;
        const m = r(6114), C = r(456), b = r(511), p = r(8460), S = r(4725), o = r(2585), _ = r(9806), u = r(9504), d = r(844), v = r(4841), w = String.fromCharCode(160), x = new RegExp(w, "g");
        let k = class extends d.Disposable {
          constructor(y, I, A, M, L, O, U, j, K) {
            super(), this._element = y, this._screenElement = I, this._linkifier = A, this._bufferService = M, this._coreService = L, this._mouseService = O, this._optionsService = U, this._renderService = j, this._coreBrowserService = K, this._dragScrollAmount = 0, this._enabled = !0, this._workCell = new b.CellData(), this._mouseDownTimeStamp = 0, this._oldHasSelection = !1, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new p.EventEmitter()), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new p.EventEmitter()), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new p.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new p.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = (T) => this._handleMouseMove(T), this._mouseUpListener = (T) => this._handleMouseUp(T), this._coreService.onUserInput(() => {
              this.hasSelection && this.clearSelection();
            }), this._trimListener = this._bufferService.buffer.lines.onTrim((T) => this._handleTrim(T)), this.register(this._bufferService.buffers.onBufferActivate((T) => this._handleBufferActivate(T))), this.enable(), this._model = new C.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, d.toDisposable)(() => {
              this._removeMouseDownListeners();
            }));
          }
          reset() {
            this.clearSelection();
          }
          disable() {
            this.clearSelection(), this._enabled = !1;
          }
          enable() {
            this._enabled = !0;
          }
          get selectionStart() {
            return this._model.finalSelectionStart;
          }
          get selectionEnd() {
            return this._model.finalSelectionEnd;
          }
          get hasSelection() {
            const y = this._model.finalSelectionStart, I = this._model.finalSelectionEnd;
            return !(!y || !I || y[0] === I[0] && y[1] === I[1]);
          }
          get selectionText() {
            const y = this._model.finalSelectionStart, I = this._model.finalSelectionEnd;
            if (!y || !I)
              return "";
            const A = this._bufferService.buffer, M = [];
            if (this._activeSelectionMode === 3) {
              if (y[0] === I[0])
                return "";
              const L = y[0] < I[0] ? y[0] : I[0], O = y[0] < I[0] ? I[0] : y[0];
              for (let U = y[1]; U <= I[1]; U++) {
                const j = A.translateBufferLineToString(U, !0, L, O);
                M.push(j);
              }
            } else {
              const L = y[1] === I[1] ? I[0] : void 0;
              M.push(A.translateBufferLineToString(y[1], !0, y[0], L));
              for (let O = y[1] + 1; O <= I[1] - 1; O++) {
                const U = A.lines.get(O), j = A.translateBufferLineToString(O, !0);
                U != null && U.isWrapped ? M[M.length - 1] += j : M.push(j);
              }
              if (y[1] !== I[1]) {
                const O = A.lines.get(I[1]), U = A.translateBufferLineToString(I[1], !0, 0, I[0]);
                O && O.isWrapped ? M[M.length - 1] += U : M.push(U);
              }
            }
            return M.map((L) => L.replace(x, " ")).join(m.isWindows ? `\r
` : `
`);
          }
          clearSelection() {
            this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();
          }
          refresh(y) {
            this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._refresh())), m.isLinux && y && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);
          }
          _refresh() {
            this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({ start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd, columnSelectMode: this._activeSelectionMode === 3 });
          }
          _isClickInSelection(y) {
            const I = this._getMouseBufferCoords(y), A = this._model.finalSelectionStart, M = this._model.finalSelectionEnd;
            return !!(A && M && I) && this._areCoordsInSelection(I, A, M);
          }
          isCellInSelection(y, I) {
            const A = this._model.finalSelectionStart, M = this._model.finalSelectionEnd;
            return !(!A || !M) && this._areCoordsInSelection([y, I], A, M);
          }
          _areCoordsInSelection(y, I, A) {
            return y[1] > I[1] && y[1] < A[1] || I[1] === A[1] && y[1] === I[1] && y[0] >= I[0] && y[0] < A[0] || I[1] < A[1] && y[1] === A[1] && y[0] < A[0] || I[1] < A[1] && y[1] === I[1] && y[0] >= I[0];
          }
          _selectWordAtCursor(y, I) {
            var A, M;
            const L = (M = (A = this._linkifier.currentLink) === null || A === void 0 ? void 0 : A.link) === null || M === void 0 ? void 0 : M.range;
            if (L)
              return this._model.selectionStart = [L.start.x - 1, L.start.y - 1], this._model.selectionStartLength = (0, v.getRangeLength)(L, this._bufferService.cols), this._model.selectionEnd = void 0, !0;
            const O = this._getMouseBufferCoords(y);
            return !!O && (this._selectWordAt(O, I), this._model.selectionEnd = void 0, !0);
          }
          selectAll() {
            this._model.isSelectAllActive = !0, this.refresh(), this._onSelectionChange.fire();
          }
          selectLines(y, I) {
            this._model.clearSelection(), y = Math.max(y, 0), I = Math.min(I, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [0, y], this._model.selectionEnd = [this._bufferService.cols, I], this.refresh(), this._onSelectionChange.fire();
          }
          _handleTrim(y) {
            this._model.handleTrim(y) && this.refresh();
          }
          _getMouseBufferCoords(y) {
            const I = this._mouseService.getCoords(y, this._screenElement, this._bufferService.cols, this._bufferService.rows, !0);
            if (I)
              return I[0]--, I[1]--, I[1] += this._bufferService.buffer.ydisp, I;
          }
          _getMouseEventScrollAmount(y) {
            let I = (0, _.getCoordsRelativeToElement)(this._coreBrowserService.window, y, this._screenElement)[1];
            const A = this._renderService.dimensions.css.canvas.height;
            return I >= 0 && I <= A ? 0 : (I > A && (I -= A), I = Math.min(Math.max(I, -50), 50), I /= 50, I / Math.abs(I) + Math.round(14 * I));
          }
          shouldForceSelection(y) {
            return m.isMac ? y.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : y.shiftKey;
          }
          handleMouseDown(y) {
            if (this._mouseDownTimeStamp = y.timeStamp, (y.button !== 2 || !this.hasSelection) && y.button === 0) {
              if (!this._enabled) {
                if (!this.shouldForceSelection(y))
                  return;
                y.stopPropagation();
              }
              y.preventDefault(), this._dragScrollAmount = 0, this._enabled && y.shiftKey ? this._handleIncrementalClick(y) : y.detail === 1 ? this._handleSingleClick(y) : y.detail === 2 ? this._handleDoubleClick(y) : y.detail === 3 && this._handleTripleClick(y), this._addMouseDownListeners(), this.refresh(!0);
            }
          }
          _addMouseDownListeners() {
            this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval(() => this._dragScroll(), 50);
          }
          _removeMouseDownListeners() {
            this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0;
          }
          _handleIncrementalClick(y) {
            this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(y));
          }
          _handleSingleClick(y) {
            if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = !1, this._activeSelectionMode = this.shouldColumnSelect(y) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(y), !this._model.selectionStart)
              return;
            this._model.selectionEnd = void 0;
            const I = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
            I && I.length !== this._model.selectionStart[0] && I.hasWidth(this._model.selectionStart[0]) === 0 && this._model.selectionStart[0]++;
          }
          _handleDoubleClick(y) {
            this._selectWordAtCursor(y, !0) && (this._activeSelectionMode = 1);
          }
          _handleTripleClick(y) {
            const I = this._getMouseBufferCoords(y);
            I && (this._activeSelectionMode = 2, this._selectLineAt(I[1]));
          }
          shouldColumnSelect(y) {
            return y.altKey && !(m.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);
          }
          _handleMouseMove(y) {
            if (y.stopImmediatePropagation(), !this._model.selectionStart)
              return;
            const I = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
            if (this._model.selectionEnd = this._getMouseBufferCoords(y), !this._model.selectionEnd)
              return void this.refresh(!0);
            this._activeSelectionMode === 2 ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : this._activeSelectionMode === 1 && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(y), this._activeSelectionMode !== 3 && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
            const A = this._bufferService.buffer;
            if (this._model.selectionEnd[1] < A.lines.length) {
              const M = A.lines.get(this._model.selectionEnd[1]);
              M && M.hasWidth(this._model.selectionEnd[0]) === 0 && this._model.selectionEnd[0]++;
            }
            I && I[0] === this._model.selectionEnd[0] && I[1] === this._model.selectionEnd[1] || this.refresh(!0);
          }
          _dragScroll() {
            if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
              this._onRequestScrollLines.fire({ amount: this._dragScrollAmount, suppressScrollEvent: !1 });
              const y = this._bufferService.buffer;
              this._dragScrollAmount > 0 ? (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(y.ydisp + this._bufferService.rows, y.lines.length - 1)) : (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = y.ydisp), this.refresh();
            }
          }
          _handleMouseUp(y) {
            const I = y.timeStamp - this._mouseDownTimeStamp;
            if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && I < 500 && y.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
              if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
                const A = this._mouseService.getCoords(y, this._element, this._bufferService.cols, this._bufferService.rows, !1);
                if (A && A[0] !== void 0 && A[1] !== void 0) {
                  const M = (0, u.moveToCellSequence)(A[0] - 1, A[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                  this._coreService.triggerDataEvent(M, !0);
                }
              }
            } else
              this._fireEventIfSelectionChanged();
          }
          _fireEventIfSelectionChanged() {
            const y = this._model.finalSelectionStart, I = this._model.finalSelectionEnd, A = !(!y || !I || y[0] === I[0] && y[1] === I[1]);
            A ? y && I && (this._oldSelectionStart && this._oldSelectionEnd && y[0] === this._oldSelectionStart[0] && y[1] === this._oldSelectionStart[1] && I[0] === this._oldSelectionEnd[0] && I[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(y, I, A)) : this._oldHasSelection && this._fireOnSelectionChange(y, I, A);
          }
          _fireOnSelectionChange(y, I, A) {
            this._oldSelectionStart = y, this._oldSelectionEnd = I, this._oldHasSelection = A, this._onSelectionChange.fire();
          }
          _handleBufferActivate(y) {
            this.clearSelection(), this._trimListener.dispose(), this._trimListener = y.activeBuffer.lines.onTrim((I) => this._handleTrim(I));
          }
          _convertViewportColToCharacterIndex(y, I) {
            let A = I;
            for (let M = 0; I >= M; M++) {
              const L = y.loadCell(M, this._workCell).getChars().length;
              this._workCell.getWidth() === 0 ? A-- : L > 1 && I !== M && (A += L - 1);
            }
            return A;
          }
          setSelection(y, I, A) {
            this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [y, I], this._model.selectionStartLength = A, this.refresh(), this._fireEventIfSelectionChanged();
          }
          rightClickSelect(y) {
            this._isClickInSelection(y) || (this._selectWordAtCursor(y, !1) && this.refresh(!0), this._fireEventIfSelectionChanged());
          }
          _getWordAt(y, I, A = !0, M = !0) {
            if (y[0] >= this._bufferService.cols)
              return;
            const L = this._bufferService.buffer, O = L.lines.get(y[1]);
            if (!O)
              return;
            const U = L.translateBufferLineToString(y[1], !1);
            let j = this._convertViewportColToCharacterIndex(O, y[0]), K = j;
            const T = y[0] - j;
            let P = 0, H = 0, N = 0, G = 0;
            if (U.charAt(j) === " ") {
              for (; j > 0 && U.charAt(j - 1) === " "; )
                j--;
              for (; K < U.length && U.charAt(K + 1) === " "; )
                K++;
            } else {
              let q = y[0], ee = y[0];
              O.getWidth(q) === 0 && (P++, q--), O.getWidth(ee) === 2 && (H++, ee++);
              const W = O.getString(ee).length;
              for (W > 1 && (G += W - 1, K += W - 1); q > 0 && j > 0 && !this._isCharWordSeparator(O.loadCell(q - 1, this._workCell)); ) {
                O.loadCell(q - 1, this._workCell);
                const F = this._workCell.getChars().length;
                this._workCell.getWidth() === 0 ? (P++, q--) : F > 1 && (N += F - 1, j -= F - 1), j--, q--;
              }
              for (; ee < O.length && K + 1 < U.length && !this._isCharWordSeparator(O.loadCell(ee + 1, this._workCell)); ) {
                O.loadCell(ee + 1, this._workCell);
                const F = this._workCell.getChars().length;
                this._workCell.getWidth() === 2 ? (H++, ee++) : F > 1 && (G += F - 1, K += F - 1), K++, ee++;
              }
            }
            K++;
            let Z = j + T - P + N, ae = Math.min(this._bufferService.cols, K - j + P + H - N - G);
            if (I || U.slice(j, K).trim() !== "") {
              if (A && Z === 0 && O.getCodePoint(0) !== 32) {
                const q = L.lines.get(y[1] - 1);
                if (q && O.isWrapped && q.getCodePoint(this._bufferService.cols - 1) !== 32) {
                  const ee = this._getWordAt([this._bufferService.cols - 1, y[1] - 1], !1, !0, !1);
                  if (ee) {
                    const W = this._bufferService.cols - ee.start;
                    Z -= W, ae += W;
                  }
                }
              }
              if (M && Z + ae === this._bufferService.cols && O.getCodePoint(this._bufferService.cols - 1) !== 32) {
                const q = L.lines.get(y[1] + 1);
                if (q != null && q.isWrapped && q.getCodePoint(0) !== 32) {
                  const ee = this._getWordAt([0, y[1] + 1], !1, !1, !0);
                  ee && (ae += ee.length);
                }
              }
              return { start: Z, length: ae };
            }
          }
          _selectWordAt(y, I) {
            const A = this._getWordAt(y, I);
            if (A) {
              for (; A.start < 0; )
                A.start += this._bufferService.cols, y[1]--;
              this._model.selectionStart = [A.start, y[1]], this._model.selectionStartLength = A.length;
            }
          }
          _selectToWordAt(y) {
            const I = this._getWordAt(y, !0);
            if (I) {
              let A = y[1];
              for (; I.start < 0; )
                I.start += this._bufferService.cols, A--;
              if (!this._model.areSelectionValuesReversed())
                for (; I.start + I.length > this._bufferService.cols; )
                  I.length -= this._bufferService.cols, A++;
              this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? I.start : I.start + I.length, A];
            }
          }
          _isCharWordSeparator(y) {
            return y.getWidth() !== 0 && this._optionsService.rawOptions.wordSeparator.indexOf(y.getChars()) >= 0;
          }
          _selectLineAt(y) {
            const I = this._bufferService.buffer.getWrappedRangeForLine(y), A = { start: { x: 0, y: I.first }, end: { x: this._bufferService.cols - 1, y: I.last } };
            this._model.selectionStart = [0, I.first], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, v.getRangeLength)(A, this._bufferService.cols);
          }
        };
        k = a([f(3, o.IBufferService), f(4, o.ICoreService), f(5, S.IMouseService), f(6, o.IOptionsService), f(7, S.IRenderService), f(8, S.ICoreBrowserService)], k), n.SelectionService = k;
      }, 4725: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.IThemeService = n.ICharacterJoinerService = n.ISelectionService = n.IRenderService = n.IMouseService = n.ICoreBrowserService = n.ICharSizeService = void 0;
        const a = r(8343);
        n.ICharSizeService = (0, a.createDecorator)("CharSizeService"), n.ICoreBrowserService = (0, a.createDecorator)("CoreBrowserService"), n.IMouseService = (0, a.createDecorator)("MouseService"), n.IRenderService = (0, a.createDecorator)("RenderService"), n.ISelectionService = (0, a.createDecorator)("SelectionService"), n.ICharacterJoinerService = (0, a.createDecorator)("CharacterJoinerService"), n.IThemeService = (0, a.createDecorator)("ThemeService");
      }, 6731: function(l, n, r) {
        var a = this && this.__decorate || function(k, y, I, A) {
          var M, L = arguments.length, O = L < 3 ? y : A === null ? A = Object.getOwnPropertyDescriptor(y, I) : A;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            O = Reflect.decorate(k, y, I, A);
          else
            for (var U = k.length - 1; U >= 0; U--)
              (M = k[U]) && (O = (L < 3 ? M(O) : L > 3 ? M(y, I, O) : M(y, I)) || O);
          return L > 3 && O && Object.defineProperty(y, I, O), O;
        }, f = this && this.__param || function(k, y) {
          return function(I, A) {
            y(I, A, k);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.ThemeService = n.DEFAULT_ANSI_COLORS = void 0;
        const m = r(7239), C = r(8055), b = r(8460), p = r(844), S = r(2585), o = C.css.toColor("#ffffff"), _ = C.css.toColor("#000000"), u = C.css.toColor("#ffffff"), d = C.css.toColor("#000000"), v = { css: "rgba(255, 255, 255, 0.3)", rgba: 4294967117 };
        n.DEFAULT_ANSI_COLORS = Object.freeze((() => {
          const k = [C.css.toColor("#2e3436"), C.css.toColor("#cc0000"), C.css.toColor("#4e9a06"), C.css.toColor("#c4a000"), C.css.toColor("#3465a4"), C.css.toColor("#75507b"), C.css.toColor("#06989a"), C.css.toColor("#d3d7cf"), C.css.toColor("#555753"), C.css.toColor("#ef2929"), C.css.toColor("#8ae234"), C.css.toColor("#fce94f"), C.css.toColor("#729fcf"), C.css.toColor("#ad7fa8"), C.css.toColor("#34e2e2"), C.css.toColor("#eeeeec")], y = [0, 95, 135, 175, 215, 255];
          for (let I = 0; I < 216; I++) {
            const A = y[I / 36 % 6 | 0], M = y[I / 6 % 6 | 0], L = y[I % 6];
            k.push({ css: C.channels.toCss(A, M, L), rgba: C.channels.toRgba(A, M, L) });
          }
          for (let I = 0; I < 24; I++) {
            const A = 8 + 10 * I;
            k.push({ css: C.channels.toCss(A, A, A), rgba: C.channels.toRgba(A, A, A) });
          }
          return k;
        })());
        let w = class extends p.Disposable {
          constructor(k) {
            super(), this._optionsService = k, this._onChangeColors = this.register(new b.EventEmitter()), this.onChangeColors = this._onChangeColors.event, this._contrastCache = new m.ColorContrastCache(), this._colors = { foreground: o, background: _, cursor: u, cursorAccent: d, selectionForeground: void 0, selectionBackgroundTransparent: v, selectionBackgroundOpaque: C.color.blend(_, v), selectionInactiveBackgroundTransparent: v, selectionInactiveBackgroundOpaque: C.color.blend(_, v), ansi: n.DEFAULT_ANSI_COLORS.slice(), contrastCache: this._contrastCache }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", () => this._contrastCache.clear())), this.register(this._optionsService.onSpecificOptionChange("theme", () => this._setTheme(this._optionsService.rawOptions.theme)));
          }
          get colors() {
            return this._colors;
          }
          _setTheme(k = {}) {
            const y = this._colors;
            if (y.foreground = x(k.foreground, o), y.background = x(k.background, _), y.cursor = x(k.cursor, u), y.cursorAccent = x(k.cursorAccent, d), y.selectionBackgroundTransparent = x(k.selectionBackground, v), y.selectionBackgroundOpaque = C.color.blend(y.background, y.selectionBackgroundTransparent), y.selectionInactiveBackgroundTransparent = x(k.selectionInactiveBackground, y.selectionBackgroundTransparent), y.selectionInactiveBackgroundOpaque = C.color.blend(y.background, y.selectionInactiveBackgroundTransparent), y.selectionForeground = k.selectionForeground ? x(k.selectionForeground, C.NULL_COLOR) : void 0, y.selectionForeground === C.NULL_COLOR && (y.selectionForeground = void 0), C.color.isOpaque(y.selectionBackgroundTransparent) && (y.selectionBackgroundTransparent = C.color.opacity(y.selectionBackgroundTransparent, 0.3)), C.color.isOpaque(y.selectionInactiveBackgroundTransparent) && (y.selectionInactiveBackgroundTransparent = C.color.opacity(y.selectionInactiveBackgroundTransparent, 0.3)), y.ansi = n.DEFAULT_ANSI_COLORS.slice(), y.ansi[0] = x(k.black, n.DEFAULT_ANSI_COLORS[0]), y.ansi[1] = x(k.red, n.DEFAULT_ANSI_COLORS[1]), y.ansi[2] = x(k.green, n.DEFAULT_ANSI_COLORS[2]), y.ansi[3] = x(k.yellow, n.DEFAULT_ANSI_COLORS[3]), y.ansi[4] = x(k.blue, n.DEFAULT_ANSI_COLORS[4]), y.ansi[5] = x(k.magenta, n.DEFAULT_ANSI_COLORS[5]), y.ansi[6] = x(k.cyan, n.DEFAULT_ANSI_COLORS[6]), y.ansi[7] = x(k.white, n.DEFAULT_ANSI_COLORS[7]), y.ansi[8] = x(k.brightBlack, n.DEFAULT_ANSI_COLORS[8]), y.ansi[9] = x(k.brightRed, n.DEFAULT_ANSI_COLORS[9]), y.ansi[10] = x(k.brightGreen, n.DEFAULT_ANSI_COLORS[10]), y.ansi[11] = x(k.brightYellow, n.DEFAULT_ANSI_COLORS[11]), y.ansi[12] = x(k.brightBlue, n.DEFAULT_ANSI_COLORS[12]), y.ansi[13] = x(k.brightMagenta, n.DEFAULT_ANSI_COLORS[13]), y.ansi[14] = x(k.brightCyan, n.DEFAULT_ANSI_COLORS[14]), y.ansi[15] = x(k.brightWhite, n.DEFAULT_ANSI_COLORS[15]), k.extendedAnsi) {
              const I = Math.min(y.ansi.length - 16, k.extendedAnsi.length);
              for (let A = 0; A < I; A++)
                y.ansi[A + 16] = x(k.extendedAnsi[A], n.DEFAULT_ANSI_COLORS[A + 16]);
            }
            this._contrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
          }
          restoreColor(k) {
            this._restoreColor(k), this._onChangeColors.fire(this.colors);
          }
          _restoreColor(k) {
            if (k !== void 0)
              switch (k) {
                case 256:
                  this._colors.foreground = this._restoreColors.foreground;
                  break;
                case 257:
                  this._colors.background = this._restoreColors.background;
                  break;
                case 258:
                  this._colors.cursor = this._restoreColors.cursor;
                  break;
                default:
                  this._colors.ansi[k] = this._restoreColors.ansi[k];
              }
            else
              for (let y = 0; y < this._restoreColors.ansi.length; ++y)
                this._colors.ansi[y] = this._restoreColors.ansi[y];
          }
          modifyColors(k) {
            k(this._colors), this._onChangeColors.fire(this.colors);
          }
          _updateRestoreColors() {
            this._restoreColors = { foreground: this._colors.foreground, background: this._colors.background, cursor: this._colors.cursor, ansi: this._colors.ansi.slice() };
          }
        };
        function x(k, y) {
          if (k !== void 0)
            try {
              return C.css.toColor(k);
            } catch {
            }
          return y;
        }
        w = a([f(0, S.IOptionsService)], w), n.ThemeService = w;
      }, 6349: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.CircularList = void 0;
        const a = r(8460), f = r(844);
        class m extends f.Disposable {
          constructor(b) {
            super(), this._maxLength = b, this.onDeleteEmitter = this.register(new a.EventEmitter()), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new a.EventEmitter()), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new a.EventEmitter()), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
          }
          get maxLength() {
            return this._maxLength;
          }
          set maxLength(b) {
            if (this._maxLength === b)
              return;
            const p = new Array(b);
            for (let S = 0; S < Math.min(b, this.length); S++)
              p[S] = this._array[this._getCyclicIndex(S)];
            this._array = p, this._maxLength = b, this._startIndex = 0;
          }
          get length() {
            return this._length;
          }
          set length(b) {
            if (b > this._length)
              for (let p = this._length; p < b; p++)
                this._array[p] = void 0;
            this._length = b;
          }
          get(b) {
            return this._array[this._getCyclicIndex(b)];
          }
          set(b, p) {
            this._array[this._getCyclicIndex(b)] = p;
          }
          push(b) {
            this._array[this._getCyclicIndex(this._length)] = b, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
          }
          recycle() {
            if (this._length !== this._maxLength)
              throw new Error("Can only recycle when the buffer is full");
            return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
          }
          get isFull() {
            return this._length === this._maxLength;
          }
          pop() {
            return this._array[this._getCyclicIndex(this._length-- - 1)];
          }
          splice(b, p, ...S) {
            if (p) {
              for (let o = b; o < this._length - p; o++)
                this._array[this._getCyclicIndex(o)] = this._array[this._getCyclicIndex(o + p)];
              this._length -= p, this.onDeleteEmitter.fire({ index: b, amount: p });
            }
            for (let o = this._length - 1; o >= b; o--)
              this._array[this._getCyclicIndex(o + S.length)] = this._array[this._getCyclicIndex(o)];
            for (let o = 0; o < S.length; o++)
              this._array[this._getCyclicIndex(b + o)] = S[o];
            if (S.length && this.onInsertEmitter.fire({ index: b, amount: S.length }), this._length + S.length > this._maxLength) {
              const o = this._length + S.length - this._maxLength;
              this._startIndex += o, this._length = this._maxLength, this.onTrimEmitter.fire(o);
            } else
              this._length += S.length;
          }
          trimStart(b) {
            b > this._length && (b = this._length), this._startIndex += b, this._length -= b, this.onTrimEmitter.fire(b);
          }
          shiftElements(b, p, S) {
            if (!(p <= 0)) {
              if (b < 0 || b >= this._length)
                throw new Error("start argument out of range");
              if (b + S < 0)
                throw new Error("Cannot shift elements in list beyond index 0");
              if (S > 0) {
                for (let _ = p - 1; _ >= 0; _--)
                  this.set(b + _ + S, this.get(b + _));
                const o = b + p + S - this._length;
                if (o > 0)
                  for (this._length += o; this._length > this._maxLength; )
                    this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
              } else
                for (let o = 0; o < p; o++)
                  this.set(b + o + S, this.get(b + o));
            }
          }
          _getCyclicIndex(b) {
            return (this._startIndex + b) % this._maxLength;
          }
        }
        n.CircularList = m;
      }, 1439: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.clone = void 0, n.clone = function r(a, f = 5) {
          if (typeof a != "object")
            return a;
          const m = Array.isArray(a) ? [] : {};
          for (const C in a)
            m[C] = f <= 1 ? a[C] : a[C] && r(a[C], f - 1);
          return m;
        };
      }, 8055: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.contrastRatio = n.toPaddedHex = n.rgba = n.rgb = n.css = n.color = n.channels = n.NULL_COLOR = void 0;
        const a = r(6114);
        let f = 0, m = 0, C = 0, b = 0;
        var p, S, o;
        function _(d) {
          const v = d.toString(16);
          return v.length < 2 ? "0" + v : v;
        }
        function u(d, v) {
          return d < v ? (v + 0.05) / (d + 0.05) : (d + 0.05) / (v + 0.05);
        }
        n.NULL_COLOR = { css: "#00000000", rgba: 0 }, function(d) {
          d.toCss = function(v, w, x, k) {
            return k !== void 0 ? `#${_(v)}${_(w)}${_(x)}${_(k)}` : `#${_(v)}${_(w)}${_(x)}`;
          }, d.toRgba = function(v, w, x, k = 255) {
            return (v << 24 | w << 16 | x << 8 | k) >>> 0;
          };
        }(p = n.channels || (n.channels = {})), function(d) {
          function v(w, x) {
            return b = Math.round(255 * x), [f, m, C] = o.toChannels(w.rgba), { css: p.toCss(f, m, C, b), rgba: p.toRgba(f, m, C, b) };
          }
          d.blend = function(w, x) {
            if (b = (255 & x.rgba) / 255, b === 1)
              return { css: x.css, rgba: x.rgba };
            const k = x.rgba >> 24 & 255, y = x.rgba >> 16 & 255, I = x.rgba >> 8 & 255, A = w.rgba >> 24 & 255, M = w.rgba >> 16 & 255, L = w.rgba >> 8 & 255;
            return f = A + Math.round((k - A) * b), m = M + Math.round((y - M) * b), C = L + Math.round((I - L) * b), { css: p.toCss(f, m, C), rgba: p.toRgba(f, m, C) };
          }, d.isOpaque = function(w) {
            return (255 & w.rgba) == 255;
          }, d.ensureContrastRatio = function(w, x, k) {
            const y = o.ensureContrastRatio(w.rgba, x.rgba, k);
            if (y)
              return o.toColor(y >> 24 & 255, y >> 16 & 255, y >> 8 & 255);
          }, d.opaque = function(w) {
            const x = (255 | w.rgba) >>> 0;
            return [f, m, C] = o.toChannels(x), { css: p.toCss(f, m, C), rgba: x };
          }, d.opacity = v, d.multiplyOpacity = function(w, x) {
            return b = 255 & w.rgba, v(w, b * x / 255);
          }, d.toColorRGB = function(w) {
            return [w.rgba >> 24 & 255, w.rgba >> 16 & 255, w.rgba >> 8 & 255];
          };
        }(n.color || (n.color = {})), function(d) {
          let v, w;
          if (!a.isNode) {
            const x = document.createElement("canvas");
            x.width = 1, x.height = 1;
            const k = x.getContext("2d", { willReadFrequently: !0 });
            k && (v = k, v.globalCompositeOperation = "copy", w = v.createLinearGradient(0, 0, 1, 1));
          }
          d.toColor = function(x) {
            if (x.match(/#[\da-f]{3,8}/i))
              switch (x.length) {
                case 4:
                  return f = parseInt(x.slice(1, 2).repeat(2), 16), m = parseInt(x.slice(2, 3).repeat(2), 16), C = parseInt(x.slice(3, 4).repeat(2), 16), o.toColor(f, m, C);
                case 5:
                  return f = parseInt(x.slice(1, 2).repeat(2), 16), m = parseInt(x.slice(2, 3).repeat(2), 16), C = parseInt(x.slice(3, 4).repeat(2), 16), b = parseInt(x.slice(4, 5).repeat(2), 16), o.toColor(f, m, C, b);
                case 7:
                  return { css: x, rgba: (parseInt(x.slice(1), 16) << 8 | 255) >>> 0 };
                case 9:
                  return { css: x, rgba: parseInt(x.slice(1), 16) >>> 0 };
              }
            const k = x.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
            if (k)
              return f = parseInt(k[1]), m = parseInt(k[2]), C = parseInt(k[3]), b = Math.round(255 * (k[5] === void 0 ? 1 : parseFloat(k[5]))), o.toColor(f, m, C, b);
            if (!v || !w)
              throw new Error("css.toColor: Unsupported css format");
            if (v.fillStyle = w, v.fillStyle = x, typeof v.fillStyle != "string")
              throw new Error("css.toColor: Unsupported css format");
            if (v.fillRect(0, 0, 1, 1), [f, m, C, b] = v.getImageData(0, 0, 1, 1).data, b !== 255)
              throw new Error("css.toColor: Unsupported css format");
            return { rgba: p.toRgba(f, m, C, b), css: x };
          };
        }(n.css || (n.css = {})), function(d) {
          function v(w, x, k) {
            const y = w / 255, I = x / 255, A = k / 255;
            return 0.2126 * (y <= 0.03928 ? y / 12.92 : Math.pow((y + 0.055) / 1.055, 2.4)) + 0.7152 * (I <= 0.03928 ? I / 12.92 : Math.pow((I + 0.055) / 1.055, 2.4)) + 0.0722 * (A <= 0.03928 ? A / 12.92 : Math.pow((A + 0.055) / 1.055, 2.4));
          }
          d.relativeLuminance = function(w) {
            return v(w >> 16 & 255, w >> 8 & 255, 255 & w);
          }, d.relativeLuminance2 = v;
        }(S = n.rgb || (n.rgb = {})), function(d) {
          function v(x, k, y) {
            const I = x >> 24 & 255, A = x >> 16 & 255, M = x >> 8 & 255;
            let L = k >> 24 & 255, O = k >> 16 & 255, U = k >> 8 & 255, j = u(S.relativeLuminance2(L, O, U), S.relativeLuminance2(I, A, M));
            for (; j < y && (L > 0 || O > 0 || U > 0); )
              L -= Math.max(0, Math.ceil(0.1 * L)), O -= Math.max(0, Math.ceil(0.1 * O)), U -= Math.max(0, Math.ceil(0.1 * U)), j = u(S.relativeLuminance2(L, O, U), S.relativeLuminance2(I, A, M));
            return (L << 24 | O << 16 | U << 8 | 255) >>> 0;
          }
          function w(x, k, y) {
            const I = x >> 24 & 255, A = x >> 16 & 255, M = x >> 8 & 255;
            let L = k >> 24 & 255, O = k >> 16 & 255, U = k >> 8 & 255, j = u(S.relativeLuminance2(L, O, U), S.relativeLuminance2(I, A, M));
            for (; j < y && (L < 255 || O < 255 || U < 255); )
              L = Math.min(255, L + Math.ceil(0.1 * (255 - L))), O = Math.min(255, O + Math.ceil(0.1 * (255 - O))), U = Math.min(255, U + Math.ceil(0.1 * (255 - U))), j = u(S.relativeLuminance2(L, O, U), S.relativeLuminance2(I, A, M));
            return (L << 24 | O << 16 | U << 8 | 255) >>> 0;
          }
          d.ensureContrastRatio = function(x, k, y) {
            const I = S.relativeLuminance(x >> 8), A = S.relativeLuminance(k >> 8);
            if (u(I, A) < y) {
              if (A < I) {
                const O = v(x, k, y), U = u(I, S.relativeLuminance(O >> 8));
                if (U < y) {
                  const j = w(x, k, y);
                  return U > u(I, S.relativeLuminance(j >> 8)) ? O : j;
                }
                return O;
              }
              const M = w(x, k, y), L = u(I, S.relativeLuminance(M >> 8));
              if (L < y) {
                const O = v(x, k, y);
                return L > u(I, S.relativeLuminance(O >> 8)) ? M : O;
              }
              return M;
            }
          }, d.reduceLuminance = v, d.increaseLuminance = w, d.toChannels = function(x) {
            return [x >> 24 & 255, x >> 16 & 255, x >> 8 & 255, 255 & x];
          }, d.toColor = function(x, k, y, I) {
            return { css: p.toCss(x, k, y, I), rgba: p.toRgba(x, k, y, I) };
          };
        }(o = n.rgba || (n.rgba = {})), n.toPaddedHex = _, n.contrastRatio = u;
      }, 8969: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.CoreTerminal = void 0;
        const a = r(844), f = r(2585), m = r(4348), C = r(7866), b = r(744), p = r(7302), S = r(6975), o = r(8460), _ = r(1753), u = r(1480), d = r(7994), v = r(9282), w = r(5435), x = r(5981), k = r(2660);
        let y = !1;
        class I extends a.Disposable {
          constructor(M) {
            super(), this._onBinary = this.register(new o.EventEmitter()), this.onBinary = this._onBinary.event, this._onData = this.register(new o.EventEmitter()), this.onData = this._onData.event, this._onLineFeed = this.register(new o.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new o.EventEmitter()), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new o.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new o.EventEmitter()), this._instantiationService = new m.InstantiationService(), this.optionsService = this.register(new p.OptionsService(M)), this._instantiationService.setService(f.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(b.BufferService)), this._instantiationService.setService(f.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(C.LogService)), this._instantiationService.setService(f.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(S.CoreService)), this._instantiationService.setService(f.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(_.CoreMouseService)), this._instantiationService.setService(f.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(u.UnicodeService)), this._instantiationService.setService(f.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(d.CharsetService), this._instantiationService.setService(f.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(k.OscLinkService), this._instantiationService.setService(f.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new w.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, o.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, o.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, o.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, o.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom(() => this.scrollToBottom())), this.register(this.coreService.onUserInput(() => this._writeBuffer.handleUserInput())), this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], () => this._handleWindowsPtyOptionChange())), this.register(this._bufferService.onScroll((L) => {
              this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
            })), this.register(this._inputHandler.onScroll((L) => {
              this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
            })), this._writeBuffer = this.register(new x.WriteBuffer((L, O) => this._inputHandler.parse(L, O))), this.register((0, o.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed)), this.register((0, a.toDisposable)(() => {
              var L;
              (L = this._windowsWrappingHeuristics) === null || L === void 0 || L.dispose(), this._windowsWrappingHeuristics = void 0;
            }));
          }
          get onScroll() {
            return this._onScrollApi || (this._onScrollApi = this.register(new o.EventEmitter()), this._onScroll.event((M) => {
              var L;
              (L = this._onScrollApi) === null || L === void 0 || L.fire(M.position);
            })), this._onScrollApi.event;
          }
          get cols() {
            return this._bufferService.cols;
          }
          get rows() {
            return this._bufferService.rows;
          }
          get buffers() {
            return this._bufferService.buffers;
          }
          get options() {
            return this.optionsService.options;
          }
          set options(M) {
            for (const L in M)
              this.optionsService.options[L] = M[L];
          }
          write(M, L) {
            this._writeBuffer.write(M, L);
          }
          writeSync(M, L) {
            this._logService.logLevel <= f.LogLevelEnum.WARN && !y && (this._logService.warn("writeSync is unreliable and will be removed soon."), y = !0), this._writeBuffer.writeSync(M, L);
          }
          resize(M, L) {
            isNaN(M) || isNaN(L) || (M = Math.max(M, b.MINIMUM_COLS), L = Math.max(L, b.MINIMUM_ROWS), this._bufferService.resize(M, L));
          }
          scroll(M, L = !1) {
            this._bufferService.scroll(M, L);
          }
          scrollLines(M, L, O) {
            this._bufferService.scrollLines(M, L, O);
          }
          scrollPages(M) {
            this._bufferService.scrollPages(M);
          }
          scrollToTop() {
            this._bufferService.scrollToTop();
          }
          scrollToBottom() {
            this._bufferService.scrollToBottom();
          }
          scrollToLine(M) {
            this._bufferService.scrollToLine(M);
          }
          registerEscHandler(M, L) {
            return this._inputHandler.registerEscHandler(M, L);
          }
          registerDcsHandler(M, L) {
            return this._inputHandler.registerDcsHandler(M, L);
          }
          registerCsiHandler(M, L) {
            return this._inputHandler.registerCsiHandler(M, L);
          }
          registerOscHandler(M, L) {
            return this._inputHandler.registerOscHandler(M, L);
          }
          _setup() {
            this._handleWindowsPtyOptionChange();
          }
          reset() {
            this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
          }
          _handleWindowsPtyOptionChange() {
            var M;
            let L = !1;
            const O = this.optionsService.rawOptions.windowsPty;
            O && O.buildNumber !== void 0 && O.buildNumber !== void 0 ? L = O.backend === "conpty" && O.buildNumber < 21376 : this.optionsService.rawOptions.windowsMode && (L = !0), L ? this._enableWindowsWrappingHeuristics() : ((M = this._windowsWrappingHeuristics) === null || M === void 0 || M.dispose(), this._windowsWrappingHeuristics = void 0);
          }
          _enableWindowsWrappingHeuristics() {
            if (!this._windowsWrappingHeuristics) {
              const M = [];
              M.push(this.onLineFeed(v.updateWindowsModeWrappedState.bind(null, this._bufferService))), M.push(this.registerCsiHandler({ final: "H" }, () => ((0, v.updateWindowsModeWrappedState)(this._bufferService), !1))), this._windowsWrappingHeuristics = (0, a.toDisposable)(() => {
                for (const L of M)
                  L.dispose();
              });
            }
          }
        }
        n.CoreTerminal = I;
      }, 8460: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.forwardEvent = n.EventEmitter = void 0, n.EventEmitter = class {
          constructor() {
            this._listeners = [], this._disposed = !1;
          }
          get event() {
            return this._event || (this._event = (r) => (this._listeners.push(r), { dispose: () => {
              if (!this._disposed) {
                for (let a = 0; a < this._listeners.length; a++)
                  if (this._listeners[a] === r)
                    return void this._listeners.splice(a, 1);
              }
            } })), this._event;
          }
          fire(r, a) {
            const f = [];
            for (let m = 0; m < this._listeners.length; m++)
              f.push(this._listeners[m]);
            for (let m = 0; m < f.length; m++)
              f[m].call(void 0, r, a);
          }
          dispose() {
            this._listeners && (this._listeners.length = 0), this._disposed = !0;
          }
        }, n.forwardEvent = function(r, a) {
          return r((f) => a.fire(f));
        };
      }, 5435: function(l, n, r) {
        var a = this && this.__decorate || function(K, T, P, H) {
          var N, G = arguments.length, Z = G < 3 ? T : H === null ? H = Object.getOwnPropertyDescriptor(T, P) : H;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            Z = Reflect.decorate(K, T, P, H);
          else
            for (var ae = K.length - 1; ae >= 0; ae--)
              (N = K[ae]) && (Z = (G < 3 ? N(Z) : G > 3 ? N(T, P, Z) : N(T, P)) || Z);
          return G > 3 && Z && Object.defineProperty(T, P, Z), Z;
        }, f = this && this.__param || function(K, T) {
          return function(P, H) {
            T(P, H, K);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.InputHandler = n.WindowsOptionsReportType = void 0;
        const m = r(2584), C = r(7116), b = r(2015), p = r(844), S = r(482), o = r(8437), _ = r(8460), u = r(643), d = r(511), v = r(3734), w = r(2585), x = r(6242), k = r(6351), y = r(5941), I = { "(": 0, ")": 1, "*": 2, "+": 3, "-": 1, ".": 2 }, A = 131072;
        function M(K, T) {
          if (K > 24)
            return T.setWinLines || !1;
          switch (K) {
            case 1:
              return !!T.restoreWin;
            case 2:
              return !!T.minimizeWin;
            case 3:
              return !!T.setWinPosition;
            case 4:
              return !!T.setWinSizePixels;
            case 5:
              return !!T.raiseWin;
            case 6:
              return !!T.lowerWin;
            case 7:
              return !!T.refreshWin;
            case 8:
              return !!T.setWinSizeChars;
            case 9:
              return !!T.maximizeWin;
            case 10:
              return !!T.fullscreenWin;
            case 11:
              return !!T.getWinState;
            case 13:
              return !!T.getWinPosition;
            case 14:
              return !!T.getWinSizePixels;
            case 15:
              return !!T.getScreenSizePixels;
            case 16:
              return !!T.getCellSizePixels;
            case 18:
              return !!T.getWinSizeChars;
            case 19:
              return !!T.getScreenSizeChars;
            case 20:
              return !!T.getIconTitle;
            case 21:
              return !!T.getWinTitle;
            case 22:
              return !!T.pushTitle;
            case 23:
              return !!T.popTitle;
            case 24:
              return !!T.setWinLines;
          }
          return !1;
        }
        var L;
        (function(K) {
          K[K.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", K[K.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
        })(L = n.WindowsOptionsReportType || (n.WindowsOptionsReportType = {}));
        let O = 0;
        class U extends p.Disposable {
          constructor(T, P, H, N, G, Z, ae, q, ee = new b.EscapeSequenceParser()) {
            super(), this._bufferService = T, this._charsetService = P, this._coreService = H, this._logService = N, this._optionsService = G, this._oscLinkService = Z, this._coreMouseService = ae, this._unicodeService = q, this._parser = ee, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new S.StringToUtf32(), this._utf8Decoder = new S.Utf8ToUtf32(), this._workCell = new d.CellData(), this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = o.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = o.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new _.EventEmitter()), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new _.EventEmitter()), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new _.EventEmitter()), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new _.EventEmitter()), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new _.EventEmitter()), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new _.EventEmitter()), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new _.EventEmitter()), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new _.EventEmitter()), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new _.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new _.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new _.EventEmitter()), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new _.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new _.EventEmitter()), this.onColor = this._onColor.event, this._parseStack = { paused: !1, cursorStartX: 0, cursorStartY: 0, decodedLength: 0, position: 0 }, this._specialColors = [256, 257, 258], this.register(this._parser), this._dirtyRowTracker = new j(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((W) => this._activeBuffer = W.activeBuffer)), this._parser.setCsiHandlerFallback((W, F) => {
              this._logService.debug("Unknown CSI code: ", { identifier: this._parser.identToString(W), params: F.toArray() });
            }), this._parser.setEscHandlerFallback((W) => {
              this._logService.debug("Unknown ESC code: ", { identifier: this._parser.identToString(W) });
            }), this._parser.setExecuteHandlerFallback((W) => {
              this._logService.debug("Unknown EXECUTE code: ", { code: W });
            }), this._parser.setOscHandlerFallback((W, F, B) => {
              this._logService.debug("Unknown OSC code: ", { identifier: W, action: F, data: B });
            }), this._parser.setDcsHandlerFallback((W, F, B) => {
              F === "HOOK" && (B = B.toArray()), this._logService.debug("Unknown DCS code: ", { identifier: this._parser.identToString(W), action: F, payload: B });
            }), this._parser.setPrintHandler((W, F, B) => this.print(W, F, B)), this._parser.registerCsiHandler({ final: "@" }, (W) => this.insertChars(W)), this._parser.registerCsiHandler({ intermediates: " ", final: "@" }, (W) => this.scrollLeft(W)), this._parser.registerCsiHandler({ final: "A" }, (W) => this.cursorUp(W)), this._parser.registerCsiHandler({ intermediates: " ", final: "A" }, (W) => this.scrollRight(W)), this._parser.registerCsiHandler({ final: "B" }, (W) => this.cursorDown(W)), this._parser.registerCsiHandler({ final: "C" }, (W) => this.cursorForward(W)), this._parser.registerCsiHandler({ final: "D" }, (W) => this.cursorBackward(W)), this._parser.registerCsiHandler({ final: "E" }, (W) => this.cursorNextLine(W)), this._parser.registerCsiHandler({ final: "F" }, (W) => this.cursorPrecedingLine(W)), this._parser.registerCsiHandler({ final: "G" }, (W) => this.cursorCharAbsolute(W)), this._parser.registerCsiHandler({ final: "H" }, (W) => this.cursorPosition(W)), this._parser.registerCsiHandler({ final: "I" }, (W) => this.cursorForwardTab(W)), this._parser.registerCsiHandler({ final: "J" }, (W) => this.eraseInDisplay(W, !1)), this._parser.registerCsiHandler({ prefix: "?", final: "J" }, (W) => this.eraseInDisplay(W, !0)), this._parser.registerCsiHandler({ final: "K" }, (W) => this.eraseInLine(W, !1)), this._parser.registerCsiHandler({ prefix: "?", final: "K" }, (W) => this.eraseInLine(W, !0)), this._parser.registerCsiHandler({ final: "L" }, (W) => this.insertLines(W)), this._parser.registerCsiHandler({ final: "M" }, (W) => this.deleteLines(W)), this._parser.registerCsiHandler({ final: "P" }, (W) => this.deleteChars(W)), this._parser.registerCsiHandler({ final: "S" }, (W) => this.scrollUp(W)), this._parser.registerCsiHandler({ final: "T" }, (W) => this.scrollDown(W)), this._parser.registerCsiHandler({ final: "X" }, (W) => this.eraseChars(W)), this._parser.registerCsiHandler({ final: "Z" }, (W) => this.cursorBackwardTab(W)), this._parser.registerCsiHandler({ final: "`" }, (W) => this.charPosAbsolute(W)), this._parser.registerCsiHandler({ final: "a" }, (W) => this.hPositionRelative(W)), this._parser.registerCsiHandler({ final: "b" }, (W) => this.repeatPrecedingCharacter(W)), this._parser.registerCsiHandler({ final: "c" }, (W) => this.sendDeviceAttributesPrimary(W)), this._parser.registerCsiHandler({ prefix: ">", final: "c" }, (W) => this.sendDeviceAttributesSecondary(W)), this._parser.registerCsiHandler({ final: "d" }, (W) => this.linePosAbsolute(W)), this._parser.registerCsiHandler({ final: "e" }, (W) => this.vPositionRelative(W)), this._parser.registerCsiHandler({ final: "f" }, (W) => this.hVPosition(W)), this._parser.registerCsiHandler({ final: "g" }, (W) => this.tabClear(W)), this._parser.registerCsiHandler({ final: "h" }, (W) => this.setMode(W)), this._parser.registerCsiHandler({ prefix: "?", final: "h" }, (W) => this.setModePrivate(W)), this._parser.registerCsiHandler({ final: "l" }, (W) => this.resetMode(W)), this._parser.registerCsiHandler({ prefix: "?", final: "l" }, (W) => this.resetModePrivate(W)), this._parser.registerCsiHandler({ final: "m" }, (W) => this.charAttributes(W)), this._parser.registerCsiHandler({ final: "n" }, (W) => this.deviceStatus(W)), this._parser.registerCsiHandler({ prefix: "?", final: "n" }, (W) => this.deviceStatusPrivate(W)), this._parser.registerCsiHandler({ intermediates: "!", final: "p" }, (W) => this.softReset(W)), this._parser.registerCsiHandler({ intermediates: " ", final: "q" }, (W) => this.setCursorStyle(W)), this._parser.registerCsiHandler({ final: "r" }, (W) => this.setScrollRegion(W)), this._parser.registerCsiHandler({ final: "s" }, (W) => this.saveCursor(W)), this._parser.registerCsiHandler({ final: "t" }, (W) => this.windowOptions(W)), this._parser.registerCsiHandler({ final: "u" }, (W) => this.restoreCursor(W)), this._parser.registerCsiHandler({ intermediates: "'", final: "}" }, (W) => this.insertColumns(W)), this._parser.registerCsiHandler({ intermediates: "'", final: "~" }, (W) => this.deleteColumns(W)), this._parser.registerCsiHandler({ intermediates: '"', final: "q" }, (W) => this.selectProtected(W)), this._parser.registerCsiHandler({ intermediates: "$", final: "p" }, (W) => this.requestMode(W, !0)), this._parser.registerCsiHandler({ prefix: "?", intermediates: "$", final: "p" }, (W) => this.requestMode(W, !1)), this._parser.setExecuteHandler(m.C0.BEL, () => this.bell()), this._parser.setExecuteHandler(m.C0.LF, () => this.lineFeed()), this._parser.setExecuteHandler(m.C0.VT, () => this.lineFeed()), this._parser.setExecuteHandler(m.C0.FF, () => this.lineFeed()), this._parser.setExecuteHandler(m.C0.CR, () => this.carriageReturn()), this._parser.setExecuteHandler(m.C0.BS, () => this.backspace()), this._parser.setExecuteHandler(m.C0.HT, () => this.tab()), this._parser.setExecuteHandler(m.C0.SO, () => this.shiftOut()), this._parser.setExecuteHandler(m.C0.SI, () => this.shiftIn()), this._parser.setExecuteHandler(m.C1.IND, () => this.index()), this._parser.setExecuteHandler(m.C1.NEL, () => this.nextLine()), this._parser.setExecuteHandler(m.C1.HTS, () => this.tabSet()), this._parser.registerOscHandler(0, new x.OscHandler((W) => (this.setTitle(W), this.setIconName(W), !0))), this._parser.registerOscHandler(1, new x.OscHandler((W) => this.setIconName(W))), this._parser.registerOscHandler(2, new x.OscHandler((W) => this.setTitle(W))), this._parser.registerOscHandler(4, new x.OscHandler((W) => this.setOrReportIndexedColor(W))), this._parser.registerOscHandler(8, new x.OscHandler((W) => this.setHyperlink(W))), this._parser.registerOscHandler(10, new x.OscHandler((W) => this.setOrReportFgColor(W))), this._parser.registerOscHandler(11, new x.OscHandler((W) => this.setOrReportBgColor(W))), this._parser.registerOscHandler(12, new x.OscHandler((W) => this.setOrReportCursorColor(W))), this._parser.registerOscHandler(104, new x.OscHandler((W) => this.restoreIndexedColor(W))), this._parser.registerOscHandler(110, new x.OscHandler((W) => this.restoreFgColor(W))), this._parser.registerOscHandler(111, new x.OscHandler((W) => this.restoreBgColor(W))), this._parser.registerOscHandler(112, new x.OscHandler((W) => this.restoreCursorColor(W))), this._parser.registerEscHandler({ final: "7" }, () => this.saveCursor()), this._parser.registerEscHandler({ final: "8" }, () => this.restoreCursor()), this._parser.registerEscHandler({ final: "D" }, () => this.index()), this._parser.registerEscHandler({ final: "E" }, () => this.nextLine()), this._parser.registerEscHandler({ final: "H" }, () => this.tabSet()), this._parser.registerEscHandler({ final: "M" }, () => this.reverseIndex()), this._parser.registerEscHandler({ final: "=" }, () => this.keypadApplicationMode()), this._parser.registerEscHandler({ final: ">" }, () => this.keypadNumericMode()), this._parser.registerEscHandler({ final: "c" }, () => this.fullReset()), this._parser.registerEscHandler({ final: "n" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "o" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "|" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "}" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "~" }, () => this.setgLevel(1)), this._parser.registerEscHandler({ intermediates: "%", final: "@" }, () => this.selectDefaultCharset()), this._parser.registerEscHandler({ intermediates: "%", final: "G" }, () => this.selectDefaultCharset());
            for (const W in C.CHARSETS)
              this._parser.registerEscHandler({ intermediates: "(", final: W }, () => this.selectCharset("(" + W)), this._parser.registerEscHandler({ intermediates: ")", final: W }, () => this.selectCharset(")" + W)), this._parser.registerEscHandler({ intermediates: "*", final: W }, () => this.selectCharset("*" + W)), this._parser.registerEscHandler({ intermediates: "+", final: W }, () => this.selectCharset("+" + W)), this._parser.registerEscHandler({ intermediates: "-", final: W }, () => this.selectCharset("-" + W)), this._parser.registerEscHandler({ intermediates: ".", final: W }, () => this.selectCharset("." + W)), this._parser.registerEscHandler({ intermediates: "/", final: W }, () => this.selectCharset("/" + W));
            this._parser.registerEscHandler({ intermediates: "#", final: "8" }, () => this.screenAlignmentPattern()), this._parser.setErrorHandler((W) => (this._logService.error("Parsing error: ", W), W)), this._parser.registerDcsHandler({ intermediates: "$", final: "q" }, new k.DcsHandler((W, F) => this.requestStatusString(W, F)));
          }
          getAttrData() {
            return this._curAttrData;
          }
          _preserveStack(T, P, H, N) {
            this._parseStack.paused = !0, this._parseStack.cursorStartX = T, this._parseStack.cursorStartY = P, this._parseStack.decodedLength = H, this._parseStack.position = N;
          }
          _logSlowResolvingAsync(T) {
            this._logService.logLevel <= w.LogLevelEnum.WARN && Promise.race([T, new Promise((P, H) => setTimeout(() => H("#SLOW_TIMEOUT"), 5e3))]).catch((P) => {
              if (P !== "#SLOW_TIMEOUT")
                throw P;
              console.warn("async parser handler taking longer than 5000 ms");
            });
          }
          _getCurrentLinkId() {
            return this._curAttrData.extended.urlId;
          }
          parse(T, P) {
            let H, N = this._activeBuffer.x, G = this._activeBuffer.y, Z = 0;
            const ae = this._parseStack.paused;
            if (ae) {
              if (H = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, P))
                return this._logSlowResolvingAsync(H), H;
              N = this._parseStack.cursorStartX, G = this._parseStack.cursorStartY, this._parseStack.paused = !1, T.length > A && (Z = this._parseStack.position + A);
            }
            if (this._logService.logLevel <= w.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + (typeof T == "string" ? ` "${T}"` : ` "${Array.prototype.map.call(T, (q) => String.fromCharCode(q)).join("")}"`), typeof T == "string" ? T.split("").map((q) => q.charCodeAt(0)) : T), this._parseBuffer.length < T.length && this._parseBuffer.length < A && (this._parseBuffer = new Uint32Array(Math.min(T.length, A))), ae || this._dirtyRowTracker.clearRange(), T.length > A)
              for (let q = Z; q < T.length; q += A) {
                const ee = q + A < T.length ? q + A : T.length, W = typeof T == "string" ? this._stringDecoder.decode(T.substring(q, ee), this._parseBuffer) : this._utf8Decoder.decode(T.subarray(q, ee), this._parseBuffer);
                if (H = this._parser.parse(this._parseBuffer, W))
                  return this._preserveStack(N, G, W, q), this._logSlowResolvingAsync(H), H;
              }
            else if (!ae) {
              const q = typeof T == "string" ? this._stringDecoder.decode(T, this._parseBuffer) : this._utf8Decoder.decode(T, this._parseBuffer);
              if (H = this._parser.parse(this._parseBuffer, q))
                return this._preserveStack(N, G, q, 0), this._logSlowResolvingAsync(H), H;
            }
            this._activeBuffer.x === N && this._activeBuffer.y === G || this._onCursorMove.fire(), this._onRequestRefreshRows.fire(this._dirtyRowTracker.start, this._dirtyRowTracker.end);
          }
          print(T, P, H) {
            let N, G;
            const Z = this._charsetService.charset, ae = this._optionsService.rawOptions.screenReaderMode, q = this._bufferService.cols, ee = this._coreService.decPrivateModes.wraparound, W = this._coreService.modes.insertMode, F = this._curAttrData;
            let B = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && H - P > 0 && B.getWidth(this._activeBuffer.x - 1) === 2 && B.setCellFromCodePoint(this._activeBuffer.x - 1, 0, 1, F.fg, F.bg, F.extended);
            for (let $ = P; $ < H; ++$) {
              if (N = T[$], G = this._unicodeService.wcwidth(N), N < 127 && Z) {
                const z = Z[String.fromCharCode(N)];
                z && (N = z.charCodeAt(0));
              }
              if (ae && this._onA11yChar.fire((0, S.stringFromCodePoint)(N)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), G || !this._activeBuffer.x) {
                if (this._activeBuffer.x + G - 1 >= q) {
                  if (ee) {
                    for (; this._activeBuffer.x < q; )
                      B.setCellFromCodePoint(this._activeBuffer.x++, 0, 1, F.fg, F.bg, F.extended);
                    this._activeBuffer.x = 0, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), !0)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !0), B = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                  } else if (this._activeBuffer.x = q - 1, G === 2)
                    continue;
                }
                if (W && (B.insertCells(this._activeBuffer.x, G, this._activeBuffer.getNullCell(F), F), B.getWidth(q - 1) === 2 && B.setCellFromCodePoint(q - 1, u.NULL_CELL_CODE, u.NULL_CELL_WIDTH, F.fg, F.bg, F.extended)), B.setCellFromCodePoint(this._activeBuffer.x++, N, G, F.fg, F.bg, F.extended), G > 0)
                  for (; --G; )
                    B.setCellFromCodePoint(this._activeBuffer.x++, 0, 0, F.fg, F.bg, F.extended);
              } else
                B.getWidth(this._activeBuffer.x - 1) ? B.addCodepointToCell(this._activeBuffer.x - 1, N) : B.addCodepointToCell(this._activeBuffer.x - 2, N);
            }
            H - P > 0 && (B.loadCell(this._activeBuffer.x - 1, this._workCell), this._workCell.getWidth() === 2 || this._workCell.getCode() > 65535 ? this._parser.precedingCodepoint = 0 : this._workCell.isCombined() ? this._parser.precedingCodepoint = this._workCell.getChars().charCodeAt(0) : this._parser.precedingCodepoint = this._workCell.content), this._activeBuffer.x < q && H - P > 0 && B.getWidth(this._activeBuffer.x) === 0 && !B.hasContent(this._activeBuffer.x) && B.setCellFromCodePoint(this._activeBuffer.x, 0, 1, F.fg, F.bg, F.extended), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          registerCsiHandler(T, P) {
            return T.final !== "t" || T.prefix || T.intermediates ? this._parser.registerCsiHandler(T, P) : this._parser.registerCsiHandler(T, (H) => !M(H.params[0], this._optionsService.rawOptions.windowOptions) || P(H));
          }
          registerDcsHandler(T, P) {
            return this._parser.registerDcsHandler(T, new k.DcsHandler(P));
          }
          registerEscHandler(T, P) {
            return this._parser.registerEscHandler(T, P);
          }
          registerOscHandler(T, P) {
            return this._parser.registerOscHandler(T, new x.OscHandler(P));
          }
          bell() {
            return this._onRequestBell.fire(), !0;
          }
          lineFeed() {
            return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), !0;
          }
          carriageReturn() {
            return this._activeBuffer.x = 0, !0;
          }
          backspace() {
            var T;
            if (!this._coreService.decPrivateModes.reverseWraparound)
              return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, !0;
            if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0)
              this._activeBuffer.x--;
            else if (this._activeBuffer.x === 0 && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && (!((T = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)) === null || T === void 0) && T.isWrapped)) {
              this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
              const P = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              P.hasWidth(this._activeBuffer.x) && !P.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
            }
            return this._restrictCursor(), !0;
          }
          tab() {
            if (this._activeBuffer.x >= this._bufferService.cols)
              return !0;
            const T = this._activeBuffer.x;
            return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - T), !0;
          }
          shiftOut() {
            return this._charsetService.setgLevel(1), !0;
          }
          shiftIn() {
            return this._charsetService.setgLevel(0), !0;
          }
          _restrictCursor(T = this._bufferService.cols - 1) {
            this._activeBuffer.x = Math.min(T, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          _setCursor(T, P) {
            this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = T, this._activeBuffer.y = this._activeBuffer.scrollTop + P) : (this._activeBuffer.x = T, this._activeBuffer.y = P), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          _moveCursor(T, P) {
            this._restrictCursor(), this._setCursor(this._activeBuffer.x + T, this._activeBuffer.y + P);
          }
          cursorUp(T) {
            const P = this._activeBuffer.y - this._activeBuffer.scrollTop;
            return P >= 0 ? this._moveCursor(0, -Math.min(P, T.params[0] || 1)) : this._moveCursor(0, -(T.params[0] || 1)), !0;
          }
          cursorDown(T) {
            const P = this._activeBuffer.scrollBottom - this._activeBuffer.y;
            return P >= 0 ? this._moveCursor(0, Math.min(P, T.params[0] || 1)) : this._moveCursor(0, T.params[0] || 1), !0;
          }
          cursorForward(T) {
            return this._moveCursor(T.params[0] || 1, 0), !0;
          }
          cursorBackward(T) {
            return this._moveCursor(-(T.params[0] || 1), 0), !0;
          }
          cursorNextLine(T) {
            return this.cursorDown(T), this._activeBuffer.x = 0, !0;
          }
          cursorPrecedingLine(T) {
            return this.cursorUp(T), this._activeBuffer.x = 0, !0;
          }
          cursorCharAbsolute(T) {
            return this._setCursor((T.params[0] || 1) - 1, this._activeBuffer.y), !0;
          }
          cursorPosition(T) {
            return this._setCursor(T.length >= 2 ? (T.params[1] || 1) - 1 : 0, (T.params[0] || 1) - 1), !0;
          }
          charPosAbsolute(T) {
            return this._setCursor((T.params[0] || 1) - 1, this._activeBuffer.y), !0;
          }
          hPositionRelative(T) {
            return this._moveCursor(T.params[0] || 1, 0), !0;
          }
          linePosAbsolute(T) {
            return this._setCursor(this._activeBuffer.x, (T.params[0] || 1) - 1), !0;
          }
          vPositionRelative(T) {
            return this._moveCursor(0, T.params[0] || 1), !0;
          }
          hVPosition(T) {
            return this.cursorPosition(T), !0;
          }
          tabClear(T) {
            const P = T.params[0];
            return P === 0 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : P === 3 && (this._activeBuffer.tabs = {}), !0;
          }
          cursorForwardTab(T) {
            if (this._activeBuffer.x >= this._bufferService.cols)
              return !0;
            let P = T.params[0] || 1;
            for (; P--; )
              this._activeBuffer.x = this._activeBuffer.nextStop();
            return !0;
          }
          cursorBackwardTab(T) {
            if (this._activeBuffer.x >= this._bufferService.cols)
              return !0;
            let P = T.params[0] || 1;
            for (; P--; )
              this._activeBuffer.x = this._activeBuffer.prevStop();
            return !0;
          }
          selectProtected(T) {
            const P = T.params[0];
            return P === 1 && (this._curAttrData.bg |= 536870912), P !== 2 && P !== 0 || (this._curAttrData.bg &= -536870913), !0;
          }
          _eraseInBufferLine(T, P, H, N = !1, G = !1) {
            const Z = this._activeBuffer.lines.get(this._activeBuffer.ybase + T);
            Z.replaceCells(P, H, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData(), G), N && (Z.isWrapped = !1);
          }
          _resetBufferLine(T, P = !1) {
            const H = this._activeBuffer.lines.get(this._activeBuffer.ybase + T);
            H && (H.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), P), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + T), H.isWrapped = !1);
          }
          eraseInDisplay(T, P = !1) {
            let H;
            switch (this._restrictCursor(this._bufferService.cols), T.params[0]) {
              case 0:
                for (H = this._activeBuffer.y, this._dirtyRowTracker.markDirty(H), this._eraseInBufferLine(H++, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, P); H < this._bufferService.rows; H++)
                  this._resetBufferLine(H, P);
                this._dirtyRowTracker.markDirty(H);
                break;
              case 1:
                for (H = this._activeBuffer.y, this._dirtyRowTracker.markDirty(H), this._eraseInBufferLine(H, 0, this._activeBuffer.x + 1, !0, P), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(H + 1).isWrapped = !1); H--; )
                  this._resetBufferLine(H, P);
                this._dirtyRowTracker.markDirty(0);
                break;
              case 2:
                for (H = this._bufferService.rows, this._dirtyRowTracker.markDirty(H - 1); H--; )
                  this._resetBufferLine(H, P);
                this._dirtyRowTracker.markDirty(0);
                break;
              case 3:
                const N = this._activeBuffer.lines.length - this._bufferService.rows;
                N > 0 && (this._activeBuffer.lines.trimStart(N), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - N, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - N, 0), this._onScroll.fire(0));
            }
            return !0;
          }
          eraseInLine(T, P = !1) {
            switch (this._restrictCursor(this._bufferService.cols), T.params[0]) {
              case 0:
                this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, P);
                break;
              case 1:
                this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, !1, P);
                break;
              case 2:
                this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, !0, P);
            }
            return this._dirtyRowTracker.markDirty(this._activeBuffer.y), !0;
          }
          insertLines(T) {
            this._restrictCursor();
            let P = T.params[0] || 1;
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
              return !0;
            const H = this._activeBuffer.ybase + this._activeBuffer.y, N = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, G = this._bufferService.rows - 1 + this._activeBuffer.ybase - N + 1;
            for (; P--; )
              this._activeBuffer.lines.splice(G - 1, 1), this._activeBuffer.lines.splice(H, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;
          }
          deleteLines(T) {
            this._restrictCursor();
            let P = T.params[0] || 1;
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
              return !0;
            const H = this._activeBuffer.ybase + this._activeBuffer.y;
            let N;
            for (N = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, N = this._bufferService.rows - 1 + this._activeBuffer.ybase - N; P--; )
              this._activeBuffer.lines.splice(H, 1), this._activeBuffer.lines.splice(N, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;
          }
          insertChars(T) {
            this._restrictCursor();
            const P = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return P && (P.insertCells(this._activeBuffer.x, T.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
          }
          deleteChars(T) {
            this._restrictCursor();
            const P = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return P && (P.deleteCells(this._activeBuffer.x, T.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
          }
          scrollUp(T) {
            let P = T.params[0] || 1;
            for (; P--; )
              this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          scrollDown(T) {
            let P = T.params[0] || 1;
            for (; P--; )
              this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(o.DEFAULT_ATTR_DATA));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          scrollLeft(T) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
              return !0;
            const P = T.params[0] || 1;
            for (let H = this._activeBuffer.scrollTop; H <= this._activeBuffer.scrollBottom; ++H) {
              const N = this._activeBuffer.lines.get(this._activeBuffer.ybase + H);
              N.deleteCells(0, P, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), N.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          scrollRight(T) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
              return !0;
            const P = T.params[0] || 1;
            for (let H = this._activeBuffer.scrollTop; H <= this._activeBuffer.scrollBottom; ++H) {
              const N = this._activeBuffer.lines.get(this._activeBuffer.ybase + H);
              N.insertCells(0, P, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), N.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          insertColumns(T) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
              return !0;
            const P = T.params[0] || 1;
            for (let H = this._activeBuffer.scrollTop; H <= this._activeBuffer.scrollBottom; ++H) {
              const N = this._activeBuffer.lines.get(this._activeBuffer.ybase + H);
              N.insertCells(this._activeBuffer.x, P, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), N.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          deleteColumns(T) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
              return !0;
            const P = T.params[0] || 1;
            for (let H = this._activeBuffer.scrollTop; H <= this._activeBuffer.scrollBottom; ++H) {
              const N = this._activeBuffer.lines.get(this._activeBuffer.ybase + H);
              N.deleteCells(this._activeBuffer.x, P, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), N.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          eraseChars(T) {
            this._restrictCursor();
            const P = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return P && (P.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (T.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
          }
          repeatPrecedingCharacter(T) {
            if (!this._parser.precedingCodepoint)
              return !0;
            const P = T.params[0] || 1, H = new Uint32Array(P);
            for (let N = 0; N < P; ++N)
              H[N] = this._parser.precedingCodepoint;
            return this.print(H, 0, H.length), !0;
          }
          sendDeviceAttributesPrimary(T) {
            return T.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(m.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(m.C0.ESC + "[?6c")), !0;
          }
          sendDeviceAttributesSecondary(T) {
            return T.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(m.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(m.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(T.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(m.C0.ESC + "[>83;40003;0c")), !0;
          }
          _is(T) {
            return (this._optionsService.rawOptions.termName + "").indexOf(T) === 0;
          }
          setMode(T) {
            for (let P = 0; P < T.length; P++)
              switch (T.params[P]) {
                case 4:
                  this._coreService.modes.insertMode = !0;
                  break;
                case 20:
                  this._optionsService.options.convertEol = !0;
              }
            return !0;
          }
          setModePrivate(T) {
            for (let P = 0; P < T.length; P++)
              switch (T.params[P]) {
                case 1:
                  this._coreService.decPrivateModes.applicationCursorKeys = !0;
                  break;
                case 2:
                  this._charsetService.setgCharset(0, C.DEFAULT_CHARSET), this._charsetService.setgCharset(1, C.DEFAULT_CHARSET), this._charsetService.setgCharset(2, C.DEFAULT_CHARSET), this._charsetService.setgCharset(3, C.DEFAULT_CHARSET);
                  break;
                case 3:
                  this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
                  break;
                case 6:
                  this._coreService.decPrivateModes.origin = !0, this._setCursor(0, 0);
                  break;
                case 7:
                  this._coreService.decPrivateModes.wraparound = !0;
                  break;
                case 12:
                  this._optionsService.options.cursorBlink = !0;
                  break;
                case 45:
                  this._coreService.decPrivateModes.reverseWraparound = !0;
                  break;
                case 66:
                  this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire();
                  break;
                case 9:
                  this._coreMouseService.activeProtocol = "X10";
                  break;
                case 1e3:
                  this._coreMouseService.activeProtocol = "VT200";
                  break;
                case 1002:
                  this._coreMouseService.activeProtocol = "DRAG";
                  break;
                case 1003:
                  this._coreMouseService.activeProtocol = "ANY";
                  break;
                case 1004:
                  this._coreService.decPrivateModes.sendFocus = !0, this._onRequestSendFocus.fire();
                  break;
                case 1005:
                  this._logService.debug("DECSET 1005 not supported (see #2507)");
                  break;
                case 1006:
                  this._coreMouseService.activeEncoding = "SGR";
                  break;
                case 1015:
                  this._logService.debug("DECSET 1015 not supported (see #2507)");
                  break;
                case 1016:
                  this._coreMouseService.activeEncoding = "SGR_PIXELS";
                  break;
                case 25:
                  this._coreService.isCursorHidden = !1;
                  break;
                case 1048:
                  this.saveCursor();
                  break;
                case 1049:
                  this.saveCursor();
                case 47:
                case 1047:
                  this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                  break;
                case 2004:
                  this._coreService.decPrivateModes.bracketedPasteMode = !0;
              }
            return !0;
          }
          resetMode(T) {
            for (let P = 0; P < T.length; P++)
              switch (T.params[P]) {
                case 4:
                  this._coreService.modes.insertMode = !1;
                  break;
                case 20:
                  this._optionsService.options.convertEol = !1;
              }
            return !0;
          }
          resetModePrivate(T) {
            for (let P = 0; P < T.length; P++)
              switch (T.params[P]) {
                case 1:
                  this._coreService.decPrivateModes.applicationCursorKeys = !1;
                  break;
                case 3:
                  this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
                  break;
                case 6:
                  this._coreService.decPrivateModes.origin = !1, this._setCursor(0, 0);
                  break;
                case 7:
                  this._coreService.decPrivateModes.wraparound = !1;
                  break;
                case 12:
                  this._optionsService.options.cursorBlink = !1;
                  break;
                case 45:
                  this._coreService.decPrivateModes.reverseWraparound = !1;
                  break;
                case 66:
                  this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire();
                  break;
                case 9:
                case 1e3:
                case 1002:
                case 1003:
                  this._coreMouseService.activeProtocol = "NONE";
                  break;
                case 1004:
                  this._coreService.decPrivateModes.sendFocus = !1;
                  break;
                case 1005:
                  this._logService.debug("DECRST 1005 not supported (see #2507)");
                  break;
                case 1006:
                case 1016:
                  this._coreMouseService.activeEncoding = "DEFAULT";
                  break;
                case 1015:
                  this._logService.debug("DECRST 1015 not supported (see #2507)");
                  break;
                case 25:
                  this._coreService.isCursorHidden = !0;
                  break;
                case 1048:
                  this.restoreCursor();
                  break;
                case 1049:
                case 47:
                case 1047:
                  this._bufferService.buffers.activateNormalBuffer(), T.params[P] === 1049 && this.restoreCursor(), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                  break;
                case 2004:
                  this._coreService.decPrivateModes.bracketedPasteMode = !1;
              }
            return !0;
          }
          requestMode(T, P) {
            const H = this._coreService.decPrivateModes, { activeProtocol: N, activeEncoding: G } = this._coreMouseService, Z = this._coreService, { buffers: ae, cols: q } = this._bufferService, { active: ee, alt: W } = ae, F = this._optionsService.rawOptions, B = (Y) => Y ? 1 : 2, $ = T.params[0];
            return z = $, ce = P ? $ === 2 ? 4 : $ === 4 ? B(Z.modes.insertMode) : $ === 12 ? 3 : $ === 20 ? B(F.convertEol) : 0 : $ === 1 ? B(H.applicationCursorKeys) : $ === 3 ? F.windowOptions.setWinLines ? q === 80 ? 2 : q === 132 ? 1 : 0 : 0 : $ === 6 ? B(H.origin) : $ === 7 ? B(H.wraparound) : $ === 8 ? 3 : $ === 9 ? B(N === "X10") : $ === 12 ? B(F.cursorBlink) : $ === 25 ? B(!Z.isCursorHidden) : $ === 45 ? B(H.reverseWraparound) : $ === 66 ? B(H.applicationKeypad) : $ === 67 ? 4 : $ === 1e3 ? B(N === "VT200") : $ === 1002 ? B(N === "DRAG") : $ === 1003 ? B(N === "ANY") : $ === 1004 ? B(H.sendFocus) : $ === 1005 ? 4 : $ === 1006 ? B(G === "SGR") : $ === 1015 ? 4 : $ === 1016 ? B(G === "SGR_PIXELS") : $ === 1048 ? 1 : $ === 47 || $ === 1047 || $ === 1049 ? B(ee === W) : $ === 2004 ? B(H.bracketedPasteMode) : 0, Z.triggerDataEvent(`${m.C0.ESC}[${P ? "" : "?"}${z};${ce}$y`), !0;
            var z, ce;
          }
          _updateAttrColor(T, P, H, N, G) {
            return P === 2 ? (T |= 50331648, T &= -16777216, T |= v.AttributeData.fromColorRGB([H, N, G])) : P === 5 && (T &= -50331904, T |= 33554432 | 255 & H), T;
          }
          _extractColor(T, P, H) {
            const N = [0, 0, -1, 0, 0, 0];
            let G = 0, Z = 0;
            do {
              if (N[Z + G] = T.params[P + Z], T.hasSubParams(P + Z)) {
                const ae = T.getSubParams(P + Z);
                let q = 0;
                do
                  N[1] === 5 && (G = 1), N[Z + q + 1 + G] = ae[q];
                while (++q < ae.length && q + Z + 1 + G < N.length);
                break;
              }
              if (N[1] === 5 && Z + G >= 2 || N[1] === 2 && Z + G >= 5)
                break;
              N[1] && (G = 1);
            } while (++Z + P < T.length && Z + G < N.length);
            for (let ae = 2; ae < N.length; ++ae)
              N[ae] === -1 && (N[ae] = 0);
            switch (N[0]) {
              case 38:
                H.fg = this._updateAttrColor(H.fg, N[1], N[3], N[4], N[5]);
                break;
              case 48:
                H.bg = this._updateAttrColor(H.bg, N[1], N[3], N[4], N[5]);
                break;
              case 58:
                H.extended = H.extended.clone(), H.extended.underlineColor = this._updateAttrColor(H.extended.underlineColor, N[1], N[3], N[4], N[5]);
            }
            return Z;
          }
          _processUnderline(T, P) {
            P.extended = P.extended.clone(), (!~T || T > 5) && (T = 1), P.extended.underlineStyle = T, P.fg |= 268435456, T === 0 && (P.fg &= -268435457), P.updateExtended();
          }
          _processSGR0(T) {
            T.fg = o.DEFAULT_ATTR_DATA.fg, T.bg = o.DEFAULT_ATTR_DATA.bg, T.extended = T.extended.clone(), T.extended.underlineStyle = 0, T.extended.underlineColor &= -67108864, T.updateExtended();
          }
          charAttributes(T) {
            if (T.length === 1 && T.params[0] === 0)
              return this._processSGR0(this._curAttrData), !0;
            const P = T.length;
            let H;
            const N = this._curAttrData;
            for (let G = 0; G < P; G++)
              H = T.params[G], H >= 30 && H <= 37 ? (N.fg &= -50331904, N.fg |= 16777216 | H - 30) : H >= 40 && H <= 47 ? (N.bg &= -50331904, N.bg |= 16777216 | H - 40) : H >= 90 && H <= 97 ? (N.fg &= -50331904, N.fg |= 16777224 | H - 90) : H >= 100 && H <= 107 ? (N.bg &= -50331904, N.bg |= 16777224 | H - 100) : H === 0 ? this._processSGR0(N) : H === 1 ? N.fg |= 134217728 : H === 3 ? N.bg |= 67108864 : H === 4 ? (N.fg |= 268435456, this._processUnderline(T.hasSubParams(G) ? T.getSubParams(G)[0] : 1, N)) : H === 5 ? N.fg |= 536870912 : H === 7 ? N.fg |= 67108864 : H === 8 ? N.fg |= 1073741824 : H === 9 ? N.fg |= 2147483648 : H === 2 ? N.bg |= 134217728 : H === 21 ? this._processUnderline(2, N) : H === 22 ? (N.fg &= -134217729, N.bg &= -134217729) : H === 23 ? N.bg &= -67108865 : H === 24 ? (N.fg &= -268435457, this._processUnderline(0, N)) : H === 25 ? N.fg &= -536870913 : H === 27 ? N.fg &= -67108865 : H === 28 ? N.fg &= -1073741825 : H === 29 ? N.fg &= 2147483647 : H === 39 ? (N.fg &= -67108864, N.fg |= 16777215 & o.DEFAULT_ATTR_DATA.fg) : H === 49 ? (N.bg &= -67108864, N.bg |= 16777215 & o.DEFAULT_ATTR_DATA.bg) : H === 38 || H === 48 || H === 58 ? G += this._extractColor(T, G, N) : H === 53 ? N.bg |= 1073741824 : H === 55 ? N.bg &= -1073741825 : H === 59 ? (N.extended = N.extended.clone(), N.extended.underlineColor = -1, N.updateExtended()) : H === 100 ? (N.fg &= -67108864, N.fg |= 16777215 & o.DEFAULT_ATTR_DATA.fg, N.bg &= -67108864, N.bg |= 16777215 & o.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", H);
            return !0;
          }
          deviceStatus(T) {
            switch (T.params[0]) {
              case 5:
                this._coreService.triggerDataEvent(`${m.C0.ESC}[0n`);
                break;
              case 6:
                const P = this._activeBuffer.y + 1, H = this._activeBuffer.x + 1;
                this._coreService.triggerDataEvent(`${m.C0.ESC}[${P};${H}R`);
            }
            return !0;
          }
          deviceStatusPrivate(T) {
            if (T.params[0] === 6) {
              const P = this._activeBuffer.y + 1, H = this._activeBuffer.x + 1;
              this._coreService.triggerDataEvent(`${m.C0.ESC}[?${P};${H}R`);
            }
            return !0;
          }
          softReset(T) {
            return this._coreService.isCursorHidden = !1, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = o.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = !1, !0;
          }
          setCursorStyle(T) {
            const P = T.params[0] || 1;
            switch (P) {
              case 1:
              case 2:
                this._optionsService.options.cursorStyle = "block";
                break;
              case 3:
              case 4:
                this._optionsService.options.cursorStyle = "underline";
                break;
              case 5:
              case 6:
                this._optionsService.options.cursorStyle = "bar";
            }
            const H = P % 2 == 1;
            return this._optionsService.options.cursorBlink = H, !0;
          }
          setScrollRegion(T) {
            const P = T.params[0] || 1;
            let H;
            return (T.length < 2 || (H = T.params[1]) > this._bufferService.rows || H === 0) && (H = this._bufferService.rows), H > P && (this._activeBuffer.scrollTop = P - 1, this._activeBuffer.scrollBottom = H - 1, this._setCursor(0, 0)), !0;
          }
          windowOptions(T) {
            if (!M(T.params[0], this._optionsService.rawOptions.windowOptions))
              return !0;
            const P = T.length > 1 ? T.params[1] : 0;
            switch (T.params[0]) {
              case 14:
                P !== 2 && this._onRequestWindowsOptionsReport.fire(L.GET_WIN_SIZE_PIXELS);
                break;
              case 16:
                this._onRequestWindowsOptionsReport.fire(L.GET_CELL_SIZE_PIXELS);
                break;
              case 18:
                this._bufferService && this._coreService.triggerDataEvent(`${m.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
                break;
              case 22:
                P !== 0 && P !== 2 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), P !== 0 && P !== 1 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
                break;
              case 23:
                P !== 0 && P !== 2 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), P !== 0 && P !== 1 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
            }
            return !0;
          }
          saveCursor(T) {
            return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, !0;
          }
          restoreCursor(T) {
            return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), !0;
          }
          setTitle(T) {
            return this._windowTitle = T, this._onTitleChange.fire(T), !0;
          }
          setIconName(T) {
            return this._iconName = T, !0;
          }
          setOrReportIndexedColor(T) {
            const P = [], H = T.split(";");
            for (; H.length > 1; ) {
              const N = H.shift(), G = H.shift();
              if (/^\d+$/.exec(N)) {
                const Z = parseInt(N);
                if (0 <= Z && Z < 256)
                  if (G === "?")
                    P.push({ type: 0, index: Z });
                  else {
                    const ae = (0, y.parseColor)(G);
                    ae && P.push({ type: 1, index: Z, color: ae });
                  }
              }
            }
            return P.length && this._onColor.fire(P), !0;
          }
          setHyperlink(T) {
            const P = T.split(";");
            return !(P.length < 2) && (P[1] ? this._createHyperlink(P[0], P[1]) : !P[0] && this._finishHyperlink());
          }
          _createHyperlink(T, P) {
            this._getCurrentLinkId() && this._finishHyperlink();
            const H = T.split(":");
            let N;
            const G = H.findIndex((Z) => Z.startsWith("id="));
            return G !== -1 && (N = H[G].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({ id: N, uri: P }), this._curAttrData.updateExtended(), !0;
          }
          _finishHyperlink() {
            return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), !0;
          }
          _setOrReportSpecialColor(T, P) {
            const H = T.split(";");
            for (let N = 0; N < H.length && !(P >= this._specialColors.length); ++N, ++P)
              if (H[N] === "?")
                this._onColor.fire([{ type: 0, index: this._specialColors[P] }]);
              else {
                const G = (0, y.parseColor)(H[N]);
                G && this._onColor.fire([{ type: 1, index: this._specialColors[P], color: G }]);
              }
            return !0;
          }
          setOrReportFgColor(T) {
            return this._setOrReportSpecialColor(T, 0);
          }
          setOrReportBgColor(T) {
            return this._setOrReportSpecialColor(T, 1);
          }
          setOrReportCursorColor(T) {
            return this._setOrReportSpecialColor(T, 2);
          }
          restoreIndexedColor(T) {
            if (!T)
              return this._onColor.fire([{ type: 2 }]), !0;
            const P = [], H = T.split(";");
            for (let N = 0; N < H.length; ++N)
              if (/^\d+$/.exec(H[N])) {
                const G = parseInt(H[N]);
                0 <= G && G < 256 && P.push({ type: 2, index: G });
              }
            return P.length && this._onColor.fire(P), !0;
          }
          restoreFgColor(T) {
            return this._onColor.fire([{ type: 2, index: 256 }]), !0;
          }
          restoreBgColor(T) {
            return this._onColor.fire([{ type: 2, index: 257 }]), !0;
          }
          restoreCursorColor(T) {
            return this._onColor.fire([{ type: 2, index: 258 }]), !0;
          }
          nextLine() {
            return this._activeBuffer.x = 0, this.index(), !0;
          }
          keypadApplicationMode() {
            return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire(), !0;
          }
          keypadNumericMode() {
            return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire(), !0;
          }
          selectDefaultCharset() {
            return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, C.DEFAULT_CHARSET), !0;
          }
          selectCharset(T) {
            return T.length !== 2 ? (this.selectDefaultCharset(), !0) : (T[0] === "/" || this._charsetService.setgCharset(I[T[0]], C.CHARSETS[T[1]] || C.DEFAULT_CHARSET), !0);
          }
          index() {
            return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), !0;
          }
          tabSet() {
            return this._activeBuffer.tabs[this._activeBuffer.x] = !0, !0;
          }
          reverseIndex() {
            if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
              const T = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
              this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, T, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
            } else
              this._activeBuffer.y--, this._restrictCursor();
            return !0;
          }
          fullReset() {
            return this._parser.reset(), this._onRequestReset.fire(), !0;
          }
          reset() {
            this._curAttrData = o.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = o.DEFAULT_ATTR_DATA.clone();
          }
          _eraseAttrData() {
            return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
          }
          setgLevel(T) {
            return this._charsetService.setgLevel(T), !0;
          }
          screenAlignmentPattern() {
            const T = new d.CellData();
            T.content = 4194304 | "E".charCodeAt(0), T.fg = this._curAttrData.fg, T.bg = this._curAttrData.bg, this._setCursor(0, 0);
            for (let P = 0; P < this._bufferService.rows; ++P) {
              const H = this._activeBuffer.ybase + this._activeBuffer.y + P, N = this._activeBuffer.lines.get(H);
              N && (N.fill(T), N.isWrapped = !1);
            }
            return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), !0;
          }
          requestStatusString(T, P) {
            const H = this._bufferService.buffer, N = this._optionsService.rawOptions;
            return ((G) => (this._coreService.triggerDataEvent(`${m.C0.ESC}${G}${m.C0.ESC}\\`), !0))(T === '"q' ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : T === '"p' ? 'P1$r61;1"p' : T === "r" ? `P1$r${H.scrollTop + 1};${H.scrollBottom + 1}r` : T === "m" ? "P1$r0m" : T === " q" ? `P1$r${{ block: 2, underline: 4, bar: 6 }[N.cursorStyle] - (N.cursorBlink ? 1 : 0)} q` : "P0$r");
          }
          markRangeDirty(T, P) {
            this._dirtyRowTracker.markRangeDirty(T, P);
          }
        }
        n.InputHandler = U;
        let j = class {
          constructor(K) {
            this._bufferService = K, this.clearRange();
          }
          clearRange() {
            this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
          }
          markDirty(K) {
            K < this.start ? this.start = K : K > this.end && (this.end = K);
          }
          markRangeDirty(K, T) {
            K > T && (O = K, K = T, T = O), K < this.start && (this.start = K), T > this.end && (this.end = T);
          }
          markAllDirty() {
            this.markRangeDirty(0, this._bufferService.rows - 1);
          }
        };
        j = a([f(0, w.IBufferService)], j);
      }, 844: (l, n) => {
        function r(a) {
          for (const f of a)
            f.dispose();
          a.length = 0;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.getDisposeArrayDisposable = n.disposeArray = n.toDisposable = n.Disposable = void 0, n.Disposable = class {
          constructor() {
            this._disposables = [], this._isDisposed = !1;
          }
          dispose() {
            this._isDisposed = !0;
            for (const a of this._disposables)
              a.dispose();
            this._disposables.length = 0;
          }
          register(a) {
            return this._disposables.push(a), a;
          }
          unregister(a) {
            const f = this._disposables.indexOf(a);
            f !== -1 && this._disposables.splice(f, 1);
          }
        }, n.toDisposable = function(a) {
          return { dispose: a };
        }, n.disposeArray = r, n.getDisposeArrayDisposable = function(a) {
          return { dispose: () => r(a) };
        };
      }, 1505: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.FourKeyMap = n.TwoKeyMap = void 0;
        class r {
          constructor() {
            this._data = {};
          }
          set(f, m, C) {
            this._data[f] || (this._data[f] = {}), this._data[f][m] = C;
          }
          get(f, m) {
            return this._data[f] ? this._data[f][m] : void 0;
          }
          clear() {
            this._data = {};
          }
        }
        n.TwoKeyMap = r, n.FourKeyMap = class {
          constructor() {
            this._data = new r();
          }
          set(a, f, m, C, b) {
            this._data.get(a, f) || this._data.set(a, f, new r()), this._data.get(a, f).set(m, C, b);
          }
          get(a, f, m, C) {
            var b;
            return (b = this._data.get(a, f)) === null || b === void 0 ? void 0 : b.get(m, C);
          }
          clear() {
            this._data.clear();
          }
        };
      }, 6114: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.isChromeOS = n.isLinux = n.isWindows = n.isIphone = n.isIpad = n.isMac = n.getSafariVersion = n.isSafari = n.isLegacyEdge = n.isFirefox = n.isNode = void 0, n.isNode = typeof navigator > "u";
        const r = n.isNode ? "node" : navigator.userAgent, a = n.isNode ? "node" : navigator.platform;
        n.isFirefox = r.includes("Firefox"), n.isLegacyEdge = r.includes("Edge"), n.isSafari = /^((?!chrome|android).)*safari/i.test(r), n.getSafariVersion = function() {
          if (!n.isSafari)
            return 0;
          const f = r.match(/Version\/(\d+)/);
          return f === null || f.length < 2 ? 0 : parseInt(f[1]);
        }, n.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(a), n.isIpad = a === "iPad", n.isIphone = a === "iPhone", n.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(a), n.isLinux = a.indexOf("Linux") >= 0, n.isChromeOS = /\bCrOS\b/.test(r);
      }, 6106: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.SortedList = void 0;
        let r = 0;
        n.SortedList = class {
          constructor(a) {
            this._getKey = a, this._array = [];
          }
          clear() {
            this._array.length = 0;
          }
          insert(a) {
            this._array.length !== 0 ? (r = this._search(this._getKey(a), 0, this._array.length - 1), this._array.splice(r, 0, a)) : this._array.push(a);
          }
          delete(a) {
            if (this._array.length === 0)
              return !1;
            const f = this._getKey(a);
            if (f === void 0 || (r = this._search(f, 0, this._array.length - 1), r === -1) || this._getKey(this._array[r]) !== f)
              return !1;
            do
              if (this._array[r] === a)
                return this._array.splice(r, 1), !0;
            while (++r < this._array.length && this._getKey(this._array[r]) === f);
            return !1;
          }
          *getKeyIterator(a) {
            if (this._array.length !== 0 && (r = this._search(a, 0, this._array.length - 1), !(r < 0 || r >= this._array.length) && this._getKey(this._array[r]) === a))
              do
                yield this._array[r];
              while (++r < this._array.length && this._getKey(this._array[r]) === a);
          }
          forEachByKey(a, f) {
            if (this._array.length !== 0 && (r = this._search(a, 0, this._array.length - 1), !(r < 0 || r >= this._array.length) && this._getKey(this._array[r]) === a))
              do
                f(this._array[r]);
              while (++r < this._array.length && this._getKey(this._array[r]) === a);
          }
          values() {
            return this._array.values();
          }
          _search(a, f, m) {
            if (m < f)
              return f;
            let C = Math.floor((f + m) / 2);
            const b = this._getKey(this._array[C]);
            if (b > a)
              return this._search(a, f, C - 1);
            if (b < a)
              return this._search(a, C + 1, m);
            for (; C > 0 && this._getKey(this._array[C - 1]) === a; )
              C--;
            return C;
          }
        };
      }, 7226: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.DebouncedIdleTask = n.IdleTaskQueue = n.PriorityTaskQueue = void 0;
        const a = r(6114);
        class f {
          constructor() {
            this._tasks = [], this._i = 0;
          }
          enqueue(b) {
            this._tasks.push(b), this._start();
          }
          flush() {
            for (; this._i < this._tasks.length; )
              this._tasks[this._i]() || this._i++;
            this.clear();
          }
          clear() {
            this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
          }
          _start() {
            this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
          }
          _process(b) {
            this._idleCallback = void 0;
            let p = 0, S = 0, o = b.timeRemaining(), _ = 0;
            for (; this._i < this._tasks.length; ) {
              if (p = Date.now(), this._tasks[this._i]() || this._i++, p = Math.max(1, Date.now() - p), S = Math.max(p, S), _ = b.timeRemaining(), 1.5 * S > _)
                return o - p < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(o - p))}ms`), void this._start();
              o = _;
            }
            this.clear();
          }
        }
        class m extends f {
          _requestCallback(b) {
            return setTimeout(() => b(this._createDeadline(16)));
          }
          _cancelCallback(b) {
            clearTimeout(b);
          }
          _createDeadline(b) {
            const p = Date.now() + b;
            return { timeRemaining: () => Math.max(0, p - Date.now()) };
          }
        }
        n.PriorityTaskQueue = m, n.IdleTaskQueue = !a.isNode && "requestIdleCallback" in window ? class extends f {
          _requestCallback(C) {
            return requestIdleCallback(C);
          }
          _cancelCallback(C) {
            cancelIdleCallback(C);
          }
        } : m, n.DebouncedIdleTask = class {
          constructor() {
            this._queue = new n.IdleTaskQueue();
          }
          set(C) {
            this._queue.clear(), this._queue.enqueue(C);
          }
          flush() {
            this._queue.flush();
          }
        };
      }, 9282: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.updateWindowsModeWrappedState = void 0;
        const a = r(643);
        n.updateWindowsModeWrappedState = function(f) {
          const m = f.buffer.lines.get(f.buffer.ybase + f.buffer.y - 1), C = m == null ? void 0 : m.get(f.cols - 1), b = f.buffer.lines.get(f.buffer.ybase + f.buffer.y);
          b && C && (b.isWrapped = C[a.CHAR_DATA_CODE_INDEX] !== a.NULL_CELL_CODE && C[a.CHAR_DATA_CODE_INDEX] !== a.WHITESPACE_CELL_CODE);
        };
      }, 3734: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.ExtendedAttrs = n.AttributeData = void 0;
        class r {
          constructor() {
            this.fg = 0, this.bg = 0, this.extended = new a();
          }
          static toColorRGB(m) {
            return [m >>> 16 & 255, m >>> 8 & 255, 255 & m];
          }
          static fromColorRGB(m) {
            return (255 & m[0]) << 16 | (255 & m[1]) << 8 | 255 & m[2];
          }
          clone() {
            const m = new r();
            return m.fg = this.fg, m.bg = this.bg, m.extended = this.extended.clone(), m;
          }
          isInverse() {
            return 67108864 & this.fg;
          }
          isBold() {
            return 134217728 & this.fg;
          }
          isUnderline() {
            return this.hasExtendedAttrs() && this.extended.underlineStyle !== 0 ? 1 : 268435456 & this.fg;
          }
          isBlink() {
            return 536870912 & this.fg;
          }
          isInvisible() {
            return 1073741824 & this.fg;
          }
          isItalic() {
            return 67108864 & this.bg;
          }
          isDim() {
            return 134217728 & this.bg;
          }
          isStrikethrough() {
            return 2147483648 & this.fg;
          }
          isProtected() {
            return 536870912 & this.bg;
          }
          isOverline() {
            return 1073741824 & this.bg;
          }
          getFgColorMode() {
            return 50331648 & this.fg;
          }
          getBgColorMode() {
            return 50331648 & this.bg;
          }
          isFgRGB() {
            return (50331648 & this.fg) == 50331648;
          }
          isBgRGB() {
            return (50331648 & this.bg) == 50331648;
          }
          isFgPalette() {
            return (50331648 & this.fg) == 16777216 || (50331648 & this.fg) == 33554432;
          }
          isBgPalette() {
            return (50331648 & this.bg) == 16777216 || (50331648 & this.bg) == 33554432;
          }
          isFgDefault() {
            return (50331648 & this.fg) == 0;
          }
          isBgDefault() {
            return (50331648 & this.bg) == 0;
          }
          isAttributeDefault() {
            return this.fg === 0 && this.bg === 0;
          }
          getFgColor() {
            switch (50331648 & this.fg) {
              case 16777216:
              case 33554432:
                return 255 & this.fg;
              case 50331648:
                return 16777215 & this.fg;
              default:
                return -1;
            }
          }
          getBgColor() {
            switch (50331648 & this.bg) {
              case 16777216:
              case 33554432:
                return 255 & this.bg;
              case 50331648:
                return 16777215 & this.bg;
              default:
                return -1;
            }
          }
          hasExtendedAttrs() {
            return 268435456 & this.bg;
          }
          updateExtended() {
            this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
          }
          getUnderlineColor() {
            if (268435456 & this.bg && ~this.extended.underlineColor)
              switch (50331648 & this.extended.underlineColor) {
                case 16777216:
                case 33554432:
                  return 255 & this.extended.underlineColor;
                case 50331648:
                  return 16777215 & this.extended.underlineColor;
                default:
                  return this.getFgColor();
              }
            return this.getFgColor();
          }
          getUnderlineColorMode() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
          }
          isUnderlineColorRGB() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 50331648 : this.isFgRGB();
          }
          isUnderlineColorPalette() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 16777216 || (50331648 & this.extended.underlineColor) == 33554432 : this.isFgPalette();
          }
          isUnderlineColorDefault() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 0 : this.isFgDefault();
          }
          getUnderlineStyle() {
            return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
          }
        }
        n.AttributeData = r;
        class a {
          constructor(m = 0, C = 0) {
            this._ext = 0, this._urlId = 0, this._ext = m, this._urlId = C;
          }
          get ext() {
            return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
          }
          set ext(m) {
            this._ext = m;
          }
          get underlineStyle() {
            return this._urlId ? 5 : (469762048 & this._ext) >> 26;
          }
          set underlineStyle(m) {
            this._ext &= -469762049, this._ext |= m << 26 & 469762048;
          }
          get underlineColor() {
            return 67108863 & this._ext;
          }
          set underlineColor(m) {
            this._ext &= -67108864, this._ext |= 67108863 & m;
          }
          get urlId() {
            return this._urlId;
          }
          set urlId(m) {
            this._urlId = m;
          }
          clone() {
            return new a(this._ext, this._urlId);
          }
          isEmpty() {
            return this.underlineStyle === 0 && this._urlId === 0;
          }
        }
        n.ExtendedAttrs = a;
      }, 9092: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.Buffer = n.MAX_BUFFER_SIZE = void 0;
        const a = r(6349), f = r(8437), m = r(511), C = r(643), b = r(4634), p = r(4863), S = r(7116), o = r(3734), _ = r(7226);
        n.MAX_BUFFER_SIZE = 4294967295, n.Buffer = class {
          constructor(u, d, v) {
            this._hasScrollback = u, this._optionsService = d, this._bufferService = v, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = f.DEFAULT_ATTR_DATA.clone(), this.savedCharset = S.DEFAULT_CHARSET, this.markers = [], this._nullCell = m.CellData.fromCharData([0, C.NULL_CELL_CHAR, C.NULL_CELL_WIDTH, C.NULL_CELL_CODE]), this._whitespaceCell = m.CellData.fromCharData([0, C.WHITESPACE_CELL_CHAR, C.WHITESPACE_CELL_WIDTH, C.WHITESPACE_CELL_CODE]), this._isClearing = !1, this._memoryCleanupQueue = new _.IdleTaskQueue(), this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new a.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
          }
          getNullCell(u) {
            return u ? (this._nullCell.fg = u.fg, this._nullCell.bg = u.bg, this._nullCell.extended = u.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new o.ExtendedAttrs()), this._nullCell;
          }
          getWhitespaceCell(u) {
            return u ? (this._whitespaceCell.fg = u.fg, this._whitespaceCell.bg = u.bg, this._whitespaceCell.extended = u.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new o.ExtendedAttrs()), this._whitespaceCell;
          }
          getBlankLine(u, d) {
            return new f.BufferLine(this._bufferService.cols, this.getNullCell(u), d);
          }
          get hasScrollback() {
            return this._hasScrollback && this.lines.maxLength > this._rows;
          }
          get isCursorInViewport() {
            const u = this.ybase + this.y - this.ydisp;
            return u >= 0 && u < this._rows;
          }
          _getCorrectBufferLength(u) {
            if (!this._hasScrollback)
              return u;
            const d = u + this._optionsService.rawOptions.scrollback;
            return d > n.MAX_BUFFER_SIZE ? n.MAX_BUFFER_SIZE : d;
          }
          fillViewportRows(u) {
            if (this.lines.length === 0) {
              u === void 0 && (u = f.DEFAULT_ATTR_DATA);
              let d = this._rows;
              for (; d--; )
                this.lines.push(this.getBlankLine(u));
            }
          }
          clear() {
            this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new a.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
          }
          resize(u, d) {
            const v = this.getNullCell(f.DEFAULT_ATTR_DATA);
            let w = 0;
            const x = this._getCorrectBufferLength(d);
            if (x > this.lines.maxLength && (this.lines.maxLength = x), this.lines.length > 0) {
              if (this._cols < u)
                for (let y = 0; y < this.lines.length; y++)
                  w += +this.lines.get(y).resize(u, v);
              let k = 0;
              if (this._rows < d)
                for (let y = this._rows; y < d; y++)
                  this.lines.length < d + this.ybase && (this._optionsService.rawOptions.windowsMode || this._optionsService.rawOptions.windowsPty.backend !== void 0 || this._optionsService.rawOptions.windowsPty.buildNumber !== void 0 ? this.lines.push(new f.BufferLine(u, v)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + k + 1 ? (this.ybase--, k++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new f.BufferLine(u, v)));
              else
                for (let y = this._rows; y > d; y--)
                  this.lines.length > d + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
              if (x < this.lines.maxLength) {
                const y = this.lines.length - x;
                y > 0 && (this.lines.trimStart(y), this.ybase = Math.max(this.ybase - y, 0), this.ydisp = Math.max(this.ydisp - y, 0), this.savedY = Math.max(this.savedY - y, 0)), this.lines.maxLength = x;
              }
              this.x = Math.min(this.x, u - 1), this.y = Math.min(this.y, d - 1), k && (this.y += k), this.savedX = Math.min(this.savedX, u - 1), this.scrollTop = 0;
            }
            if (this.scrollBottom = d - 1, this._isReflowEnabled && (this._reflow(u, d), this._cols > u))
              for (let k = 0; k < this.lines.length; k++)
                w += +this.lines.get(k).resize(u, v);
            this._cols = u, this._rows = d, this._memoryCleanupQueue.clear(), w > 0.1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue(() => this._batchedMemoryCleanup()));
          }
          _batchedMemoryCleanup() {
            let u = !0;
            this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, u = !1);
            let d = 0;
            for (; this._memoryCleanupPosition < this.lines.length; )
              if (d += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), d > 100)
                return !0;
            return u;
          }
          get _isReflowEnabled() {
            const u = this._optionsService.rawOptions.windowsPty;
            return u && u.buildNumber ? this._hasScrollback && u.backend === "conpty" && u.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
          }
          _reflow(u, d) {
            this._cols !== u && (u > this._cols ? this._reflowLarger(u, d) : this._reflowSmaller(u, d));
          }
          _reflowLarger(u, d) {
            const v = (0, b.reflowLargerGetLinesToRemove)(this.lines, this._cols, u, this.ybase + this.y, this.getNullCell(f.DEFAULT_ATTR_DATA));
            if (v.length > 0) {
              const w = (0, b.reflowLargerCreateNewLayout)(this.lines, v);
              (0, b.reflowLargerApplyNewLayout)(this.lines, w.layout), this._reflowLargerAdjustViewport(u, d, w.countRemoved);
            }
          }
          _reflowLargerAdjustViewport(u, d, v) {
            const w = this.getNullCell(f.DEFAULT_ATTR_DATA);
            let x = v;
            for (; x-- > 0; )
              this.ybase === 0 ? (this.y > 0 && this.y--, this.lines.length < d && this.lines.push(new f.BufferLine(u, w))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
            this.savedY = Math.max(this.savedY - v, 0);
          }
          _reflowSmaller(u, d) {
            const v = this.getNullCell(f.DEFAULT_ATTR_DATA), w = [];
            let x = 0;
            for (let k = this.lines.length - 1; k >= 0; k--) {
              let y = this.lines.get(k);
              if (!y || !y.isWrapped && y.getTrimmedLength() <= u)
                continue;
              const I = [y];
              for (; y.isWrapped && k > 0; )
                y = this.lines.get(--k), I.unshift(y);
              const A = this.ybase + this.y;
              if (A >= k && A < k + I.length)
                continue;
              const M = I[I.length - 1].getTrimmedLength(), L = (0, b.reflowSmallerGetNewLineLengths)(I, this._cols, u), O = L.length - I.length;
              let U;
              U = this.ybase === 0 && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + O) : Math.max(0, this.lines.length - this.lines.maxLength + O);
              const j = [];
              for (let G = 0; G < O; G++) {
                const Z = this.getBlankLine(f.DEFAULT_ATTR_DATA, !0);
                j.push(Z);
              }
              j.length > 0 && (w.push({ start: k + I.length + x, newLines: j }), x += j.length), I.push(...j);
              let K = L.length - 1, T = L[K];
              T === 0 && (K--, T = L[K]);
              let P = I.length - O - 1, H = M;
              for (; P >= 0; ) {
                const G = Math.min(H, T);
                if (I[K] === void 0)
                  break;
                if (I[K].copyCellsFrom(I[P], H - G, T - G, G, !0), T -= G, T === 0 && (K--, T = L[K]), H -= G, H === 0) {
                  P--;
                  const Z = Math.max(P, 0);
                  H = (0, b.getWrappedLineTrimmedLength)(I, Z, this._cols);
                }
              }
              for (let G = 0; G < I.length; G++)
                L[G] < u && I[G].setCell(L[G], v);
              let N = O - U;
              for (; N-- > 0; )
                this.ybase === 0 ? this.y < d - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + x) - d && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
              this.savedY = Math.min(this.savedY + O, this.ybase + d - 1);
            }
            if (w.length > 0) {
              const k = [], y = [];
              for (let K = 0; K < this.lines.length; K++)
                y.push(this.lines.get(K));
              const I = this.lines.length;
              let A = I - 1, M = 0, L = w[M];
              this.lines.length = Math.min(this.lines.maxLength, this.lines.length + x);
              let O = 0;
              for (let K = Math.min(this.lines.maxLength - 1, I + x - 1); K >= 0; K--)
                if (L && L.start > A + O) {
                  for (let T = L.newLines.length - 1; T >= 0; T--)
                    this.lines.set(K--, L.newLines[T]);
                  K++, k.push({ index: A + 1, amount: L.newLines.length }), O += L.newLines.length, L = w[++M];
                } else
                  this.lines.set(K, y[A--]);
              let U = 0;
              for (let K = k.length - 1; K >= 0; K--)
                k[K].index += U, this.lines.onInsertEmitter.fire(k[K]), U += k[K].amount;
              const j = Math.max(0, I + x - this.lines.maxLength);
              j > 0 && this.lines.onTrimEmitter.fire(j);
            }
          }
          translateBufferLineToString(u, d, v = 0, w) {
            const x = this.lines.get(u);
            return x ? x.translateToString(d, v, w) : "";
          }
          getWrappedRangeForLine(u) {
            let d = u, v = u;
            for (; d > 0 && this.lines.get(d).isWrapped; )
              d--;
            for (; v + 1 < this.lines.length && this.lines.get(v + 1).isWrapped; )
              v++;
            return { first: d, last: v };
          }
          setupTabStops(u) {
            for (u != null ? this.tabs[u] || (u = this.prevStop(u)) : (this.tabs = {}, u = 0); u < this._cols; u += this._optionsService.rawOptions.tabStopWidth)
              this.tabs[u] = !0;
          }
          prevStop(u) {
            for (u == null && (u = this.x); !this.tabs[--u] && u > 0; )
              ;
            return u >= this._cols ? this._cols - 1 : u < 0 ? 0 : u;
          }
          nextStop(u) {
            for (u == null && (u = this.x); !this.tabs[++u] && u < this._cols; )
              ;
            return u >= this._cols ? this._cols - 1 : u < 0 ? 0 : u;
          }
          clearMarkers(u) {
            this._isClearing = !0;
            for (let d = 0; d < this.markers.length; d++)
              this.markers[d].line === u && (this.markers[d].dispose(), this.markers.splice(d--, 1));
            this._isClearing = !1;
          }
          clearAllMarkers() {
            this._isClearing = !0;
            for (let u = 0; u < this.markers.length; u++)
              this.markers[u].dispose(), this.markers.splice(u--, 1);
            this._isClearing = !1;
          }
          addMarker(u) {
            const d = new p.Marker(u);
            return this.markers.push(d), d.register(this.lines.onTrim((v) => {
              d.line -= v, d.line < 0 && d.dispose();
            })), d.register(this.lines.onInsert((v) => {
              d.line >= v.index && (d.line += v.amount);
            })), d.register(this.lines.onDelete((v) => {
              d.line >= v.index && d.line < v.index + v.amount && d.dispose(), d.line > v.index && (d.line -= v.amount);
            })), d.register(d.onDispose(() => this._removeMarker(d))), d;
          }
          _removeMarker(u) {
            this._isClearing || this.markers.splice(this.markers.indexOf(u), 1);
          }
        };
      }, 8437: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.BufferLine = n.DEFAULT_ATTR_DATA = void 0;
        const a = r(482), f = r(643), m = r(511), C = r(3734);
        n.DEFAULT_ATTR_DATA = Object.freeze(new C.AttributeData());
        let b = 0;
        class p {
          constructor(o, _, u = !1) {
            this.isWrapped = u, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * o);
            const d = _ || m.CellData.fromCharData([0, f.NULL_CELL_CHAR, f.NULL_CELL_WIDTH, f.NULL_CELL_CODE]);
            for (let v = 0; v < o; ++v)
              this.setCell(v, d);
            this.length = o;
          }
          get(o) {
            const _ = this._data[3 * o + 0], u = 2097151 & _;
            return [this._data[3 * o + 1], 2097152 & _ ? this._combined[o] : u ? (0, a.stringFromCodePoint)(u) : "", _ >> 22, 2097152 & _ ? this._combined[o].charCodeAt(this._combined[o].length - 1) : u];
          }
          set(o, _) {
            this._data[3 * o + 1] = _[f.CHAR_DATA_ATTR_INDEX], _[f.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[o] = _[1], this._data[3 * o + 0] = 2097152 | o | _[f.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * o + 0] = _[f.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | _[f.CHAR_DATA_WIDTH_INDEX] << 22;
          }
          getWidth(o) {
            return this._data[3 * o + 0] >> 22;
          }
          hasWidth(o) {
            return 12582912 & this._data[3 * o + 0];
          }
          getFg(o) {
            return this._data[3 * o + 1];
          }
          getBg(o) {
            return this._data[3 * o + 2];
          }
          hasContent(o) {
            return 4194303 & this._data[3 * o + 0];
          }
          getCodePoint(o) {
            const _ = this._data[3 * o + 0];
            return 2097152 & _ ? this._combined[o].charCodeAt(this._combined[o].length - 1) : 2097151 & _;
          }
          isCombined(o) {
            return 2097152 & this._data[3 * o + 0];
          }
          getString(o) {
            const _ = this._data[3 * o + 0];
            return 2097152 & _ ? this._combined[o] : 2097151 & _ ? (0, a.stringFromCodePoint)(2097151 & _) : "";
          }
          isProtected(o) {
            return 536870912 & this._data[3 * o + 2];
          }
          loadCell(o, _) {
            return b = 3 * o, _.content = this._data[b + 0], _.fg = this._data[b + 1], _.bg = this._data[b + 2], 2097152 & _.content && (_.combinedData = this._combined[o]), 268435456 & _.bg && (_.extended = this._extendedAttrs[o]), _;
          }
          setCell(o, _) {
            2097152 & _.content && (this._combined[o] = _.combinedData), 268435456 & _.bg && (this._extendedAttrs[o] = _.extended), this._data[3 * o + 0] = _.content, this._data[3 * o + 1] = _.fg, this._data[3 * o + 2] = _.bg;
          }
          setCellFromCodePoint(o, _, u, d, v, w) {
            268435456 & v && (this._extendedAttrs[o] = w), this._data[3 * o + 0] = _ | u << 22, this._data[3 * o + 1] = d, this._data[3 * o + 2] = v;
          }
          addCodepointToCell(o, _) {
            let u = this._data[3 * o + 0];
            2097152 & u ? this._combined[o] += (0, a.stringFromCodePoint)(_) : (2097151 & u ? (this._combined[o] = (0, a.stringFromCodePoint)(2097151 & u) + (0, a.stringFromCodePoint)(_), u &= -2097152, u |= 2097152) : u = _ | 4194304, this._data[3 * o + 0] = u);
          }
          insertCells(o, _, u, d) {
            if ((o %= this.length) && this.getWidth(o - 1) === 2 && this.setCellFromCodePoint(o - 1, 0, 1, (d == null ? void 0 : d.fg) || 0, (d == null ? void 0 : d.bg) || 0, (d == null ? void 0 : d.extended) || new C.ExtendedAttrs()), _ < this.length - o) {
              const v = new m.CellData();
              for (let w = this.length - o - _ - 1; w >= 0; --w)
                this.setCell(o + _ + w, this.loadCell(o + w, v));
              for (let w = 0; w < _; ++w)
                this.setCell(o + w, u);
            } else
              for (let v = o; v < this.length; ++v)
                this.setCell(v, u);
            this.getWidth(this.length - 1) === 2 && this.setCellFromCodePoint(this.length - 1, 0, 1, (d == null ? void 0 : d.fg) || 0, (d == null ? void 0 : d.bg) || 0, (d == null ? void 0 : d.extended) || new C.ExtendedAttrs());
          }
          deleteCells(o, _, u, d) {
            if (o %= this.length, _ < this.length - o) {
              const v = new m.CellData();
              for (let w = 0; w < this.length - o - _; ++w)
                this.setCell(o + w, this.loadCell(o + _ + w, v));
              for (let w = this.length - _; w < this.length; ++w)
                this.setCell(w, u);
            } else
              for (let v = o; v < this.length; ++v)
                this.setCell(v, u);
            o && this.getWidth(o - 1) === 2 && this.setCellFromCodePoint(o - 1, 0, 1, (d == null ? void 0 : d.fg) || 0, (d == null ? void 0 : d.bg) || 0, (d == null ? void 0 : d.extended) || new C.ExtendedAttrs()), this.getWidth(o) !== 0 || this.hasContent(o) || this.setCellFromCodePoint(o, 0, 1, (d == null ? void 0 : d.fg) || 0, (d == null ? void 0 : d.bg) || 0, (d == null ? void 0 : d.extended) || new C.ExtendedAttrs());
          }
          replaceCells(o, _, u, d, v = !1) {
            if (v)
              for (o && this.getWidth(o - 1) === 2 && !this.isProtected(o - 1) && this.setCellFromCodePoint(o - 1, 0, 1, (d == null ? void 0 : d.fg) || 0, (d == null ? void 0 : d.bg) || 0, (d == null ? void 0 : d.extended) || new C.ExtendedAttrs()), _ < this.length && this.getWidth(_ - 1) === 2 && !this.isProtected(_) && this.setCellFromCodePoint(_, 0, 1, (d == null ? void 0 : d.fg) || 0, (d == null ? void 0 : d.bg) || 0, (d == null ? void 0 : d.extended) || new C.ExtendedAttrs()); o < _ && o < this.length; )
                this.isProtected(o) || this.setCell(o, u), o++;
            else
              for (o && this.getWidth(o - 1) === 2 && this.setCellFromCodePoint(o - 1, 0, 1, (d == null ? void 0 : d.fg) || 0, (d == null ? void 0 : d.bg) || 0, (d == null ? void 0 : d.extended) || new C.ExtendedAttrs()), _ < this.length && this.getWidth(_ - 1) === 2 && this.setCellFromCodePoint(_, 0, 1, (d == null ? void 0 : d.fg) || 0, (d == null ? void 0 : d.bg) || 0, (d == null ? void 0 : d.extended) || new C.ExtendedAttrs()); o < _ && o < this.length; )
                this.setCell(o++, u);
          }
          resize(o, _) {
            if (o === this.length)
              return 4 * this._data.length * 2 < this._data.buffer.byteLength;
            const u = 3 * o;
            if (o > this.length) {
              if (this._data.buffer.byteLength >= 4 * u)
                this._data = new Uint32Array(this._data.buffer, 0, u);
              else {
                const d = new Uint32Array(u);
                d.set(this._data), this._data = d;
              }
              for (let d = this.length; d < o; ++d)
                this.setCell(d, _);
            } else {
              this._data = this._data.subarray(0, u);
              const d = Object.keys(this._combined);
              for (let w = 0; w < d.length; w++) {
                const x = parseInt(d[w], 10);
                x >= o && delete this._combined[x];
              }
              const v = Object.keys(this._extendedAttrs);
              for (let w = 0; w < v.length; w++) {
                const x = parseInt(v[w], 10);
                x >= o && delete this._extendedAttrs[x];
              }
            }
            return this.length = o, 4 * u * 2 < this._data.buffer.byteLength;
          }
          cleanupMemory() {
            if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
              const o = new Uint32Array(this._data.length);
              return o.set(this._data), this._data = o, 1;
            }
            return 0;
          }
          fill(o, _ = !1) {
            if (_)
              for (let u = 0; u < this.length; ++u)
                this.isProtected(u) || this.setCell(u, o);
            else {
              this._combined = {}, this._extendedAttrs = {};
              for (let u = 0; u < this.length; ++u)
                this.setCell(u, o);
            }
          }
          copyFrom(o) {
            this.length !== o.length ? this._data = new Uint32Array(o._data) : this._data.set(o._data), this.length = o.length, this._combined = {};
            for (const _ in o._combined)
              this._combined[_] = o._combined[_];
            this._extendedAttrs = {};
            for (const _ in o._extendedAttrs)
              this._extendedAttrs[_] = o._extendedAttrs[_];
            this.isWrapped = o.isWrapped;
          }
          clone() {
            const o = new p(0);
            o._data = new Uint32Array(this._data), o.length = this.length;
            for (const _ in this._combined)
              o._combined[_] = this._combined[_];
            for (const _ in this._extendedAttrs)
              o._extendedAttrs[_] = this._extendedAttrs[_];
            return o.isWrapped = this.isWrapped, o;
          }
          getTrimmedLength() {
            for (let o = this.length - 1; o >= 0; --o)
              if (4194303 & this._data[3 * o + 0])
                return o + (this._data[3 * o + 0] >> 22);
            return 0;
          }
          copyCellsFrom(o, _, u, d, v) {
            const w = o._data;
            if (v)
              for (let k = d - 1; k >= 0; k--) {
                for (let y = 0; y < 3; y++)
                  this._data[3 * (u + k) + y] = w[3 * (_ + k) + y];
                268435456 & w[3 * (_ + k) + 2] && (this._extendedAttrs[u + k] = o._extendedAttrs[_ + k]);
              }
            else
              for (let k = 0; k < d; k++) {
                for (let y = 0; y < 3; y++)
                  this._data[3 * (u + k) + y] = w[3 * (_ + k) + y];
                268435456 & w[3 * (_ + k) + 2] && (this._extendedAttrs[u + k] = o._extendedAttrs[_ + k]);
              }
            const x = Object.keys(o._combined);
            for (let k = 0; k < x.length; k++) {
              const y = parseInt(x[k], 10);
              y >= _ && (this._combined[y - _ + u] = o._combined[y]);
            }
          }
          translateToString(o = !1, _ = 0, u = this.length) {
            o && (u = Math.min(u, this.getTrimmedLength()));
            let d = "";
            for (; _ < u; ) {
              const v = this._data[3 * _ + 0], w = 2097151 & v;
              d += 2097152 & v ? this._combined[_] : w ? (0, a.stringFromCodePoint)(w) : f.WHITESPACE_CELL_CHAR, _ += v >> 22 || 1;
            }
            return d;
          }
        }
        n.BufferLine = p;
      }, 4841: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.getRangeLength = void 0, n.getRangeLength = function(r, a) {
          if (r.start.y > r.end.y)
            throw new Error(`Buffer range end (${r.end.x}, ${r.end.y}) cannot be before start (${r.start.x}, ${r.start.y})`);
          return a * (r.end.y - r.start.y) + (r.end.x - r.start.x + 1);
        };
      }, 4634: (l, n) => {
        function r(a, f, m) {
          if (f === a.length - 1)
            return a[f].getTrimmedLength();
          const C = !a[f].hasContent(m - 1) && a[f].getWidth(m - 1) === 1, b = a[f + 1].getWidth(0) === 2;
          return C && b ? m - 1 : m;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.getWrappedLineTrimmedLength = n.reflowSmallerGetNewLineLengths = n.reflowLargerApplyNewLayout = n.reflowLargerCreateNewLayout = n.reflowLargerGetLinesToRemove = void 0, n.reflowLargerGetLinesToRemove = function(a, f, m, C, b) {
          const p = [];
          for (let S = 0; S < a.length - 1; S++) {
            let o = S, _ = a.get(++o);
            if (!_.isWrapped)
              continue;
            const u = [a.get(S)];
            for (; o < a.length && _.isWrapped; )
              u.push(_), _ = a.get(++o);
            if (C >= S && C < o) {
              S += u.length - 1;
              continue;
            }
            let d = 0, v = r(u, d, f), w = 1, x = 0;
            for (; w < u.length; ) {
              const y = r(u, w, f), I = y - x, A = m - v, M = Math.min(I, A);
              u[d].copyCellsFrom(u[w], x, v, M, !1), v += M, v === m && (d++, v = 0), x += M, x === y && (w++, x = 0), v === 0 && d !== 0 && u[d - 1].getWidth(m - 1) === 2 && (u[d].copyCellsFrom(u[d - 1], m - 1, v++, 1, !1), u[d - 1].setCell(m - 1, b));
            }
            u[d].replaceCells(v, m, b);
            let k = 0;
            for (let y = u.length - 1; y > 0 && (y > d || u[y].getTrimmedLength() === 0); y--)
              k++;
            k > 0 && (p.push(S + u.length - k), p.push(k)), S += u.length - 1;
          }
          return p;
        }, n.reflowLargerCreateNewLayout = function(a, f) {
          const m = [];
          let C = 0, b = f[C], p = 0;
          for (let S = 0; S < a.length; S++)
            if (b === S) {
              const o = f[++C];
              a.onDeleteEmitter.fire({ index: S - p, amount: o }), S += o - 1, p += o, b = f[++C];
            } else
              m.push(S);
          return { layout: m, countRemoved: p };
        }, n.reflowLargerApplyNewLayout = function(a, f) {
          const m = [];
          for (let C = 0; C < f.length; C++)
            m.push(a.get(f[C]));
          for (let C = 0; C < m.length; C++)
            a.set(C, m[C]);
          a.length = f.length;
        }, n.reflowSmallerGetNewLineLengths = function(a, f, m) {
          const C = [], b = a.map((_, u) => r(a, u, f)).reduce((_, u) => _ + u);
          let p = 0, S = 0, o = 0;
          for (; o < b; ) {
            if (b - o < m) {
              C.push(b - o);
              break;
            }
            p += m;
            const _ = r(a, S, f);
            p > _ && (p -= _, S++);
            const u = a[S].getWidth(p - 1) === 2;
            u && p--;
            const d = u ? m - 1 : m;
            C.push(d), o += d;
          }
          return C;
        }, n.getWrappedLineTrimmedLength = r;
      }, 5295: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.BufferSet = void 0;
        const a = r(9092), f = r(8460), m = r(844);
        class C extends m.Disposable {
          constructor(p, S) {
            super(), this._optionsService = p, this._bufferService = S, this._onBufferActivate = this.register(new f.EventEmitter()), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.resize(this._bufferService.cols, this._bufferService.rows))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", () => this.setupTabStops()));
          }
          reset() {
            this._normal = new a.Buffer(!0, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new a.Buffer(!1, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }), this.setupTabStops();
          }
          get alt() {
            return this._alt;
          }
          get active() {
            return this._activeBuffer;
          }
          get normal() {
            return this._normal;
          }
          activateNormalBuffer() {
            this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }));
          }
          activateAltBuffer(p) {
            this._activeBuffer !== this._alt && (this._alt.fillViewportRows(p), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({ activeBuffer: this._alt, inactiveBuffer: this._normal }));
          }
          resize(p, S) {
            this._normal.resize(p, S), this._alt.resize(p, S), this.setupTabStops(p);
          }
          setupTabStops(p) {
            this._normal.setupTabStops(p), this._alt.setupTabStops(p);
          }
        }
        n.BufferSet = C;
      }, 511: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.CellData = void 0;
        const a = r(482), f = r(643), m = r(3734);
        class C extends m.AttributeData {
          constructor() {
            super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new m.ExtendedAttrs(), this.combinedData = "";
          }
          static fromCharData(p) {
            const S = new C();
            return S.setFromCharData(p), S;
          }
          isCombined() {
            return 2097152 & this.content;
          }
          getWidth() {
            return this.content >> 22;
          }
          getChars() {
            return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, a.stringFromCodePoint)(2097151 & this.content) : "";
          }
          getCode() {
            return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
          }
          setFromCharData(p) {
            this.fg = p[f.CHAR_DATA_ATTR_INDEX], this.bg = 0;
            let S = !1;
            if (p[f.CHAR_DATA_CHAR_INDEX].length > 2)
              S = !0;
            else if (p[f.CHAR_DATA_CHAR_INDEX].length === 2) {
              const o = p[f.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
              if (55296 <= o && o <= 56319) {
                const _ = p[f.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
                56320 <= _ && _ <= 57343 ? this.content = 1024 * (o - 55296) + _ - 56320 + 65536 | p[f.CHAR_DATA_WIDTH_INDEX] << 22 : S = !0;
              } else
                S = !0;
            } else
              this.content = p[f.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | p[f.CHAR_DATA_WIDTH_INDEX] << 22;
            S && (this.combinedData = p[f.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | p[f.CHAR_DATA_WIDTH_INDEX] << 22);
          }
          getAsCharData() {
            return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
          }
        }
        n.CellData = C;
      }, 643: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.WHITESPACE_CELL_CODE = n.WHITESPACE_CELL_WIDTH = n.WHITESPACE_CELL_CHAR = n.NULL_CELL_CODE = n.NULL_CELL_WIDTH = n.NULL_CELL_CHAR = n.CHAR_DATA_CODE_INDEX = n.CHAR_DATA_WIDTH_INDEX = n.CHAR_DATA_CHAR_INDEX = n.CHAR_DATA_ATTR_INDEX = n.DEFAULT_EXT = n.DEFAULT_ATTR = n.DEFAULT_COLOR = void 0, n.DEFAULT_COLOR = 0, n.DEFAULT_ATTR = 256 | n.DEFAULT_COLOR << 9, n.DEFAULT_EXT = 0, n.CHAR_DATA_ATTR_INDEX = 0, n.CHAR_DATA_CHAR_INDEX = 1, n.CHAR_DATA_WIDTH_INDEX = 2, n.CHAR_DATA_CODE_INDEX = 3, n.NULL_CELL_CHAR = "", n.NULL_CELL_WIDTH = 1, n.NULL_CELL_CODE = 0, n.WHITESPACE_CELL_CHAR = " ", n.WHITESPACE_CELL_WIDTH = 1, n.WHITESPACE_CELL_CODE = 32;
      }, 4863: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.Marker = void 0;
        const a = r(8460), f = r(844);
        class m {
          constructor(b) {
            this.line = b, this.isDisposed = !1, this._disposables = [], this._id = m._nextId++, this._onDispose = this.register(new a.EventEmitter()), this.onDispose = this._onDispose.event;
          }
          get id() {
            return this._id;
          }
          dispose() {
            this.isDisposed || (this.isDisposed = !0, this.line = -1, this._onDispose.fire(), (0, f.disposeArray)(this._disposables), this._disposables.length = 0);
          }
          register(b) {
            return this._disposables.push(b), b;
          }
        }
        n.Marker = m, m._nextId = 1;
      }, 7116: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.DEFAULT_CHARSET = n.CHARSETS = void 0, n.CHARSETS = {}, n.DEFAULT_CHARSET = n.CHARSETS.B, n.CHARSETS[0] = { "`": "◆", a: "▒", b: "␉", c: "␌", d: "␍", e: "␊", f: "°", g: "±", h: "␤", i: "␋", j: "┘", k: "┐", l: "┌", m: "└", n: "┼", o: "⎺", p: "⎻", q: "─", r: "⎼", s: "⎽", t: "├", u: "┤", v: "┴", w: "┬", x: "│", y: "≤", z: "≥", "{": "π", "|": "≠", "}": "£", "~": "·" }, n.CHARSETS.A = { "#": "£" }, n.CHARSETS.B = void 0, n.CHARSETS[4] = { "#": "£", "@": "¾", "[": "ij", "\\": "½", "]": "|", "{": "¨", "|": "f", "}": "¼", "~": "´" }, n.CHARSETS.C = n.CHARSETS[5] = { "[": "Ä", "\\": "Ö", "]": "Å", "^": "Ü", "`": "é", "{": "ä", "|": "ö", "}": "å", "~": "ü" }, n.CHARSETS.R = { "#": "£", "@": "à", "[": "°", "\\": "ç", "]": "§", "{": "é", "|": "ù", "}": "è", "~": "¨" }, n.CHARSETS.Q = { "@": "à", "[": "â", "\\": "ç", "]": "ê", "^": "î", "`": "ô", "{": "é", "|": "ù", "}": "è", "~": "û" }, n.CHARSETS.K = { "@": "§", "[": "Ä", "\\": "Ö", "]": "Ü", "{": "ä", "|": "ö", "}": "ü", "~": "ß" }, n.CHARSETS.Y = { "#": "£", "@": "§", "[": "°", "\\": "ç", "]": "é", "`": "ù", "{": "à", "|": "ò", "}": "è", "~": "ì" }, n.CHARSETS.E = n.CHARSETS[6] = { "@": "Ä", "[": "Æ", "\\": "Ø", "]": "Å", "^": "Ü", "`": "ä", "{": "æ", "|": "ø", "}": "å", "~": "ü" }, n.CHARSETS.Z = { "#": "£", "@": "§", "[": "¡", "\\": "Ñ", "]": "¿", "{": "°", "|": "ñ", "}": "ç" }, n.CHARSETS.H = n.CHARSETS[7] = { "@": "É", "[": "Ä", "\\": "Ö", "]": "Å", "^": "Ü", "`": "é", "{": "ä", "|": "ö", "}": "å", "~": "ü" }, n.CHARSETS["="] = { "#": "ù", "@": "à", "[": "é", "\\": "ç", "]": "ê", "^": "î", _: "è", "`": "ô", "{": "ä", "|": "ö", "}": "ü", "~": "û" };
      }, 2584: (l, n) => {
        var r, a;
        Object.defineProperty(n, "__esModule", { value: !0 }), n.C1_ESCAPED = n.C1 = n.C0 = void 0, function(f) {
          f.NUL = "\0", f.SOH = "", f.STX = "", f.ETX = "", f.EOT = "", f.ENQ = "", f.ACK = "", f.BEL = "\x07", f.BS = "\b", f.HT = "	", f.LF = `
`, f.VT = "\v", f.FF = "\f", f.CR = "\r", f.SO = "", f.SI = "", f.DLE = "", f.DC1 = "", f.DC2 = "", f.DC3 = "", f.DC4 = "", f.NAK = "", f.SYN = "", f.ETB = "", f.CAN = "", f.EM = "", f.SUB = "", f.ESC = "\x1B", f.FS = "", f.GS = "", f.RS = "", f.US = "", f.SP = " ", f.DEL = "";
        }(r = n.C0 || (n.C0 = {})), (a = n.C1 || (n.C1 = {})).PAD = "", a.HOP = "", a.BPH = "", a.NBH = "", a.IND = "", a.NEL = "", a.SSA = "", a.ESA = "", a.HTS = "", a.HTJ = "", a.VTS = "", a.PLD = "", a.PLU = "", a.RI = "", a.SS2 = "", a.SS3 = "", a.DCS = "", a.PU1 = "", a.PU2 = "", a.STS = "", a.CCH = "", a.MW = "", a.SPA = "", a.EPA = "", a.SOS = "", a.SGCI = "", a.SCI = "", a.CSI = "", a.ST = "", a.OSC = "", a.PM = "", a.APC = "", (n.C1_ESCAPED || (n.C1_ESCAPED = {})).ST = `${r.ESC}\\`;
      }, 7399: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.evaluateKeyboardEvent = void 0;
        const a = r(2584), f = { 48: ["0", ")"], 49: ["1", "!"], 50: ["2", "@"], 51: ["3", "#"], 52: ["4", "$"], 53: ["5", "%"], 54: ["6", "^"], 55: ["7", "&"], 56: ["8", "*"], 57: ["9", "("], 186: [";", ":"], 187: ["=", "+"], 188: [",", "<"], 189: ["-", "_"], 190: [".", ">"], 191: ["/", "?"], 192: ["`", "~"], 219: ["[", "{"], 220: ["\\", "|"], 221: ["]", "}"], 222: ["'", '"'] };
        n.evaluateKeyboardEvent = function(m, C, b, p) {
          const S = { type: 0, cancel: !1, key: void 0 }, o = (m.shiftKey ? 1 : 0) | (m.altKey ? 2 : 0) | (m.ctrlKey ? 4 : 0) | (m.metaKey ? 8 : 0);
          switch (m.keyCode) {
            case 0:
              m.key === "UIKeyInputUpArrow" ? S.key = C ? a.C0.ESC + "OA" : a.C0.ESC + "[A" : m.key === "UIKeyInputLeftArrow" ? S.key = C ? a.C0.ESC + "OD" : a.C0.ESC + "[D" : m.key === "UIKeyInputRightArrow" ? S.key = C ? a.C0.ESC + "OC" : a.C0.ESC + "[C" : m.key === "UIKeyInputDownArrow" && (S.key = C ? a.C0.ESC + "OB" : a.C0.ESC + "[B");
              break;
            case 8:
              if (m.altKey) {
                S.key = a.C0.ESC + a.C0.DEL;
                break;
              }
              S.key = a.C0.DEL;
              break;
            case 9:
              if (m.shiftKey) {
                S.key = a.C0.ESC + "[Z";
                break;
              }
              S.key = a.C0.HT, S.cancel = !0;
              break;
            case 13:
              S.key = m.altKey ? a.C0.ESC + a.C0.CR : a.C0.CR, S.cancel = !0;
              break;
            case 27:
              S.key = a.C0.ESC, m.altKey && (S.key = a.C0.ESC + a.C0.ESC), S.cancel = !0;
              break;
            case 37:
              if (m.metaKey)
                break;
              o ? (S.key = a.C0.ESC + "[1;" + (o + 1) + "D", S.key === a.C0.ESC + "[1;3D" && (S.key = a.C0.ESC + (b ? "b" : "[1;5D"))) : S.key = C ? a.C0.ESC + "OD" : a.C0.ESC + "[D";
              break;
            case 39:
              if (m.metaKey)
                break;
              o ? (S.key = a.C0.ESC + "[1;" + (o + 1) + "C", S.key === a.C0.ESC + "[1;3C" && (S.key = a.C0.ESC + (b ? "f" : "[1;5C"))) : S.key = C ? a.C0.ESC + "OC" : a.C0.ESC + "[C";
              break;
            case 38:
              if (m.metaKey)
                break;
              o ? (S.key = a.C0.ESC + "[1;" + (o + 1) + "A", b || S.key !== a.C0.ESC + "[1;3A" || (S.key = a.C0.ESC + "[1;5A")) : S.key = C ? a.C0.ESC + "OA" : a.C0.ESC + "[A";
              break;
            case 40:
              if (m.metaKey)
                break;
              o ? (S.key = a.C0.ESC + "[1;" + (o + 1) + "B", b || S.key !== a.C0.ESC + "[1;3B" || (S.key = a.C0.ESC + "[1;5B")) : S.key = C ? a.C0.ESC + "OB" : a.C0.ESC + "[B";
              break;
            case 45:
              m.shiftKey || m.ctrlKey || (S.key = a.C0.ESC + "[2~");
              break;
            case 46:
              S.key = o ? a.C0.ESC + "[3;" + (o + 1) + "~" : a.C0.ESC + "[3~";
              break;
            case 36:
              S.key = o ? a.C0.ESC + "[1;" + (o + 1) + "H" : C ? a.C0.ESC + "OH" : a.C0.ESC + "[H";
              break;
            case 35:
              S.key = o ? a.C0.ESC + "[1;" + (o + 1) + "F" : C ? a.C0.ESC + "OF" : a.C0.ESC + "[F";
              break;
            case 33:
              m.shiftKey ? S.type = 2 : m.ctrlKey ? S.key = a.C0.ESC + "[5;" + (o + 1) + "~" : S.key = a.C0.ESC + "[5~";
              break;
            case 34:
              m.shiftKey ? S.type = 3 : m.ctrlKey ? S.key = a.C0.ESC + "[6;" + (o + 1) + "~" : S.key = a.C0.ESC + "[6~";
              break;
            case 112:
              S.key = o ? a.C0.ESC + "[1;" + (o + 1) + "P" : a.C0.ESC + "OP";
              break;
            case 113:
              S.key = o ? a.C0.ESC + "[1;" + (o + 1) + "Q" : a.C0.ESC + "OQ";
              break;
            case 114:
              S.key = o ? a.C0.ESC + "[1;" + (o + 1) + "R" : a.C0.ESC + "OR";
              break;
            case 115:
              S.key = o ? a.C0.ESC + "[1;" + (o + 1) + "S" : a.C0.ESC + "OS";
              break;
            case 116:
              S.key = o ? a.C0.ESC + "[15;" + (o + 1) + "~" : a.C0.ESC + "[15~";
              break;
            case 117:
              S.key = o ? a.C0.ESC + "[17;" + (o + 1) + "~" : a.C0.ESC + "[17~";
              break;
            case 118:
              S.key = o ? a.C0.ESC + "[18;" + (o + 1) + "~" : a.C0.ESC + "[18~";
              break;
            case 119:
              S.key = o ? a.C0.ESC + "[19;" + (o + 1) + "~" : a.C0.ESC + "[19~";
              break;
            case 120:
              S.key = o ? a.C0.ESC + "[20;" + (o + 1) + "~" : a.C0.ESC + "[20~";
              break;
            case 121:
              S.key = o ? a.C0.ESC + "[21;" + (o + 1) + "~" : a.C0.ESC + "[21~";
              break;
            case 122:
              S.key = o ? a.C0.ESC + "[23;" + (o + 1) + "~" : a.C0.ESC + "[23~";
              break;
            case 123:
              S.key = o ? a.C0.ESC + "[24;" + (o + 1) + "~" : a.C0.ESC + "[24~";
              break;
            default:
              if (!m.ctrlKey || m.shiftKey || m.altKey || m.metaKey)
                if (b && !p || !m.altKey || m.metaKey)
                  !b || m.altKey || m.ctrlKey || m.shiftKey || !m.metaKey ? m.key && !m.ctrlKey && !m.altKey && !m.metaKey && m.keyCode >= 48 && m.key.length === 1 ? S.key = m.key : m.key && m.ctrlKey && (m.key === "_" && (S.key = a.C0.US), m.key === "@" && (S.key = a.C0.NUL)) : m.keyCode === 65 && (S.type = 1);
                else {
                  const _ = f[m.keyCode], u = _ == null ? void 0 : _[m.shiftKey ? 1 : 0];
                  if (u)
                    S.key = a.C0.ESC + u;
                  else if (m.keyCode >= 65 && m.keyCode <= 90) {
                    const d = m.ctrlKey ? m.keyCode - 64 : m.keyCode + 32;
                    let v = String.fromCharCode(d);
                    m.shiftKey && (v = v.toUpperCase()), S.key = a.C0.ESC + v;
                  } else if (m.keyCode === 32)
                    S.key = a.C0.ESC + (m.ctrlKey ? a.C0.NUL : " ");
                  else if (m.key === "Dead" && m.code.startsWith("Key")) {
                    let d = m.code.slice(3, 4);
                    m.shiftKey || (d = d.toLowerCase()), S.key = a.C0.ESC + d, S.cancel = !0;
                  }
                }
              else
                m.keyCode >= 65 && m.keyCode <= 90 ? S.key = String.fromCharCode(m.keyCode - 64) : m.keyCode === 32 ? S.key = a.C0.NUL : m.keyCode >= 51 && m.keyCode <= 55 ? S.key = String.fromCharCode(m.keyCode - 51 + 27) : m.keyCode === 56 ? S.key = a.C0.DEL : m.keyCode === 219 ? S.key = a.C0.ESC : m.keyCode === 220 ? S.key = a.C0.FS : m.keyCode === 221 && (S.key = a.C0.GS);
          }
          return S;
        };
      }, 482: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.Utf8ToUtf32 = n.StringToUtf32 = n.utf32ToString = n.stringFromCodePoint = void 0, n.stringFromCodePoint = function(r) {
          return r > 65535 ? (r -= 65536, String.fromCharCode(55296 + (r >> 10)) + String.fromCharCode(r % 1024 + 56320)) : String.fromCharCode(r);
        }, n.utf32ToString = function(r, a = 0, f = r.length) {
          let m = "";
          for (let C = a; C < f; ++C) {
            let b = r[C];
            b > 65535 ? (b -= 65536, m += String.fromCharCode(55296 + (b >> 10)) + String.fromCharCode(b % 1024 + 56320)) : m += String.fromCharCode(b);
          }
          return m;
        }, n.StringToUtf32 = class {
          constructor() {
            this._interim = 0;
          }
          clear() {
            this._interim = 0;
          }
          decode(r, a) {
            const f = r.length;
            if (!f)
              return 0;
            let m = 0, C = 0;
            if (this._interim) {
              const b = r.charCodeAt(C++);
              56320 <= b && b <= 57343 ? a[m++] = 1024 * (this._interim - 55296) + b - 56320 + 65536 : (a[m++] = this._interim, a[m++] = b), this._interim = 0;
            }
            for (let b = C; b < f; ++b) {
              const p = r.charCodeAt(b);
              if (55296 <= p && p <= 56319) {
                if (++b >= f)
                  return this._interim = p, m;
                const S = r.charCodeAt(b);
                56320 <= S && S <= 57343 ? a[m++] = 1024 * (p - 55296) + S - 56320 + 65536 : (a[m++] = p, a[m++] = S);
              } else
                p !== 65279 && (a[m++] = p);
            }
            return m;
          }
        }, n.Utf8ToUtf32 = class {
          constructor() {
            this.interim = new Uint8Array(3);
          }
          clear() {
            this.interim.fill(0);
          }
          decode(r, a) {
            const f = r.length;
            if (!f)
              return 0;
            let m, C, b, p, S = 0, o = 0, _ = 0;
            if (this.interim[0]) {
              let v = !1, w = this.interim[0];
              w &= (224 & w) == 192 ? 31 : (240 & w) == 224 ? 15 : 7;
              let x, k = 0;
              for (; (x = 63 & this.interim[++k]) && k < 4; )
                w <<= 6, w |= x;
              const y = (224 & this.interim[0]) == 192 ? 2 : (240 & this.interim[0]) == 224 ? 3 : 4, I = y - k;
              for (; _ < I; ) {
                if (_ >= f)
                  return 0;
                if (x = r[_++], (192 & x) != 128) {
                  _--, v = !0;
                  break;
                }
                this.interim[k++] = x, w <<= 6, w |= 63 & x;
              }
              v || (y === 2 ? w < 128 ? _-- : a[S++] = w : y === 3 ? w < 2048 || w >= 55296 && w <= 57343 || w === 65279 || (a[S++] = w) : w < 65536 || w > 1114111 || (a[S++] = w)), this.interim.fill(0);
            }
            const u = f - 4;
            let d = _;
            for (; d < f; ) {
              for (; !(!(d < u) || 128 & (m = r[d]) || 128 & (C = r[d + 1]) || 128 & (b = r[d + 2]) || 128 & (p = r[d + 3])); )
                a[S++] = m, a[S++] = C, a[S++] = b, a[S++] = p, d += 4;
              if (m = r[d++], m < 128)
                a[S++] = m;
              else if ((224 & m) == 192) {
                if (d >= f)
                  return this.interim[0] = m, S;
                if (C = r[d++], (192 & C) != 128) {
                  d--;
                  continue;
                }
                if (o = (31 & m) << 6 | 63 & C, o < 128) {
                  d--;
                  continue;
                }
                a[S++] = o;
              } else if ((240 & m) == 224) {
                if (d >= f)
                  return this.interim[0] = m, S;
                if (C = r[d++], (192 & C) != 128) {
                  d--;
                  continue;
                }
                if (d >= f)
                  return this.interim[0] = m, this.interim[1] = C, S;
                if (b = r[d++], (192 & b) != 128) {
                  d--;
                  continue;
                }
                if (o = (15 & m) << 12 | (63 & C) << 6 | 63 & b, o < 2048 || o >= 55296 && o <= 57343 || o === 65279)
                  continue;
                a[S++] = o;
              } else if ((248 & m) == 240) {
                if (d >= f)
                  return this.interim[0] = m, S;
                if (C = r[d++], (192 & C) != 128) {
                  d--;
                  continue;
                }
                if (d >= f)
                  return this.interim[0] = m, this.interim[1] = C, S;
                if (b = r[d++], (192 & b) != 128) {
                  d--;
                  continue;
                }
                if (d >= f)
                  return this.interim[0] = m, this.interim[1] = C, this.interim[2] = b, S;
                if (p = r[d++], (192 & p) != 128) {
                  d--;
                  continue;
                }
                if (o = (7 & m) << 18 | (63 & C) << 12 | (63 & b) << 6 | 63 & p, o < 65536 || o > 1114111)
                  continue;
                a[S++] = o;
              }
            }
            return S;
          }
        };
      }, 225: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.UnicodeV6 = void 0;
        const r = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]], a = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]];
        let f;
        n.UnicodeV6 = class {
          constructor() {
            if (this.version = "6", !f) {
              f = new Uint8Array(65536), f.fill(1), f[0] = 0, f.fill(0, 1, 32), f.fill(0, 127, 160), f.fill(2, 4352, 4448), f[9001] = 2, f[9002] = 2, f.fill(2, 11904, 42192), f[12351] = 1, f.fill(2, 44032, 55204), f.fill(2, 63744, 64256), f.fill(2, 65040, 65050), f.fill(2, 65072, 65136), f.fill(2, 65280, 65377), f.fill(2, 65504, 65511);
              for (let m = 0; m < r.length; ++m)
                f.fill(0, r[m][0], r[m][1] + 1);
            }
          }
          wcwidth(m) {
            return m < 32 ? 0 : m < 127 ? 1 : m < 65536 ? f[m] : function(C, b) {
              let p, S = 0, o = b.length - 1;
              if (C < b[0][0] || C > b[o][1])
                return !1;
              for (; o >= S; )
                if (p = S + o >> 1, C > b[p][1])
                  S = p + 1;
                else {
                  if (!(C < b[p][0]))
                    return !0;
                  o = p - 1;
                }
              return !1;
            }(m, a) ? 0 : m >= 131072 && m <= 196605 || m >= 196608 && m <= 262141 ? 2 : 1;
          }
        };
      }, 5981: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.WriteBuffer = void 0;
        const a = r(8460), f = r(844);
        class m extends f.Disposable {
          constructor(b) {
            super(), this._action = b, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = !1, this._syncCalls = 0, this._didUserInput = !1, this._onWriteParsed = this.register(new a.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event;
          }
          handleUserInput() {
            this._didUserInput = !0;
          }
          writeSync(b, p) {
            if (p !== void 0 && this._syncCalls > p)
              return void (this._syncCalls = 0);
            if (this._pendingData += b.length, this._writeBuffer.push(b), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting)
              return;
            let S;
            for (this._isSyncWriting = !0; S = this._writeBuffer.shift(); ) {
              this._action(S);
              const o = this._callbacks.shift();
              o && o();
            }
            this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = !1, this._syncCalls = 0;
          }
          write(b, p) {
            if (this._pendingData > 5e7)
              throw new Error("write data discarded, use flow control to avoid losing data");
            if (!this._writeBuffer.length) {
              if (this._bufferOffset = 0, this._didUserInput)
                return this._didUserInput = !1, this._pendingData += b.length, this._writeBuffer.push(b), this._callbacks.push(p), void this._innerWrite();
              setTimeout(() => this._innerWrite());
            }
            this._pendingData += b.length, this._writeBuffer.push(b), this._callbacks.push(p);
          }
          _innerWrite(b = 0, p = !0) {
            const S = b || Date.now();
            for (; this._writeBuffer.length > this._bufferOffset; ) {
              const o = this._writeBuffer[this._bufferOffset], _ = this._action(o, p);
              if (_) {
                const d = (v) => Date.now() - S >= 12 ? setTimeout(() => this._innerWrite(0, v)) : this._innerWrite(S, v);
                return void _.catch((v) => (queueMicrotask(() => {
                  throw v;
                }), Promise.resolve(!1))).then(d);
              }
              const u = this._callbacks[this._bufferOffset];
              if (u && u(), this._bufferOffset++, this._pendingData -= o.length, Date.now() - S >= 12)
                break;
            }
            this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(() => this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
          }
        }
        n.WriteBuffer = m;
      }, 5941: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.toRgbString = n.parseColor = void 0;
        const r = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, a = /^[\da-f]+$/;
        function f(m, C) {
          const b = m.toString(16), p = b.length < 2 ? "0" + b : b;
          switch (C) {
            case 4:
              return b[0];
            case 8:
              return p;
            case 12:
              return (p + p).slice(0, 3);
            default:
              return p + p;
          }
        }
        n.parseColor = function(m) {
          if (!m)
            return;
          let C = m.toLowerCase();
          if (C.indexOf("rgb:") === 0) {
            C = C.slice(4);
            const b = r.exec(C);
            if (b) {
              const p = b[1] ? 15 : b[4] ? 255 : b[7] ? 4095 : 65535;
              return [Math.round(parseInt(b[1] || b[4] || b[7] || b[10], 16) / p * 255), Math.round(parseInt(b[2] || b[5] || b[8] || b[11], 16) / p * 255), Math.round(parseInt(b[3] || b[6] || b[9] || b[12], 16) / p * 255)];
            }
          } else if (C.indexOf("#") === 0 && (C = C.slice(1), a.exec(C) && [3, 6, 9, 12].includes(C.length))) {
            const b = C.length / 3, p = [0, 0, 0];
            for (let S = 0; S < 3; ++S) {
              const o = parseInt(C.slice(b * S, b * S + b), 16);
              p[S] = b === 1 ? o << 4 : b === 2 ? o : b === 3 ? o >> 4 : o >> 8;
            }
            return p;
          }
        }, n.toRgbString = function(m, C = 16) {
          const [b, p, S] = m;
          return `rgb:${f(b, C)}/${f(p, C)}/${f(S, C)}`;
        };
      }, 5770: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.PAYLOAD_LIMIT = void 0, n.PAYLOAD_LIMIT = 1e7;
      }, 6351: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.DcsHandler = n.DcsParser = void 0;
        const a = r(482), f = r(8742), m = r(5770), C = [];
        n.DcsParser = class {
          constructor() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._active = C, this._ident = 0, this._handlerFb = () => {
            }, this._stack = { paused: !1, loopPosition: 0, fallThrough: !1 };
          }
          dispose() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._active = C;
          }
          registerHandler(p, S) {
            this._handlers[p] === void 0 && (this._handlers[p] = []);
            const o = this._handlers[p];
            return o.push(S), { dispose: () => {
              const _ = o.indexOf(S);
              _ !== -1 && o.splice(_, 1);
            } };
          }
          clearHandler(p) {
            this._handlers[p] && delete this._handlers[p];
          }
          setHandlerFallback(p) {
            this._handlerFb = p;
          }
          reset() {
            if (this._active.length)
              for (let p = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; p >= 0; --p)
                this._active[p].unhook(!1);
            this._stack.paused = !1, this._active = C, this._ident = 0;
          }
          hook(p, S) {
            if (this.reset(), this._ident = p, this._active = this._handlers[p] || C, this._active.length)
              for (let o = this._active.length - 1; o >= 0; o--)
                this._active[o].hook(S);
            else
              this._handlerFb(this._ident, "HOOK", S);
          }
          put(p, S, o) {
            if (this._active.length)
              for (let _ = this._active.length - 1; _ >= 0; _--)
                this._active[_].put(p, S, o);
            else
              this._handlerFb(this._ident, "PUT", (0, a.utf32ToString)(p, S, o));
          }
          unhook(p, S = !0) {
            if (this._active.length) {
              let o = !1, _ = this._active.length - 1, u = !1;
              if (this._stack.paused && (_ = this._stack.loopPosition - 1, o = S, u = this._stack.fallThrough, this._stack.paused = !1), !u && o === !1) {
                for (; _ >= 0 && (o = this._active[_].unhook(p), o !== !0); _--)
                  if (o instanceof Promise)
                    return this._stack.paused = !0, this._stack.loopPosition = _, this._stack.fallThrough = !1, o;
                _--;
              }
              for (; _ >= 0; _--)
                if (o = this._active[_].unhook(!1), o instanceof Promise)
                  return this._stack.paused = !0, this._stack.loopPosition = _, this._stack.fallThrough = !0, o;
            } else
              this._handlerFb(this._ident, "UNHOOK", p);
            this._active = C, this._ident = 0;
          }
        };
        const b = new f.Params();
        b.addParam(0), n.DcsHandler = class {
          constructor(p) {
            this._handler = p, this._data = "", this._params = b, this._hitLimit = !1;
          }
          hook(p) {
            this._params = p.length > 1 || p.params[0] ? p.clone() : b, this._data = "", this._hitLimit = !1;
          }
          put(p, S, o) {
            this._hitLimit || (this._data += (0, a.utf32ToString)(p, S, o), this._data.length > m.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0));
          }
          unhook(p) {
            let S = !1;
            if (this._hitLimit)
              S = !1;
            else if (p && (S = this._handler(this._data, this._params), S instanceof Promise))
              return S.then((o) => (this._params = b, this._data = "", this._hitLimit = !1, o));
            return this._params = b, this._data = "", this._hitLimit = !1, S;
          }
        };
      }, 2015: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.EscapeSequenceParser = n.VT500_TRANSITION_TABLE = n.TransitionTable = void 0;
        const a = r(844), f = r(8742), m = r(6242), C = r(6351);
        class b {
          constructor(_) {
            this.table = new Uint8Array(_);
          }
          setDefault(_, u) {
            this.table.fill(_ << 4 | u);
          }
          add(_, u, d, v) {
            this.table[u << 8 | _] = d << 4 | v;
          }
          addMany(_, u, d, v) {
            for (let w = 0; w < _.length; w++)
              this.table[u << 8 | _[w]] = d << 4 | v;
          }
        }
        n.TransitionTable = b;
        const p = 160;
        n.VT500_TRANSITION_TABLE = function() {
          const o = new b(4095), _ = Array.apply(null, Array(256)).map((k, y) => y), u = (k, y) => _.slice(k, y), d = u(32, 127), v = u(0, 24);
          v.push(25), v.push.apply(v, u(28, 32));
          const w = u(0, 14);
          let x;
          for (x in o.setDefault(1, 0), o.addMany(d, 0, 2, 0), w)
            o.addMany([24, 26, 153, 154], x, 3, 0), o.addMany(u(128, 144), x, 3, 0), o.addMany(u(144, 152), x, 3, 0), o.add(156, x, 0, 0), o.add(27, x, 11, 1), o.add(157, x, 4, 8), o.addMany([152, 158, 159], x, 0, 7), o.add(155, x, 11, 3), o.add(144, x, 11, 9);
          return o.addMany(v, 0, 3, 0), o.addMany(v, 1, 3, 1), o.add(127, 1, 0, 1), o.addMany(v, 8, 0, 8), o.addMany(v, 3, 3, 3), o.add(127, 3, 0, 3), o.addMany(v, 4, 3, 4), o.add(127, 4, 0, 4), o.addMany(v, 6, 3, 6), o.addMany(v, 5, 3, 5), o.add(127, 5, 0, 5), o.addMany(v, 2, 3, 2), o.add(127, 2, 0, 2), o.add(93, 1, 4, 8), o.addMany(d, 8, 5, 8), o.add(127, 8, 5, 8), o.addMany([156, 27, 24, 26, 7], 8, 6, 0), o.addMany(u(28, 32), 8, 0, 8), o.addMany([88, 94, 95], 1, 0, 7), o.addMany(d, 7, 0, 7), o.addMany(v, 7, 0, 7), o.add(156, 7, 0, 0), o.add(127, 7, 0, 7), o.add(91, 1, 11, 3), o.addMany(u(64, 127), 3, 7, 0), o.addMany(u(48, 60), 3, 8, 4), o.addMany([60, 61, 62, 63], 3, 9, 4), o.addMany(u(48, 60), 4, 8, 4), o.addMany(u(64, 127), 4, 7, 0), o.addMany([60, 61, 62, 63], 4, 0, 6), o.addMany(u(32, 64), 6, 0, 6), o.add(127, 6, 0, 6), o.addMany(u(64, 127), 6, 0, 0), o.addMany(u(32, 48), 3, 9, 5), o.addMany(u(32, 48), 5, 9, 5), o.addMany(u(48, 64), 5, 0, 6), o.addMany(u(64, 127), 5, 7, 0), o.addMany(u(32, 48), 4, 9, 5), o.addMany(u(32, 48), 1, 9, 2), o.addMany(u(32, 48), 2, 9, 2), o.addMany(u(48, 127), 2, 10, 0), o.addMany(u(48, 80), 1, 10, 0), o.addMany(u(81, 88), 1, 10, 0), o.addMany([89, 90, 92], 1, 10, 0), o.addMany(u(96, 127), 1, 10, 0), o.add(80, 1, 11, 9), o.addMany(v, 9, 0, 9), o.add(127, 9, 0, 9), o.addMany(u(28, 32), 9, 0, 9), o.addMany(u(32, 48), 9, 9, 12), o.addMany(u(48, 60), 9, 8, 10), o.addMany([60, 61, 62, 63], 9, 9, 10), o.addMany(v, 11, 0, 11), o.addMany(u(32, 128), 11, 0, 11), o.addMany(u(28, 32), 11, 0, 11), o.addMany(v, 10, 0, 10), o.add(127, 10, 0, 10), o.addMany(u(28, 32), 10, 0, 10), o.addMany(u(48, 60), 10, 8, 10), o.addMany([60, 61, 62, 63], 10, 0, 11), o.addMany(u(32, 48), 10, 9, 12), o.addMany(v, 12, 0, 12), o.add(127, 12, 0, 12), o.addMany(u(28, 32), 12, 0, 12), o.addMany(u(32, 48), 12, 9, 12), o.addMany(u(48, 64), 12, 0, 11), o.addMany(u(64, 127), 12, 12, 13), o.addMany(u(64, 127), 10, 12, 13), o.addMany(u(64, 127), 9, 12, 13), o.addMany(v, 13, 13, 13), o.addMany(d, 13, 13, 13), o.add(127, 13, 0, 13), o.addMany([27, 156, 24, 26], 13, 14, 0), o.add(p, 0, 2, 0), o.add(p, 8, 5, 8), o.add(p, 6, 0, 6), o.add(p, 11, 0, 11), o.add(p, 13, 13, 13), o;
        }();
        class S extends a.Disposable {
          constructor(_ = n.VT500_TRANSITION_TABLE) {
            super(), this._transitions = _, this._parseStack = { state: 0, handlers: [], handlerPos: 0, transition: 0, chunkPos: 0 }, this.initialState = 0, this.currentState = this.initialState, this._params = new f.Params(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._printHandlerFb = (u, d, v) => {
            }, this._executeHandlerFb = (u) => {
            }, this._csiHandlerFb = (u, d) => {
            }, this._escHandlerFb = (u) => {
            }, this._errorHandlerFb = (u) => u, this._printHandler = this._printHandlerFb, this._executeHandlers = /* @__PURE__ */ Object.create(null), this._csiHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null), this.register((0, a.toDisposable)(() => {
              this._csiHandlers = /* @__PURE__ */ Object.create(null), this._executeHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null);
            })), this._oscParser = this.register(new m.OscParser()), this._dcsParser = this.register(new C.DcsParser()), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({ final: "\\" }, () => !0);
          }
          _identifier(_, u = [64, 126]) {
            let d = 0;
            if (_.prefix) {
              if (_.prefix.length > 1)
                throw new Error("only one byte as prefix supported");
              if (d = _.prefix.charCodeAt(0), d && 60 > d || d > 63)
                throw new Error("prefix must be in range 0x3c .. 0x3f");
            }
            if (_.intermediates) {
              if (_.intermediates.length > 2)
                throw new Error("only two bytes as intermediates are supported");
              for (let w = 0; w < _.intermediates.length; ++w) {
                const x = _.intermediates.charCodeAt(w);
                if (32 > x || x > 47)
                  throw new Error("intermediate must be in range 0x20 .. 0x2f");
                d <<= 8, d |= x;
              }
            }
            if (_.final.length !== 1)
              throw new Error("final must be a single byte");
            const v = _.final.charCodeAt(0);
            if (u[0] > v || v > u[1])
              throw new Error(`final must be in range ${u[0]} .. ${u[1]}`);
            return d <<= 8, d |= v, d;
          }
          identToString(_) {
            const u = [];
            for (; _; )
              u.push(String.fromCharCode(255 & _)), _ >>= 8;
            return u.reverse().join("");
          }
          setPrintHandler(_) {
            this._printHandler = _;
          }
          clearPrintHandler() {
            this._printHandler = this._printHandlerFb;
          }
          registerEscHandler(_, u) {
            const d = this._identifier(_, [48, 126]);
            this._escHandlers[d] === void 0 && (this._escHandlers[d] = []);
            const v = this._escHandlers[d];
            return v.push(u), { dispose: () => {
              const w = v.indexOf(u);
              w !== -1 && v.splice(w, 1);
            } };
          }
          clearEscHandler(_) {
            this._escHandlers[this._identifier(_, [48, 126])] && delete this._escHandlers[this._identifier(_, [48, 126])];
          }
          setEscHandlerFallback(_) {
            this._escHandlerFb = _;
          }
          setExecuteHandler(_, u) {
            this._executeHandlers[_.charCodeAt(0)] = u;
          }
          clearExecuteHandler(_) {
            this._executeHandlers[_.charCodeAt(0)] && delete this._executeHandlers[_.charCodeAt(0)];
          }
          setExecuteHandlerFallback(_) {
            this._executeHandlerFb = _;
          }
          registerCsiHandler(_, u) {
            const d = this._identifier(_);
            this._csiHandlers[d] === void 0 && (this._csiHandlers[d] = []);
            const v = this._csiHandlers[d];
            return v.push(u), { dispose: () => {
              const w = v.indexOf(u);
              w !== -1 && v.splice(w, 1);
            } };
          }
          clearCsiHandler(_) {
            this._csiHandlers[this._identifier(_)] && delete this._csiHandlers[this._identifier(_)];
          }
          setCsiHandlerFallback(_) {
            this._csiHandlerFb = _;
          }
          registerDcsHandler(_, u) {
            return this._dcsParser.registerHandler(this._identifier(_), u);
          }
          clearDcsHandler(_) {
            this._dcsParser.clearHandler(this._identifier(_));
          }
          setDcsHandlerFallback(_) {
            this._dcsParser.setHandlerFallback(_);
          }
          registerOscHandler(_, u) {
            return this._oscParser.registerHandler(_, u);
          }
          clearOscHandler(_) {
            this._oscParser.clearHandler(_);
          }
          setOscHandlerFallback(_) {
            this._oscParser.setHandlerFallback(_);
          }
          setErrorHandler(_) {
            this._errorHandler = _;
          }
          clearErrorHandler() {
            this._errorHandler = this._errorHandlerFb;
          }
          reset() {
            this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._parseStack.state !== 0 && (this._parseStack.state = 2, this._parseStack.handlers = []);
          }
          _preserveStack(_, u, d, v, w) {
            this._parseStack.state = _, this._parseStack.handlers = u, this._parseStack.handlerPos = d, this._parseStack.transition = v, this._parseStack.chunkPos = w;
          }
          parse(_, u, d) {
            let v, w = 0, x = 0, k = 0;
            if (this._parseStack.state)
              if (this._parseStack.state === 2)
                this._parseStack.state = 0, k = this._parseStack.chunkPos + 1;
              else {
                if (d === void 0 || this._parseStack.state === 1)
                  throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
                const y = this._parseStack.handlers;
                let I = this._parseStack.handlerPos - 1;
                switch (this._parseStack.state) {
                  case 3:
                    if (d === !1 && I > -1) {
                      for (; I >= 0 && (v = y[I](this._params), v !== !0); I--)
                        if (v instanceof Promise)
                          return this._parseStack.handlerPos = I, v;
                    }
                    this._parseStack.handlers = [];
                    break;
                  case 4:
                    if (d === !1 && I > -1) {
                      for (; I >= 0 && (v = y[I](), v !== !0); I--)
                        if (v instanceof Promise)
                          return this._parseStack.handlerPos = I, v;
                    }
                    this._parseStack.handlers = [];
                    break;
                  case 6:
                    if (w = _[this._parseStack.chunkPos], v = this._dcsParser.unhook(w !== 24 && w !== 26, d), v)
                      return v;
                    w === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                    break;
                  case 5:
                    if (w = _[this._parseStack.chunkPos], v = this._oscParser.end(w !== 24 && w !== 26, d), v)
                      return v;
                    w === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                }
                this._parseStack.state = 0, k = this._parseStack.chunkPos + 1, this.precedingCodepoint = 0, this.currentState = 15 & this._parseStack.transition;
              }
            for (let y = k; y < u; ++y) {
              switch (w = _[y], x = this._transitions.table[this.currentState << 8 | (w < 160 ? w : p)], x >> 4) {
                case 2:
                  for (let O = y + 1; ; ++O) {
                    if (O >= u || (w = _[O]) < 32 || w > 126 && w < p) {
                      this._printHandler(_, y, O), y = O - 1;
                      break;
                    }
                    if (++O >= u || (w = _[O]) < 32 || w > 126 && w < p) {
                      this._printHandler(_, y, O), y = O - 1;
                      break;
                    }
                    if (++O >= u || (w = _[O]) < 32 || w > 126 && w < p) {
                      this._printHandler(_, y, O), y = O - 1;
                      break;
                    }
                    if (++O >= u || (w = _[O]) < 32 || w > 126 && w < p) {
                      this._printHandler(_, y, O), y = O - 1;
                      break;
                    }
                  }
                  break;
                case 3:
                  this._executeHandlers[w] ? this._executeHandlers[w]() : this._executeHandlerFb(w), this.precedingCodepoint = 0;
                  break;
                case 0:
                  break;
                case 1:
                  if (this._errorHandler({ position: y, code: w, currentState: this.currentState, collect: this._collect, params: this._params, abort: !1 }).abort)
                    return;
                  break;
                case 7:
                  const I = this._csiHandlers[this._collect << 8 | w];
                  let A = I ? I.length - 1 : -1;
                  for (; A >= 0 && (v = I[A](this._params), v !== !0); A--)
                    if (v instanceof Promise)
                      return this._preserveStack(3, I, A, x, y), v;
                  A < 0 && this._csiHandlerFb(this._collect << 8 | w, this._params), this.precedingCodepoint = 0;
                  break;
                case 8:
                  do
                    switch (w) {
                      case 59:
                        this._params.addParam(0);
                        break;
                      case 58:
                        this._params.addSubParam(-1);
                        break;
                      default:
                        this._params.addDigit(w - 48);
                    }
                  while (++y < u && (w = _[y]) > 47 && w < 60);
                  y--;
                  break;
                case 9:
                  this._collect <<= 8, this._collect |= w;
                  break;
                case 10:
                  const M = this._escHandlers[this._collect << 8 | w];
                  let L = M ? M.length - 1 : -1;
                  for (; L >= 0 && (v = M[L](), v !== !0); L--)
                    if (v instanceof Promise)
                      return this._preserveStack(4, M, L, x, y), v;
                  L < 0 && this._escHandlerFb(this._collect << 8 | w), this.precedingCodepoint = 0;
                  break;
                case 11:
                  this._params.reset(), this._params.addParam(0), this._collect = 0;
                  break;
                case 12:
                  this._dcsParser.hook(this._collect << 8 | w, this._params);
                  break;
                case 13:
                  for (let O = y + 1; ; ++O)
                    if (O >= u || (w = _[O]) === 24 || w === 26 || w === 27 || w > 127 && w < p) {
                      this._dcsParser.put(_, y, O), y = O - 1;
                      break;
                    }
                  break;
                case 14:
                  if (v = this._dcsParser.unhook(w !== 24 && w !== 26), v)
                    return this._preserveStack(6, [], 0, x, y), v;
                  w === 27 && (x |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
                  break;
                case 4:
                  this._oscParser.start();
                  break;
                case 5:
                  for (let O = y + 1; ; O++)
                    if (O >= u || (w = _[O]) < 32 || w > 127 && w < p) {
                      this._oscParser.put(_, y, O), y = O - 1;
                      break;
                    }
                  break;
                case 6:
                  if (v = this._oscParser.end(w !== 24 && w !== 26), v)
                    return this._preserveStack(5, [], 0, x, y), v;
                  w === 27 && (x |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
              }
              this.currentState = 15 & x;
            }
          }
        }
        n.EscapeSequenceParser = S;
      }, 6242: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.OscHandler = n.OscParser = void 0;
        const a = r(5770), f = r(482), m = [];
        n.OscParser = class {
          constructor() {
            this._state = 0, this._active = m, this._id = -1, this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._stack = { paused: !1, loopPosition: 0, fallThrough: !1 };
          }
          registerHandler(C, b) {
            this._handlers[C] === void 0 && (this._handlers[C] = []);
            const p = this._handlers[C];
            return p.push(b), { dispose: () => {
              const S = p.indexOf(b);
              S !== -1 && p.splice(S, 1);
            } };
          }
          clearHandler(C) {
            this._handlers[C] && delete this._handlers[C];
          }
          setHandlerFallback(C) {
            this._handlerFb = C;
          }
          dispose() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._active = m;
          }
          reset() {
            if (this._state === 2)
              for (let C = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; C >= 0; --C)
                this._active[C].end(!1);
            this._stack.paused = !1, this._active = m, this._id = -1, this._state = 0;
          }
          _start() {
            if (this._active = this._handlers[this._id] || m, this._active.length)
              for (let C = this._active.length - 1; C >= 0; C--)
                this._active[C].start();
            else
              this._handlerFb(this._id, "START");
          }
          _put(C, b, p) {
            if (this._active.length)
              for (let S = this._active.length - 1; S >= 0; S--)
                this._active[S].put(C, b, p);
            else
              this._handlerFb(this._id, "PUT", (0, f.utf32ToString)(C, b, p));
          }
          start() {
            this.reset(), this._state = 1;
          }
          put(C, b, p) {
            if (this._state !== 3) {
              if (this._state === 1)
                for (; b < p; ) {
                  const S = C[b++];
                  if (S === 59) {
                    this._state = 2, this._start();
                    break;
                  }
                  if (S < 48 || 57 < S)
                    return void (this._state = 3);
                  this._id === -1 && (this._id = 0), this._id = 10 * this._id + S - 48;
                }
              this._state === 2 && p - b > 0 && this._put(C, b, p);
            }
          }
          end(C, b = !0) {
            if (this._state !== 0) {
              if (this._state !== 3)
                if (this._state === 1 && this._start(), this._active.length) {
                  let p = !1, S = this._active.length - 1, o = !1;
                  if (this._stack.paused && (S = this._stack.loopPosition - 1, p = b, o = this._stack.fallThrough, this._stack.paused = !1), !o && p === !1) {
                    for (; S >= 0 && (p = this._active[S].end(C), p !== !0); S--)
                      if (p instanceof Promise)
                        return this._stack.paused = !0, this._stack.loopPosition = S, this._stack.fallThrough = !1, p;
                    S--;
                  }
                  for (; S >= 0; S--)
                    if (p = this._active[S].end(!1), p instanceof Promise)
                      return this._stack.paused = !0, this._stack.loopPosition = S, this._stack.fallThrough = !0, p;
                } else
                  this._handlerFb(this._id, "END", C);
              this._active = m, this._id = -1, this._state = 0;
            }
          }
        }, n.OscHandler = class {
          constructor(C) {
            this._handler = C, this._data = "", this._hitLimit = !1;
          }
          start() {
            this._data = "", this._hitLimit = !1;
          }
          put(C, b, p) {
            this._hitLimit || (this._data += (0, f.utf32ToString)(C, b, p), this._data.length > a.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0));
          }
          end(C) {
            let b = !1;
            if (this._hitLimit)
              b = !1;
            else if (C && (b = this._handler(this._data), b instanceof Promise))
              return b.then((p) => (this._data = "", this._hitLimit = !1, p));
            return this._data = "", this._hitLimit = !1, b;
          }
        };
      }, 8742: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.Params = void 0;
        const r = 2147483647;
        class a {
          constructor(m = 32, C = 32) {
            if (this.maxLength = m, this.maxSubParamsLength = C, C > 256)
              throw new Error("maxSubParamsLength must not be greater than 256");
            this.params = new Int32Array(m), this.length = 0, this._subParams = new Int32Array(C), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(m), this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;
          }
          static fromArray(m) {
            const C = new a();
            if (!m.length)
              return C;
            for (let b = Array.isArray(m[0]) ? 1 : 0; b < m.length; ++b) {
              const p = m[b];
              if (Array.isArray(p))
                for (let S = 0; S < p.length; ++S)
                  C.addSubParam(p[S]);
              else
                C.addParam(p);
            }
            return C;
          }
          clone() {
            const m = new a(this.maxLength, this.maxSubParamsLength);
            return m.params.set(this.params), m.length = this.length, m._subParams.set(this._subParams), m._subParamsLength = this._subParamsLength, m._subParamsIdx.set(this._subParamsIdx), m._rejectDigits = this._rejectDigits, m._rejectSubDigits = this._rejectSubDigits, m._digitIsSub = this._digitIsSub, m;
          }
          toArray() {
            const m = [];
            for (let C = 0; C < this.length; ++C) {
              m.push(this.params[C]);
              const b = this._subParamsIdx[C] >> 8, p = 255 & this._subParamsIdx[C];
              p - b > 0 && m.push(Array.prototype.slice.call(this._subParams, b, p));
            }
            return m;
          }
          reset() {
            this.length = 0, this._subParamsLength = 0, this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;
          }
          addParam(m) {
            if (this._digitIsSub = !1, this.length >= this.maxLength)
              this._rejectDigits = !0;
            else {
              if (m < -1)
                throw new Error("values lesser than -1 are not allowed");
              this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = m > r ? r : m;
            }
          }
          addSubParam(m) {
            if (this._digitIsSub = !0, this.length)
              if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength)
                this._rejectSubDigits = !0;
              else {
                if (m < -1)
                  throw new Error("values lesser than -1 are not allowed");
                this._subParams[this._subParamsLength++] = m > r ? r : m, this._subParamsIdx[this.length - 1]++;
              }
          }
          hasSubParams(m) {
            return (255 & this._subParamsIdx[m]) - (this._subParamsIdx[m] >> 8) > 0;
          }
          getSubParams(m) {
            const C = this._subParamsIdx[m] >> 8, b = 255 & this._subParamsIdx[m];
            return b - C > 0 ? this._subParams.subarray(C, b) : null;
          }
          getSubParamsAll() {
            const m = {};
            for (let C = 0; C < this.length; ++C) {
              const b = this._subParamsIdx[C] >> 8, p = 255 & this._subParamsIdx[C];
              p - b > 0 && (m[C] = this._subParams.slice(b, p));
            }
            return m;
          }
          addDigit(m) {
            let C;
            if (this._rejectDigits || !(C = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits)
              return;
            const b = this._digitIsSub ? this._subParams : this.params, p = b[C - 1];
            b[C - 1] = ~p ? Math.min(10 * p + m, r) : m;
          }
        }
        n.Params = a;
      }, 5741: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.AddonManager = void 0, n.AddonManager = class {
          constructor() {
            this._addons = [];
          }
          dispose() {
            for (let r = this._addons.length - 1; r >= 0; r--)
              this._addons[r].instance.dispose();
          }
          loadAddon(r, a) {
            const f = { instance: a, dispose: a.dispose, isDisposed: !1 };
            this._addons.push(f), a.dispose = () => this._wrappedAddonDispose(f), a.activate(r);
          }
          _wrappedAddonDispose(r) {
            if (r.isDisposed)
              return;
            let a = -1;
            for (let f = 0; f < this._addons.length; f++)
              if (this._addons[f] === r) {
                a = f;
                break;
              }
            if (a === -1)
              throw new Error("Could not dispose an addon that has not been loaded");
            r.isDisposed = !0, r.dispose.apply(r.instance), this._addons.splice(a, 1);
          }
        };
      }, 8771: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.BufferApiView = void 0;
        const a = r(3785), f = r(511);
        n.BufferApiView = class {
          constructor(m, C) {
            this._buffer = m, this.type = C;
          }
          init(m) {
            return this._buffer = m, this;
          }
          get cursorY() {
            return this._buffer.y;
          }
          get cursorX() {
            return this._buffer.x;
          }
          get viewportY() {
            return this._buffer.ydisp;
          }
          get baseY() {
            return this._buffer.ybase;
          }
          get length() {
            return this._buffer.lines.length;
          }
          getLine(m) {
            const C = this._buffer.lines.get(m);
            if (C)
              return new a.BufferLineApiView(C);
          }
          getNullCell() {
            return new f.CellData();
          }
        };
      }, 3785: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.BufferLineApiView = void 0;
        const a = r(511);
        n.BufferLineApiView = class {
          constructor(f) {
            this._line = f;
          }
          get isWrapped() {
            return this._line.isWrapped;
          }
          get length() {
            return this._line.length;
          }
          getCell(f, m) {
            if (!(f < 0 || f >= this._line.length))
              return m ? (this._line.loadCell(f, m), m) : this._line.loadCell(f, new a.CellData());
          }
          translateToString(f, m, C) {
            return this._line.translateToString(f, m, C);
          }
        };
      }, 8285: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.BufferNamespaceApi = void 0;
        const a = r(8771), f = r(8460);
        n.BufferNamespaceApi = class {
          constructor(m) {
            this._core = m, this._onBufferChange = new f.EventEmitter(), this.onBufferChange = this._onBufferChange.event, this._normal = new a.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new a.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate(() => this._onBufferChange.fire(this.active));
          }
          get active() {
            if (this._core.buffers.active === this._core.buffers.normal)
              return this.normal;
            if (this._core.buffers.active === this._core.buffers.alt)
              return this.alternate;
            throw new Error("Active buffer is neither normal nor alternate");
          }
          get normal() {
            return this._normal.init(this._core.buffers.normal);
          }
          get alternate() {
            return this._alternate.init(this._core.buffers.alt);
          }
        };
      }, 7975: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.ParserApi = void 0, n.ParserApi = class {
          constructor(r) {
            this._core = r;
          }
          registerCsiHandler(r, a) {
            return this._core.registerCsiHandler(r, (f) => a(f.toArray()));
          }
          addCsiHandler(r, a) {
            return this.registerCsiHandler(r, a);
          }
          registerDcsHandler(r, a) {
            return this._core.registerDcsHandler(r, (f, m) => a(f, m.toArray()));
          }
          addDcsHandler(r, a) {
            return this.registerDcsHandler(r, a);
          }
          registerEscHandler(r, a) {
            return this._core.registerEscHandler(r, a);
          }
          addEscHandler(r, a) {
            return this.registerEscHandler(r, a);
          }
          registerOscHandler(r, a) {
            return this._core.registerOscHandler(r, a);
          }
          addOscHandler(r, a) {
            return this.registerOscHandler(r, a);
          }
        };
      }, 7090: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.UnicodeApi = void 0, n.UnicodeApi = class {
          constructor(r) {
            this._core = r;
          }
          register(r) {
            this._core.unicodeService.register(r);
          }
          get versions() {
            return this._core.unicodeService.versions;
          }
          get activeVersion() {
            return this._core.unicodeService.activeVersion;
          }
          set activeVersion(r) {
            this._core.unicodeService.activeVersion = r;
          }
        };
      }, 744: function(l, n, r) {
        var a = this && this.__decorate || function(o, _, u, d) {
          var v, w = arguments.length, x = w < 3 ? _ : d === null ? d = Object.getOwnPropertyDescriptor(_, u) : d;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            x = Reflect.decorate(o, _, u, d);
          else
            for (var k = o.length - 1; k >= 0; k--)
              (v = o[k]) && (x = (w < 3 ? v(x) : w > 3 ? v(_, u, x) : v(_, u)) || x);
          return w > 3 && x && Object.defineProperty(_, u, x), x;
        }, f = this && this.__param || function(o, _) {
          return function(u, d) {
            _(u, d, o);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.BufferService = n.MINIMUM_ROWS = n.MINIMUM_COLS = void 0;
        const m = r(2585), C = r(5295), b = r(8460), p = r(844);
        n.MINIMUM_COLS = 2, n.MINIMUM_ROWS = 1;
        let S = class extends p.Disposable {
          constructor(o) {
            super(), this.isUserScrolling = !1, this._onResize = this.register(new b.EventEmitter()), this.onResize = this._onResize.event, this._onScroll = this.register(new b.EventEmitter()), this.onScroll = this._onScroll.event, this.cols = Math.max(o.rawOptions.cols || 0, n.MINIMUM_COLS), this.rows = Math.max(o.rawOptions.rows || 0, n.MINIMUM_ROWS), this.buffers = this.register(new C.BufferSet(o, this));
          }
          get buffer() {
            return this.buffers.active;
          }
          resize(o, _) {
            this.cols = o, this.rows = _, this.buffers.resize(o, _), this._onResize.fire({ cols: o, rows: _ });
          }
          reset() {
            this.buffers.reset(), this.isUserScrolling = !1;
          }
          scroll(o, _ = !1) {
            const u = this.buffer;
            let d;
            d = this._cachedBlankLine, d && d.length === this.cols && d.getFg(0) === o.fg && d.getBg(0) === o.bg || (d = u.getBlankLine(o, _), this._cachedBlankLine = d), d.isWrapped = _;
            const v = u.ybase + u.scrollTop, w = u.ybase + u.scrollBottom;
            if (u.scrollTop === 0) {
              const x = u.lines.isFull;
              w === u.lines.length - 1 ? x ? u.lines.recycle().copyFrom(d) : u.lines.push(d.clone()) : u.lines.splice(w + 1, 0, d.clone()), x ? this.isUserScrolling && (u.ydisp = Math.max(u.ydisp - 1, 0)) : (u.ybase++, this.isUserScrolling || u.ydisp++);
            } else {
              const x = w - v + 1;
              u.lines.shiftElements(v + 1, x - 1, -1), u.lines.set(w, d.clone());
            }
            this.isUserScrolling || (u.ydisp = u.ybase), this._onScroll.fire(u.ydisp);
          }
          scrollLines(o, _, u) {
            const d = this.buffer;
            if (o < 0) {
              if (d.ydisp === 0)
                return;
              this.isUserScrolling = !0;
            } else
              o + d.ydisp >= d.ybase && (this.isUserScrolling = !1);
            const v = d.ydisp;
            d.ydisp = Math.max(Math.min(d.ydisp + o, d.ybase), 0), v !== d.ydisp && (_ || this._onScroll.fire(d.ydisp));
          }
          scrollPages(o) {
            this.scrollLines(o * (this.rows - 1));
          }
          scrollToTop() {
            this.scrollLines(-this.buffer.ydisp);
          }
          scrollToBottom() {
            this.scrollLines(this.buffer.ybase - this.buffer.ydisp);
          }
          scrollToLine(o) {
            const _ = o - this.buffer.ydisp;
            _ !== 0 && this.scrollLines(_);
          }
        };
        S = a([f(0, m.IOptionsService)], S), n.BufferService = S;
      }, 7994: (l, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.CharsetService = void 0, n.CharsetService = class {
          constructor() {
            this.glevel = 0, this._charsets = [];
          }
          reset() {
            this.charset = void 0, this._charsets = [], this.glevel = 0;
          }
          setgLevel(r) {
            this.glevel = r, this.charset = this._charsets[r];
          }
          setgCharset(r, a) {
            this._charsets[r] = a, this.glevel === r && (this.charset = a);
          }
        };
      }, 1753: function(l, n, r) {
        var a = this && this.__decorate || function(d, v, w, x) {
          var k, y = arguments.length, I = y < 3 ? v : x === null ? x = Object.getOwnPropertyDescriptor(v, w) : x;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            I = Reflect.decorate(d, v, w, x);
          else
            for (var A = d.length - 1; A >= 0; A--)
              (k = d[A]) && (I = (y < 3 ? k(I) : y > 3 ? k(v, w, I) : k(v, w)) || I);
          return y > 3 && I && Object.defineProperty(v, w, I), I;
        }, f = this && this.__param || function(d, v) {
          return function(w, x) {
            v(w, x, d);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.CoreMouseService = void 0;
        const m = r(2585), C = r(8460), b = r(844), p = { NONE: { events: 0, restrict: () => !1 }, X10: { events: 1, restrict: (d) => d.button !== 4 && d.action === 1 && (d.ctrl = !1, d.alt = !1, d.shift = !1, !0) }, VT200: { events: 19, restrict: (d) => d.action !== 32 }, DRAG: { events: 23, restrict: (d) => d.action !== 32 || d.button !== 3 }, ANY: { events: 31, restrict: (d) => !0 } };
        function S(d, v) {
          let w = (d.ctrl ? 16 : 0) | (d.shift ? 4 : 0) | (d.alt ? 8 : 0);
          return d.button === 4 ? (w |= 64, w |= d.action) : (w |= 3 & d.button, 4 & d.button && (w |= 64), 8 & d.button && (w |= 128), d.action === 32 ? w |= 32 : d.action !== 0 || v || (w |= 3)), w;
        }
        const o = String.fromCharCode, _ = { DEFAULT: (d) => {
          const v = [S(d, !1) + 32, d.col + 32, d.row + 32];
          return v[0] > 255 || v[1] > 255 || v[2] > 255 ? "" : `\x1B[M${o(v[0])}${o(v[1])}${o(v[2])}`;
        }, SGR: (d) => {
          const v = d.action === 0 && d.button !== 4 ? "m" : "M";
          return `\x1B[<${S(d, !0)};${d.col};${d.row}${v}`;
        }, SGR_PIXELS: (d) => {
          const v = d.action === 0 && d.button !== 4 ? "m" : "M";
          return `\x1B[<${S(d, !0)};${d.x};${d.y}${v}`;
        } };
        let u = class extends b.Disposable {
          constructor(d, v) {
            super(), this._bufferService = d, this._coreService = v, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new C.EventEmitter()), this.onProtocolChange = this._onProtocolChange.event;
            for (const w of Object.keys(p))
              this.addProtocol(w, p[w]);
            for (const w of Object.keys(_))
              this.addEncoding(w, _[w]);
            this.reset();
          }
          addProtocol(d, v) {
            this._protocols[d] = v;
          }
          addEncoding(d, v) {
            this._encodings[d] = v;
          }
          get activeProtocol() {
            return this._activeProtocol;
          }
          get areMouseEventsActive() {
            return this._protocols[this._activeProtocol].events !== 0;
          }
          set activeProtocol(d) {
            if (!this._protocols[d])
              throw new Error(`unknown protocol "${d}"`);
            this._activeProtocol = d, this._onProtocolChange.fire(this._protocols[d].events);
          }
          get activeEncoding() {
            return this._activeEncoding;
          }
          set activeEncoding(d) {
            if (!this._encodings[d])
              throw new Error(`unknown encoding "${d}"`);
            this._activeEncoding = d;
          }
          reset() {
            this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
          }
          triggerMouseEvent(d) {
            if (d.col < 0 || d.col >= this._bufferService.cols || d.row < 0 || d.row >= this._bufferService.rows || d.button === 4 && d.action === 32 || d.button === 3 && d.action !== 32 || d.button !== 4 && (d.action === 2 || d.action === 3) || (d.col++, d.row++, d.action === 32 && this._lastEvent && this._equalEvents(this._lastEvent, d, this._activeEncoding === "SGR_PIXELS")) || !this._protocols[this._activeProtocol].restrict(d))
              return !1;
            const v = this._encodings[this._activeEncoding](d);
            return v && (this._activeEncoding === "DEFAULT" ? this._coreService.triggerBinaryEvent(v) : this._coreService.triggerDataEvent(v, !0)), this._lastEvent = d, !0;
          }
          explainEvents(d) {
            return { down: !!(1 & d), up: !!(2 & d), drag: !!(4 & d), move: !!(8 & d), wheel: !!(16 & d) };
          }
          _equalEvents(d, v, w) {
            if (w) {
              if (d.x !== v.x || d.y !== v.y)
                return !1;
            } else if (d.col !== v.col || d.row !== v.row)
              return !1;
            return d.button === v.button && d.action === v.action && d.ctrl === v.ctrl && d.alt === v.alt && d.shift === v.shift;
          }
        };
        u = a([f(0, m.IBufferService), f(1, m.ICoreService)], u), n.CoreMouseService = u;
      }, 6975: function(l, n, r) {
        var a = this && this.__decorate || function(u, d, v, w) {
          var x, k = arguments.length, y = k < 3 ? d : w === null ? w = Object.getOwnPropertyDescriptor(d, v) : w;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            y = Reflect.decorate(u, d, v, w);
          else
            for (var I = u.length - 1; I >= 0; I--)
              (x = u[I]) && (y = (k < 3 ? x(y) : k > 3 ? x(d, v, y) : x(d, v)) || y);
          return k > 3 && y && Object.defineProperty(d, v, y), y;
        }, f = this && this.__param || function(u, d) {
          return function(v, w) {
            d(v, w, u);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.CoreService = void 0;
        const m = r(2585), C = r(8460), b = r(1439), p = r(844), S = Object.freeze({ insertMode: !1 }), o = Object.freeze({ applicationCursorKeys: !1, applicationKeypad: !1, bracketedPasteMode: !1, origin: !1, reverseWraparound: !1, sendFocus: !1, wraparound: !0 });
        let _ = class extends p.Disposable {
          constructor(u, d, v) {
            super(), this._bufferService = u, this._logService = d, this._optionsService = v, this.isCursorInitialized = !1, this.isCursorHidden = !1, this._onData = this.register(new C.EventEmitter()), this.onData = this._onData.event, this._onUserInput = this.register(new C.EventEmitter()), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new C.EventEmitter()), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new C.EventEmitter()), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, b.clone)(S), this.decPrivateModes = (0, b.clone)(o);
          }
          reset() {
            this.modes = (0, b.clone)(S), this.decPrivateModes = (0, b.clone)(o);
          }
          triggerDataEvent(u, d = !1) {
            if (this._optionsService.rawOptions.disableStdin)
              return;
            const v = this._bufferService.buffer;
            d && this._optionsService.rawOptions.scrollOnUserInput && v.ybase !== v.ydisp && this._onRequestScrollToBottom.fire(), d && this._onUserInput.fire(), this._logService.debug(`sending data "${u}"`, () => u.split("").map((w) => w.charCodeAt(0))), this._onData.fire(u);
          }
          triggerBinaryEvent(u) {
            this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${u}"`, () => u.split("").map((d) => d.charCodeAt(0))), this._onBinary.fire(u));
          }
        };
        _ = a([f(0, m.IBufferService), f(1, m.ILogService), f(2, m.IOptionsService)], _), n.CoreService = _;
      }, 9074: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.DecorationService = void 0;
        const a = r(8055), f = r(8460), m = r(844), C = r(6106);
        let b = 0, p = 0;
        class S extends m.Disposable {
          constructor() {
            super(), this._decorations = new C.SortedList((u) => u == null ? void 0 : u.marker.line), this._onDecorationRegistered = this.register(new f.EventEmitter()), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new f.EventEmitter()), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, m.toDisposable)(() => {
              for (const u of this._decorations.values())
                this._onDecorationRemoved.fire(u);
              this.reset();
            }));
          }
          get decorations() {
            return this._decorations.values();
          }
          registerDecoration(u) {
            if (u.marker.isDisposed)
              return;
            const d = new o(u);
            if (d) {
              const v = d.marker.onDispose(() => d.dispose());
              d.onDispose(() => {
                d && (this._decorations.delete(d) && this._onDecorationRemoved.fire(d), v.dispose());
              }), this._decorations.insert(d), this._onDecorationRegistered.fire(d);
            }
            return d;
          }
          reset() {
            for (const u of this._decorations.values())
              u.dispose();
            this._decorations.clear();
          }
          *getDecorationsAtCell(u, d, v) {
            var w, x, k;
            let y = 0, I = 0;
            for (const A of this._decorations.getKeyIterator(d))
              y = (w = A.options.x) !== null && w !== void 0 ? w : 0, I = y + ((x = A.options.width) !== null && x !== void 0 ? x : 1), u >= y && u < I && (!v || ((k = A.options.layer) !== null && k !== void 0 ? k : "bottom") === v) && (yield A);
          }
          forEachDecorationAtCell(u, d, v, w) {
            this._decorations.forEachByKey(d, (x) => {
              var k, y, I;
              b = (k = x.options.x) !== null && k !== void 0 ? k : 0, p = b + ((y = x.options.width) !== null && y !== void 0 ? y : 1), u >= b && u < p && (!v || ((I = x.options.layer) !== null && I !== void 0 ? I : "bottom") === v) && w(x);
            });
          }
          dispose() {
            for (const u of this._decorations.values())
              this._onDecorationRemoved.fire(u);
            this.reset();
          }
        }
        n.DecorationService = S;
        class o extends m.Disposable {
          constructor(u) {
            super(), this.options = u, this.onRenderEmitter = this.register(new f.EventEmitter()), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new f.EventEmitter()), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = u.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full");
          }
          get isDisposed() {
            return this._isDisposed;
          }
          get backgroundColorRGB() {
            return this._cachedBg === null && (this.options.backgroundColor ? this._cachedBg = a.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg;
          }
          get foregroundColorRGB() {
            return this._cachedFg === null && (this.options.foregroundColor ? this._cachedFg = a.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg;
          }
          dispose() {
            this._onDispose.fire(), super.dispose();
          }
        }
      }, 4348: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.InstantiationService = n.ServiceCollection = void 0;
        const a = r(2585), f = r(8343);
        class m {
          constructor(...b) {
            this._entries = /* @__PURE__ */ new Map();
            for (const [p, S] of b)
              this.set(p, S);
          }
          set(b, p) {
            const S = this._entries.get(b);
            return this._entries.set(b, p), S;
          }
          forEach(b) {
            for (const [p, S] of this._entries.entries())
              b(p, S);
          }
          has(b) {
            return this._entries.has(b);
          }
          get(b) {
            return this._entries.get(b);
          }
        }
        n.ServiceCollection = m, n.InstantiationService = class {
          constructor() {
            this._services = new m(), this._services.set(a.IInstantiationService, this);
          }
          setService(C, b) {
            this._services.set(C, b);
          }
          getService(C) {
            return this._services.get(C);
          }
          createInstance(C, ...b) {
            const p = (0, f.getServiceDependencies)(C).sort((_, u) => _.index - u.index), S = [];
            for (const _ of p) {
              const u = this._services.get(_.id);
              if (!u)
                throw new Error(`[createInstance] ${C.name} depends on UNKNOWN service ${_.id}.`);
              S.push(u);
            }
            const o = p.length > 0 ? p[0].index : b.length;
            if (b.length !== o)
              throw new Error(`[createInstance] First service dependency of ${C.name} at position ${o + 1} conflicts with ${b.length} static arguments`);
            return new C(...b, ...S);
          }
        };
      }, 7866: function(l, n, r) {
        var a = this && this.__decorate || function(S, o, _, u) {
          var d, v = arguments.length, w = v < 3 ? o : u === null ? u = Object.getOwnPropertyDescriptor(o, _) : u;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            w = Reflect.decorate(S, o, _, u);
          else
            for (var x = S.length - 1; x >= 0; x--)
              (d = S[x]) && (w = (v < 3 ? d(w) : v > 3 ? d(o, _, w) : d(o, _)) || w);
          return v > 3 && w && Object.defineProperty(o, _, w), w;
        }, f = this && this.__param || function(S, o) {
          return function(_, u) {
            o(_, u, S);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.LogService = void 0;
        const m = r(844), C = r(2585), b = { debug: C.LogLevelEnum.DEBUG, info: C.LogLevelEnum.INFO, warn: C.LogLevelEnum.WARN, error: C.LogLevelEnum.ERROR, off: C.LogLevelEnum.OFF };
        let p = class extends m.Disposable {
          constructor(S) {
            super(), this._optionsService = S, this.logLevel = C.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel()));
          }
          _updateLogLevel() {
            this.logLevel = b[this._optionsService.rawOptions.logLevel];
          }
          _evalLazyOptionalParams(S) {
            for (let o = 0; o < S.length; o++)
              typeof S[o] == "function" && (S[o] = S[o]());
          }
          _log(S, o, _) {
            this._evalLazyOptionalParams(_), S.call(console, "xterm.js: " + o, ..._);
          }
          debug(S, ...o) {
            this.logLevel <= C.LogLevelEnum.DEBUG && this._log(console.log, S, o);
          }
          info(S, ...o) {
            this.logLevel <= C.LogLevelEnum.INFO && this._log(console.info, S, o);
          }
          warn(S, ...o) {
            this.logLevel <= C.LogLevelEnum.WARN && this._log(console.warn, S, o);
          }
          error(S, ...o) {
            this.logLevel <= C.LogLevelEnum.ERROR && this._log(console.error, S, o);
          }
        };
        p = a([f(0, C.IOptionsService)], p), n.LogService = p;
      }, 7302: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.OptionsService = n.DEFAULT_OPTIONS = void 0;
        const a = r(8460), f = r(6114), m = r(844);
        n.DEFAULT_OPTIONS = { cols: 80, rows: 24, cursorBlink: !1, cursorStyle: "block", cursorWidth: 1, customGlyphs: !0, drawBoldTextInBrightColors: !0, fastScrollModifier: "alt", fastScrollSensitivity: 5, fontFamily: "courier-new, courier, monospace", fontSize: 15, fontWeight: "normal", fontWeightBold: "bold", lineHeight: 1, letterSpacing: 0, linkHandler: null, logLevel: "info", scrollback: 1e3, scrollOnUserInput: !0, scrollSensitivity: 1, screenReaderMode: !1, smoothScrollDuration: 0, macOptionIsMeta: !1, macOptionClickForcesSelection: !1, minimumContrastRatio: 1, disableStdin: !1, allowProposedApi: !1, allowTransparency: !1, tabStopWidth: 8, theme: {}, rightClickSelectsWord: f.isMac, windowOptions: {}, windowsMode: !1, windowsPty: {}, wordSeparator: " ()[]{}',\"`", altClickMovesCursor: !0, convertEol: !1, termName: "xterm", cancelEvents: !1, overviewRulerWidth: 0 };
        const C = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
        class b extends m.Disposable {
          constructor(S) {
            super(), this._onOptionChange = this.register(new a.EventEmitter()), this.onOptionChange = this._onOptionChange.event;
            const o = Object.assign({}, n.DEFAULT_OPTIONS);
            for (const _ in S)
              if (_ in o)
                try {
                  const u = S[_];
                  o[_] = this._sanitizeAndValidateOption(_, u);
                } catch (u) {
                  console.error(u);
                }
            this.rawOptions = o, this.options = Object.assign({}, o), this._setupOptions();
          }
          onSpecificOptionChange(S, o) {
            return this.onOptionChange((_) => {
              _ === S && o(this.rawOptions[S]);
            });
          }
          onMultipleOptionChange(S, o) {
            return this.onOptionChange((_) => {
              S.indexOf(_) !== -1 && o();
            });
          }
          _setupOptions() {
            const S = (_) => {
              if (!(_ in n.DEFAULT_OPTIONS))
                throw new Error(`No option with key "${_}"`);
              return this.rawOptions[_];
            }, o = (_, u) => {
              if (!(_ in n.DEFAULT_OPTIONS))
                throw new Error(`No option with key "${_}"`);
              u = this._sanitizeAndValidateOption(_, u), this.rawOptions[_] !== u && (this.rawOptions[_] = u, this._onOptionChange.fire(_));
            };
            for (const _ in this.rawOptions) {
              const u = { get: S.bind(this, _), set: o.bind(this, _) };
              Object.defineProperty(this.options, _, u);
            }
          }
          _sanitizeAndValidateOption(S, o) {
            switch (S) {
              case "cursorStyle":
                if (o || (o = n.DEFAULT_OPTIONS[S]), !function(_) {
                  return _ === "block" || _ === "underline" || _ === "bar";
                }(o))
                  throw new Error(`"${o}" is not a valid value for ${S}`);
                break;
              case "wordSeparator":
                o || (o = n.DEFAULT_OPTIONS[S]);
                break;
              case "fontWeight":
              case "fontWeightBold":
                if (typeof o == "number" && 1 <= o && o <= 1e3)
                  break;
                o = C.includes(o) ? o : n.DEFAULT_OPTIONS[S];
                break;
              case "cursorWidth":
                o = Math.floor(o);
              case "lineHeight":
              case "tabStopWidth":
                if (o < 1)
                  throw new Error(`${S} cannot be less than 1, value: ${o}`);
                break;
              case "minimumContrastRatio":
                o = Math.max(1, Math.min(21, Math.round(10 * o) / 10));
                break;
              case "scrollback":
                if ((o = Math.min(o, 4294967295)) < 0)
                  throw new Error(`${S} cannot be less than 0, value: ${o}`);
                break;
              case "fastScrollSensitivity":
              case "scrollSensitivity":
                if (o <= 0)
                  throw new Error(`${S} cannot be less than or equal to 0, value: ${o}`);
                break;
              case "rows":
              case "cols":
                if (!o && o !== 0)
                  throw new Error(`${S} must be numeric, value: ${o}`);
                break;
              case "windowsPty":
                o = o ?? {};
            }
            return o;
          }
        }
        n.OptionsService = b;
      }, 2660: function(l, n, r) {
        var a = this && this.__decorate || function(b, p, S, o) {
          var _, u = arguments.length, d = u < 3 ? p : o === null ? o = Object.getOwnPropertyDescriptor(p, S) : o;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            d = Reflect.decorate(b, p, S, o);
          else
            for (var v = b.length - 1; v >= 0; v--)
              (_ = b[v]) && (d = (u < 3 ? _(d) : u > 3 ? _(p, S, d) : _(p, S)) || d);
          return u > 3 && d && Object.defineProperty(p, S, d), d;
        }, f = this && this.__param || function(b, p) {
          return function(S, o) {
            p(S, o, b);
          };
        };
        Object.defineProperty(n, "__esModule", { value: !0 }), n.OscLinkService = void 0;
        const m = r(2585);
        let C = class {
          constructor(b) {
            this._bufferService = b, this._nextId = 1, this._entriesWithId = /* @__PURE__ */ new Map(), this._dataByLinkId = /* @__PURE__ */ new Map();
          }
          registerLink(b) {
            const p = this._bufferService.buffer;
            if (b.id === void 0) {
              const v = p.addMarker(p.ybase + p.y), w = { data: b, id: this._nextId++, lines: [v] };
              return v.onDispose(() => this._removeMarkerFromLink(w, v)), this._dataByLinkId.set(w.id, w), w.id;
            }
            const S = b, o = this._getEntryIdKey(S), _ = this._entriesWithId.get(o);
            if (_)
              return this.addLineToLink(_.id, p.ybase + p.y), _.id;
            const u = p.addMarker(p.ybase + p.y), d = { id: this._nextId++, key: this._getEntryIdKey(S), data: S, lines: [u] };
            return u.onDispose(() => this._removeMarkerFromLink(d, u)), this._entriesWithId.set(d.key, d), this._dataByLinkId.set(d.id, d), d.id;
          }
          addLineToLink(b, p) {
            const S = this._dataByLinkId.get(b);
            if (S && S.lines.every((o) => o.line !== p)) {
              const o = this._bufferService.buffer.addMarker(p);
              S.lines.push(o), o.onDispose(() => this._removeMarkerFromLink(S, o));
            }
          }
          getLinkData(b) {
            var p;
            return (p = this._dataByLinkId.get(b)) === null || p === void 0 ? void 0 : p.data;
          }
          _getEntryIdKey(b) {
            return `${b.id};;${b.uri}`;
          }
          _removeMarkerFromLink(b, p) {
            const S = b.lines.indexOf(p);
            S !== -1 && (b.lines.splice(S, 1), b.lines.length === 0 && (b.data.id !== void 0 && this._entriesWithId.delete(b.key), this._dataByLinkId.delete(b.id)));
          }
        };
        C = a([f(0, m.IBufferService)], C), n.OscLinkService = C;
      }, 8343: (l, n) => {
        function r(a, f, m) {
          f.di$target === f ? f.di$dependencies.push({ id: a, index: m }) : (f.di$dependencies = [{ id: a, index: m }], f.di$target = f);
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.createDecorator = n.getServiceDependencies = n.serviceRegistry = void 0, n.serviceRegistry = /* @__PURE__ */ new Map(), n.getServiceDependencies = function(a) {
          return a.di$dependencies || [];
        }, n.createDecorator = function(a) {
          if (n.serviceRegistry.has(a))
            return n.serviceRegistry.get(a);
          const f = function(m, C, b) {
            if (arguments.length !== 3)
              throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
            r(f, m, b);
          };
          return f.toString = () => a, n.serviceRegistry.set(a, f), f;
        };
      }, 2585: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.IDecorationService = n.IUnicodeService = n.IOscLinkService = n.IOptionsService = n.ILogService = n.LogLevelEnum = n.IInstantiationService = n.ICharsetService = n.ICoreService = n.ICoreMouseService = n.IBufferService = void 0;
        const a = r(8343);
        var f;
        n.IBufferService = (0, a.createDecorator)("BufferService"), n.ICoreMouseService = (0, a.createDecorator)("CoreMouseService"), n.ICoreService = (0, a.createDecorator)("CoreService"), n.ICharsetService = (0, a.createDecorator)("CharsetService"), n.IInstantiationService = (0, a.createDecorator)("InstantiationService"), (f = n.LogLevelEnum || (n.LogLevelEnum = {}))[f.DEBUG = 0] = "DEBUG", f[f.INFO = 1] = "INFO", f[f.WARN = 2] = "WARN", f[f.ERROR = 3] = "ERROR", f[f.OFF = 4] = "OFF", n.ILogService = (0, a.createDecorator)("LogService"), n.IOptionsService = (0, a.createDecorator)("OptionsService"), n.IOscLinkService = (0, a.createDecorator)("OscLinkService"), n.IUnicodeService = (0, a.createDecorator)("UnicodeService"), n.IDecorationService = (0, a.createDecorator)("DecorationService");
      }, 1480: (l, n, r) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.UnicodeService = void 0;
        const a = r(8460), f = r(225);
        n.UnicodeService = class {
          constructor() {
            this._providers = /* @__PURE__ */ Object.create(null), this._active = "", this._onChange = new a.EventEmitter(), this.onChange = this._onChange.event;
            const m = new f.UnicodeV6();
            this.register(m), this._active = m.version, this._activeProvider = m;
          }
          dispose() {
            this._onChange.dispose();
          }
          get versions() {
            return Object.keys(this._providers);
          }
          get activeVersion() {
            return this._active;
          }
          set activeVersion(m) {
            if (!this._providers[m])
              throw new Error(`unknown Unicode version "${m}"`);
            this._active = m, this._activeProvider = this._providers[m], this._onChange.fire(m);
          }
          register(m) {
            this._providers[m.version] = m;
          }
          wcwidth(m) {
            return this._activeProvider.wcwidth(m);
          }
          getStringCellWidth(m) {
            let C = 0;
            const b = m.length;
            for (let p = 0; p < b; ++p) {
              let S = m.charCodeAt(p);
              if (55296 <= S && S <= 56319) {
                if (++p >= b)
                  return C + this.wcwidth(S);
                const o = m.charCodeAt(p);
                56320 <= o && o <= 57343 ? S = 1024 * (S - 55296) + o - 56320 + 65536 : C += this.wcwidth(o);
              }
              C += this.wcwidth(S);
            }
            return C;
          }
        };
      } }, i = {};
      function s(l) {
        var n = i[l];
        if (n !== void 0)
          return n.exports;
        var r = i[l] = { exports: {} };
        return t[l].call(r.exports, r, r.exports, s), r.exports;
      }
      var c = {};
      return (() => {
        var l = c;
        Object.defineProperty(l, "__esModule", { value: !0 }), l.Terminal = void 0;
        const n = s(3236), r = s(9042), a = s(7975), f = s(7090), m = s(5741), C = s(8285), b = ["cols", "rows"];
        l.Terminal = class {
          constructor(p) {
            this._core = new n.Terminal(p), this._addonManager = new m.AddonManager(), this._publicOptions = Object.assign({}, this._core.options);
            const S = (_) => this._core.options[_], o = (_, u) => {
              this._checkReadonlyOptions(_), this._core.options[_] = u;
            };
            for (const _ in this._core.options) {
              const u = { get: S.bind(this, _), set: o.bind(this, _) };
              Object.defineProperty(this._publicOptions, _, u);
            }
          }
          _checkReadonlyOptions(p) {
            if (b.includes(p))
              throw new Error(`Option "${p}" can only be set in the constructor`);
          }
          _checkProposedApi() {
            if (!this._core.optionsService.rawOptions.allowProposedApi)
              throw new Error("You must set the allowProposedApi option to true to use proposed API");
          }
          get onBell() {
            return this._core.onBell;
          }
          get onBinary() {
            return this._core.onBinary;
          }
          get onCursorMove() {
            return this._core.onCursorMove;
          }
          get onData() {
            return this._core.onData;
          }
          get onKey() {
            return this._core.onKey;
          }
          get onLineFeed() {
            return this._core.onLineFeed;
          }
          get onRender() {
            return this._core.onRender;
          }
          get onResize() {
            return this._core.onResize;
          }
          get onScroll() {
            return this._core.onScroll;
          }
          get onSelectionChange() {
            return this._core.onSelectionChange;
          }
          get onTitleChange() {
            return this._core.onTitleChange;
          }
          get onWriteParsed() {
            return this._core.onWriteParsed;
          }
          get element() {
            return this._core.element;
          }
          get parser() {
            return this._parser || (this._parser = new a.ParserApi(this._core)), this._parser;
          }
          get unicode() {
            return this._checkProposedApi(), new f.UnicodeApi(this._core);
          }
          get textarea() {
            return this._core.textarea;
          }
          get rows() {
            return this._core.rows;
          }
          get cols() {
            return this._core.cols;
          }
          get buffer() {
            return this._buffer || (this._buffer = new C.BufferNamespaceApi(this._core)), this._buffer;
          }
          get markers() {
            return this._checkProposedApi(), this._core.markers;
          }
          get modes() {
            const p = this._core.coreService.decPrivateModes;
            let S = "none";
            switch (this._core.coreMouseService.activeProtocol) {
              case "X10":
                S = "x10";
                break;
              case "VT200":
                S = "vt200";
                break;
              case "DRAG":
                S = "drag";
                break;
              case "ANY":
                S = "any";
            }
            return { applicationCursorKeysMode: p.applicationCursorKeys, applicationKeypadMode: p.applicationKeypad, bracketedPasteMode: p.bracketedPasteMode, insertMode: this._core.coreService.modes.insertMode, mouseTrackingMode: S, originMode: p.origin, reverseWraparoundMode: p.reverseWraparound, sendFocusMode: p.sendFocus, wraparoundMode: p.wraparound };
          }
          get options() {
            return this._publicOptions;
          }
          set options(p) {
            for (const S in p)
              this._publicOptions[S] = p[S];
          }
          blur() {
            this._core.blur();
          }
          focus() {
            this._core.focus();
          }
          resize(p, S) {
            this._verifyIntegers(p, S), this._core.resize(p, S);
          }
          open(p) {
            this._core.open(p);
          }
          attachCustomKeyEventHandler(p) {
            this._core.attachCustomKeyEventHandler(p);
          }
          registerLinkProvider(p) {
            return this._core.registerLinkProvider(p);
          }
          registerCharacterJoiner(p) {
            return this._checkProposedApi(), this._core.registerCharacterJoiner(p);
          }
          deregisterCharacterJoiner(p) {
            this._checkProposedApi(), this._core.deregisterCharacterJoiner(p);
          }
          registerMarker(p = 0) {
            return this._verifyIntegers(p), this._core.addMarker(p);
          }
          registerDecoration(p) {
            var S, o, _;
            return this._checkProposedApi(), this._verifyPositiveIntegers((S = p.x) !== null && S !== void 0 ? S : 0, (o = p.width) !== null && o !== void 0 ? o : 0, (_ = p.height) !== null && _ !== void 0 ? _ : 0), this._core.registerDecoration(p);
          }
          hasSelection() {
            return this._core.hasSelection();
          }
          select(p, S, o) {
            this._verifyIntegers(p, S, o), this._core.select(p, S, o);
          }
          getSelection() {
            return this._core.getSelection();
          }
          getSelectionPosition() {
            return this._core.getSelectionPosition();
          }
          clearSelection() {
            this._core.clearSelection();
          }
          selectAll() {
            this._core.selectAll();
          }
          selectLines(p, S) {
            this._verifyIntegers(p, S), this._core.selectLines(p, S);
          }
          dispose() {
            this._addonManager.dispose(), this._core.dispose();
          }
          scrollLines(p) {
            this._verifyIntegers(p), this._core.scrollLines(p);
          }
          scrollPages(p) {
            this._verifyIntegers(p), this._core.scrollPages(p);
          }
          scrollToTop() {
            this._core.scrollToTop();
          }
          scrollToBottom() {
            this._core.scrollToBottom();
          }
          scrollToLine(p) {
            this._verifyIntegers(p), this._core.scrollToLine(p);
          }
          clear() {
            this._core.clear();
          }
          write(p, S) {
            this._core.write(p, S);
          }
          writeln(p, S) {
            this._core.write(p), this._core.write(`\r
`, S);
          }
          paste(p) {
            this._core.paste(p);
          }
          refresh(p, S) {
            this._verifyIntegers(p, S), this._core.refresh(p, S);
          }
          reset() {
            this._core.reset();
          }
          clearTextureAtlas() {
            this._core.clearTextureAtlas();
          }
          loadAddon(p) {
            return this._addonManager.loadAddon(this, p);
          }
          static get strings() {
            return r;
          }
          _verifyIntegers(...p) {
            for (const S of p)
              if (S === 1 / 0 || isNaN(S) || S % 1 != 0)
                throw new Error("This API only accepts integers");
          }
          _verifyPositiveIntegers(...p) {
            for (const S of p)
              if (S && (S === 1 / 0 || isNaN(S) || S % 1 != 0 || S < 0))
                throw new Error("This API only accepts positive integers");
          }
        };
      })(), c;
    })());
  }(ws)), ws.exports;
}
var Cs = tu();
let pn;
const iu = [
  "bash",
  "zsh",
  "pwsh",
  "pwsh"
];
var Ze;
let ot = (Ze = class extends ue {
  get domElement() {
    return this._wrapperElement;
  }
  get usedShellIntegrationInjection() {
    return this._usedShellIntegrationInjection;
  }
  get extEnvironmentVariableCollection() {
    return this._processManager.extEnvironmentVariableCollection;
  }
  get waitOnExit() {
    var e;
    return ((e = this._shellLaunchConfig.attachPersistentProcess) == null ? void 0 : e.waitOnExit) || this._shellLaunchConfig.waitOnExit;
  }
  set waitOnExit(e) {
    this._shellLaunchConfig.waitOnExit = e;
  }
  get target() {
    return this._target;
  }
  set target(e) {
    this._target = e;
  }
  get instanceId() {
    return this._instanceId;
  }
  get resource() {
    return this._resource;
  }
  get cols() {
    return this._fixedCols !== void 0 ? this._fixedCols : this._dimensionsOverride && this._dimensionsOverride.cols ? this._dimensionsOverride.forceExactSize ? this._dimensionsOverride.cols : Math.min(Math.max(this._dimensionsOverride.cols, 2), this._cols) : this._cols;
  }
  get rows() {
    return this._fixedRows !== void 0 ? this._fixedRows : this._dimensionsOverride && this._dimensionsOverride.rows ? this._dimensionsOverride.forceExactSize ? this._dimensionsOverride.rows : Math.min(Math.max(this._dimensionsOverride.rows, 2), this._rows) : this._rows;
  }
  get isDisposed() {
    return this._isDisposed;
  }
  get fixedCols() {
    return this._fixedCols;
  }
  get fixedRows() {
    return this._fixedRows;
  }
  get maxCols() {
    return this._cols;
  }
  get maxRows() {
    return this._rows;
  }
  get processId() {
    return this._processManager.shellProcessId;
  }
  get processReady() {
    return this._processManager.ptyProcessReady;
  }
  get hasChildProcesses() {
    var e;
    return ((e = this.shellLaunchConfig.attachPersistentProcess) == null ? void 0 : e.hasChildProcesses) || this._processManager.hasChildProcesses;
  }
  get reconnectionProperties() {
    var e;
    return ((e = this.shellLaunchConfig.attachPersistentProcess) == null ? void 0 : e.reconnectionProperties) || this.shellLaunchConfig.reconnectionProperties;
  }
  get areLinksReady() {
    return this._areLinksReady;
  }
  get initialDataEvents() {
    return this._initialDataEvents;
  }
  get exitCode() {
    return this._exitCode;
  }
  get exitReason() {
    return this._exitReason;
  }
  get hadFocusOnExit() {
    return this._hadFocusOnExit;
  }
  get isTitleSetByProcess() {
    return !!this._messageTitleDisposable;
  }
  get shellLaunchConfig() {
    return this._shellLaunchConfig;
  }
  get shellType() {
    return this._shellType;
  }
  get os() {
    return this._processManager.os;
  }
  get isRemote() {
    return this._processManager.remoteAuthority !== void 0;
  }
  get remoteAuthority() {
    return this._processManager.remoteAuthority;
  }
  get hasFocus() {
    return this._wrapperElement.contains(document.activeElement) ?? !1;
  }
  get title() {
    return this._title;
  }
  get titleSource() {
    return this._titleSource;
  }
  get icon() {
    return this._getIcon();
  }
  get color() {
    return this._getColor();
  }
  get processName() {
    return this._processName;
  }
  get sequence() {
    return this._sequence;
  }
  get staticTitle() {
    return this._staticTitle;
  }
  get workspaceFolder() {
    return this._workspaceFolder;
  }
  get cwd() {
    return this._cwd;
  }
  get initialCwd() {
    return this._initialCwd;
  }
  get description() {
    var t;
    if (this._description)
      return this._description;
    const e = ((t = this.shellLaunchConfig.attachPersistentProcess) == null ? void 0 : t.type) || this.shellLaunchConfig.type;
    if (e)
      return e === "Task" ? g("terminalTypeTask", "Task") : g("terminalTypeLocal", "Local");
  }
  get userHome() {
    return this._userHome;
  }
  get shellIntegrationNonce() {
    return this._processManager.shellIntegrationNonce;
  }
  get injectedArgs() {
    return this._injectedArgs;
  }
  constructor(e, t, i, s, c, l, n, r, a, f, m, C, b, p, S, o, _, u, d, v, w, x, k, y, I, A, M, L, O, U, j, K) {
    var N, G, Z, ae, q, ee, W, F;
    if (super(), this._terminalShellTypeContextKey = e, this._terminalInRunCommandPicker = t, this._terminalSuggestWidgetVisibleContextKey = i, this._configHelper = s, this._shellLaunchConfig = c, this._contextKeyService = l, this._terminalProfileResolverService = r, this._pathService = a, this._keybindingService = f, this._notificationService = m, this._preferencesService = C, this._viewsService = b, this._clipboardService = p, this._themeService = S, this._configurationService = o, this._logService = _, this._dialogService = u, this._storageService = d, this._accessibilityService = v, this._productService = w, this._quickInputService = x, this._workspaceContextService = y, this._editorService = I, this._workspaceTrustRequestService = A, this._historyService = M, this._telemetryService = L, this._openerService = O, this._commandService = U, this._audioCueService = j, this._viewDescriptorService = K, this._contributions = /* @__PURE__ */ new Map(), this._latestXtermWriteData = 0, this._latestXtermParseData = 0, this._title = "", this._titleSource = Ye.Process, this._cols = 0, this._rows = 0, this._cwd = void 0, this._initialCwd = void 0, this._injectedArgs = void 0, this._layoutSettingsChanged = !0, this._areLinksReady = !1, this._initialDataEvents = [], this._widgetManager = new Zd(), this._processName = "", this._usedShellIntegrationInjection = !1, this.capabilities = new xd(), this.disableLayout = !1, this._onExit = new V(), this.onExit = this._onExit.event, this._onDisposed = this._register(new V()), this.onDisposed = this._onDisposed.event, this._onProcessIdReady = this._register(new V()), this.onProcessIdReady = this._onProcessIdReady.event, this._onProcessReplayComplete = this._register(new V()), this.onProcessReplayComplete = this._onProcessReplayComplete.event, this._onTitleChanged = this._register(new V()), this.onTitleChanged = this._onTitleChanged.event, this._onIconChanged = this._register(new V()), this.onIconChanged = this._onIconChanged.event, this._onData = this._register(new V()), this.onData = this._onData.event, this._onBinary = this._register(new V()), this.onBinary = this._onBinary.event, this._onLineData = this._register(new V({
      onDidAddFirstListener: () => this._onLineDataSetup()
    })), this.onLineData = this._onLineData.event, this._onRequestExtHostProcess = this._register(new V()), this.onRequestExtHostProcess = this._onRequestExtHostProcess.event, this._onDimensionsChanged = this._register(new V()), this.onDimensionsChanged = this._onDimensionsChanged.event, this._onMaximumDimensionsChanged = this._register(new V()), this.onMaximumDimensionsChanged = this._onMaximumDimensionsChanged.event, this._onDidFocus = this._register(new V()), this.onDidFocus = this._onDidFocus.event, this._onDidRequestFocus = this._register(new V()), this.onDidRequestFocus = this._onDidRequestFocus.event, this._onDidBlur = this._register(new V()), this.onDidBlur = this._onDidBlur.event, this._onDidInputData = this._register(new V()), this.onDidInputData = this._onDidInputData.event, this._onDidChangeSelection = this._register(new V()), this.onDidChangeSelection = this._onDidChangeSelection.event, this._onRequestAddInstanceToGroup = this._register(new V()), this.onRequestAddInstanceToGroup = this._onRequestAddInstanceToGroup.event, this._onDidChangeHasChildProcesses = this._register(new V()), this.onDidChangeHasChildProcesses = this._onDidChangeHasChildProcesses.event, this._wrapperElement = document.createElement("div"), this._wrapperElement.classList.add("terminal-wrapper"), this._skipTerminalCommands = [], this._isExiting = !1, this._hadFocusOnExit = !1, this._isVisible = !1, this._isDisposed = !1, this._instanceId = Ze._instanceIdCounter++, this._hasHadInput = !1, this._fixedRows = (G = (N = c.attachPersistentProcess) == null ? void 0 : N.fixedDimensions) == null ? void 0 : G.rows, this._fixedCols = (ae = (Z = c.attachPersistentProcess) == null ? void 0 : Z.fixedDimensions) == null ? void 0 : ae.cols, this._resource = Oa(this._workspaceContextService.getWorkspace().id, this.instanceId, this.title), (q = this._shellLaunchConfig.attachPersistentProcess) != null && q.hideFromUser && (this._shellLaunchConfig.hideFromUser = this._shellLaunchConfig.attachPersistentProcess.hideFromUser), (ee = this._shellLaunchConfig.attachPersistentProcess) != null && ee.isFeatureTerminal && (this._shellLaunchConfig.isFeatureTerminal = this._shellLaunchConfig.attachPersistentProcess.isFeatureTerminal), (W = this._shellLaunchConfig.attachPersistentProcess) != null && W.type && (this._shellLaunchConfig.type = this._shellLaunchConfig.attachPersistentProcess.type), this.shellLaunchConfig.cwd) {
      const B = typeof this._shellLaunchConfig.cwd == "string" ? oe.from({
        scheme: me.file,
        path: this._shellLaunchConfig.cwd
      }) : this._shellLaunchConfig.cwd;
      B && (this._workspaceFolder = Pt(this._workspaceContextService.getWorkspaceFolder(B)));
    }
    if (!this._workspaceFolder) {
      const B = this._historyService.getLastActiveWorkspaceRoot();
      this._workspaceFolder = B ? Pt(this._workspaceContextService.getWorkspaceFolder(B)) : void 0;
    }
    const T = this._register(l.createScoped(this._wrapperElement));
    this._scopedInstantiationService = n.createChild(new Tl([Fe, T])), this._terminalFocusContextKey = E.focus.bindTo(T), this._terminalHasFixedWidth = E.terminalHasFixedWidth.bindTo(T), this._terminalHasTextContextKey = E.textSelected.bindTo(T), this._terminalAltBufferActiveContextKey = E.altBufferActive.bindTo(T), this._terminalShellIntegrationEnabledContextKey = E.terminalShellIntegrationEnabled.bindTo(T), this._logService.trace(`terminalInstance#ctor (instanceId: ${this.instanceId})`, this._shellLaunchConfig), this._register(this.capabilities.onDidAddCapability((B) => {
      var $;
      if (this._logService.debug("terminalInstance added capability", B), B === 0)
        ($ = this.capabilities.get(0)) == null || $.onDidChangeCwd((z) => {
          var ce;
          this._cwd = z, this._setTitle(this.title, Ye.Config), (ce = this._scopedInstantiationService.invokeFunction(Os)) == null || ce.add(z, { remoteAuthority: this.remoteAuthority });
        });
      else if (B === 2) {
        const z = this.capabilities.get(2);
        z == null || z.onCommandFinished((ce) => {
          var Y;
          ce.command.trim().length > 0 && ((Y = this._scopedInstantiationService.invokeFunction(Ln)) == null || Y.add(ce.command, { shellType: this._shellType }));
        });
      }
    })), this._register(this.capabilities.onDidRemoveCapability((B) => this._logService.debug("terminalInstance removed capability", B))), !this.shellLaunchConfig.executable && !k.remoteAuthority && this._terminalProfileResolverService.resolveIcon(this._shellLaunchConfig, Lt), this._icon = ((F = c.attachPersistentProcess) == null ? void 0 : F.icon) || c.icon, this.shellLaunchConfig.customPtyImplementation && this._setTitle(this._shellLaunchConfig.name, Ye.Api), this.statusList = this._scopedInstantiationService.createInstance(ur), this._initDimensions(), this._processManager = this._createProcessManager(), this._register(je(() => {
      var B;
      return (B = this._dndObserver) == null ? void 0 : B.dispose();
    })), this._containerReadyBarrier = new Ps(100), this._attachBarrier = new Ps(1e3), this._xtermReadyPromise = this._createXterm(), this._xtermReadyPromise.then(async () => {
      var B, $, z;
      if (await this._containerReadyBarrier.wait(), !this.shellLaunchConfig.customPtyImplementation && ((B = this._configHelper.config.shellIntegration) != null && B.enabled) && !this.shellLaunchConfig.executable) {
        const ce = await this._processManager.getBackendOS(), Y = await this._terminalProfileResolverService.getDefaultProfile({ remoteAuthority: this.remoteAuthority, os: ce });
        this.shellLaunchConfig.executable = Y.path, this.shellLaunchConfig.args = Y.args, this.shellLaunchConfig.isExtensionOwnedTerminal ? (($ = this.shellLaunchConfig).icon ?? ($.icon = Y.icon), (z = this.shellLaunchConfig).color ?? (z.color = Y.color)) : (this.shellLaunchConfig.icon = Y.icon, this.shellLaunchConfig.color = Y.color);
      }
      await this._createProcess(), this.shellLaunchConfig.attachPersistentProcess && (this._cwd = this.shellLaunchConfig.attachPersistentProcess.cwd, this._setTitle(this.shellLaunchConfig.attachPersistentProcess.title, this.shellLaunchConfig.attachPersistentProcess.titleSource), this.setShellType(this.shellType)), this._fixedCols && await this._addScrollbar();
    }).catch((B) => {
      if (!this._isDisposed)
        throw B;
    }), this._register(this._configurationService.onDidChangeConfiguration(async (B) => {
      var z, ce;
      B.affectsConfiguration("accessibility.verbosity.terminal") && this._setAriaLabel((z = this.xterm) == null ? void 0 : z.raw, this._instanceId, this.title), B.affectsConfiguration("terminal.integrated") && (this.updateConfig(), this.setVisible(this._isVisible)), [
        "terminal.integrated.fontSize",
        "terminal.integrated.fontFamily",
        "terminal.integrated.fontWeight",
        "terminal.integrated.fontWeightBold",
        "terminal.integrated.letterSpacing",
        "terminal.integrated.lineHeight",
        "editor.fontFamily"
      ].some((Y) => B.affectsConfiguration(Y)) && (this._layoutSettingsChanged = !0, await this._resize()), B.affectsConfiguration("terminal.integrated.unicodeVersion") && this._updateUnicodeVersion(), B.affectsConfiguration("editor.accessibilitySupport") && this.updateAccessibilitySupport(), (B.affectsConfiguration("terminal.integrated.tabs.title") || B.affectsConfiguration("terminal.integrated.tabs.separator") || B.affectsConfiguration("terminal.integrated.tabs.description")) && ((ce = this._labelComputer) == null || ce.refreshLabel());
    })), this._register(this._workspaceContextService.onDidChangeWorkspaceFolders(() => {
      var B;
      return (B = this._labelComputer) == null ? void 0 : B.refreshLabel();
    })), this._register(this.onDidBlur(() => {
      var B, $;
      return ($ = (B = this.xterm) == null ? void 0 : B.suggestController) == null ? void 0 : $.hideSuggestWidget();
    }));
    let P = window.setTimeout(() => {
      P = void 0, this._initialDataEvents = void 0;
    }, 1e4);
    this._register(je(() => {
      P && window.clearTimeout(P);
    }));
    const H = cr.getTerminalContributions();
    for (const B of H) {
      if (this._contributions.has(B.id)) {
        ao(new Error(`Cannot have two terminal contributions with the same id ${B.id}`));
        continue;
      }
      let $;
      try {
        $ = this._scopedInstantiationService.createInstance(B.ctor, this, this._processManager, this._widgetManager), this._contributions.set(B.id, $);
      } catch (z) {
        ao(z);
      }
      this._xtermReadyPromise.then((z) => {
        var ce;
        (ce = $.xtermReady) == null || ce.call($, z);
      }), this.onDisposed(() => {
        $.dispose();
      });
    }
  }
  getContribution(e) {
    return this._contributions.get(e);
  }
  _getIcon() {
    return this._icon || (this._icon = this._processManager.processState >= 2 ? ts().getIcon(this._configurationService.getValue("terminal.integrated.tabs.defaultIcon")) : void 0), this._icon;
  }
  _getColor() {
    var e, t;
    if (this.shellLaunchConfig.color)
      return this.shellLaunchConfig.color;
    if ((t = (e = this.shellLaunchConfig) == null ? void 0 : e.attachPersistentProcess) != null && t.color)
      return this.shellLaunchConfig.attachPersistentProcess.color;
    this._processManager.processState >= 2;
  }
  _initDimensions() {
    if (!this._container) {
      this._cols = 80, this._rows = 30;
      return;
    }
    const e = window.getComputedStyle(this._container), t = parseInt(e.width), i = parseInt(e.height);
    this._evaluateColsAndRows(t, i);
  }
  _evaluateColsAndRows(e, t) {
    if (!e || !t)
      return this._setLastKnownColsAndRows(), null;
    const i = this._getDimension(e, t);
    if (!i)
      return this._setLastKnownColsAndRows(), null;
    const s = this.xterm ? this.xterm.getFont() : this._configHelper.getFont(), c = Wd(s, i.width, i.height);
    return c ? ((this._cols !== c.cols || this._rows !== c.rows) && (this._cols = c.cols, this._rows = c.rows, this._fireMaximumDimensionsChanged()), i.width) : (this._setLastKnownColsAndRows(), null);
  }
  _setLastKnownColsAndRows() {
    Ze._lastKnownGridDimensions && (this._cols = Ze._lastKnownGridDimensions.cols, this._rows = Ze._lastKnownGridDimensions.rows);
  }
  _fireMaximumDimensionsChanged() {
    this._onMaximumDimensionsChanged.fire();
  }
  _getDimension(e, t) {
    var n;
    const i = this.xterm ? this.xterm.getFont() : this._configHelper.getFont();
    if (!i || !i.charWidth || !i.charHeight || !((n = this.xterm) != null && n.raw.element))
      return;
    const s = window.getComputedStyle(this.xterm.raw.element), c = parseInt(s.paddingLeft) + parseInt(s.paddingRight), l = parseInt(s.paddingTop) + parseInt(s.paddingBottom);
    return Ze._lastKnownCanvasDimensions = new Nt(Math.min(8e3, e - c), t + (this._hasScrollBar && !this._horizontalScrollbar ? -5 : 0) - 2 - l), Ze._lastKnownCanvasDimensions;
  }
  get persistentProcessId() {
    return this._processManager.persistentProcessId;
  }
  get shouldPersist() {
    return this._processManager.shouldPersist && !this.shellLaunchConfig.isTransient && (!this.reconnectionProperties || this._configurationService.getValue("task.reconnection") === !0);
  }
  static getXtermConstructor(e, t) {
    const i = e.lookupKeybinding("workbench.action.terminal.focusAccessibleBuffer", t);
    return pn || (pn = Dl.withAsyncBody(async (s) => {
      Cs.Terminal.strings.promptLabel = g("terminal.integrated.a11yPromptLabel", "Terminal input"), Cs.Terminal.strings.tooMuchOutput = i ? g(
        "terminal.integrated.useAccessibleBuffer",
        "Use the accessible buffer {0} to manually review output",
        i.getLabel()
      ) : g(
        "terminal.integrated.useAccessibleBufferNoKb",
        "Use the Terminal: Focus Accessible Buffer command to manually review output"
      ), s(Cs.Terminal);
    }), pn);
  }
  async _createXterm() {
    const e = await Ze.getXtermConstructor(this._keybindingService, this._contextKeyService);
    if (this._isDisposed)
      throw new Rs("Terminal disposed of during xterm.js creation");
    const t = this.shellLaunchConfig.hideFromUser || this.shellLaunchConfig.executable === void 0 || this.shellType === void 0 || !iu.includes(this.shellType), i = this._scopedInstantiationService.createInstance(Di, e, this._configHelper, this._cols, this._rows, {
      getBackgroundColor: (l) => {
        const n = l.getColor(na);
        return n || (this.target === se.Editor ? l.getColor(El) : this._viewDescriptorService.getViewLocationById(fe) === 1 ? l.getColor(sa) : l.getColor(Al));
      }
    }, this.capabilities, this._processManager.shellIntegrationNonce, this._terminalSuggestWidgetVisibleContextKey, t);
    this.xterm = i, this.updateAccessibilitySupport(), this.xterm.onDidRequestRunCommand((l) => {
      l.copyAsHtml ? this.copySelection(!0, l.command) : this.sendText(l.command.command, !l.noNewLine);
    }), this.xterm.onDidRequestFocus(() => this.focus()), this.xterm.onDidRequestSendText((l) => this.sendText(l, !1));
    const s = this._shellLaunchConfig.initialText ? new Promise((l) => this._writeInitialText(i, l)) : void 0, c = new eu(s);
    if (c.onLineData((l) => this._onLineData.fire(l)), this._lineDataEventAddon = c, setTimeout(() => {
      i.raw.onBell(() => {
        this._configHelper.config.enableBell && (this.statusList.add({
          id: "bell",
          severity: Te.Warning,
          icon: te.bell,
          tooltip: g("bellStatus", "Bell")
        }, this._configHelper.config.bellDuration), this._audioCueService.playSound(Xr.terminalBell.sound.getSound()));
      });
    }, 1e3), i.raw.onSelectionChange(async () => this._onSelectionChange()), i.raw.buffer.onBufferChange(() => this._refreshAltBufferContextKey()), this._processManager.onProcessData((l) => this._onProcessData(l)), i.raw.onData(async (l) => {
      await this._processManager.write(l), this._onDidInputData.fire(this);
    }), i.raw.onBinary((l) => this._processManager.processBinary(l)), this._processManager.onProcessReady(async (l) => {
      this._processManager.os && c.setOperatingSystem(this._processManager.os), i.raw.options.windowsPty = l.windowsPty;
    }), this._processManager.onRestoreCommands((l) => {
      var n;
      return (n = this.xterm) == null ? void 0 : n.shellIntegration.deserialize(l);
    }), this._register(this._viewDescriptorService.onDidChangeLocation(({ views: l }) => {
      l.some((n) => n.id === fe) && i.refresh();
    })), !this.capabilities.has(0)) {
      let l = i.raw.onKey((n) => {
        new co(n.domEvent).equals(3) && this._updateProcessCwd();
      });
      this._register(this.capabilities.onDidAddCapability((n) => {
        n === 0 && (l == null || l.dispose(), l = void 0);
      }));
    }
    return this._pathService.userHome().then((l) => {
      this._userHome = l.fsPath;
    }), this._isVisible && this._open(), i;
  }
  async _onLineDataSetup() {
    (this.xterm || await this._xtermReadyPromise).raw.loadAddon(this._lineDataEventAddon);
  }
  async runCommand(e, t) {
    var i;
    ((i = this.capabilities.get(2)) == null ? void 0 : i.hasInput) !== !1 && (await this.sendText("", !1), await di(100)), await this.sendText(e, t, !t);
  }
  async runRecent(e, t, i) {
    return this._scopedInstantiationService.invokeFunction(Cn, this, this._terminalInRunCommandPicker, e, t, i);
  }
  detachFromElement() {
    this._wrapperElement.remove(), this._container = void 0;
  }
  attachToElement(e) {
    var t;
    this._container !== e && (this._attachBarrier.open(), this._container = e, this._container.appendChild(this._wrapperElement), (t = this.xterm) == null || t.refresh(), setTimeout(() => this._initDragAndDrop(e)));
  }
  _open() {
    if (!this.xterm || this.xterm.raw.element)
      return;
    if (!this._container || !this._container.isConnected)
      throw new Error("A container element needs to be set with `attachToElement` and be part of the DOM before calling `_open`");
    const e = document.createElement("div");
    this._wrapperElement.appendChild(e), this._container.appendChild(this._wrapperElement);
    const t = this.xterm;
    this._wrapperElement.xterm = t.raw;
    const i = t.attachToElement(e);
    if (this._register(t.shellIntegration.onDidChangeStatus(() => {
      this.hasFocus ? this._setShellIntegrationContextKey() : this._terminalShellIntegrationEnabledContextKey.reset();
    })), !t.raw.element || !t.raw.textarea)
      throw new Error("xterm elements not set after open");
    this._setAriaLabel(t.raw, this._instanceId, this._title), t.raw.attachCustomKeyEventHandler((s) => {
      if (this._isExiting)
        return !1;
      const c = new co(s), l = this._keybindingService.softDispatch(c, c.target), n = l.kind === 1 && this._configHelper.config.allowChords && s.key !== "Escape";
      if (this._keybindingService.inChordMode || n)
        return s.preventDefault(), !1;
      const r = "terminal.integrated.showTerminalConfigPrompt", a = ["RightArrow", "LeftArrow", "UpArrow", "DownArrow", "Space", "Meta", "Control", "Shift", "Alt", "", "Delete", "Backspace", "Tab"];
      return this._storageService.getBoolean(r, -1, !0) && !a.includes(s.key) && !s.ctrlKey && !s.shiftKey && !s.altKey && (this._hasHadInput = !0), l.kind === 2 && l.commandId && this._skipTerminalCommands.some((f) => f === l.commandId) && !this._configHelper.config.sendKeybindingsToShell ? (this._storageService.getBoolean(r, -1, !0) && this._hasHadInput && !Ll.includes(l.commandId) && (this._notificationService.prompt(Te.Info, g(
        "keybindingHandling",
        "Some keybindings don't go to the terminal by default and are handled by {0} instead.",
        this._productService.nameLong
      ), [
        {
          label: g("configureTerminalSettings", "Configure Terminal Settings"),
          run: () => {
            this._preferencesService.openSettings({ jsonEditor: !1, query: "@id:terminal.integrated.commandsToSkipShell,terminal.integrated.sendKeybindingsToShell,terminal.integrated.allowChords" });
          }
        }
      ]), this._storageService.store(r, !1, -1, 0)), s.preventDefault(), !1) : !(this._configHelper.config.allowMnemonics && !rt && s.altKey || Pl.getTabFocusMode("terminalFocus") && s.key === "Tab" || Le && s.altKey && s.key === "F4" && !s.ctrlKey || !bi.clipboard.readText && s.key === "v" && s.ctrlKey);
    }), this._register(he(t.raw.element, "mousedown", () => {
      const s = he(document, "mouseup", () => {
        setTimeout(() => this._refreshSelectionContextKey(), 0), s.dispose();
      });
    })), this._register(he(t.raw.element, "touchstart", () => {
      t.raw.focus();
    })), this._register(he(t.raw.element, "keyup", () => {
      setTimeout(() => this._refreshSelectionContextKey(), 0);
    })), this._register(he(t.raw.textarea, "focus", () => this._setFocus(!0))), this._register(he(t.raw.textarea, "blur", () => this._setFocus(!1))), this._register(he(t.raw.textarea, "focusout", () => this._setFocus(!1))), this._initDragAndDrop(this._container), this._widgetManager.attachToElement(i), this._lastLayoutDimensions && this.layout(this._lastLayoutDimensions), this.updateConfig(), t.raw.options.disableStdin && this._attachPressAnyKeyToCloseListener(t.raw);
  }
  _setFocus(e) {
    e ? (this._terminalFocusContextKey.set(!0), this._setShellIntegrationContextKey(), this._onDidFocus.fire(this)) : (this.resetFocusContextKey(), this._onDidBlur.fire(this), this._refreshSelectionContextKey());
  }
  _setShellIntegrationContextKey() {
    this.xterm && this._terminalShellIntegrationEnabledContextKey.set(this.xterm.shellIntegration.status === 2);
  }
  resetFocusContextKey() {
    this._terminalFocusContextKey.reset(), this._terminalShellIntegrationEnabledContextKey.reset();
  }
  _initDragAndDrop(e) {
    var i;
    (i = this._dndObserver) == null || i.dispose();
    const t = this._scopedInstantiationService.createInstance(mr, e);
    t.onDropTerminal((s) => this._onRequestAddInstanceToGroup.fire(s)), t.onDropFile(async (s) => {
      this.focus(), await this.sendPath(s, !1);
    }), this._dndObserver = new Rl(e, t);
  }
  hasSelection() {
    return this.xterm ? this.xterm.raw.hasSelection() : !1;
  }
  async copySelection(e, t) {
    await (await this._xtermReadyPromise).copySelection(e, t);
  }
  get selection() {
    return this.xterm && this.hasSelection() ? this.xterm.raw.getSelection() : void 0;
  }
  clearSelection() {
    var e;
    (e = this.xterm) == null || e.raw.clearSelection();
  }
  _refreshAltBufferContextKey() {
    this._terminalAltBufferActiveContextKey.set(!!(this.xterm && this.xterm.raw.buffer.active === this.xterm.raw.buffer.alternate));
  }
  async _shouldPasteText(e) {
    var r;
    if ((r = this.xterm) != null && r.raw.modes.bracketedPasteMode)
      return !0;
    const t = e.split(/\r?\n/);
    if (t.length === 2 && t[1].trim().length === 0 || t.length === 1 || !this._configurationService.getValue("terminal.integrated.enableMultiLinePasteWarning"))
      return !0;
    const i = 3, s = 30;
    let c = g("preview", "Preview:");
    for (let a = 0; a < Math.min(t.length, i); a++) {
      const f = t[a], m = f.length > s ? `${f.slice(0, s)}…` : f;
      c += `
${m}`;
    }
    t.length > i && (c += `
…`);
    const { confirmed: l, checkboxChecked: n } = await this._dialogService.confirm({
      message: g(
        "confirmMoveTrashMessageFilesAndDirectories",
        "Are you sure you want to paste {0} lines of text into the terminal?",
        t.length
      ),
      detail: c,
      primaryButton: g(
        { key: "multiLinePasteButton", comment: ["&& denotes a mnemonic"] },
        "&&Paste"
      ),
      checkbox: {
        label: g("doNotAskAgain", "Do not ask me again")
      }
    });
    return l && n && await this._configurationService.updateValue("terminal.integrated.enableMultiLinePasteWarning", !1), l;
  }
  dispose(e) {
    var t, i;
    if (!this._isDisposed) {
      this._isDisposed = !0, this._logService.trace(`terminalInstance#dispose (instanceId: ${this.instanceId})`), ye(this._widgetManager), (t = this.xterm) != null && t.raw.element && (this._hadFocusOnExit = this.hasFocus), this._wrapperElement.xterm && (this._wrapperElement.xterm = void 0), this._horizontalScrollbar && (this._horizontalScrollbar.dispose(), this._horizontalScrollbar = void 0);
      try {
        (i = this.xterm) == null || i.dispose();
      } catch (s) {
        this._logService.error("Exception occurred during xterm disposal", s);
      }
      Ml && (this.resetFocusContextKey(), this._terminalHasTextContextKey.reset(), this._onDidBlur.fire(this)), this._pressAnyKeyToCloseListener && (this._pressAnyKeyToCloseListener.dispose(), this._pressAnyKeyToCloseListener = void 0), this._exitReason === void 0 && (this._exitReason = e ?? Et.Unknown), this._processManager.dispose(), this._onProcessExit(void 0), this._onDisposed.fire(this), super.dispose();
    }
  }
  async detachProcessAndDispose(e) {
    await this._processManager.detachFromProcess(e === Et.User), this.dispose(e);
  }
  focus(e) {
    var t;
    this._refreshAltBufferContextKey(), this.xterm && (e || !((t = window.getSelection()) != null && t.toString())) && (this.xterm.raw.focus(), this._onDidRequestFocus.fire());
  }
  async focusWhenReady(e) {
    await this._xtermReadyPromise, await this._attachBarrier.wait(), this.focus(e);
  }
  async paste() {
    if (!this.xterm)
      return;
    const e = await this._clipboardService.readText();
    await this._shouldPasteText(e) && (this.focus(), this.xterm.raw.paste(e));
  }
  async pasteSelection() {
    if (!this.xterm)
      return;
    const e = await this._clipboardService.readText("selection");
    await this._shouldPasteText(e) && (this.focus(), this.xterm.raw.paste(e));
  }
  async sendText(e, t, i) {
    var s, c, l, n;
    i && ((s = this.xterm) != null && s.raw.modes.bracketedPasteMode) && (e = `\x1B[200~${e}\x1B[201~`), e = e.replace(/\r?\n/g, "\r"), t && !e.endsWith("\r") && (e += "\r"), await this._processManager.write(e), this._onDidInputData.fire(this), (l = (c = this.xterm) == null ? void 0 : c.suggestController) == null || l.handleNonXtermData(e), (n = this.xterm) == null || n.scrollToBottom();
  }
  async sendPath(e, t) {
    return this.sendText(await this.preparePathForShell(e), t);
  }
  async preparePathForShell(e) {
    return await this.processReady, Qd(e, this.shellLaunchConfig.executable, this.title, this.shellType, this._processManager.backend, this._processManager.os);
  }
  setVisible(e) {
    this._isVisible = e, this._wrapperElement.classList.toggle("active", e), e && this.xterm && (this._open(), this._resize(), setTimeout(() => this.xterm.forceRefresh(), 0));
  }
  scrollDownLine() {
    var e;
    (e = this.xterm) == null || e.scrollDownLine();
  }
  scrollDownPage() {
    var e;
    (e = this.xterm) == null || e.scrollDownPage();
  }
  scrollToBottom() {
    var e;
    (e = this.xterm) == null || e.scrollToBottom();
  }
  scrollUpLine() {
    var e;
    (e = this.xterm) == null || e.scrollUpLine();
  }
  scrollUpPage() {
    var e;
    (e = this.xterm) == null || e.scrollUpPage();
  }
  scrollToTop() {
    var e;
    (e = this.xterm) == null || e.scrollToTop();
  }
  clearBuffer() {
    var e;
    this._processManager.clearBuffer(), (e = this.xterm) == null || e.clearBuffer();
  }
  _refreshSelectionContextKey() {
    const e = !!this._viewsService.getActiveViewWithId(fe);
    let t = !1;
    const i = this._editorService.activeEditor;
    i && (t = i instanceof it), this._terminalHasTextContextKey.set((e || t) && this.hasSelection());
  }
  _createProcessManager() {
    var i, s, c;
    let e;
    (i = this.shellLaunchConfig.attachPersistentProcess) != null && i.environmentVariableCollections && (e = Bl(this.shellLaunchConfig.attachPersistentProcess.environmentVariableCollections));
    const t = this._scopedInstantiationService.createInstance(hr, this._instanceId, this._configHelper, (s = this.shellLaunchConfig) == null ? void 0 : s.cwd, e, (c = this.shellLaunchConfig.attachPersistentProcess) == null ? void 0 : c.shellIntegrationNonce);
    return this.capabilities.add(t.capabilities), t.onProcessReady(async (l) => {
      this._onProcessIdReady.fire(this), this._initialCwd = await this.getInitialCwd(), this._labelComputer || (this._labelComputer = this._register(this._scopedInstantiationService.createInstance(fr, this._configHelper, this)), this._labelComputer.onDidChangeLabel((n) => {
        this._title = n.title, this._description = n.description, this._onTitleChanged.fire(this);
      })), this._shellLaunchConfig.name ? this._setTitle(this._shellLaunchConfig.name, Ye.Api) : (setTimeout(() => {
        this._xtermReadyPromise.then((n) => {
          this._messageTitleDisposable = n.raw.onTitleChange((r) => this._onTitleChange(r));
        });
      }), this._setTitle(this._shellLaunchConfig.executable, Ye.Process));
    }), t.onProcessExit((l) => this._onProcessExit(l)), t.onDidChangeProperty(({ type: l, value: n }) => {
      var r, a;
      switch (l) {
        case "cwd":
          this._cwd = n, (r = this._labelComputer) == null || r.refreshLabel();
          break;
        case "initialCwd":
          this._initialCwd = n, this._cwd = this._initialCwd, this._setTitle(this.title, Ye.Config), this._icon = ((a = this._shellLaunchConfig.attachPersistentProcess) == null ? void 0 : a.icon) || this._shellLaunchConfig.icon, this._onIconChanged.fire({ instance: this, userInitiated: !1 });
          break;
        case "title":
          this._setTitle(n ?? "", Ye.Process);
          break;
        case "overrideDimensions":
          this.setOverrideDimensions(n, !0);
          break;
        case "resolvedShellLaunchConfig":
          this._setResolvedShellLaunchConfig(n);
          break;
        case "shellType":
          this.setShellType(n);
          break;
        case "hasChildProcesses":
          this._onDidChangeHasChildProcesses.fire(n);
          break;
        case "usedShellIntegrationInjection":
          this._usedShellIntegrationInjection = !0;
          break;
      }
    }), t.onProcessData((l) => {
      var n;
      (n = this._initialDataEvents) == null || n.push(l.data), this._onData.fire(l.data);
    }), t.onProcessReplayComplete(() => this._onProcessReplayComplete.fire()), t.onEnvironmentVariableInfoChanged((l) => this._onEnvironmentVariableInfoChanged(l)), t.onPtyDisconnect(() => {
      this.xterm && (this.xterm.raw.options.disableStdin = !0), this.statusList.add({
        id: "disconnected",
        severity: Te.Error,
        icon: te.debugDisconnect,
        tooltip: g("disconnectStatus", "Lost connection to process")
      });
    }), t.onPtyReconnect(() => {
      this.xterm && (this.xterm.raw.options.disableStdin = !1), this.statusList.remove("disconnected");
    }), t;
  }
  async _createProcess() {
    var i, s, c;
    if (this._isDisposed)
      return;
    this._historyService.getLastActiveWorkspaceRoot(me.file) ? await this._trust() || this._onProcessExit({ message: g(
      "workspaceNotTrustedCreateTerminal",
      "Cannot launch a terminal process in an untrusted workspace"
    ) }) : this._cwd && this._userHome && this._cwd !== this._userHome && this._onProcessExit({
      message: g(
        "workspaceNotTrustedCreateTerminalCwd",
        "Cannot launch a terminal process in an untrusted workspace with cwd {0} and userHome {1}",
        this._cwd,
        this._userHome
      )
    }), this._container && this._cols === 0 && this._rows === 0 && (this._initDimensions(), (i = this.xterm) == null || i.raw.resize(this._cols || 80, this._rows || 30));
    const t = this.shellLaunchConfig.icon;
    await this._processManager.createProcess(this._shellLaunchConfig, this._cols || 80, this._rows || 30).then((l) => {
      l && ("message" in l ? this._onProcessExit(l) : "injectedArgs" in l && (this._injectedArgs = l.injectedArgs));
    }), (s = this.xterm) != null && s.shellIntegration && this.capabilities.add(this.xterm.shellIntegration.capabilities), (t !== this.shellLaunchConfig.icon || this.shellLaunchConfig.color) && (this._icon = ((c = this._shellLaunchConfig.attachPersistentProcess) == null ? void 0 : c.icon) || this._shellLaunchConfig.icon, this._onIconChanged.fire({ instance: this, userInitiated: !1 }));
  }
  registerMarker() {
    var e;
    return (e = this.xterm) == null ? void 0 : e.raw.registerMarker();
  }
  addBufferMarker(e) {
    var t;
    (t = this.capabilities.get(4)) == null || t.addMark(e);
  }
  scrollToMark(e, t, i) {
    var s;
    (s = this.xterm) == null || s.markTracker.scrollToClosestMarker(e, t, i);
  }
  async freePortKillProcess(e, t) {
    var i;
    await ((i = this._processManager) == null ? void 0 : i.freePortKillProcess(e)), this.runCommand(t, !1);
  }
  _onProcessData(e) {
    var i;
    const t = ++this._latestXtermWriteData;
    e.trackCommit ? e.writePromise = new Promise((s) => {
      var c;
      (c = this.xterm) == null || c.raw.write(e.data, () => {
        this._latestXtermParseData = t, this._processManager.acknowledgeDataEvent(e.data.length), s();
      });
    }) : (i = this.xterm) == null || i.raw.write(e.data, () => {
      this._latestXtermParseData = t, this._processManager.acknowledgeDataEvent(e.data.length);
    });
  }
  async _onProcessExit(e) {
    if (this._isExiting)
      return;
    const t = nu(e, this.shellLaunchConfig, this._processManager.processState, this._initialCwd);
    if (this._usedShellIntegrationInjection && this._processManager.processState === 4 && (t == null ? void 0 : t.code) !== 0) {
      this._relaunchWithShellIntegrationDisabled(t == null ? void 0 : t.message), this._onExit.fire(e);
      return;
    }
    this._isExiting = !0, await this._flushXtermData(), this._exitCode = t == null ? void 0 : t.code;
    const i = t == null ? void 0 : t.message;
    this._logService.debug("Terminal process exit", "instanceId", this.instanceId, "code", this._exitCode, "processState", this._processManager.processState);
    const s = this.waitOnExit;
    s && this._processManager.processState !== 5 ? this._xtermReadyPromise.then((c) => {
      switch (i && c.raw.write(yi(i)), typeof s) {
        case "string":
          c.raw.write(yi(s, { excludeLeadingNewLine: !0 }));
          break;
        case "function":
          this.exitCode !== void 0 && c.raw.write(yi(s(this.exitCode), { excludeLeadingNewLine: !0 }));
          break;
      }
      c.raw.options.disableStdin = !0, c.raw.textarea && this._attachPressAnyKeyToCloseListener(c.raw);
    }) : (this.dispose(Et.Process), i && (this._processManager.processState === 4 || this._configHelper.config.showExitAlert ? this._notificationService.notify({
      message: i,
      severity: Te.Error,
      actions: { primary: [this._scopedInstantiationService.createInstance(Fs)] }
    }) : this._logService.warn(i))), this._onExit.fire(e), this._isDisposed && this._onExit.dispose();
  }
  _relaunchWithShellIntegrationDisabled(e) {
    this._shellLaunchConfig.ignoreShellIntegration = !0, this.relaunch(), this.statusList.add({
      id: "shell-integration-attention-needed",
      severity: Te.Warning,
      icon: te.warning,
      tooltip: (`${e} ` ?? "") + g(
        "launchFailed.exitCodeOnlyShellIntegration",
        "Disabling shell integration in user settings might help."
      ),
      hoverActions: [{
        commandId: "workbench.action.terminal.learnMore",
        label: g("shellIntegration.learnMore", "Learn more about shell integration"),
        run: () => {
          this._openerService.open("https://code.visualstudio.com/docs/editor/integrated-terminal#_shell-integration");
        }
      }, {
        commandId: "workbench.action.openSettings",
        label: g("shellIntegration.openSettings", "Open user settings"),
        run: () => {
          this._commandService.executeCommand("workbench.action.openSettings", "terminal.integrated.shellIntegration.enabled");
        }
      }]
    }), this._telemetryService.publicLog2("terminal/shellIntegrationFailureProcessExit");
  }
  _flushXtermData() {
    if (this._latestXtermWriteData === this._latestXtermParseData)
      return Promise.resolve();
    let e = 0;
    return new Promise((t) => {
      const i = setInterval(() => {
        (this._latestXtermWriteData === this._latestXtermParseData || ++e === 5) && (clearInterval(i), t());
      }, 20);
    });
  }
  _attachPressAnyKeyToCloseListener(e) {
    e.textarea && !this._pressAnyKeyToCloseListener && (this._pressAnyKeyToCloseListener = he(e.textarea, "keypress", (t) => {
      this._pressAnyKeyToCloseListener && (this._pressAnyKeyToCloseListener.dispose(), this._pressAnyKeyToCloseListener = void 0, this.dispose(Et.Process), t.preventDefault());
    }));
  }
  _writeInitialText(e, t) {
    var s;
    if (!this._shellLaunchConfig.initialText) {
      t == null || t();
      return;
    }
    const i = typeof this._shellLaunchConfig.initialText == "string" ? this._shellLaunchConfig.initialText : (s = this._shellLaunchConfig.initialText) == null ? void 0 : s.text;
    typeof this._shellLaunchConfig.initialText == "string" || this._shellLaunchConfig.initialText.trailingNewLine ? e.raw.writeln(i, t) : e.raw.write(i, t);
  }
  async reuseTerminal(e, t = !1) {
    var s;
    (s = this._pressAnyKeyToCloseListener) == null || s.dispose(), this._pressAnyKeyToCloseListener = void 0;
    const i = this.xterm;
    i && (t || await new Promise((c) => i.raw.write(`
\x1B[G`, c)), e.initialText && (this._shellLaunchConfig.initialText = e.initialText, await new Promise((c) => this._writeInitialText(i, c))), this._isExiting && this._shellLaunchConfig.waitOnExit && (i.raw.options.disableStdin = !1, this._isExiting = !1), t && i.clearDecorations()), this.statusList.remove("relaunch-needed"), t || (e.initialText = " "), this._shellLaunchConfig = e, await this._processManager.relaunch(this._shellLaunchConfig, this._cols || 80, this._rows || 30, t).then((c) => {
      c && ("message" in c ? this._onProcessExit(c) : "injectedArgs" in c && (this._injectedArgs = c.injectedArgs));
    });
  }
  relaunch() {
    this.reuseTerminal(this._shellLaunchConfig, !0);
  }
  _onTitleChange(e) {
    this.isTitleSetByProcess && this._setTitle(e, Ye.Sequence);
  }
  async _trust() {
    return await this._workspaceTrustRequestService.requestWorkspaceTrust({
      message: g(
        "terminal.requestTrust",
        "Creating a terminal process requires executing code"
      )
    }) === !0;
  }
  async _onSelectionChange() {
    this._onDidChangeSelection.fire(this), this._configurationService.getValue("terminal.integrated.copyOnSelection") && this.hasSelection() && await this.copySelection();
  }
  async _updateProcessCwd() {
    if (!(this._isDisposed || this.shellLaunchConfig.customPtyImplementation))
      try {
        const e = await this._refreshProperty("cwd");
        if (typeof e != "string")
          throw new Error(`cwd is not a string ${e}`);
      } catch (e) {
        if (e instanceof Error && e.message === "Cannot refresh property when process is not set")
          return;
        throw e;
      }
  }
  updateConfig() {
    this._setCommandsToSkipShell(this._configHelper.config.commandsToSkipShell), this._refreshEnvironmentVariableInfoWidgetState(this._processManager.environmentVariableInfo);
  }
  async _updateUnicodeVersion() {
    this._processManager.setUnicodeVersion(this._configHelper.config.unicodeVersion);
  }
  updateAccessibilitySupport() {
    this.xterm.raw.options.screenReaderMode = this._accessibilityService.isScreenReaderOptimized();
  }
  _setCommandsToSkipShell(e) {
    const t = e.filter((i) => i[0] === "-").map((i) => i.slice(1));
    this._skipTerminalCommands = aa.filter((i) => !t.includes(i)).concat(e);
  }
  layout(e) {
    var i;
    if (this._lastLayoutDimensions = e, !(this.disableLayout || e.width <= 0 || e.height <= 0 || !this._evaluateColsAndRows(e.width, e.height))) {
      this._resize(), this._containerReadyBarrier.open();
      for (const s of this._contributions.values())
        this.xterm ? (i = s.layout) == null || i.call(s, this.xterm, e) : this._xtermReadyPromise.then((c) => {
          var l;
          return (l = s.layout) == null ? void 0 : l.call(s, c, e);
        });
    }
  }
  async _resize() {
    this._resizeNow(!1);
  }
  async _resizeNow(e) {
    let t = this.cols, i = this.rows;
    if (this.xterm) {
      if (this._isVisible && this._layoutSettingsChanged) {
        const s = this.xterm.getFont(), c = this._configHelper.config;
        this.xterm.raw.options.letterSpacing = s.letterSpacing, this.xterm.raw.options.lineHeight = s.lineHeight, this.xterm.raw.options.fontSize = s.fontSize, this.xterm.raw.options.fontFamily = s.fontFamily, this.xterm.raw.options.fontWeight = c.fontWeight, this.xterm.raw.options.fontWeightBold = c.fontWeightBold, this._initDimensions(), t = this.cols, i = this.rows, this._layoutSettingsChanged = !1;
      }
      if (isNaN(t) || isNaN(i))
        return;
      (t !== this.xterm.raw.cols || i !== this.xterm.raw.rows) && ((this._fixedRows || this._fixedCols) && await this._updateProperty("fixedDimensions", { cols: this._fixedCols, rows: this._fixedRows }), this._onDimensionsChanged.fire()), this.xterm.raw.resize(t, i), Ze._lastKnownGridDimensions = { cols: t, rows: i }, this._isVisible && this.xterm.forceUnpause();
    }
    e ? this._processManager.setDimensions(t, i, !0) : await this._processManager.setDimensions(t, i);
  }
  setShellType(e) {
    this._shellType = e, e && this._terminalShellTypeContextKey.set(e == null ? void 0 : e.toString());
  }
  _setAriaLabel(e, t, i) {
    var c;
    const s = [];
    if (e && e.textarea) {
      i && i.length > 0 ? s.push(g(
        "terminalTextBoxAriaLabelNumberAndTitle",
        "Terminal {0}, {1}",
        t,
        i
      )) : s.push(g("terminalTextBoxAriaLabel", "Terminal {0}", t)), this._accessibilityService.isScreenReaderOptimized() || s.push(g(
        "terminalScreenReaderMode",
        "Run the command: Toggle Screen Reader Accessibility Mode for an optimized screen reader experience"
      ));
      const n = (c = this._keybindingService.lookupKeybinding("editor.action.accessibilityHelp")) == null ? void 0 : c.getLabel();
      this._configurationService.getValue("accessibility.verbosity.terminal") && n && s.push(g(
        "terminalHelpAriaLabel",
        "Use {0} for terminal accessibility help",
        n
      )), e.textarea.setAttribute("aria-label", s.join(`
`));
    }
  }
  _updateTitleProperties(e, t) {
    if (!e)
      return this._processName;
    switch (t) {
      case Ye.Process:
        if (this._processManager.os === 1)
          e = Ts.parse(e).name;
        else {
          const i = e.indexOf(" ");
          e.startsWith("/") ? e = Ii(e) : i > -1 && (e = e.substring(0, i));
        }
        this._processName = e;
        break;
      case Ye.Api:
        this._staticTitle = e, ye(this._messageTitleDisposable), this._messageTitleDisposable = void 0;
        break;
      case Ye.Sequence:
        this._sequence = e, this._processManager.os === 1 && (e.match(/^[a-zA-Z]:\\.+\.[a-zA-Z]{1,3}/) ? (e = Ts.parse(e).name, this._sequence = e) : this._sequence = void 0);
        break;
    }
    return this._titleSource = t, e;
  }
  setOverrideDimensions(e, t = !1) {
    this._dimensionsOverride && this._dimensionsOverride.forceExactSize && !e && this._rows === 0 && this._cols === 0 && (this._cols = this._dimensionsOverride.cols, this._rows = this._dimensionsOverride.rows), this._dimensionsOverride = e, t ? this._resizeNow(!0) : this._resize();
  }
  async setFixedDimensions() {
    var i, s;
    const e = await this._quickInputService.input({
      title: g("setTerminalDimensionsColumn", "Set Fixed Dimensions: Column"),
      placeHolder: "Enter a number of columns or leave empty for automatic width",
      validateInput: async (c) => c.length > 0 && !c.match(/^\d+$/) ? { content: "Enter a number or leave empty size automatically", severity: Te.Error } : void 0
    });
    if (e === void 0)
      return;
    this._fixedCols = this._parseFixedDimension(e), (i = this._labelComputer) == null || i.refreshLabel(), this._terminalHasFixedWidth.set(!!this._fixedCols);
    const t = await this._quickInputService.input({
      title: g("setTerminalDimensionsRow", "Set Fixed Dimensions: Row"),
      placeHolder: "Enter a number of rows or leave empty for automatic height",
      validateInput: async (c) => c.length > 0 && !c.match(/^\d+$/) ? { content: "Enter a number or leave empty size automatically", severity: Te.Error } : void 0
    });
    t !== void 0 && (this._fixedRows = this._parseFixedDimension(t), (s = this._labelComputer) == null || s.refreshLabel(), await this._refreshScrollbar(), this._resize(), this.focus());
  }
  _parseFixedDimension(e) {
    if (e === "")
      return;
    const t = parseInt(e);
    if (t <= 0)
      throw new Error(`Could not parse dimension "${e}"`);
    return t;
  }
  async toggleSizeToContentWidth() {
    var e, t;
    if ((e = this.xterm) != null && e.raw.buffer.active) {
      if (this._hasScrollBar)
        this._terminalHasFixedWidth.set(!1), this._fixedCols = void 0, this._fixedRows = void 0, this._hasScrollBar = !1, this._initDimensions(), await this._resize();
      else {
        const i = Math.max(this.maxCols, Math.min(this.xterm.getLongestViewportWrappedLineLength(), 5e3));
        i > this.xterm.raw.cols && (this._fixedCols = i);
      }
      await this._refreshScrollbar(), (t = this._labelComputer) == null || t.refreshLabel(), this.focus();
    }
  }
  _refreshScrollbar() {
    return this._fixedCols || this._fixedRows ? this._addScrollbar() : this._removeScrollbar();
  }
  async _addScrollbar() {
    var t;
    const e = (this.xterm ? this.xterm.getFont() : this._configHelper.getFont()).charWidth;
    if (!(!((t = this.xterm) != null && t.raw.element) || !this._container || !e || !this._fixedCols) && (this._wrapperElement.classList.add("fixed-dims"), this._hasScrollBar = !0, this._initDimensions(), this._fixedRows = this._rows - 1, await this._resize(), this._terminalHasFixedWidth.set(!0), this._horizontalScrollbar || (this._horizontalScrollbar = this._register(new Ol(this._wrapperElement, {
      vertical: 2,
      horizontal: 1,
      useShadows: !1,
      scrollYToX: !1,
      consumeMouseWheelIfScrollbarIsNeeded: !1
    })), this._container.appendChild(this._horizontalScrollbar.getDomNode())), this._horizontalScrollbar.setScrollDimensions({
      width: this.xterm.raw.element.clientWidth,
      scrollWidth: this._fixedCols * e + 40
    }), this._horizontalScrollbar.getDomNode().style.paddingBottom = "16px", Le))
      for (let i = this.xterm.raw.buffer.active.viewportY; i < this.xterm.raw.buffer.active.length; i++) {
        const s = this.xterm.raw.buffer.active.getLine(i);
        s._line.isWrapped = !1;
      }
  }
  async _removeScrollbar() {
    !this._container || !this._horizontalScrollbar || (this._horizontalScrollbar.getDomNode().remove(), this._horizontalScrollbar.dispose(), this._horizontalScrollbar = void 0, this._wrapperElement.remove(), this._wrapperElement.classList.remove("fixed-dims"), this._container.appendChild(this._wrapperElement));
  }
  _setResolvedShellLaunchConfig(e) {
    this._shellLaunchConfig.args = e.args, this._shellLaunchConfig.cwd = e.cwd, this._shellLaunchConfig.executable = e.executable, this._shellLaunchConfig.env = e.env;
  }
  _onEnvironmentVariableInfoChanged(e) {
    var t, i;
    e.requiresAction && ((i = (t = this.xterm) == null ? void 0 : t.raw.textarea) == null || i.setAttribute("aria-label", g(
      "terminalStaleTextBoxAriaLabel",
      "Terminal {0} environment is stale, run the 'Show Environment Information' command for more information",
      this._instanceId
    ))), this._refreshEnvironmentVariableInfoWidgetState(e);
  }
  async _refreshEnvironmentVariableInfoWidgetState(e) {
    if (!e) {
      this.statusList.remove("relaunch-needed"), this.statusList.remove("env-var-info-changes-active");
      return;
    }
    if (e.requiresAction && this._configHelper.config.environmentChangesRelaunch && !this._processManager.hasWrittenData && (!this._shellLaunchConfig.isFeatureTerminal || this.reconnectionProperties && this._configurationService.getValue("task.reconnection") === !0) && !this._shellLaunchConfig.customPtyImplementation && !this._shellLaunchConfig.isExtensionOwnedTerminal && !this._shellLaunchConfig.attachPersistentProcess && !(this._processManager.remoteAuthority && this._configHelper.config.windowsEnableConpty && await this._processManager.getBackendOS() === 1)) {
      this.relaunch();
      return;
    }
    const t = lr(this.shellLaunchConfig.cwd, this._workspaceContextService, this._historyService);
    this.statusList.add(e.getStatus({ workspaceFolder: t }));
  }
  async getInitialCwd() {
    return this._initialCwd || (this._initialCwd = this._processManager.initialCwd), this._initialCwd;
  }
  async getCwd() {
    return this.capabilities.has(0) ? this.capabilities.get(0).getCwd() : this.capabilities.has(1) ? this.capabilities.get(1).getCwd() : this._processManager.initialCwd;
  }
  async _refreshProperty(e) {
    return await this.processReady, this._processManager.refreshProperty(e);
  }
  async _updateProperty(e, t) {
    return this._processManager.updateProperty(e, t);
  }
  async rename(e) {
    this._setTitle(e, Ye.Api);
  }
  _setTitle(e, t) {
    var c, l;
    const i = !e;
    e = this._updateTitleProperties(e, t);
    const s = e !== this._title;
    this._title = e, (c = this._labelComputer) == null || c.refreshLabel(i), this._setAriaLabel((l = this.xterm) == null ? void 0 : l.raw, this._instanceId, this._title), s && this._onTitleChanged.fire(this);
  }
  async changeIcon() {
    const e = [];
    for (const i of Ms())
      e.push({ label: `$(${i.id})`, description: `${i.id}`, icon: i });
    const t = await this._quickInputService.pick(e, {
      matchOnDescription: !0
    });
    t && (this._icon = t.icon, this._onIconChanged.fire({ instance: this, userInitiated: !0 }));
  }
  async changeColor() {
    if (!this._getIcon())
      return;
    const t = this._themeService.getColorTheme(), i = Fl(t), s = ta(t), c = [];
    for (const f of i) {
      const m = Jt(f);
      c.push({
        label: `$(${te.circleFilled.id}) ${f.replace("terminal.ansi", "")}`,
        id: f,
        description: f,
        iconClasses: [m]
      });
    }
    c.push({ type: "separator" });
    const l = { label: "Reset to default" };
    c.push(l), document.body.appendChild(s);
    const n = this._quickInputService.createQuickPick();
    n.items = c, n.matchOnDescription = !0, n.show();
    const r = [], a = await new Promise((f) => {
      r.push(n.onDidHide(() => f(void 0))), r.push(n.onDidAccept(() => f(n.selectedItems[0])));
    });
    ye(r), a && (this.shellLaunchConfig.color = a.id, this._onIconChanged.fire({ instance: this, userInitiated: !0 })), n.hide(), document.body.removeChild(s);
  }
  selectPreviousSuggestion() {
    var e, t;
    (t = (e = this.xterm) == null ? void 0 : e.suggestController) == null || t.selectPreviousSuggestion();
  }
  selectPreviousPageSuggestion() {
    var e, t;
    (t = (e = this.xterm) == null ? void 0 : e.suggestController) == null || t.selectPreviousPageSuggestion();
  }
  selectNextSuggestion() {
    var e, t;
    (t = (e = this.xterm) == null ? void 0 : e.suggestController) == null || t.selectNextSuggestion();
  }
  selectNextPageSuggestion() {
    var e, t;
    (t = (e = this.xterm) == null ? void 0 : e.suggestController) == null || t.selectNextPageSuggestion();
  }
  async acceptSelectedSuggestion(e) {
    var t, i;
    (i = (t = this.xterm) == null ? void 0 : t.suggestController) == null || i.acceptSelectedSuggestion(e);
  }
  hideSuggestWidget() {
    var e, t;
    (t = (e = this.xterm) == null ? void 0 : e.suggestController) == null || t.hideSuggestWidget();
  }
  forceScrollbarVisibility() {
    this._wrapperElement.classList.add("force-scrollbar");
  }
  resetScrollbarVisibility() {
    this._wrapperElement.classList.remove("force-scrollbar");
  }
}, Ze._instanceIdCounter = 1, Ze);
ot.__decorator = X([
  ft(50)
], ot.prototype, "_fireMaximumDimensionsChanged", null);
ot.__decorator = X([
  ft(1e3)
], ot.prototype, "relaunch", null);
ot.__decorator = X([
  ft(2e3)
], ot.prototype, "_updateProcessCwd", null);
ot.__decorator = X([
  ft(50)
], ot.prototype, "_resize", null);
ot = X([
  D(5, Fe),
  D(6, le),
  D(7, ii),
  D(8, ra),
  D(9, ui),
  D(10, Ee),
  D(11, Gr),
  D(12, Yr),
  D(13, $n),
  D(14, Me),
  D(15, Se),
  D(16, Ot),
  D(17, nn),
  D(18, ti),
  D(19, ns),
  D(20, Xn),
  D(21, qe),
  D(22, Fi),
  D(23, tt),
  D(24, Bi),
  D(25, Hl),
  D(26, jn),
  D(27, Ni),
  D(28, tn),
  D(29, dt),
  D(30, jr),
  D(31, an)
], ot);
let mr = class extends ue {
  get onDropFile() {
    return this._onDropFile.event;
  }
  get onDropTerminal() {
    return this._onDropTerminal.event;
  }
  constructor(e, t, i) {
    super(), this._container = e, this._layoutService = t, this._viewDescriptorService = i, this._onDropFile = new V(), this._onDropTerminal = new V(), this._register(je(() => this._clearDropOverlay()));
  }
  _clearDropOverlay() {
    this._dropOverlay && this._dropOverlay.parentElement && this._dropOverlay.parentElement.removeChild(this._dropOverlay), this._dropOverlay = void 0;
  }
  onDragEnter(e) {
    if (zi(e, wi.FILES, wi.RESOURCES, "Terminals", Tn.FILES)) {
      if (this._dropOverlay || (this._dropOverlay = document.createElement("div"), this._dropOverlay.classList.add("terminal-drop-overlay")), zi(e, "Terminals")) {
        const t = this._getDropSide(e);
        this._dropOverlay.classList.toggle("drop-before", t === "before"), this._dropOverlay.classList.toggle("drop-after", t === "after");
      }
      this._dropOverlay.parentElement || this._container.appendChild(this._dropOverlay);
    }
  }
  onDragLeave(e) {
    this._clearDropOverlay();
  }
  onDragEnd(e) {
    this._clearDropOverlay();
  }
  onDragOver(e) {
    if (!(!e.dataTransfer || !this._dropOverlay)) {
      if (zi(e, "Terminals")) {
        const t = this._getDropSide(e);
        this._dropOverlay.classList.toggle("drop-before", t === "before"), this._dropOverlay.classList.toggle("drop-after", t === "after");
      }
      this._dropOverlay.style.opacity = "1";
    }
  }
  async onDrop(e) {
    if (this._clearDropOverlay(), !e.dataTransfer)
      return;
    const t = Fa(e);
    if (t) {
      for (const l of t) {
        const n = this._getDropSide(e);
        this._onDropTerminal.fire({ uri: l, side: n });
      }
      return;
    }
    let i;
    const s = e.dataTransfer.getData(wi.RESOURCES);
    s && (i = oe.parse(JSON.parse(s)[0]));
    const c = e.dataTransfer.getData(Tn.FILES);
    !i && c && (i = oe.file(JSON.parse(c)[0])), !i && e.dataTransfer.files.length > 0 && e.dataTransfer.files[0].path && (i = oe.file(e.dataTransfer.files[0].path)), i && this._onDropFile.fire(i);
  }
  _getDropSide(e) {
    const t = this._container;
    if (!t)
      return "after";
    const i = t.getBoundingClientRect();
    return this._getViewOrientation() === 1 ? e.clientX - i.left < i.width / 2 ? "before" : "after" : e.clientY - i.top < i.height / 2 ? "before" : "after";
  }
  _getViewOrientation() {
    const e = this._layoutService.getPanelPosition();
    return this._viewDescriptorService.getViewLocationById(fe) === 1 && e === 2 ? 1 : 0;
  }
};
mr = X([
  D(1, ss),
  D(2, an)
], mr);
let fr = class extends ue {
  get title() {
    return this._title;
  }
  get description() {
    return this._description;
  }
  constructor(e, t, i, s) {
    super(), this._configHelper = e, this._instance = t, this._fileService = i, this._workspaceContextService = s, this._title = "", this._description = "", this._onDidChangeLabel = this._register(new V()), this.onDidChangeLabel = this._onDidChangeLabel.event;
  }
  refreshLabel(e) {
    this._title = this.computeLabel(this._configHelper.config.tabs.title, "title", e), this._description = this.computeLabel(this._configHelper.config.tabs.description, "description"), (this._title !== this._instance.title || this._description !== this._instance.description || e) && this._onDidChangeLabel.fire({ title: this._title, description: this._description });
  }
  computeLabel(e, t, i) {
    var f, m, C, b;
    const s = ((f = this._instance.shellLaunchConfig.attachPersistentProcess) == null ? void 0 : f.type) || this._instance.shellLaunchConfig.type, c = {
      cwd: this._instance.cwd || this._instance.initialCwd || "",
      cwdFolder: "",
      workspaceFolder: this._instance.workspaceFolder ? Ii(this._instance.workspaceFolder.uri.fsPath) : void 0,
      local: s === "Local" ? s : void 0,
      process: this._instance.processName,
      sequence: this._instance.sequence,
      task: s === "Task" ? s : void 0,
      fixedDimensions: this._instance.fixedCols ? this._instance.fixedRows ? `↔${this._instance.fixedCols} ↕${this._instance.fixedRows}` : `↔${this._instance.fixedCols}` : this._instance.fixedRows ? `↕${this._instance.fixedRows}` : "",
      separator: { label: this._configHelper.config.tabs.separator }
    };
    if (e = e.trim(), !e)
      return t === "title" && this._instance.processName || "";
    if (!i && this._instance.staticTitle && t === "title")
      return this._instance.staticTitle.replace(/[\n\r\t]/g, "") || ((m = c.process) == null ? void 0 : m.replace(/[\n\r\t]/g, "")) || "";
    const l = this._instance.capabilities.has(0) || this._instance.capabilities.has(1), r = this._workspaceContextService.getWorkspace().folders.length > 1;
    if (c.cwd && l && (!this._instance.shellLaunchConfig.isFeatureTerminal || t === "title")) {
      const p = oe.from({
        scheme: ((C = this._instance.workspaceFolder) == null ? void 0 : C.uri.scheme) || me.file,
        path: this._instance.cwd ? Wl(this._instance.cwd) : void 0
      });
      let S = !1;
      if (r)
        S = !0;
      else if ((b = this._instance.workspaceFolder) != null && b.uri) {
        const o = this._fileService.hasCapability(this._instance.workspaceFolder.uri, 1024);
        S = p.fsPath.localeCompare(this._instance.workspaceFolder.uri.fsPath, void 0, { sensitivity: o ? "case" : "base" }) !== 0;
      }
      S && (c.cwdFolder = Ii(c.cwd));
    }
    const a = Nl(e, c).replace(/[\n\r\t]/g, "").trim();
    return a === "" && t === "title" ? this._instance.processName || "" : a;
  }
};
fr = X([
  D(2, Oi),
  D(3, tt)
], fr);
function nu(h, e, t, i) {
  if (h === void 0 || h === 0)
    return { code: h, message: void 0 };
  const s = typeof h == "number" ? h : h.code;
  let c;
  switch (typeof h) {
    case "number": {
      let l;
      e.executable && (l = e.executable, typeof e.args == "string" ? l += ` ${e.args}` : e.args && e.args.length && (l += e.args.map((n) => ` '${n}'`).join())), t === 4 ? l ? c = g(
        "launchFailed.exitCodeAndCommandLine",
        'The terminal process "{0}" failed to launch (exit code: {1}).',
        l,
        s
      ) : c = g(
        "launchFailed.exitCodeOnly",
        "The terminal process failed to launch (exit code: {0}).",
        s
      ) : l ? c = g(
        "terminated.exitCodeAndCommandLine",
        'The terminal process "{0}" terminated with exit code: {1}.',
        l,
        s
      ) : c = g(
        "terminated.exitCodeOnly",
        "The terminal process terminated with exit code: {0}.",
        s
      );
      break;
    }
    case "object": {
      if (h.message.toString().includes("Could not find pty with id"))
        break;
      let l = h.message;
      const n = h.message.match(/.*error code:\s*(\d+).*$/);
      if (n)
        switch (n.length > 1 ? parseInt(n[1]) : void 0) {
          case 5:
            l = `Access was denied to the path containing your executable "${e.executable}". Manage and change your permissions to get this to work`;
            break;
          case 267:
            l = `Invalid starting directory "${i}", review your terminal.integrated.cwd setting`;
            break;
          case 1260:
            l = "Windows cannot open this program because it has been prevented by a software restriction policy. For more information, open Event Viewer or contact your system Administrator";
            break;
        }
      c = g(
        "launchFailed.errorMessage",
        "The terminal process failed to launch: {0}.",
        l
      );
      break;
    }
  }
  return { code: s, message: c };
}
let Rt = class {
  get isProcessSupportRegistered() {
    return !!this._processSupportContextKey.get();
  }
  get connectionState() {
    return this._connectionState;
  }
  get whenConnected() {
    return this._whenConnected.p;
  }
  get restoredGroupCount() {
    return this._restoredGroupCount;
  }
  get configHelper() {
    return this._configHelper;
  }
  get instances() {
    return this._terminalGroupService.instances.concat(this._terminalEditorService.instances);
  }
  get detachedXterms() {
    return this._detachedXterms;
  }
  getReconnectedTerminals(e) {
    return this._reconnectedTerminals.get(e);
  }
  get defaultLocation() {
    return this.configHelper.config.defaultLocation === "editor" ? se.Editor : se.Panel;
  }
  get activeInstance() {
    for (const e of this._hostActiveTerminals.values())
      if (e != null && e.hasFocus)
        return e;
    return this._activeInstance;
  }
  get onDidChangeActiveGroup() {
    return this._onDidChangeActiveGroup.event;
  }
  get onDidCreateInstance() {
    return this._onDidCreateInstance.event;
  }
  get onDidDisposeInstance() {
    return this._onDidDisposeInstance.event;
  }
  get onDidFocusInstance() {
    return this._onDidFocusInstance.event;
  }
  get onDidReceiveProcessId() {
    return this._onDidReceiveProcessId.event;
  }
  get onDidRequestStartExtensionTerminal() {
    return this._onDidRequestStartExtensionTerminal.event;
  }
  get onDidChangeInstanceDimensions() {
    return this._onDidChangeInstanceDimensions.event;
  }
  get onDidMaximumDimensionsChange() {
    return this._onDidMaxiumumDimensionsChange.event;
  }
  get onDidChangeInstanceCapability() {
    return this._onDidChangeInstanceCapability.event;
  }
  get onDidChangeInstances() {
    return this._onDidChangeInstances.event;
  }
  get onDidChangeInstanceTitle() {
    return this._onDidChangeInstanceTitle.event;
  }
  get onDidChangeInstanceIcon() {
    return this._onDidChangeInstanceIcon.event;
  }
  get onDidChangeInstanceColor() {
    return this._onDidChangeInstanceColor.event;
  }
  get onDidChangeActiveInstance() {
    return this._onDidChangeActiveInstance.event;
  }
  get onDidChangeInstancePrimaryStatus() {
    return this._onDidChangeInstancePrimaryStatus.event;
  }
  get onDidInputInstanceData() {
    return this._onDidInputInstanceData.event;
  }
  get onDidChangeSelection() {
    return this._onDidChangeSelection.event;
  }
  get onDidDisposeGroup() {
    return this._onDidDisposeGroup.event;
  }
  get onDidChangeGroups() {
    return this._onDidChangeGroups.event;
  }
  get onDidRegisterProcessSupport() {
    return this._onDidRegisterProcessSupport.event;
  }
  get onDidChangeConnectionState() {
    return this._onDidChangeConnectionState.event;
  }
  constructor(e, t, i, s, c, l, n, r, a, f, m, C, b, p, S, o, _, u, d, v) {
    this._contextKeyService = e, this._lifecycleService = t, this._logService = i, this._dialogService = s, this._instantiationService = c, this._remoteAgentService = l, this._viewsService = n, this._configurationService = r, this._environmentService = a, this._terminalEditorService = f, this._terminalGroupService = m, this._terminalInstanceService = C, this._editorGroupsService = b, this._terminalProfileService = p, this._extensionService = S, this._notificationService = o, this._workspaceContextService = _, this._commandService = u, this._keybindingService = d, this._timerService = v, this._hostActiveTerminals = /* @__PURE__ */ new Map(), this._detachedXterms = /* @__PURE__ */ new Set(), this._isShuttingDown = !1, this._backgroundedTerminalInstances = [], this._backgroundedTerminalDisposables = /* @__PURE__ */ new Map(), this._connectionState = 0, this._whenConnected = new ca(), this._restoredGroupCount = 0, this._reconnectedTerminals = /* @__PURE__ */ new Map(), this._onDidChangeActiveGroup = new V(), this._onDidCreateInstance = new V(), this._onDidDisposeInstance = new V(), this._onDidFocusInstance = new V(), this._onDidReceiveProcessId = new V(), this._onDidRequestStartExtensionTerminal = new V(), this._onDidChangeInstanceDimensions = new V(), this._onDidMaxiumumDimensionsChange = new V(), this._onDidChangeInstanceCapability = new V(), this._onDidChangeInstances = new V(), this._onDidChangeInstanceTitle = new V(), this._onDidChangeInstanceIcon = new V(), this._onDidChangeInstanceColor = new V(), this._onDidChangeActiveInstance = new V(), this._onDidChangeInstancePrimaryStatus = new V(), this._onDidInputInstanceData = new V(), this._onDidChangeSelection = new V(), this._onDidDisposeGroup = new V(), this._onDidChangeGroups = new V(), this._onDidRegisterProcessSupport = new V(), this._onDidChangeConnectionState = new V(), this._configHelper = this._instantiationService.createInstance(Fn), this.onDidCreateInstance(() => this._terminalProfileService.refreshAvailableProfiles()), this._forwardInstanceHostEvents(this._terminalGroupService), this._forwardInstanceHostEvents(this._terminalEditorService), this._terminalGroupService.onDidChangeActiveGroup(this._onDidChangeActiveGroup.fire, this._onDidChangeActiveGroup), this._terminalInstanceService.onDidCreateInstance((w) => {
      this._initInstanceListeners(w), this._onDidCreateInstance.fire(w);
    }), this._terminalGroupService.onDidChangeActiveInstance((w) => {
      !w && !this._isShuttingDown && this._terminalGroupService.hidePanel(), w != null && w.shellType ? this._terminalShellTypeContextKey.set(w.shellType.toString()) : w || this._terminalShellTypeContextKey.reset();
    }), this._handleInstanceContextKeys(), this._terminalShellTypeContextKey = E.shellType.bindTo(this._contextKeyService), this._processSupportContextKey = E.processSupported.bindTo(this._contextKeyService), this._processSupportContextKey.set(!ki || this._remoteAgentService.getConnection() !== null || Oe.as(Ki.Backend).getTerminalBackend() !== void 0), this._terminalHasBeenCreated = E.terminalHasBeenCreated.bindTo(this._contextKeyService), this._terminalCountContextKey = E.count.bindTo(this._contextKeyService), this._terminalEditorActive = E.terminalEditorActive.bindTo(this._contextKeyService), this.onDidChangeActiveInstance((w) => {
      this._terminalEditorActive.set(!!(w != null && w.target) && w.target === se.Editor);
    }), t.onBeforeShutdown(async (w) => w.veto(this._onBeforeShutdown(w.reason), "veto.terminal")), t.onWillShutdown((w) => this._onWillShutdown(w)), this.initializePrimaryBackend(), di(0).then(() => this._instantiationService.createInstance(_r, document.head));
  }
  async showProfileQuickPick(e, t) {
    var l, n;
    const s = await this._instantiationService.createInstance(Zs).showAndGetResult(e);
    if (!s || typeof s == "string")
      return;
    const c = s.keyMods;
    if (e === "createInstance") {
      const r = this.getDefaultInstanceHost().activeInstance;
      let a;
      if (s.config && "id" in (s == null ? void 0 : s.config)) {
        await this.createContributedTerminalProfile(s.config.extensionIdentifier, s.config.id, {
          icon: (l = s.config.options) == null ? void 0 : l.icon,
          color: (n = s.config.options) == null ? void 0 : n.color,
          location: c != null && c.alt && r ? { splitActiveTerminal: !0 } : this.defaultLocation
        });
        return;
      } else
        s.config && "profileName" in s.config && (c != null && c.alt && r ? a = await this.createTerminal({ location: { parentTerminal: r }, config: s.config, cwd: t }) : a = await this.createTerminal({ location: this.defaultLocation, config: s.config, cwd: t }));
      if (a && this.defaultLocation !== se.Editor)
        return this._terminalGroupService.showPanel(!0), this.setActiveInstance(a), a;
    }
  }
  async initializePrimaryBackend() {
    var s;
    Ce("code/terminal/willGetTerminalBackend"), this._primaryBackend = await this._terminalInstanceService.getBackend(this._environmentService.remoteAuthority), Ce("code/terminal/didGetTerminalBackend");
    const e = this.configHelper.config.enablePersistentSessions;
    this._connectionState = 0;
    const t = !!this._environmentService.remoteAuthority && e;
    (s = this._primaryBackend) == null || s.onDidRequestDetach(async (c) => {
      var n, r, a;
      const l = this.getInstanceFromResource(Oa(c.workspaceId, c.instanceId));
      if (l) {
        const f = l == null ? void 0 : l.persistentProcessId;
        f && !l.shellLaunchConfig.isFeatureTerminal && !l.shellLaunchConfig.customPtyImplementation ? (l.target === se.Editor ? this._terminalEditorService.detachInstance(l) : (n = this._terminalGroupService.getGroupForInstance(l)) == null || n.removeInstance(l), await l.detachProcessAndDispose(Et.User), await ((r = this._primaryBackend) == null ? void 0 : r.acceptDetachInstanceReply(c.requestId, f))) : await ((a = this._primaryBackend) == null ? void 0 : a.acceptDetachInstanceReply(c.requestId, void 0));
      }
    }), Ce("code/terminal/willReconnect");
    let i;
    t ? i = this._reconnectToRemoteTerminals() : e ? i = this._reconnectToLocalTerminals() : i = Promise.resolve(), i.then(async () => {
      var l;
      this._setConnected(), Ce("code/terminal/didReconnect"), Ce("code/terminal/willReplay");
      const c = await ((l = this._reconnectedTerminalGroups) == null ? void 0 : l.then((n) => n.map((r) => r.terminalInstances).flat())) ?? [];
      await Promise.all(c.map((n) => new Promise((r) => be.once(n.onProcessReplayComplete)(r)))), Ce("code/terminal/didReplay"), Ce("code/terminal/willGetPerformanceMarks"), await Promise.all(Array.from(this._terminalInstanceService.getRegisteredBackends()).map(async (n) => {
        this._timerService.setPerformanceMarks(n.remoteAuthority === void 0 ? "localPtyHost" : "remotePtyHost", await n.getPerformanceMarks()), n.setReady();
      })), Ce("code/terminal/didGetPerformanceMarks"), this._whenConnected.complete();
    });
  }
  getPrimaryBackend() {
    return this._primaryBackend;
  }
  _forwardInstanceHostEvents(e) {
    e.onDidChangeInstances(this._onDidChangeInstances.fire, this._onDidChangeInstances), e.onDidDisposeInstance(this._onDidDisposeInstance.fire, this._onDidDisposeInstance), e.onDidChangeActiveInstance((t) => this._evaluateActiveInstance(e, t)), e.onDidFocusInstance((t) => {
      this._onDidFocusInstance.fire(t), this._evaluateActiveInstance(e, t);
    }), e.onDidChangeInstanceCapability((t) => {
      this._onDidChangeInstanceCapability.fire(t);
    }), this._hostActiveTerminals.set(e, void 0);
  }
  _evaluateActiveInstance(e, t) {
    if (this._hostActiveTerminals.set(e, t), t === void 0)
      for (const i of this._hostActiveTerminals.values())
        i && (t = i);
    this._activeInstance = t, this._onDidChangeActiveInstance.fire(t);
  }
  setActiveInstance(e) {
    e.shellLaunchConfig.hideFromUser && this._showBackgroundTerminal(e), e.target === se.Editor ? this._terminalEditorService.setActiveInstance(e) : this._terminalGroupService.setActiveInstance(e);
  }
  async focusActiveInstance() {
    if (this._activeInstance)
      return this._activeInstance.target === se.Editor ? this._terminalEditorService.focusActiveInstance() : this._terminalGroupService.focusActiveInstance();
  }
  async createContributedTerminalProfile(e, t, i) {
    var c;
    await this._extensionService.activateByEvent(`onTerminalProfile:${t}`);
    const s = this._terminalProfileService.getContributedProfileProvider(e, t);
    if (!s) {
      this._notificationService.error(`No terminal profile provider registered for id "${t}"`);
      return;
    }
    try {
      await s.createContributedTerminalProfile(i), this._terminalGroupService.setActiveInstanceByIndex(this._terminalGroupService.instances.length - 1), await ((c = this._terminalGroupService.activeInstance) == null ? void 0 : c.focusWhenReady());
    } catch (l) {
      this._notificationService.error(l.message);
    }
  }
  async safeDisposeTerminal(e) {
    if (!(e.target !== se.Editor && e.hasChildProcesses && (this.configHelper.config.confirmOnKill === "panel" || this.configHelper.config.confirmOnKill === "always") && await this._showTerminalCloseConfirmation(!0)))
      return new Promise((t) => {
        e.onExit(() => t()), e.dispose(Et.User);
      });
  }
  _setConnected() {
    this._connectionState = 1, this._onDidChangeConnectionState.fire(), this._logService.trace("Pty host ready");
  }
  async _reconnectToRemoteTerminals() {
    const e = this._environmentService.remoteAuthority;
    if (!e)
      return;
    const t = await this._terminalInstanceService.getBackend(e);
    if (!t)
      return;
    Ce("code/terminal/willGetTerminalLayoutInfo");
    const i = await t.getTerminalLayoutInfo();
    Ce("code/terminal/didGetTerminalLayoutInfo"), t.reduceConnectionGraceTime(), Ce("code/terminal/willRecreateTerminalGroups"), await this._recreateTerminalGroups(i), Ce("code/terminal/didRecreateTerminalGroups"), this._attachProcessLayoutListeners(), this._logService.trace("Reconnected to remote terminals");
  }
  async _reconnectToLocalTerminals() {
    const e = await this._terminalInstanceService.getBackend();
    if (!e)
      return;
    Ce("code/terminal/willGetTerminalLayoutInfo");
    const t = await e.getTerminalLayoutInfo();
    Ce("code/terminal/didGetTerminalLayoutInfo"), t && t.tabs.length > 0 && (Ce("code/terminal/willRecreateTerminalGroups"), this._reconnectedTerminalGroups = this._recreateTerminalGroups(t), Ce("code/terminal/didRecreateTerminalGroups")), this._attachProcessLayoutListeners(), this._logService.trace("Reconnected to local terminals");
  }
  _recreateTerminalGroups(e) {
    const t = [];
    let i;
    if (e) {
      for (const s of e.tabs) {
        const c = s.terminals.filter((l) => l.terminal && l.terminal.isOrphan);
        if (c.length) {
          this._restoredGroupCount += c.length;
          const l = this._recreateTerminalGroup(s, c);
          t.push(l), s.isActive && (i = l);
          const n = this.instances.find((r) => {
            var a;
            return ((a = r.shellLaunchConfig.attachPersistentProcess) == null ? void 0 : a.id) === s.activePersistentProcessId;
          });
          n && this.setActiveInstance(n);
        }
      }
      e.tabs.length && (i == null || i.then((s) => this._terminalGroupService.activeGroup = s));
    }
    return Promise.all(t).then((s) => s.filter((c) => !!c));
  }
  async _recreateTerminalGroup(e, t) {
    let i, s;
    for (const c of t) {
      const l = c.terminal;
      this._lifecycleService.startupKind !== 3 && l.type === "Task" || (Ce(`code/terminal/willRecreateTerminal/${l.id}-${l.pid}`), i ? i = this.createTerminal({
        config: { attachPersistentProcess: l },
        location: { parentTerminal: i }
      }) : (i = this.createTerminal({
        config: { attachPersistentProcess: l },
        location: se.Panel
      }), s = i.then((n) => this._terminalGroupService.getGroupForInstance(n))), Ce(`code/terminal/didRecreateTerminal/${l.id}-${l.pid}`));
    }
    return s == null || s.then((c) => c == null ? void 0 : c.resizePanes(e.terminals.map((l) => l.relativeSize))), s;
  }
  _attachProcessLayoutListeners() {
    this.onDidChangeActiveGroup(() => this._saveState()), this.onDidChangeActiveInstance(() => this._saveState()), this.onDidChangeInstances(() => this._saveState()), this.onDidReceiveProcessId(() => this._saveState()), this.onDidChangeInstanceTitle((e) => this._updateTitle(e)), this.onDidChangeInstanceIcon((e) => this._updateIcon(e.instance, e.userInitiated));
  }
  _handleInstanceContextKeys() {
    const e = E.isOpen.bindTo(this._contextKeyService), t = () => {
      e.set(this.instances.length > 0), this._terminalCountContextKey.set(this.instances.length);
    };
    this.onDidChangeInstances(() => t());
  }
  async getActiveOrCreateInstance(e) {
    var s;
    const t = this.activeInstance;
    if (!t)
      return this.createTerminal();
    if (!(e != null && e.acceptsInput) || ((s = t.xterm) == null ? void 0 : s.isStdinDisabled) !== !0)
      return t;
    const i = await this.createTerminal();
    return this.setActiveInstance(i), await this.revealActiveTerminal(), i;
  }
  async revealActiveTerminal() {
    const e = this.activeInstance;
    e && (e.target === se.Editor ? await this._terminalEditorService.revealActiveEditor() : await this._terminalGroupService.showPanel());
  }
  setEditable(e, t) {
    var c;
    t ? this._editable = { instance: e, data: t } : this._editable = void 0;
    const i = this._viewsService.getActiveViewWithId(fe), s = this.isEditable(e);
    (c = i == null ? void 0 : i.terminalTabbedView) == null || c.setEditable(s);
  }
  isEditable(e) {
    return !!this._editable && (this._editable.instance === e || !e);
  }
  getEditableData(e) {
    return this._editable && this._editable.instance === e ? this._editable.data : void 0;
  }
  requestStartExtensionTerminal(e, t, i) {
    return new Promise((s) => {
      this._onDidRequestStartExtensionTerminal.fire({ proxy: e, cols: t, rows: i, callback: s });
    });
  }
  _onBeforeShutdown(e) {
    return ki ? (this._isShuttingDown = !0, !1) : this._onBeforeShutdownAsync(e);
  }
  async _onBeforeShutdownAsync(e) {
    var t, i;
    if (this.instances.length === 0)
      return !1;
    try {
      if (this._shutdownWindowCount = await ((t = this._nativeDelegate) == null ? void 0 : t.getWindowCount()), this._shouldReviveProcesses(e) && await Promise.race([
        (i = this._primaryBackend) == null ? void 0 : i.persistTerminalState(),
        di(2e3)
      ]), !(this._configHelper.config.enablePersistentSessions && e === 3) && (this.configHelper.config.confirmOnExit === "always" && this.instances.length > 0 || this.configHelper.config.confirmOnExit === "hasChildProcesses" && this.instances.some((n) => n.hasChildProcesses)))
        return this._onBeforeShutdownConfirmation(e);
    } catch (s) {
      this._logService.warn("Exception occurred during terminal shutdown", s);
    }
    return this._isShuttingDown = !0, !1;
  }
  setNativeDelegate(e) {
    this._nativeDelegate = e;
  }
  _shouldReviveProcesses(e) {
    if (!this._configHelper.config.enablePersistentSessions)
      return !1;
    switch (this.configHelper.config.persistentSessionReviveProcess) {
      case "onExit":
        return e === 1 && this._shutdownWindowCount === 1 && !rt ? !0 : e === 4 || e === 2;
      case "onExitAndWindowClose":
        return e !== 3;
      default:
        return !1;
    }
  }
  async _onBeforeShutdownConfirmation(e) {
    const t = await this._showTerminalCloseConfirmation();
    return t || (this._isShuttingDown = !0), t;
  }
  _onWillShutdown(e) {
    var i;
    const t = this._configHelper.config.enablePersistentSessions && e.reason === 3;
    for (const s of [...this._terminalGroupService.instances, ...this._backgroundedTerminalInstances])
      t && s.shouldPersist ? s.detachProcessAndDispose(Et.Shutdown) : s.dispose(Et.Shutdown);
    !t && !this._shouldReviveProcesses(e.reason) && ((i = this._primaryBackend) == null || i.setTerminalLayoutInfo(void 0));
  }
  _saveState() {
    var i;
    if (this._isShuttingDown || !this.configHelper.config.enablePersistentSessions)
      return;
    const t = { tabs: this._terminalGroupService.groups.map((s) => s.getLayoutInfo(s === this._terminalGroupService.activeGroup)) };
    (i = this._primaryBackend) == null || i.setTerminalLayoutInfo(t);
  }
  _updateTitle(e) {
    var t, i;
    !this.configHelper.config.enablePersistentSessions || !e || !e.persistentProcessId || !e.title || e.isDisposed || (e.staticTitle ? (t = this._primaryBackend) == null || t.updateTitle(e.persistentProcessId, e.staticTitle, Ye.Api) : (i = this._primaryBackend) == null || i.updateTitle(e.persistentProcessId, e.title, e.titleSource));
  }
  _updateIcon(e, t) {
    var i;
    !this.configHelper.config.enablePersistentSessions || !e || !e.persistentProcessId || !e.icon || e.isDisposed || (i = this._primaryBackend) == null || i.updateIcon(e.persistentProcessId, t, e.icon, e.color);
  }
  refreshActiveGroup() {
    this._onDidChangeActiveGroup.fire(this._terminalGroupService.activeGroup);
  }
  getInstanceFromId(e) {
    let t = -1;
    if (this._backgroundedTerminalInstances.forEach((i, s) => {
      i.instanceId === e && (t = s);
    }), t !== -1)
      return this._backgroundedTerminalInstances[t];
    try {
      return this.instances[this._getIndexFromId(e)];
    } catch {
      return;
    }
  }
  getInstanceFromIndex(e) {
    return this.instances[e];
  }
  getInstanceFromResource(e) {
    return to(this.instances, e);
  }
  isAttachedToTerminal(e) {
    return this.instances.some((t) => t.processId === e.pid);
  }
  moveToEditor(e) {
    if (e.target === se.Editor)
      return;
    const t = this._terminalGroupService.getGroupForInstance(e);
    t && (t.removeInstance(e), this._terminalEditorService.openEditor(e));
  }
  async moveToTerminalView(e, t, i) {
    if (oe.isUri(e) && (e = this.getInstanceFromResource(e)), !e)
      return;
    if (this._terminalEditorService.detachInstance(e), e.target !== se.Editor) {
      await this._terminalGroupService.showPanel(!0);
      return;
    }
    e.target = se.Panel;
    let s;
    if (t && (s = this._terminalGroupService.getGroupForInstance(t)), s || (s = this._terminalGroupService.createGroup()), s.addInstance(e), this.setActiveInstance(e), await this._terminalGroupService.showPanel(!0), t && i) {
      const c = s.terminalInstances.indexOf(t) + (i === "after" ? 1 : 0);
      s.moveInstance(e, c);
    }
    this._onDidChangeInstances.fire(), this._onDidChangeActiveGroup.fire(this._terminalGroupService.activeGroup);
  }
  _initInstanceListeners(e) {
    const t = [
      e.onTitleChanged(this._onDidChangeInstanceTitle.fire, this._onDidChangeInstanceTitle),
      e.onIconChanged(this._onDidChangeInstanceIcon.fire, this._onDidChangeInstanceIcon),
      e.onIconChanged(this._onDidChangeInstanceColor.fire, this._onDidChangeInstanceColor),
      e.onProcessIdReady(this._onDidReceiveProcessId.fire, this._onDidReceiveProcessId),
      e.statusList.onDidChangePrimaryStatus(() => this._onDidChangeInstancePrimaryStatus.fire(e)),
      e.onDimensionsChanged(() => {
        this._onDidChangeInstanceDimensions.fire(e), this.configHelper.config.enablePersistentSessions && this.isProcessSupportRegistered && this._saveState();
      }),
      e.onMaximumDimensionsChanged(() => this._onDidMaxiumumDimensionsChange.fire(e)),
      e.onDidInputData(this._onDidInputInstanceData.fire, this._onDidInputInstanceData),
      e.onDidFocus(this._onDidChangeActiveInstance.fire, this._onDidChangeActiveInstance),
      e.onRequestAddInstanceToGroup(async (i) => await this._addInstanceToGroup(e, i)),
      e.onDidChangeSelection(this._onDidChangeSelection.fire, this._onDidChangeSelection)
    ];
    e.onDisposed(() => ye(t));
  }
  async _addInstanceToGroup(e, t) {
    var c;
    const i = eo(t.uri);
    if (i.instanceId === void 0)
      return;
    let s = this.getInstanceFromResource(t.uri);
    if (!s) {
      const l = await ((c = this._primaryBackend) == null ? void 0 : c.requestDetachInstance(i.workspaceId, i.instanceId));
      if (l) {
        s = await this.createTerminal({ config: { attachPersistentProcess: l }, resource: t.uri }), this._terminalGroupService.moveInstance(s, e, t.side);
        return;
      }
    }
    if (s = this._terminalGroupService.getInstanceFromResource(t.uri), s) {
      this._terminalGroupService.moveInstance(s, e, t.side);
      return;
    }
    if (s = this._terminalEditorService.getInstanceFromResource(t.uri), s) {
      this.moveToTerminalView(s, e, t.side);
      return;
    }
  }
  registerProcessSupport(e) {
    e && (this._processSupportContextKey.set(e), this._onDidRegisterProcessSupport.fire());
  }
  _getIndexFromId(e) {
    let t = -1;
    if (this.instances.forEach((i, s) => {
      i.instanceId === e && (t = s);
    }), t === -1)
      throw new Error(`Terminal with ID ${e} does not exist (has it already been disposed?)`);
    return t;
  }
  async _showTerminalCloseConfirmation(e) {
    let t;
    this.instances.length === 1 || e ? t = g(
      "terminalService.terminalCloseConfirmationSingular",
      "Do you want to terminate the active terminal session?"
    ) : t = g(
      "terminalService.terminalCloseConfirmationPlural",
      "Do you want to terminate the {0} active terminal sessions?",
      this.instances.length
    );
    const { confirmed: i } = await this._dialogService.confirm({
      type: "warning",
      message: t,
      primaryButton: g({ key: "terminate", comment: ["&& denotes a mnemonic"] }, "&&Terminate")
    });
    return !i;
  }
  getDefaultInstanceHost() {
    return this.defaultLocation === se.Editor ? this._terminalEditorService : this._terminalGroupService;
  }
  async getInstanceHost(e) {
    if (e) {
      if (e === se.Editor)
        return this._terminalEditorService;
      if (typeof e == "object") {
        if ("viewColumn" in e)
          return this._terminalEditorService;
        if ("parentTerminal" in e)
          return (await e.parentTerminal).target === se.Editor ? this._terminalEditorService : this._terminalGroupService;
      } else
        return this._terminalGroupService;
    }
    return this;
  }
  async createTerminal(e) {
    if (this._terminalProfileService.availableProfiles.length === 0) {
      const r = (e == null ? void 0 : e.config) && "customPtyImplementation" in e.config, a = this._remoteAgentService.getConnection() && oe.isUri(e == null ? void 0 : e.cwd) && (e == null ? void 0 : e.cwd.scheme) === me.vscodeFileResource;
      !r && !a && (this._connectionState === 0 && Ce("code/terminal/willGetProfiles"), await this._terminalProfileService.profilesReady, this._connectionState === 0 && Ce("code/terminal/didGetProfiles"));
    }
    const t = (e == null ? void 0 : e.config) || this._terminalProfileService.getDefaultProfile(), i = t && "extensionIdentifier" in t ? {} : this._terminalInstanceService.convertProfileToShellLaunchConfig(t || {});
    let s = t && "extensionIdentifier" in t ? t : void 0;
    !s && (!e || !e.config) && (s = await this._terminalProfileService.getContributedDefaultProfile(i));
    const c = typeof (e == null ? void 0 : e.location) == "object" && "splitActiveTerminal" in e.location ? e.location.splitActiveTerminal : typeof (e == null ? void 0 : e.location) == "object" ? "parentTerminal" in e.location : !1;
    if (await this._resolveCwd(i, c, e), s) {
      const r = await this.resolveLocation(e == null ? void 0 : e.location);
      let a;
      c ? a = r === se.Editor ? { viewColumn: Vn } : { splitActiveTerminal: !0 } : a = typeof (e == null ? void 0 : e.location) == "object" && "viewColumn" in e.location ? e.location : r, await this.createContributedTerminalProfile(s.extensionIdentifier, s.id, {
        icon: s.icon,
        color: s.color,
        location: a
      });
      const f = r === se.Editor ? this._terminalEditorService : this._terminalGroupService, m = f.instances[f.instances.length - 1];
      return await m.focusWhenReady(), this._terminalHasBeenCreated.set(!0), m;
    }
    if (!i.customPtyImplementation && !this.isProcessSupportRegistered)
      throw new Error("Could not create terminal when process support is not registered");
    if (i.hideFromUser) {
      const r = this._terminalInstanceService.createInstance(i, se.Panel);
      return this._backgroundedTerminalInstances.push(r), this._backgroundedTerminalDisposables.set(r.instanceId, [
        r.onDisposed(this._onDidDisposeInstance.fire, this._onDidDisposeInstance)
      ]), this._terminalHasBeenCreated.set(!0), r;
    }
    this._evaluateLocalCwd(i);
    const l = await this.resolveLocation(e == null ? void 0 : e.location) || this.defaultLocation, n = await this._getSplitParent(e == null ? void 0 : e.location);
    return this._terminalHasBeenCreated.set(!0), n ? this._splitTerminal(i, l, n) : this._createTerminal(i, l, e);
  }
  async createDetachedXterm(e) {
    const t = await ot.getXtermConstructor(this._keybindingService, this._contextKeyService), i = this._instantiationService.createInstance(Di, t, this._configHelper, e.cols, e.rows, e.colorProvider, e.capabilities || new io(), "", void 0, !1);
    return e.readonly && i.raw.attachCustomKeyEventHandler(() => !1), this._detachedXterms.add(i), i.onDidDispose(() => this._detachedXterms.delete(i)), i;
  }
  async _resolveCwd(e, t, i) {
    if (!e.cwd) {
      if (i != null && i.cwd)
        e.cwd = i.cwd;
      else if (t && (i != null && i.location)) {
        let c = this.activeInstance;
        if (typeof i.location == "object" && "parentTerminal" in i.location && (c = await i.location.parentTerminal), !c)
          throw new Error("Cannot split without an active instance");
        e.cwd = await Ea(this.configHelper, c, this._workspaceContextService.getWorkspace().folders, this._commandService);
      }
    }
  }
  _splitTerminal(e, t, i) {
    let s;
    if (typeof e.cwd != "object" && typeof i.shellLaunchConfig.cwd == "object" && (e.cwd = oe.from({
      scheme: i.shellLaunchConfig.cwd.scheme,
      authority: i.shellLaunchConfig.cwd.authority,
      path: e.cwd || i.shellLaunchConfig.cwd.path
    })), t === se.Editor || i.target === se.Editor)
      s = this._terminalEditorService.splitInstance(i, e);
    else {
      const c = this._terminalGroupService.getGroupForInstance(i);
      if (!c)
        throw new Error(`Cannot split a terminal without a group ${i}`);
      e.parentTerminalId = i.instanceId, s = c.split(e);
    }
    return this._addToReconnected(s), s;
  }
  _addToReconnected(e) {
    var i;
    if (!((i = e.reconnectionProperties) != null && i.ownerId))
      return;
    const t = this._reconnectedTerminals.get(e.reconnectionProperties.ownerId);
    t ? t.push(e) : this._reconnectedTerminals.set(e.reconnectionProperties.ownerId, [e]);
  }
  _createTerminal(e, t, i) {
    let s;
    const c = this._getEditorOptions(i == null ? void 0 : i.location);
    return t === se.Editor ? (s = this._terminalInstanceService.createInstance(e, se.Editor), this._terminalEditorService.openEditor(s, c)) : s = this._terminalGroupService.createGroup(e).terminalInstances[0], this._addToReconnected(s), s;
  }
  async resolveLocation(e) {
    var t, i;
    if (e && typeof e == "object")
      if ("parentTerminal" in e) {
        const s = await e.parentTerminal;
        return s.target ? s.target : se.Panel;
      } else {
        if ("viewColumn" in e)
          return se.Editor;
        if ("splitActiveTerminal" in e)
          return (t = this._activeInstance) != null && t.target ? (i = this._activeInstance) == null ? void 0 : i.target : se.Panel;
      }
    return e;
  }
  async _getSplitParent(e) {
    if (e && typeof e == "object" && "parentTerminal" in e)
      return e.parentTerminal;
    if (e && typeof e == "object" && "splitActiveTerminal" in e)
      return this.activeInstance;
  }
  _getEditorOptions(e) {
    if (e && typeof e == "object" && "viewColumn" in e)
      return e.viewColumn = $l(this._editorGroupsService, this._configurationService, e.viewColumn), e;
  }
  _evaluateLocalCwd(e) {
    var t;
    typeof e.cwd != "string" && ((t = e.cwd) == null ? void 0 : t.scheme) === me.file && (Ul.getValue(this._contextKeyService) ? (e.initialText = yi(g(
      "localTerminalVirtualWorkspace",
      "This shell is open to a {0}local{1} folder, NOT to the virtual folder",
      "\x1B[3m",
      "\x1B[23m"
    ), { excludeLeadingNewLine: !0, loudFormatting: !0 }), e.type = "Local") : this._remoteAgentService.getConnection() && (e.initialText = yi(g(
      "localTerminalRemote",
      "This shell is running on your {0}local{1} machine, NOT on the connected remote machine",
      "\x1B[3m",
      "\x1B[23m"
    ), { excludeLeadingNewLine: !0, loudFormatting: !0 }), e.type = "Local"));
  }
  _showBackgroundTerminal(e) {
    this._backgroundedTerminalInstances.splice(this._backgroundedTerminalInstances.indexOf(e), 1);
    const t = this._backgroundedTerminalDisposables.get(e.instanceId);
    t && ye(t), this._backgroundedTerminalDisposables.delete(e.instanceId), e.shellLaunchConfig.hideFromUser = !1, this._terminalGroupService.createGroup(e), this.instances.length === 1 && this._terminalGroupService.setActiveInstanceByIndex(0), this._onDidChangeInstances.fire(), this._onDidChangeGroups.fire();
  }
  async setContainers(e, t) {
    this._configHelper.panelContainer = e, this._terminalGroupService.setContainer(t);
  }
  getEditingTerminal() {
    return this._editingTerminal;
  }
  setEditingTerminal(e) {
    this._editingTerminal = e;
  }
};
Rt.__decorator = X([
  ft(500)
], Rt.prototype, "_saveState", null);
Rt.__decorator = X([
  ft(500)
], Rt.prototype, "_updateTitle", null);
Rt.__decorator = X([
  ft(500)
], Rt.prototype, "_updateIcon", null);
Rt = X([
  D(0, Fe),
  D(1, is),
  D(2, Ot),
  D(3, nn),
  D(4, le),
  D(5, Mt),
  D(6, Yr),
  D(7, Se),
  D(8, Fi),
  D(9, li),
  D(10, Ae),
  D(11, yt),
  D(12, Ur),
  D(13, Bt),
  D(14, mt),
  D(15, Ee),
  D(16, tt),
  D(17, dt),
  D(18, ui),
  D(19, Vl)
], Rt);
let _r = class extends la {
  constructor(e, t, i, s, c) {
    super(i), this._terminalService = t, this._themeService = i, this._terminalProfileService = s, this._editorService = c, this._registerListeners(), this._styleElement = document.createElement("style"), e.appendChild(this._styleElement), this._register(je(() => e.removeChild(this._styleElement))), this.updateStyles();
  }
  _registerListeners() {
    this._register(this._terminalService.onDidChangeInstanceIcon(() => this.updateStyles())), this._register(this._terminalService.onDidChangeInstanceColor(() => this.updateStyles())), this._register(this._terminalService.onDidCreateInstance(() => this.updateStyles())), this._register(this._editorService.onDidActiveEditorChange(() => {
      this._editorService.activeEditor instanceof it && this.updateStyles();
    })), this._register(this._editorService.onDidCloseEditor(() => {
      this._editorService.activeEditor instanceof it && this.updateStyles();
    })), this._register(this._terminalProfileService.onDidChangeAvailableProfiles(() => this.updateStyles()));
  }
  updateStyles() {
    var c;
    super.updateStyles();
    const e = this._themeService.getColorTheme();
    let t = "";
    const i = this._themeService.getProductIconTheme();
    for (const l of this._terminalService.instances) {
      const n = l.icon;
      if (!n)
        continue;
      let r;
      n instanceof oe ? r = n : n instanceof Object && "light" in n && "dark" in n && (r = e.type === ha.LIGHT ? n.light : n.dark);
      const a = fi(l, e.type);
      if (r instanceof oe && a && a.length > 1 && (t += `.monaco-workbench .terminal-tab.${a[0]}::before{background-image: ${da(r)};}`), re.isThemeIcon(n)) {
        const m = ts().getIcon(n.id);
        if (m) {
          const C = i.getIcon(m);
          C && (t += `.monaco-workbench .terminal-tab.codicon-${n.id}::before{content: '${C.fontCharacter}' !important; font-family: ${Gl(((c = C.font) == null ? void 0 : c.id) ?? "codicon")} !important;}`);
        }
      }
    }
    const s = e.getColor(zl);
    s && (t += `.monaco-workbench .show-file-icons .file-icon.terminal-tab::before { color: ${s}; }`), t += Kl(e, !0), this._styleElement.textContent = t;
  }
};
_r = X([
  D(1, we),
  D(2, Me),
  D(3, Bt),
  D(4, Bi)
], _r);
let gr = class extends ue {
  constructor(e, t, i, s, c, l) {
    super(), this._editorService = e, this._editorGroupsService = t, this._terminalInstanceService = i, this._instantiationService = s, this.instances = [], this._activeInstanceIndex = -1, this._isShuttingDown = !1, this._editorInputs = /* @__PURE__ */ new Map(), this._instanceDisposables = /* @__PURE__ */ new Map(), this._onDidDisposeInstance = new V(), this.onDidDisposeInstance = this._onDidDisposeInstance.event, this._onDidFocusInstance = new V(), this.onDidFocusInstance = this._onDidFocusInstance.event, this._onDidChangeInstanceCapability = new V(), this.onDidChangeInstanceCapability = this._onDidChangeInstanceCapability.event, this._onDidChangeActiveInstance = new V(), this.onDidChangeActiveInstance = this._onDidChangeActiveInstance.event, this._onDidChangeInstances = new V(), this.onDidChangeInstances = this._onDidChangeInstances.event, this._terminalEditorActive = E.terminalEditorActive.bindTo(l), this._register(je(() => {
      for (const n of this._instanceDisposables.values())
        ye(n);
    })), this._register(c.onWillShutdown(() => this._isShuttingDown = !0)), this._register(this._editorService.onDidActiveEditorChange(() => {
      var f;
      const n = this._editorService.activeEditor, r = n instanceof it ? n == null ? void 0 : n.terminalInstance : void 0, a = !!r && n instanceof it;
      if (this._terminalEditorActive.set(a), a)
        n == null || n.setGroup((f = this._editorService.activeEditorPane) == null ? void 0 : f.group), this.setActiveInstance(r);
      else
        for (const m of this.instances)
          m.resetFocusContextKey();
    })), this._register(this._editorService.onDidVisibleEditorsChange(() => {
      const n = this.instances.map((f) => f.instanceId), a = this._getActiveTerminalEditors().find((f) => {
        var C;
        const m = f instanceof it ? (C = f.terminalInstance) == null ? void 0 : C.instanceId : void 0;
        return m === void 0 ? !1 : !n.includes(m);
      });
      a instanceof it && a.terminalInstance && (this._editorInputs.set(a.terminalInstance.resource.path, a), this.instances.push(a.terminalInstance));
    })), this._register(this._editorService.onDidCloseEditor((n) => {
      const r = n.editor instanceof it ? n.editor.terminalInstance : void 0;
      if (r) {
        const a = this.instances.findIndex((f) => f === r);
        if (a !== -1) {
          const f = this.instances[a] === this.activeInstance;
          this._removeInstance(r), f && this.setActiveInstance(void 0);
        }
      }
    }));
  }
  _getActiveTerminalEditors() {
    return this._editorService.visibleEditors.filter((e) => {
      var t;
      return e instanceof it && ((t = e.terminalInstance) == null ? void 0 : t.instanceId);
    });
  }
  get activeInstance() {
    if (!(this.instances.length === 0 || this._activeInstanceIndex === -1))
      return this.instances[this._activeInstanceIndex];
  }
  setActiveInstance(e) {
    this._activeInstanceIndex = e ? this.instances.findIndex((t) => t === e) : -1, this._onDidChangeActiveInstance.fire(this.activeInstance);
  }
  async focusActiveInstance() {
    var e;
    return (e = this.activeInstance) == null ? void 0 : e.focusWhenReady(!0);
  }
  async openEditor(e, t) {
    var s, c;
    const i = this.resolveResource(e);
    i && (await ((s = this._activeOpenEditorRequest) == null ? void 0 : s.promise), this._activeOpenEditorRequest = {
      instanceId: e.instanceId,
      promise: this._editorService.openEditor({
        resource: i,
        description: e.description || e.shellLaunchConfig.type,
        options: {
          pinned: !0,
          forceReload: !0,
          preserveFocus: t == null ? void 0 : t.preserveFocus
        }
      }, (t == null ? void 0 : t.viewColumn) ?? Qr)
    }, await ((c = this._activeOpenEditorRequest) == null ? void 0 : c.promise), this._activeOpenEditorRequest = void 0);
  }
  resolveResource(e) {
    const t = e.resource, i = t.path, s = this._editorInputs.get(i);
    if (s)
      return s.resource;
    e.target = se.Editor;
    const c = this._instantiationService.createInstance(it, t, e);
    return this._registerInstance(i, c, e), c.resource;
  }
  getInputFromResource(e) {
    const t = this._editorInputs.get(e.path);
    if (!t)
      throw new Error(`Could not get input from resource: ${e.path}`);
    return t;
  }
  _registerInstance(e, t, i) {
    this._editorInputs.set(e, t), this._instanceDisposables.set(e, [
      i.onDidFocus(this._onDidFocusInstance.fire, this._onDidFocusInstance),
      i.onDisposed(this._onDidDisposeInstance.fire, this._onDidDisposeInstance),
      i.capabilities.onDidAddCapability(() => this._onDidChangeInstanceCapability.fire(i)),
      i.capabilities.onDidRemoveCapability(() => this._onDidChangeInstanceCapability.fire(i))
    ]), this.instances.push(i), this._onDidChangeInstances.fire();
  }
  _removeInstance(e) {
    const t = e.resource.path;
    this._editorInputs.delete(t);
    const i = this.instances.findIndex((c) => c === e);
    i !== -1 && this.instances.splice(i, 1);
    const s = this._instanceDisposables.get(t);
    this._instanceDisposables.delete(t), s && ye(s), this._onDidChangeInstances.fire();
  }
  getInstanceFromResource(e) {
    return to(this.instances, e);
  }
  splitInstance(e, t = {}) {
    var c;
    if (e.target === se.Editor) {
      const l = (c = this._editorInputs.get(e.resource.path)) == null ? void 0 : c.group;
      l && this._editorGroupsService.activateGroup(l);
    }
    const i = this._terminalInstanceService.createInstance(t, se.Editor), s = this.resolveResource(i);
    return s && this._editorService.openEditor({
      resource: oe.revive(s),
      description: i.description,
      options: {
        pinned: !0,
        forceReload: !0
      }
    }, Vn), i;
  }
  reviveInput(e) {
    if ("pid" in e) {
      const t = { ...e, findRevivedId: !0 }, i = this._terminalInstanceService.createInstance({ attachPersistentProcess: t }, se.Editor), s = this._instantiationService.createInstance(it, i.resource, i);
      return this._registerInstance(i.resource.path, s, i), s;
    } else
      throw new Error(`Could not revive terminal editor input, ${e}`);
  }
  detachInstance(e) {
    const t = e.resource.path, i = this._editorInputs.get(t);
    i == null || i.detachInstance(), this._removeInstance(e), this._isShuttingDown || i == null || i.dispose();
  }
  async revealActiveEditor(e) {
    var s;
    const t = this.activeInstance;
    if (!t || ((s = this._activeOpenEditorRequest) == null ? void 0 : s.instanceId) === t.instanceId)
      return;
    const i = this._editorInputs.get(t.resource.path);
    this._editorService.openEditor(i, {
      pinned: !0,
      forceReload: !0,
      preserveFocus: e,
      activation: ql.PRESERVE
    });
  }
};
gr = X([
  D(0, Bi),
  D(1, Ur),
  D(2, yt),
  D(3, le),
  D(4, is),
  D(5, Fe)
], gr);
let pr = class extends ue {
  get onDidChange() {
    return this._onDidChange;
  }
  constructor(e, t, i) {
    super(), this._container = e, this.orientation = t, this._layoutService = i, this._splitViewDisposables = this._register(new Zt()), this._children = [], this._terminalToPane = /* @__PURE__ */ new Map(), this._onDidChange = be.None, this._width = this._container.offsetWidth, this._height = this._container.offsetHeight, this._createSplitView(), this._splitView.layout(this.orientation === 1 ? this._width : this._height);
  }
  _createSplitView() {
    this._splitView = new ua(this._container, { orientation: this.orientation }), this._splitViewDisposables.clear(), this._splitViewDisposables.add(this._splitView.onDidSashReset(() => this._splitView.distributeViewSizes()));
  }
  split(e, t) {
    this._addChild(e, t);
  }
  resizePane(e, t, i, s) {
    const c = t === 0 || t === 1;
    if (c && this.orientation !== 1 || !c && this.orientation !== 0) {
      (this.orientation === 1 && t === 3 || this.orientation === 0 && t === 1) && (i *= -1), this._layoutService.resizePart(s, i, i);
      return;
    }
    if (this._children.length <= 1)
      return;
    const l = [];
    for (let a = 0; a < this._splitView.length; a++)
      l.push(this._splitView.getViewSize(a));
    const n = e !== this._children.length - 1, r = n ? e + 1 : e - 1;
    (n && t === 0 || !n && t === 1 || n && t === 2 || !n && t === 3) && (i *= -1), l[e] + i < 80 ? i = 80 - l[e] : l[r] - i < 80 && (i = l[r] - 80), l[e] += i, l[r] -= i;
    for (let a = 0; a < this._splitView.length - 1; a++)
      this._splitView.resizeView(a, l[a]);
  }
  resizePanes(e) {
    if (this._children.length <= 1)
      return;
    e[e.length - 1] += 1 - e.reduce((i, s) => i + s, 0);
    let t = 0;
    for (let i = 0; i < this._splitView.length; i++)
      t += this._splitView.getViewSize(i);
    for (let i = 0; i < this._splitView.length; i++)
      this._splitView.resizeView(i, t * e[i]);
  }
  getPaneSize(e) {
    const t = this._terminalToPane.get(e);
    if (!t)
      return 0;
    const i = this._children.indexOf(t);
    return this._splitView.getViewSize(i);
  }
  _addChild(e, t) {
    const i = new su(
      e,
      this.orientation === 1 ? this._height : this._width
    );
    i.orientation = this.orientation, typeof t == "number" ? this._children.splice(t, 0, i) : this._children.push(i), this._terminalToPane.set(e, this._children[this._children.indexOf(i)]), this._withDisabledLayout(() => this._splitView.addView(i, Dn.Distribute, t)), this.layout(this._width, this._height), this._onDidChange = be.any(...this._children.map((s) => s.onDidChange));
  }
  remove(e) {
    let t = null;
    for (let i = 0; i < this._children.length; i++)
      this._children[i].instance === e && (t = i);
    t !== null && (this._children.splice(t, 1), this._terminalToPane.delete(e), this._splitView.removeView(t, Dn.Distribute), e.detachFromElement());
  }
  layout(e, t) {
    this._width = e, this._height = t, this.orientation === 1 ? (this._children.forEach((i) => i.orthogonalLayout(t)), this._splitView.layout(e)) : (this._children.forEach((i) => i.orthogonalLayout(e)), this._splitView.layout(t));
  }
  setOrientation(e) {
    if (this.orientation !== e) {
      for (this.orientation = e; this._container.children.length > 0; )
        this._container.removeChild(this._container.children[0]);
      this._splitViewDisposables.clear(), this._splitView.dispose(), this._createSplitView(), this._withDisabledLayout(() => {
        this._children.forEach((t) => {
          t.orientation = e, this._splitView.addView(t, 1);
        });
      });
    }
  }
  _withDisabledLayout(e) {
    this._children.forEach((t) => t.instance.disableLayout = !0), e(), this._children.forEach((t) => t.instance.disableLayout = !1);
  }
};
pr = X([
  D(2, ss)
], pr);
class su {
  get onDidChange() {
    return this._onDidChange;
  }
  constructor(e, t) {
    this.instance = e, this.orthogonalSize = t, this.minimumSize = 80, this.maximumSize = Number.MAX_VALUE, this._onDidChange = be.None, this.element = document.createElement("div"), this.element.className = "terminal-split-pane", this.instance.attachToElement(this.element);
  }
  layout(e) {
    !e || !this.orthogonalSize || (this.orientation === 0 ? this.instance.layout({ width: this.orthogonalSize, height: e }) : this.instance.layout({ width: e, height: this.orthogonalSize }));
  }
  orthogonalLayout(e) {
    this.orthogonalSize = e;
  }
}
let vr = class extends ue {
  get terminalInstances() {
    return this._terminalInstances;
  }
  constructor(e, t, i, s, c, l, n) {
    super(), this._container = e, this._terminalService = i, this._terminalInstanceService = s, this._layoutService = c, this._viewDescriptorService = l, this._instantiationService = n, this._terminalInstances = [], this._panelPosition = 2, this._terminalLocation = 1, this._instanceDisposables = /* @__PURE__ */ new Map(), this._activeInstanceIndex = -1, this._onDidDisposeInstance = this._register(new V()), this.onDidDisposeInstance = this._onDidDisposeInstance.event, this._onDidFocusInstance = this._register(new V()), this.onDidFocusInstance = this._onDidFocusInstance.event, this._onDidChangeInstanceCapability = this._register(new V()), this.onDidChangeInstanceCapability = this._onDidChangeInstanceCapability.event, this._onDisposed = this._register(new V()), this.onDisposed = this._onDisposed.event, this._onInstancesChanged = this._register(new V()), this.onInstancesChanged = this._onInstancesChanged.event, this._onDidChangeActiveInstance = new V(), this.onDidChangeActiveInstance = this._onDidChangeActiveInstance.event, this._onPanelOrientationChanged = new V(), this.onPanelOrientationChanged = this._onPanelOrientationChanged.event, t && this.addInstance(t), this._container && this.attachToElement(this._container), this._onPanelOrientationChanged.fire(this._terminalLocation === 1 && this._panelPosition === 2 ? 1 : 0);
  }
  addInstance(e, t) {
    let i;
    const s = t ? this._terminalInstances.findIndex((c) => c.instanceId === t) : this._activeInstanceIndex;
    "instanceId" in e ? i = e : i = this._terminalInstanceService.createInstance(e, se.Panel), this._terminalInstances.length === 0 ? (this._terminalInstances.push(i), this._activeInstanceIndex = 0) : this._terminalInstances.splice(s + 1, 0, i), this._initInstanceListeners(i), this._splitPaneContainer && this._splitPaneContainer.split(i, s + 1), this._onInstancesChanged.fire();
  }
  dispose() {
    super.dispose(), this._container && this._groupElement && (this._container.removeChild(this._groupElement), this._groupElement = void 0), this._terminalInstances = [], this._onInstancesChanged.fire();
  }
  get activeInstance() {
    if (this._terminalInstances.length !== 0)
      return this._terminalInstances[this._activeInstanceIndex];
  }
  getLayoutInfo(e) {
    const t = this.terminalInstances.filter((s) => typeof s.persistentProcessId == "number" && s.shouldPersist), i = t.map((s) => {
      var c;
      return ((c = this._splitPaneContainer) == null ? void 0 : c.getPaneSize(s)) || 0;
    }).reduce((s, c) => s += c, 0);
    return {
      isActive: e,
      activePersistentProcessId: this.activeInstance ? this.activeInstance.persistentProcessId : void 0,
      terminals: t.map((s) => ({
        relativeSize: i > 0 ? this._splitPaneContainer.getPaneSize(s) / i : 0,
        terminal: s.persistentProcessId || 0
      }))
    };
  }
  _initInstanceListeners(e) {
    this._instanceDisposables.set(e.instanceId, [
      e.onDisposed((t) => {
        this._onDidDisposeInstance.fire(t), this._handleOnDidDisposeInstance(t);
      }),
      e.onDidFocus((t) => {
        this._setActiveInstance(t), this._onDidFocusInstance.fire(t);
      }),
      e.capabilities.onDidAddCapability(() => this._onDidChangeInstanceCapability.fire(e)),
      e.capabilities.onDidRemoveCapability(() => this._onDidChangeInstanceCapability.fire(e))
    ]);
  }
  _handleOnDidDisposeInstance(e) {
    this._removeInstance(e);
  }
  removeInstance(e) {
    this._removeInstance(e);
    const t = this._instanceDisposables.get(e.instanceId);
    t && (ye(t), this._instanceDisposables.delete(e.instanceId));
  }
  _removeInstance(e) {
    var s, c;
    const t = this._terminalInstances.indexOf(e);
    if (t === -1)
      return;
    const i = e === this.activeInstance;
    if (this._terminalInstances.splice(t, 1), i && this._terminalInstances.length > 0) {
      const l = t < this._terminalInstances.length ? t : this._terminalInstances.length - 1;
      this.setActiveInstanceByIndex(l), (s = this.activeInstance) == null || s.focus(!0);
    } else
      t < this._activeInstanceIndex && this._activeInstanceIndex--;
    (c = this._splitPaneContainer) == null || c.remove(e), this._terminalInstances.length === 0 ? (this._onDisposed.fire(this), this.dispose()) : this._onInstancesChanged.fire();
  }
  moveInstance(e, t) {
    const i = this.terminalInstances.indexOf(e);
    i !== -1 && (this._terminalInstances.splice(i, 1), this._terminalInstances.splice(t, 0, e), this._splitPaneContainer && (this._splitPaneContainer.remove(e), this._splitPaneContainer.split(e, t)), this._onInstancesChanged.fire());
  }
  _setActiveInstance(e) {
    this.setActiveInstanceByIndex(this._getIndexFromId(e.instanceId));
  }
  _getIndexFromId(e) {
    let t = -1;
    if (this.terminalInstances.forEach((i, s) => {
      i.instanceId === e && (t = s);
    }), t === -1)
      throw new Error(`Terminal with ID ${e} does not exist (has it already been disposed?)`);
    return t;
  }
  setActiveInstanceByIndex(e, t) {
    if (e < 0 || e >= this._terminalInstances.length)
      return;
    const i = this.activeInstance;
    this._activeInstanceIndex = e, (i !== this.activeInstance || t) && (this._onInstancesChanged.fire(), this._onDidChangeActiveInstance.fire(this.activeInstance));
  }
  attachToElement(e) {
    if (this._container = e, this._groupElement || (this._groupElement = document.createElement("div"), this._groupElement.classList.add("terminal-group")), this._container.appendChild(this._groupElement), !this._splitPaneContainer) {
      this._panelPosition = this._layoutService.getPanelPosition(), this._terminalLocation = this._viewDescriptorService.getViewLocationById(fe);
      const t = this._terminalLocation === 1 && this._panelPosition === 2 ? 1 : 0;
      this._splitPaneContainer = this._instantiationService.createInstance(pr, this._groupElement, t), this.terminalInstances.forEach((i) => this._splitPaneContainer.split(i, this._activeInstanceIndex + 1)), this._initialRelativeSizes && (this.resizePanes(this._initialRelativeSizes), this._initialRelativeSizes = void 0);
    }
  }
  get title() {
    if (this._terminalInstances.length === 0)
      return "";
    let e = this.terminalInstances[0].title + this._getBellTitle(this.terminalInstances[0]);
    this.terminalInstances[0].description && (e += ` (${this.terminalInstances[0].description})`);
    for (let t = 1; t < this.terminalInstances.length; t++) {
      const i = this.terminalInstances[t];
      i.title && (e += `, ${i.title + this._getBellTitle(i)}`, i.description && (e += ` (${i.description})`));
    }
    return e;
  }
  _getBellTitle(e) {
    return this._terminalService.configHelper.config.enableBell && e.statusList.statuses.some((t) => t.id === "bell") ? "*" : "";
  }
  setVisible(e) {
    this._groupElement && (this._groupElement.style.display = e ? "" : "none"), this.terminalInstances.forEach((t) => t.setVisible(e));
  }
  split(e) {
    const t = this._terminalInstanceService.createInstance(e, se.Panel);
    return this.addInstance(t, e.parentTerminalId), this._setActiveInstance(t), t;
  }
  addDisposable(e) {
    this._register(e);
  }
  layout(e, t) {
    if (this._splitPaneContainer) {
      const i = this._layoutService.getPanelPosition(), s = this._viewDescriptorService.getViewLocationById(fe);
      if (i !== this._panelPosition || s !== this._terminalLocation) {
        const l = s === 1 && i === 2 ? 1 : 0;
        this._splitPaneContainer.setOrientation(l), this._panelPosition = i, this._terminalLocation = s, this._onPanelOrientationChanged.fire(this._splitPaneContainer.orientation);
      }
      this._splitPaneContainer.layout(e, t);
    }
  }
  focusPreviousPane() {
    const e = this._activeInstanceIndex === 0 ? this._terminalInstances.length - 1 : this._activeInstanceIndex - 1;
    this.setActiveInstanceByIndex(e);
  }
  focusNextPane() {
    const e = this._activeInstanceIndex === this._terminalInstances.length - 1 ? 0 : this._activeInstanceIndex + 1;
    this.setActiveInstanceByIndex(e);
  }
  resizePane(e) {
    if (!this._splitPaneContainer)
      return;
    const t = e === 0 || e === 1, i = this._terminalService.configHelper.getFont(), s = t ? i.charWidth : i.charHeight;
    s && this._splitPaneContainer.resizePane(this._activeInstanceIndex, e, s * 4, qh(this._terminalLocation));
  }
  resizePanes(e) {
    if (!this._splitPaneContainer) {
      this._initialRelativeSizes = e;
      return;
    }
    this._splitPaneContainer.resizePanes(e);
  }
};
vr = X([
  D(2, we),
  D(3, yt),
  D(4, ss),
  D(5, an),
  D(6, le)
], vr);
let Sr = class extends ue {
  get instances() {
    return this.groups.reduce((e, t) => e.concat(t.terminalInstances), []);
  }
  constructor(e, t, i, s, c) {
    super(), this._contextKeyService = e, this._instantiationService = t, this._viewsService = i, this._viewDescriptorService = s, this._configurationService = c, this.groups = [], this.activeGroupIndex = -1, this._onDidChangeActiveGroup = new V(), this.onDidChangeActiveGroup = this._onDidChangeActiveGroup.event, this._onDidDisposeGroup = new V(), this.onDidDisposeGroup = this._onDidDisposeGroup.event, this._onDidChangeGroups = new V(), this.onDidChangeGroups = this._onDidChangeGroups.event, this._onDidShow = new V(), this.onDidShow = this._onDidShow.event, this._onDidDisposeInstance = new V(), this.onDidDisposeInstance = this._onDidDisposeInstance.event, this._onDidFocusInstance = new V(), this.onDidFocusInstance = this._onDidFocusInstance.event, this._onDidChangeActiveInstance = new V(), this.onDidChangeActiveInstance = this._onDidChangeActiveInstance.event, this._onDidChangeInstances = new V(), this.onDidChangeInstances = this._onDidChangeInstances.event, this._onDidChangeInstanceCapability = new V(), this.onDidChangeInstanceCapability = this._onDidChangeInstanceCapability.event, this._onDidChangePanelOrientation = new V(), this.onDidChangePanelOrientation = this._onDidChangePanelOrientation.event, this.onDidDisposeGroup((l) => this._removeGroup(l)), this._terminalGroupCountContextKey = E.groupCount.bindTo(this._contextKeyService), this.onDidChangeGroups(() => this._terminalGroupCountContextKey.set(this.groups.length)), be.any(this.onDidChangeActiveGroup, this.onDidChangeInstances)(() => this.updateVisibility());
  }
  hidePanel() {
    const e = this._viewDescriptorService.getViewContainerByViewId(fe);
    e && this._viewDescriptorService.getViewContainerModel(e).activeViewDescriptors.length === 1 && (this._viewsService.closeView(fe), E.tabsMouse.bindTo(this._contextKeyService).set(!1));
  }
  showTabs() {
    this._configurationService.updateValue("terminal.integrated.tabs.enabled", !0);
  }
  get activeGroup() {
    if (!(this.activeGroupIndex < 0 || this.activeGroupIndex >= this.groups.length))
      return this.groups[this.activeGroupIndex];
  }
  set activeGroup(e) {
    if (e === void 0)
      return;
    const t = this.groups.findIndex((i) => i === e);
    this.setActiveGroupByIndex(t);
  }
  get activeInstance() {
    var e;
    return (e = this.activeGroup) == null ? void 0 : e.activeInstance;
  }
  setActiveInstance(e) {
    this.setActiveInstanceByIndex(this._getIndexFromId(e.instanceId));
  }
  _getIndexFromId(e) {
    const t = this.instances.findIndex((i) => i.instanceId === e);
    if (t === -1)
      throw new Error(`Terminal with ID ${e} does not exist (has it already been disposed?)`);
    return t;
  }
  setContainer(e) {
    this._container = e, this.groups.forEach((t) => t.attachToElement(e));
  }
  async focusTabs() {
    var t;
    if (this.instances.length === 0)
      return;
    await this.showPanel(!0);
    const e = this._viewsService.getActiveViewWithId(fe);
    (t = e == null ? void 0 : e.terminalTabbedView) == null || t.focusTabs();
  }
  async focusHover() {
    var t;
    if (this.instances.length === 0)
      return;
    const e = this._viewsService.getActiveViewWithId(fe);
    (t = e == null ? void 0 : e.terminalTabbedView) == null || t.focusHover();
  }
  async focusActiveInstance() {
    return this.showPanel(!0);
  }
  createGroup(e) {
    const t = this._instantiationService.createInstance(vr, this._container, e);
    return t.onPanelOrientationChanged((i) => this._onDidChangePanelOrientation.fire(i)), this.groups.push(t), t.addDisposable(t.onDidDisposeInstance(this._onDidDisposeInstance.fire, this._onDidDisposeInstance)), t.addDisposable(t.onDidFocusInstance(this._onDidFocusInstance.fire, this._onDidFocusInstance)), t.addDisposable(t.onDidChangeActiveInstance((i) => {
      t === this.activeGroup && this._onDidChangeActiveInstance.fire(i);
    })), t.addDisposable(t.onDidChangeInstanceCapability(this._onDidChangeInstanceCapability.fire, this._onDidChangeInstanceCapability)), t.addDisposable(t.onInstancesChanged(this._onDidChangeInstances.fire, this._onDidChangeInstances)), t.addDisposable(t.onDisposed(this._onDidDisposeGroup.fire, this._onDidDisposeGroup)), t.terminalInstances.length > 0 && this._onDidChangeInstances.fire(), this.instances.length === 1 && this.setActiveInstanceByIndex(0), this._onDidChangeGroups.fire(), t;
  }
  async showPanel(e) {
    const t = this._viewsService.getActiveViewWithId(fe) ?? await this._viewsService.openView(fe, e);
    if (t == null || t.setExpanded(!0), e) {
      await di(0);
      const i = this.activeInstance;
      i && (t && !t.isVisible() && await this._viewsService.openView(fe, e), await i.focusWhenReady(!0));
    }
    this._onDidShow.fire();
  }
  getInstanceFromResource(e) {
    return to(this.instances, e);
  }
  _removeGroup(e) {
    var c;
    const t = this.activeGroup, i = e === t, s = this.groups.indexOf(e);
    if (s !== -1 && (this.groups.splice(s, 1), this._onDidChangeGroups.fire()), i) {
      if (this.groups.length > 0) {
        const l = s < this.groups.length ? s : this.groups.length - 1;
        this.setActiveGroupByIndex(l, !0), (c = this.activeInstance) == null || c.focus(!0);
      }
    } else
      this.activeGroupIndex > s && this.setActiveGroupByIndex(this.activeGroupIndex - 1);
    this.activeGroupIndex >= this.groups.length && this.setActiveGroupByIndex(this.groups.length - 1), this._onDidChangeInstances.fire(), this._onDidChangeGroups.fire(), i && (this._onDidChangeActiveGroup.fire(this.activeGroup), this._onDidChangeActiveInstance.fire(this.activeInstance));
  }
  setActiveGroupByIndex(e, t) {
    if (e === -1 && this.groups.length === 0) {
      this.activeGroupIndex !== -1 && (this.activeGroupIndex = -1, this._onDidChangeActiveGroup.fire(this.activeGroup), this._onDidChangeActiveInstance.fire(this.activeInstance));
      return;
    }
    if (e < 0 || e >= this.groups.length)
      return;
    const i = this.activeGroup;
    this.activeGroupIndex = e, (t || i !== this.activeGroup) && (this._onDidChangeActiveGroup.fire(this.activeGroup), this._onDidChangeActiveInstance.fire(this.activeInstance));
  }
  _getInstanceLocation(e) {
    let t = 0;
    for (; e >= 0 && t < this.groups.length; ) {
      const i = this.groups[t], s = i.terminalInstances.length;
      if (e < s)
        return {
          group: i,
          groupIndex: t,
          instance: i.terminalInstances[e],
          instanceIndex: e
        };
      e -= s, t++;
    }
  }
  setActiveInstanceByIndex(e) {
    const t = this.activeInstance, i = this._getInstanceLocation(e), s = i == null ? void 0 : i.group.terminalInstances[i.instanceIndex];
    if (!i || t === s)
      return;
    const c = i.instanceIndex;
    this.activeGroupIndex = i.groupIndex, this._onDidChangeActiveGroup.fire(this.activeGroup), i.group.setActiveInstanceByIndex(c, !0);
  }
  setActiveGroupToNext() {
    if (this.groups.length <= 1)
      return;
    let e = this.activeGroupIndex + 1;
    e >= this.groups.length && (e = 0), this.setActiveGroupByIndex(e);
  }
  setActiveGroupToPrevious() {
    if (this.groups.length <= 1)
      return;
    let e = this.activeGroupIndex - 1;
    e < 0 && (e = this.groups.length - 1), this.setActiveGroupByIndex(e);
  }
  moveGroup(e, t) {
    const i = this.getGroupForInstance(e), s = this.getGroupForInstance(t);
    if (!i || !s)
      return;
    if (i === s) {
      const n = i.terminalInstances.indexOf(t);
      n !== -1 && i.moveInstance(e, n);
      return;
    }
    const c = this.groups.indexOf(i), l = this.groups.indexOf(s);
    this.groups.splice(c, 1), this.groups.splice(l, 0, i), this._onDidChangeInstances.fire();
  }
  moveGroupToEnd(e) {
    const t = this.getGroupForInstance(e);
    if (!t)
      return;
    const i = this.groups.indexOf(t);
    this.groups.splice(i, 1), this.groups.push(t), this._onDidChangeInstances.fire();
  }
  moveInstance(e, t, i) {
    const s = this.getGroupForInstance(e), c = this.getGroupForInstance(t);
    if (!s || !c)
      return;
    s !== c && (s.removeInstance(e), c.addInstance(e));
    const l = c.terminalInstances.indexOf(t) + (i === "after" ? 1 : 0);
    c.moveInstance(e, l);
  }
  unsplitInstance(e) {
    const t = this.getGroupForInstance(e);
    !t || t.terminalInstances.length < 2 || (t.removeInstance(e), this.createGroup(e));
  }
  joinInstances(e) {
    const t = this.getGroupForInstance(e[0]);
    if (t) {
      let l = !0;
      for (let n = 1; n < t.terminalInstances.length; n++)
        if (t.terminalInstances.includes(e[n])) {
          l = !1;
          break;
        }
      if (!l)
        return;
    }
    let i, s;
    for (const l of e) {
      const n = this.getGroupForInstance(l);
      if ((n == null ? void 0 : n.terminalInstances.length) === 1) {
        i = l, s = n;
        break;
      }
    }
    s || (s = this.createGroup());
    const c = this.activeGroup === s;
    for (const l of e) {
      if (l === i)
        continue;
      const n = this.getGroupForInstance(l);
      n && (n.removeInstance(l), s.addInstance(l));
    }
    this.setActiveInstance(e[0]), this._onDidChangeInstances.fire(), c || this._onDidChangeActiveGroup.fire(this.activeGroup);
  }
  instanceIsSplit(e) {
    const t = this.getGroupForInstance(e);
    return t ? t.terminalInstances.length > 1 : !1;
  }
  getGroupForInstance(e) {
    return this.groups.find((t) => t.terminalInstances.includes(e));
  }
  getGroupLabels() {
    return this.groups.filter((e) => e.terminalInstances.length > 0).map((e, t) => `${t + 1}: ${e.title ? e.title : ""}`);
  }
  updateVisibility() {
    const e = this._viewsService.isViewVisible(fe);
    this.groups.forEach((t, i) => t.setVisible(e && i === this.activeGroupIndex));
  }
};
Sr = X([
  D(0, Fe),
  D(1, le),
  D(2, Yr),
  D(3, an),
  D(4, Se)
], Sr);
let br = class extends ue {
  get onDidCreateInstance() {
    return this._onDidCreateInstance.event;
  }
  constructor(e, t, i) {
    super(), this._instantiationService = e, this._contextKeyService = t, this._environmentService = i, this._backendRegistration = /* @__PURE__ */ new Map(), this._onDidCreateInstance = new V(), this._terminalShellTypeContextKey = E.shellType.bindTo(this._contextKeyService), this._terminalInRunCommandPicker = E.inTerminalRunCommandPicker.bindTo(this._contextKeyService), this._terminalSuggestWidgetVisibleContextKey = E.suggestWidgetVisible.bindTo(this._contextKeyService), this._configHelper = e.createInstance(Fn);
    for (const s of [void 0, i.remoteAuthority]) {
      let c;
      const l = new Promise((n) => c = n);
      this._backendRegistration.set(s, { promise: l, resolve: c });
    }
  }
  createInstance(e, t) {
    const i = this.convertProfileToShellLaunchConfig(e), s = this._instantiationService.createInstance(ot, this._terminalShellTypeContextKey, this._terminalInRunCommandPicker, this._terminalSuggestWidgetVisibleContextKey, this._configHelper, i);
    return s.target = t, this._onDidCreateInstance.fire(s), s;
  }
  convertProfileToShellLaunchConfig(e, t) {
    if (e && "profileName" in e) {
      const i = e;
      return i.path ? {
        executable: i.path,
        args: i.args,
        env: i.env,
        icon: i.icon,
        color: i.color,
        name: i.overrideName ? i.profileName : void 0,
        cwd: t
      } : e;
    }
    return e ? (t && (e.cwd = t), e) : {};
  }
  async getBackend(e) {
    var i;
    let t = Oe.as(Ki.Backend).getTerminalBackend(e);
    return t || (await ((i = this._backendRegistration.get(e)) == null ? void 0 : i.promise), t = Oe.as(Ki.Backend).getTerminalBackend(e)), t;
  }
  getRegisteredBackends() {
    return Oe.as(Ki.Backend).backends.values();
  }
  didRegisterBackend(e) {
    var t;
    (t = this._backendRegistration.get(e)) == null || t.resolve();
  }
};
br = X([
  D(0, le),
  D(1, Fe),
  D(2, Fi)
], br);
const Ua = {
  type: ["string", "null"],
  enum: [
    "terminal.ansiBlack",
    "terminal.ansiRed",
    "terminal.ansiGreen",
    "terminal.ansiYellow",
    "terminal.ansiBlue",
    "terminal.ansiMagenta",
    "terminal.ansiCyan",
    "terminal.ansiWhite"
  ],
  default: null
}, Ga = {
  type: "string",
  enum: Array.from(Ms(), (h) => h.id),
  markdownEnumDescriptions: Array.from(Ms(), (h) => `$(${h.id})`)
}, Si = {
  args: {
    description: g(
      "terminalProfile.args",
      "An optional set of arguments to run the shell executable with."
    ),
    type: "array",
    items: {
      type: "string"
    }
  },
  overrideName: {
    description: g(
      "terminalProfile.overrideName",
      "Controls whether or not the profile name overrides the auto detected one."
    ),
    type: "boolean"
  },
  icon: {
    description: g(
      "terminalProfile.icon",
      "A codicon ID to associate with the terminal icon."
    ),
    ...Ga
  },
  color: {
    description: g(
      "terminalProfile.color",
      "A theme color ID to associate with the terminal icon."
    ),
    ...Ua
  },
  env: {
    markdownDescription: g(
      "terminalProfile.env",
      "An object with environment variables that will be added to the terminal profile process. Set to `null` to delete environment variables from the base environment."
    ),
    type: "object",
    additionalProperties: {
      type: ["string", "null"]
    },
    default: {}
  }
}, ys = {
  type: "object",
  required: ["path"],
  properties: {
    path: {
      description: g(
        "terminalProfile.path",
        "A single path to a shell executable or an array of paths that will be used as fallbacks when one fails."
      ),
      type: ["string", "array"],
      items: {
        type: "string"
      }
    },
    ...Si
  }
}, xs = {
  type: "object",
  required: ["path"],
  properties: {
    path: {
      description: g("terminalAutomationProfile.path", "A single path to a shell executable."),
      type: ["string"],
      items: {
        type: "string"
      }
    },
    ...Si
  }
};
function ks(h) {
  const e = h === 2 ? "linux" : h === 1 ? "osx" : "windows";
  return g({
    key: "terminal.integrated.profile",
    comment: ["{0} is the platform, {1} is a code block, {2} and {3} are a link start and end"]
  }, `A set of terminal profile customizations for {0} which allows adding, removing or changing how terminals are launched. Profiles are made up of a mandatory path, optional arguments and other presentation options.

To override an existing profile use its profile name as the key, for example:

{1}

{2}Read more about configuring profiles{3}.`, jl(h), '```json\n"terminal.integrated.profile.' + e + '": {\n  "bash": null\n}\n```', "[", "](https://code.visualstudio.com/docs/terminal/profiles)");
}
const ru = {
  id: "terminal",
  order: 100,
  title: g("terminalIntegratedConfigurationTitle", "Integrated Terminal"),
  type: "object",
  properties: {
    "terminal.integrated.automationProfile.linux": {
      restricted: !0,
      markdownDescription: g(
        "terminal.integrated.automationProfile.linux",
        "The terminal profile to use on Linux for automation-related terminal usage like tasks and debug."
      ),
      type: ["object", "null"],
      default: null,
      anyOf: [
        { type: "null" },
        xs
      ],
      defaultSnippets: [
        {
          body: {
            path: "${1}",
            icon: "${2}"
          }
        }
      ]
    },
    "terminal.integrated.automationProfile.osx": {
      restricted: !0,
      markdownDescription: g(
        "terminal.integrated.automationProfile.osx",
        "The terminal profile to use on macOS for automation-related terminal usage like tasks and debug."
      ),
      type: ["object", "null"],
      default: null,
      anyOf: [
        { type: "null" },
        xs
      ],
      defaultSnippets: [
        {
          body: {
            path: "${1}",
            icon: "${2}"
          }
        }
      ]
    },
    "terminal.integrated.automationProfile.windows": {
      restricted: !0,
      markdownDescription: g(
        "terminal.integrated.automationProfile.windows",
        "The terminal profile to use for automation-related terminal usage like tasks and debug. This setting will currently be ignored if {0} (now deprecated) is set.",
        "`terminal.integrated.automationShell.windows`"
      ),
      type: ["object", "null"],
      default: null,
      anyOf: [
        { type: "null" },
        xs
      ],
      defaultSnippets: [
        {
          body: {
            path: "${1}",
            icon: "${2}"
          }
        }
      ]
    },
    "terminal.integrated.profiles.windows": {
      restricted: !0,
      markdownDescription: ks(3),
      type: "object",
      default: {
        PowerShell: {
          source: "PowerShell",
          icon: "terminal-powershell"
        },
        "Command Prompt": {
          path: [
            "${env:windir}\\Sysnative\\cmd.exe",
            "${env:windir}\\System32\\cmd.exe"
          ],
          args: [],
          icon: "terminal-cmd"
        },
        "Git Bash": {
          source: "Git Bash"
        }
      },
      additionalProperties: {
        anyOf: [
          {
            type: "object",
            required: ["source"],
            properties: {
              source: {
                description: g(
                  "terminalProfile.windowsSource",
                  "A profile source that will auto detect the paths to the shell. Note that non-standard executable locations are not supported and must be created manually in a new profile."
                ),
                enum: ["PowerShell", "Git Bash"]
              },
              ...Si
            }
          },
          {
            type: "object",
            required: ["extensionIdentifier", "id", "title"],
            properties: {
              extensionIdentifier: {
                description: g(
                  "terminalProfile.windowsExtensionIdentifier",
                  "The extension that contributed this profile."
                ),
                type: "string"
              },
              id: {
                description: g("terminalProfile.windowsExtensionId", "The id of the extension terminal"),
                type: "string"
              },
              title: {
                description: g(
                  "terminalProfile.windowsExtensionTitle",
                  "The name of the extension terminal"
                ),
                type: "string"
              },
              ...Si
            }
          },
          { type: "null" },
          ys
        ]
      }
    },
    "terminal.integrated.profiles.osx": {
      restricted: !0,
      markdownDescription: ks(1),
      type: "object",
      default: {
        bash: {
          path: "bash",
          args: ["-l"],
          icon: "terminal-bash"
        },
        zsh: {
          path: "zsh",
          args: ["-l"]
        },
        fish: {
          path: "fish",
          args: ["-l"]
        },
        tmux: {
          path: "tmux",
          icon: "terminal-tmux"
        },
        pwsh: {
          path: "pwsh",
          icon: "terminal-powershell"
        }
      },
      additionalProperties: {
        anyOf: [
          {
            type: "object",
            required: ["extensionIdentifier", "id", "title"],
            properties: {
              extensionIdentifier: {
                description: g(
                  "terminalProfile.osxExtensionIdentifier",
                  "The extension that contributed this profile."
                ),
                type: "string"
              },
              id: {
                description: g("terminalProfile.osxExtensionId", "The id of the extension terminal"),
                type: "string"
              },
              title: {
                description: g("terminalProfile.osxExtensionTitle", "The name of the extension terminal"),
                type: "string"
              },
              ...Si
            }
          },
          { type: "null" },
          ys
        ]
      }
    },
    "terminal.integrated.profiles.linux": {
      restricted: !0,
      markdownDescription: ks(2),
      type: "object",
      default: {
        bash: {
          path: "bash",
          icon: "terminal-bash"
        },
        zsh: {
          path: "zsh"
        },
        fish: {
          path: "fish"
        },
        tmux: {
          path: "tmux",
          icon: "terminal-tmux"
        },
        pwsh: {
          path: "pwsh",
          icon: "terminal-powershell"
        }
      },
      additionalProperties: {
        anyOf: [
          {
            type: "object",
            required: ["extensionIdentifier", "id", "title"],
            properties: {
              extensionIdentifier: {
                description: g(
                  "terminalProfile.linuxExtensionIdentifier",
                  "The extension that contributed this profile."
                ),
                type: "string"
              },
              id: {
                description: g("terminalProfile.linuxExtensionId", "The id of the extension terminal"),
                type: "string"
              },
              title: {
                description: g(
                  "terminalProfile.linuxExtensionTitle",
                  "The name of the extension terminal"
                ),
                type: "string"
              },
              ...Si
            }
          },
          { type: "null" },
          ys
        ]
      }
    },
    "terminal.integrated.useWslProfiles": {
      description: g(
        "terminal.integrated.useWslProfiles",
        "Controls whether or not WSL distros are shown in the terminal dropdown"
      ),
      type: "boolean",
      default: !0
    },
    "terminal.integrated.inheritEnv": {
      scope: 1,
      description: g(
        "terminal.integrated.inheritEnv",
        "Whether new shells should inherit their environment from VS Code, which may source a login shell to ensure $PATH and other development variables are initialized. This has no effect on Windows."
      ),
      type: "boolean",
      default: !0
    },
    "terminal.integrated.persistentSessionScrollback": {
      scope: 1,
      markdownDescription: g(
        "terminal.integrated.persistentSessionScrollback",
        "Controls the maximum amount of lines that will be restored when reconnecting to a persistent terminal session. Increasing this will restore more lines of scrollback at the cost of more memory and increase the time it takes to connect to terminals on start up. This setting requires a restart to take effect and should be set to a value less than or equal to `#terminal.integrated.scrollback#`."
      ),
      type: "number",
      default: 100
    },
    "terminal.integrated.showLinkHover": {
      scope: 1,
      description: g(
        "terminal.integrated.showLinkHover",
        "Whether to show hovers for links in the terminal output."
      ),
      type: "boolean",
      default: !0
    },
    "terminal.integrated.ignoreProcessNames": {
      description: g(
        "terminal.integrated.confirmIgnoreProcesses",
        "A set of process names to ignore when using the {0} setting.",
        "`terminal.integrated.confirmOnKill`"
      ),
      type: "array",
      items: {
        type: "string",
        uniqueItems: !0
      },
      default: [
        "starship",
        "oh-my-posh",
        "bash",
        "zsh"
      ]
    }
  }
};
function ou() {
  Oe.as(Jr.Configuration).registerConfiguration(ru), za();
}
let Is;
function za(h, e) {
  const t = Oe.as(Jr.Configuration);
  let i;
  h && (i = ka(h == null ? void 0 : h.profiles, e));
  const s = Is;
  Is = {
    id: "terminal",
    order: 100,
    title: g("terminalIntegratedConfigurationTitle", "Integrated Terminal"),
    type: "object",
    properties: {
      "terminal.integrated.defaultProfile.linux": {
        restricted: !0,
        markdownDescription: g(
          "terminal.integrated.defaultProfile.linux",
          "The default terminal profile on Linux."
        ),
        type: ["string", "null"],
        default: null,
        enum: (h == null ? void 0 : h.os) === 3 ? i == null ? void 0 : i.values : void 0,
        markdownEnumDescriptions: (h == null ? void 0 : h.os) === 3 ? i == null ? void 0 : i.markdownDescriptions : void 0
      },
      "terminal.integrated.defaultProfile.osx": {
        restricted: !0,
        markdownDescription: g(
          "terminal.integrated.defaultProfile.osx",
          "The default terminal profile on macOS."
        ),
        type: ["string", "null"],
        default: null,
        enum: (h == null ? void 0 : h.os) === 2 ? i == null ? void 0 : i.values : void 0,
        markdownEnumDescriptions: (h == null ? void 0 : h.os) === 2 ? i == null ? void 0 : i.markdownDescriptions : void 0
      },
      "terminal.integrated.defaultProfile.windows": {
        restricted: !0,
        markdownDescription: g(
          "terminal.integrated.defaultProfile.windows",
          "The default terminal profile on Windows."
        ),
        type: ["string", "null"],
        default: null,
        enum: (h == null ? void 0 : h.os) === 1 ? i == null ? void 0 : i.values : void 0,
        markdownEnumDescriptions: (h == null ? void 0 : h.os) === 1 ? i == null ? void 0 : i.markdownDescriptions : void 0
      }
    }
  }, t.updateConfigurations({ add: [Is], remove: s ? [s] : [] });
}
let en = class {
  get onDidChangeAvailableProfiles() {
    return this._onDidChangeAvailableProfiles.event;
  }
  get profilesReady() {
    return this._profilesReadyBarrier.wait().then(() => {
    });
  }
  get availableProfiles() {
    return this._platformConfigJustRefreshed || this.refreshAvailableProfiles(), this._availableProfiles || [];
  }
  get contributedProfiles() {
    return this._contributedProfiles || [];
  }
  constructor(e, t, i, s, c, l, n) {
    this._contextKeyService = e, this._configurationService = t, this._terminalContributionService = i, this._extensionService = s, this._remoteAgentService = c, this._environmentService = l, this._terminalInstanceService = n, this._contributedProfiles = [], this._platformConfigJustRefreshed = !1, this._profileProviders = /* @__PURE__ */ new Map(), this._onDidChangeAvailableProfiles = new V(), this._extensionService.onDidChangeExtensions(() => this.refreshAvailableProfiles()), this._webExtensionContributedProfileContextKey = E.webExtensionContributedProfile.bindTo(this._contextKeyService), this._updateWebContextKey(), this._profilesReadyBarrier = new Ps(2e4), this.refreshAvailableProfiles(), this._setupConfigListener();
  }
  async _setupConfigListener() {
    const e = await this.getPlatformKey();
    this._configurationService.onDidChangeConfiguration(async (t) => {
      (t.affectsConfiguration("terminal.integrated.defaultProfile." + e) || t.affectsConfiguration("terminal.integrated.profiles." + e) || t.affectsConfiguration("terminal.integrated.useWslProfiles")) && (t.source !== 7 ? (this.refreshAvailableProfiles(), this._platformConfigJustRefreshed = !1) : this._platformConfigJustRefreshed = !0);
    });
  }
  getDefaultProfileName() {
    return this._defaultProfileName;
  }
  getDefaultProfile(e) {
    let t;
    if (e) {
      if (t = this._configurationService.getValue(`terminal.integrated.defaultProfile.${this._getOsKey(e)}`), !t || typeof t != "string")
        return;
    } else
      t = this._defaultProfileName;
    if (t)
      return this.availableProfiles.find((i) => i.profileName === t && !i.isAutoDetected);
  }
  _getOsKey(e) {
    switch (e) {
      case 3:
        return "linux";
      case 2:
        return "osx";
      case 1:
        return "windows";
    }
  }
  refreshAvailableProfiles() {
    this._refreshAvailableProfilesNow();
  }
  async _refreshAvailableProfilesNow() {
    const e = await this._detectProfiles(!0), t = !Bs(e, this._availableProfiles, au), i = await this._updateContributedProfiles();
    (t || i) && (this._availableProfiles = e, this._onDidChangeAvailableProfiles.fire(this._availableProfiles), this._profilesReadyBarrier.open(), this._updateWebContextKey(), await this._refreshPlatformConfig(this._availableProfiles));
  }
  async _updateContributedProfiles() {
    const e = await this.getPlatformKey(), t = [], i = this._configurationService.getValue("terminal.integrated.profiles." + e);
    for (const [l, n] of Object.entries(i))
      n === null && t.push(l);
    const s = Array.from(this._terminalContributionService.terminalProfiles.filter((l) => !t.includes(l.title))), c = !Bs(s, this._contributedProfiles, cu);
    return this._contributedProfiles = s, c;
  }
  getContributedProfileProvider(e, t) {
    const i = this._profileProviders.get(e);
    return i == null ? void 0 : i.get(t);
  }
  async _detectProfiles(e) {
    const t = await this._terminalInstanceService.getBackend(this._environmentService.remoteAuthority);
    if (!t)
      return this._availableProfiles || [];
    const i = await this.getPlatformKey();
    return this._defaultProfileName = this._configurationService.getValue(`terminal.integrated.defaultProfile.${i}`) ?? void 0, t.getProfiles(this._configurationService.getValue(`terminal.integrated.profiles.${i}`), this._defaultProfileName, e);
  }
  _updateWebContextKey() {
    this._webExtensionContributedProfileContextKey.set(ki && this._contributedProfiles.length > 0);
  }
  async _refreshPlatformConfig(e) {
    const t = await this._remoteAgentService.getEnvironment();
    za({ os: (t == null ? void 0 : t.os) || Lt, profiles: e }, this._contributedProfiles), Ra(e);
  }
  async getPlatformKey() {
    const e = await this._remoteAgentService.getEnvironment();
    return e ? e.os === 1 ? "windows" : e.os === 2 ? "osx" : "linux" : Le ? "windows" : rt ? "osx" : "linux";
  }
  registerTerminalProfileProvider(e, t, i) {
    let s = this._profileProviders.get(e);
    return s || (s = /* @__PURE__ */ new Map(), this._profileProviders.set(e, s)), s.set(t, i), je(() => this._profileProviders.delete(t));
  }
  async registerContributedProfile(e) {
    const t = await this.getPlatformKey(), i = await this._configurationService.getValue(`terminal.integrated.profiles.${t}`);
    if (typeof i == "object") {
      const s = {
        extensionIdentifier: e.extensionIdentifier,
        icon: e.options.icon,
        id: e.id,
        title: e.title,
        color: e.options.color
      };
      i[e.title] = s;
    }
    await this._configurationService.updateValue(`terminal.integrated.profiles.${t}`, i, 2);
  }
  async getContributedDefaultProfile(e) {
    if (e && !e.extHostTerminalId && !("executable" in e)) {
      const t = await this.getPlatformKey(), i = this._configurationService.getValue(`terminal.integrated.defaultProfile.${t}`);
      return this.contributedProfiles.find((c) => c.title === i);
    }
  }
};
en.__decorator = X([
  ma(2e3)
], en.prototype, "refreshAvailableProfiles", null);
en = X([
  D(0, Fe),
  D(1, Se),
  D(2, fa),
  D(3, mt),
  D(4, Mt),
  D(5, Fi),
  D(6, yt)
], en);
function au(h, e) {
  return h.profileName === e.profileName && Ia(h.args, e.args) && h.color === e.color && od(h.icon, e.icon) && h.isAutoDetected === e.isAutoDetected && h.isDefault === e.isDefault && h.overrideName === e.overrideName && h.path === e.path;
}
function cu(h, e) {
  return h.extensionIdentifier === e.extensionIdentifier && h.color === e.color && h.icon === e.icon && h.id === e.id && h.title === e.title;
}
class lu {
  constructor() {
    this._linkProviders = /* @__PURE__ */ new Set(), this._onDidAddLinkProvider = new V(), this._onDidRemoveLinkProvider = new V();
  }
  get linkProviders() {
    return this._linkProviders;
  }
  get onDidAddLinkProvider() {
    return this._onDidAddLinkProvider.event;
  }
  get onDidRemoveLinkProvider() {
    return this._onDidRemoveLinkProvider.event;
  }
  registerLinkProvider(e) {
    const t = [];
    return this._linkProviders.add(e), this._onDidAddLinkProvider.fire(e), {
      dispose: () => {
        for (const i of t)
          i.dispose();
        this._linkProviders.delete(e), this._onDidRemoveLinkProvider.fire(e);
      }
    };
  }
}
const Bo = "Generated";
class wr {
  get defaultProfileName() {
    return this._defaultProfileName;
  }
  constructor(e, t, i, s, c, l, n, r) {
    this._context = e, this._configurationService = t, this._configurationResolverService = i, this._historyService = s, this._logService = c, this._terminalProfileService = l, this._workspaceContextService = n, this._remoteAgentService = r, this._iconRegistry = ts(), this._remoteAgentService.getConnection() ? this._remoteAgentService.getEnvironment().then((a) => this._primaryBackendOs = (a == null ? void 0 : a.os) || Lt) : this._primaryBackendOs = Lt, this._configurationService.onDidChangeConfiguration((a) => {
      (a.affectsConfiguration("terminal.integrated.defaultProfile.windows") || a.affectsConfiguration("terminal.integrated.defaultProfile.osx") || a.affectsConfiguration("terminal.integrated.defaultProfile.linux")) && this._refreshDefaultProfileName();
    }), this._terminalProfileService.onDidChangeAvailableProfiles(() => this._refreshDefaultProfileName());
  }
  async _refreshDefaultProfileName() {
    var e, t;
    this._primaryBackendOs && (this._defaultProfileName = (t = await this.getDefaultProfile({
      remoteAuthority: (e = this._remoteAgentService.getConnection()) == null ? void 0 : e.remoteAuthority,
      os: this._primaryBackendOs
    })) == null ? void 0 : t.profileName);
  }
  resolveIcon(e, t) {
    if (e.icon) {
      e.icon = this._getCustomIcon(e.icon) || this.getDefaultIcon();
      return;
    }
    if (e.customPtyImplementation) {
      e.icon = this.getDefaultIcon();
      return;
    }
    if (e.executable)
      return;
    const i = this._getUnresolvedRealDefaultProfile(t);
    i && (e.icon = i.icon), e.icon || (e.icon = this.getDefaultIcon());
  }
  getDefaultIcon(e) {
    return this._iconRegistry.getIcon(this._configurationService.getValue("terminal.integrated.tabs.defaultIcon", { resource: e })) || te.terminal;
  }
  async resolveShellLaunchConfig(e, t) {
    let i;
    e.executable ? i = await this._resolveProfile({
      path: e.executable,
      args: e.args,
      profileName: Bo,
      isDefault: !1
    }, t) : i = await this.getDefaultProfile(t), e.executable = i.path, e.args = i.args, i.env && (e.env ? e.env = { ...e.env, ...i.env } : e.env = i.env);
    const s = e === void 0 || typeof e.cwd == "string" ? void 0 : e.cwd;
    e.icon = this._getCustomIcon(e.icon) || this._getCustomIcon(i.icon) || this.getDefaultIcon(s), i.overrideName && (e.name = i.profileName), e.color = e.color || i.color || this._configurationService.getValue("terminal.integrated.tabs.defaultColor", { resource: s }), e.useShellEnvironment === void 0 && (e.useShellEnvironment = this._configurationService.getValue("terminal.integrated.inheritEnv"));
  }
  async getDefaultShell(e) {
    return (await this.getDefaultProfile(e)).path;
  }
  async getDefaultShellArgs(e) {
    return (await this.getDefaultProfile(e)).args || [];
  }
  async getDefaultProfile(e) {
    return this._resolveProfile(await this._getUnresolvedDefaultProfile(e), e);
  }
  getEnvironment(e) {
    return this._context.getEnvironment(e);
  }
  _getCustomIcon(e) {
    if (e) {
      if (typeof e == "string")
        return re.fromId(e);
      if (re.isThemeIcon(e))
        return e;
      if (oe.isUri(e) || It(e))
        return oe.revive(e);
      if (typeof e == "object" && "light" in e && "dark" in e) {
        const t = e;
        if ((oe.isUri(t.light) || It(t.light)) && (oe.isUri(t.dark) || It(t.dark)))
          return { light: oe.revive(t.light), dark: oe.revive(t.dark) };
      }
    }
  }
  async _getUnresolvedDefaultProfile(e) {
    if (e.allowAutomationShell) {
      const i = this._getUnresolvedAutomationShellProfile(e);
      if (i)
        return i;
    }
    await this._terminalProfileService.profilesReady;
    const t = this._getUnresolvedRealDefaultProfile(e.os);
    return t ? this._setIconForAutomation(e, t) : this._setIconForAutomation(e, await this._getUnresolvedFallbackDefaultProfile(e));
  }
  _setIconForAutomation(e, t) {
    if (e.allowAutomationShell) {
      const i = lo(t);
      return i.icon = te.tools, i;
    }
    return t;
  }
  _getUnresolvedRealDefaultProfile(e) {
    return this._terminalProfileService.getDefaultProfile(e);
  }
  async _getUnresolvedFallbackDefaultProfile(e) {
    const t = await this._context.getDefaultSystemShell(e.remoteAuthority, e.os);
    if (e.os === Lt) {
      let c = this._terminalProfileService.availableProfiles.find((l) => un(l.path).name === un(t).name);
      if (c)
        return e.allowAutomationShell && (c = lo(c), c.icon = te.tools), c;
    }
    let i;
    e.os === 2 && un(t).name.match(/(zsh|bash)/) ? i = ["--login"] : i = [];
    const s = this._guessProfileIcon(t);
    return {
      profileName: Bo,
      path: t,
      args: i,
      icon: s,
      isDefault: !1
    };
  }
  _getUnresolvedAutomationShellProfile(e) {
    const t = this._configurationService.getValue(`terminal.integrated.automationProfile.${this._getOsKey(e.os)}`);
    if (this._isValidAutomationProfile(t, e.os))
      return t.icon = this._getCustomIcon(t.icon) || te.tools, t;
  }
  async _resolveProfile(e, t) {
    const i = await this._context.getEnvironment(t.remoteAuthority);
    if (t.os === 1) {
      const l = !!i.hasOwnProperty("PROCESSOR_ARCHITEW6432"), n = i.windir;
      if (!l && n) {
        const r = Ls(n, "Sysnative").replace(/\//g, "\\").toLowerCase();
        e.path && e.path.toLowerCase().indexOf(r) === 0 && (e.path = Ls(n, "System32", e.path.substr(r.length + 1)));
      }
      e.path && (e.path = e.path.replace(/\//g, "\\"));
    }
    const s = this._historyService.getLastActiveWorkspaceRoot(t.remoteAuthority ? me.vscodeRemote : me.file), c = s ? Pt(this._workspaceContextService.getWorkspaceFolder(s)) : void 0;
    return e.path = await this._resolveVariables(e.path, i, c), e.args && (typeof e.args == "string" ? e.args = await this._resolveVariables(e.args, i, c) : e.args = await Promise.all(e.args.map((l) => this._resolveVariables(l, i, c)))), e;
  }
  async _resolveVariables(e, t, i) {
    try {
      e = await this._configurationResolverService.resolveWithEnvironment(t, i, e);
    } catch (s) {
      this._logService.error("Could not resolve shell", s);
    }
    return e;
  }
  _getOsKey(e) {
    switch (e) {
      case 3:
        return "linux";
      case 2:
        return "osx";
      case 1:
        return "windows";
    }
  }
  _guessProfileIcon(e) {
    switch (un(e).name) {
      case "bash":
        return te.terminalBash;
      case "pwsh":
      case "powershell":
        return te.terminalPowershell;
      case "tmux":
        return te.terminalTmux;
      case "cmd":
        return te.terminalCmd;
      default:
        return;
    }
  }
  _isValidShellArgs(e, t) {
    return !!(e === void 0 || t === 1 && typeof e == "string" || Array.isArray(e) && e.every((i) => typeof i == "string"));
  }
  async createProfileFromShellAndShellArgs(e, t) {
    var r, a;
    const i = (r = this._terminalProfileService.availableProfiles) == null ? void 0 : r.find((f) => f.path !== e ? !1 : f.args === void 0 || typeof f.args == "string" ? f.args === t : f.path === e && Bs(f.args, t || [])), s = await this.getDefaultProfile({
      remoteAuthority: (a = this._remoteAgentService.getConnection()) == null ? void 0 : a.remoteAuthority,
      os: this._primaryBackendOs
    });
    s.profileName = `${s.path} (migrated)`;
    const c = i || s, l = this._isValidShellArgs(t, this._primaryBackendOs) ? t : c.args, n = {
      profileName: c.profileName,
      path: c.path,
      args: l,
      isDefault: !0
    };
    return i && i.profileName === n.profileName && i.path === n.path && Ia(i.args, n.args) ? i.profileName : n;
  }
  _isValidAutomationProfile(e, t) {
    return e == null || typeof e != "object" ? !1 : "path" in e && typeof e.path == "string";
  }
}
wr.__decorator = X([
  ft(200)
], wr.prototype, "_refreshDefaultProfileName", null);
let Cr = class extends wr {
  constructor(e, t, i, s, c, l, n, r) {
    super({
      getDefaultSystemShell: async (a, f) => {
        const m = await r.getBackend(a);
        if (!m)
          throw new Rs(`Cannot get default system shell when there is no backend for remote authority '${a}'`);
        return m.getDefaultSystemShell(f);
      },
      getEnvironment: async (a) => {
        const f = await r.getBackend(a);
        if (!f)
          throw new Rs(`Cannot get environment when there is no backend for remote authority '${a}'`);
        return f.getEnvironment();
      }
    }, t, e, i, s, l, c, n);
  }
};
Cr = X([
  D(0, qn),
  D(1, Se),
  D(2, jn),
  D(3, Ot),
  D(4, tt),
  D(5, Bt),
  D(6, Mt),
  D(7, yt)
], Cr);
let mi = class {
  get onDidChangeCollections() {
    return this._onDidChangeCollections.event;
  }
  constructor(e, t) {
    this._extensionService = e, this._storageService = t, this.collections = /* @__PURE__ */ new Map(), this._onDidChangeCollections = new V(), this._storageService.remove("terminal.integrated.environmentVariableCollections", 1);
    const i = this._storageService.get("terminal.integrated.environmentVariableCollectionsV2", 1);
    i && (JSON.parse(i).forEach((c) => this.collections.set(c.extensionIdentifier, {
      persistent: !0,
      map: Xl(c.collection),
      descriptionMap: Yl(c.description)
    })), this._invalidateExtensionCollections()), this.mergedCollection = this._resolveMergedCollection(), this._extensionService.onDidChangeExtensions(() => this._invalidateExtensionCollections());
  }
  set(e, t) {
    this.collections.set(e, t), this._updateCollections();
  }
  delete(e) {
    this.collections.delete(e), this._updateCollections();
  }
  _updateCollections() {
    this._persistCollectionsEventually(), this.mergedCollection = this._resolveMergedCollection(), this._notifyCollectionUpdatesEventually();
  }
  _persistCollectionsEventually() {
    this._persistCollections();
  }
  _persistCollections() {
    const e = [];
    this.collections.forEach((i, s) => {
      i.persistent && e.push({
        extensionIdentifier: s,
        collection: Ql(this.collections.get(s).map),
        description: Jl(i.descriptionMap)
      });
    });
    const t = JSON.stringify(e);
    this._storageService.store("terminal.integrated.environmentVariableCollectionsV2", t, 1, 1);
  }
  _notifyCollectionUpdatesEventually() {
    this._notifyCollectionUpdates();
  }
  _notifyCollectionUpdates() {
    this._onDidChangeCollections.fire(this.mergedCollection);
  }
  _resolveMergedCollection() {
    return new Na(this.collections);
  }
  async _invalidateExtensionCollections() {
    await this._extensionService.whenInstalledExtensionsRegistered();
    const e = this._extensionService.extensions;
    let t = !1;
    this.collections.forEach((i, s) => {
      e.some((l) => l.identifier.value === s) || (this.collections.delete(s), t = !0);
    }), t && this._updateCollections();
  }
};
mi.__decorator = X([
  ma(1e3)
], mi.prototype, "_persistCollectionsEventually", null);
mi.__decorator = X([
  ft(1e3)
], mi.prototype, "_notifyCollectionUpdatesEventually", null);
mi = X([
  D(0, mt),
  D(1, ti)
], mi);
let yr = class extends ue {
  get onDidChangeLogLevel() {
    return this._logger.onDidChangeLogLevel;
  }
  constructor(e, t) {
    super(), this._loggerService = e, this._logger = this._loggerService.createLogger("terminal", { name: g("terminalLoggerName", "Terminal") }), this._register(be.runAndSubscribe(t.onDidChangeWorkspaceFolders, () => {
      this._workspaceId = t.getWorkspace().id.substring(0, 7);
    }));
  }
  getLevel() {
    return this._logger.getLevel();
  }
  setLevel(e) {
    this._logger.setLevel(e);
  }
  flush() {
    this._logger.flush();
  }
  trace(e, ...t) {
    this._logger.trace(this._formatMessage(e), t);
  }
  debug(e, ...t) {
    this._logger.debug(this._formatMessage(e), t);
  }
  info(e, ...t) {
    this._logger.info(this._formatMessage(e), t);
  }
  warn(e, ...t) {
    this._logger.warn(this._formatMessage(e), t);
  }
  error(e, ...t) {
    if (e instanceof Error) {
      this._logger.error(this._formatMessage(""), e, t);
      return;
    }
    this._logger.error(this._formatMessage(e), t);
  }
  _formatMessage(e) {
    return this._logger.getLevel() === vi.Trace ? `[${this._workspaceId}] ${e}` : e;
  }
};
yr = X([
  D(0, Zl),
  D(1, tt)
], yr);
class hu {
  get providers() {
    return this._providers;
  }
  constructor() {
    this._selectors = /* @__PURE__ */ new Map(), this._providers = /* @__PURE__ */ new Map(), this._onDidRegisterProvider = new V(), this.onDidRegisterProvider = this._onDidRegisterProvider.event, this._onDidRegisterCommandSelector = new V(), this.onDidRegisterCommandSelector = this._onDidRegisterCommandSelector.event, this._onDidUnregisterProvider = new V(), this.onDidUnregisterProvider = this._onDidUnregisterProvider.event, this.extensionQuickFixes = new Promise((e) => du.setHandler((t) => {
      e(t.filter((i) => th(i.description, "terminalQuickFixProvider")).map((i) => i.value ? i.value.map(
        (s) => ({ ...s, extensionIdentifier: i.description.identifier.value })
      ) : []).flat());
    })), this.extensionQuickFixes.then((e) => {
      for (const t of e)
        this.registerCommandSelector(t);
    });
  }
  registerCommandSelector(e) {
    this._selectors.set(e.id, e), this._onDidRegisterCommandSelector.fire(e);
  }
  registerQuickFixProvider(e, t) {
    let i = !1;
    return this.extensionQuickFixes.then(() => {
      if (i)
        return;
      this._providers.set(e, t);
      const s = this._selectors.get(e);
      if (!s)
        throw new Error(`No registered selector for ID: ${e}`);
      this._onDidRegisterProvider.fire({ selector: s, provider: t });
    }), je(() => {
      i = !0, this._providers.delete(e);
      const s = this._selectors.get(e);
      s && (this._selectors.delete(e), this._onDidUnregisterProvider.fire(s.id));
    });
  }
}
const du = eh.registerExtensionPoint({
  extensionPoint: "terminalQuickFixes",
  defaultExtensionKind: ["workspace"],
  activationEventsGenerator: (h, e) => {
    for (const t of h ?? [])
      e.push(`onTerminalQuickFixRequest:${t.id}`);
  },
  jsonSchema: {
    description: g(
      "vscode.extension.contributes.terminalQuickFixes",
      "Contributes terminal quick fixes."
    ),
    type: "array",
    items: {
      type: "object",
      additionalProperties: !1,
      required: ["id", "commandLineMatcher", "outputMatcher", "commandExitResult"],
      defaultSnippets: [{
        body: {
          id: "$1",
          commandLineMatcher: "$2",
          outputMatcher: "$3",
          exitStatus: "$4"
        }
      }],
      properties: {
        id: {
          description: g(
            "vscode.extension.contributes.terminalQuickFixes.id",
            "The ID of the quick fix provider"
          ),
          type: "string"
        },
        commandLineMatcher: {
          description: g(
            "vscode.extension.contributes.terminalQuickFixes.commandLineMatcher",
            "A regular expression or string to test the command line against"
          ),
          type: "string"
        },
        outputMatcher: {
          markdownDescription: g(
            "vscode.extension.contributes.terminalQuickFixes.outputMatcher",
            `A regular expression or string to match a single line of the output against, which provides groups to be referenced in terminalCommand and uri.

For example:

 \`lineMatcher: /git push --set-upstream origin (?<branchName>[^s]+)/;\`

\`terminalCommand: 'git push --set-upstream origin \${group:branchName}';\`
`
          ),
          type: "object",
          required: ["lineMatcher", "anchor", "offset", "length"],
          properties: {
            lineMatcher: {
              description: "A regular expression or string to test the command line against",
              type: "string"
            },
            anchor: {
              description: "Where the search should begin in the buffer",
              enum: ["top", "bottom"]
            },
            offset: {
              description: "The number of lines vertically from the anchor in the buffer to start matching against",
              type: "number"
            },
            length: {
              description: "The number of rows to match against, this should be as small as possible for performance reasons",
              type: "number"
            }
          }
        },
        commandExitResult: {
          description: g(
            "vscode.extension.contributes.terminalQuickFixes.commandExitResult",
            "The command exit result to match on"
          ),
          enum: ["success", "error"],
          enumDescriptions: [
            "The command exited with an exit code of zero.",
            "The command exited with a non-zero exit code."
          ]
        }
      }
    }
  }
});
var uu = ".monaco-workbench .xterm-viewport{-webkit-text-fill-color:transparent;-webkit-background-clip:text;background-clip:text;scrollbar-width:thin;transition:background-color .8s linear}.monaco-workbench .xterm-viewport::-webkit-scrollbar{width:10px}.monaco-workbench .xterm-viewport::-webkit-scrollbar-track{opacity:0}.monaco-workbench .xterm-viewport::-webkit-scrollbar-thumb{background-color:inherit;min-height:20px}.monaco-workbench .force-scrollbar .xterm .xterm-viewport,.monaco-workbench .xterm.focus .xterm-viewport,.monaco-workbench .xterm:focus .xterm-viewport,.monaco-workbench .xterm:hover .xterm-viewport{cursor:default;transition:opacity .1s linear}.monaco-workbench .xterm .xterm-viewport::-webkit-scrollbar-thumb:hover{transition:opacity 0ms linear}.monaco-workbench .xterm .xterm-viewport::-webkit-scrollbar-thumb:window-inactive{background-color:inherit}";
Wi(uu, {});
var mu = '.monaco-workbench .pane-body.integrated-terminal{align-content:flex-start;align-items:baseline;background-color:transparent!important;display:flex;flex-direction:column;position:relative;user-select:auto;-webkit-user-select:initial;z-index:0}.terminal-command-decoration.hide{visibility:hidden}.monaco-workbench .part.panel .pane-body.integrated-terminal .terminal-outer-container{background-color:var(--vscode-terminal-background,--vscode-panel-background)}.monaco-workbench .pane-body.integrated-terminal .terminal-group,.monaco-workbench .pane-body.integrated-terminal .terminal-groups-container,.monaco-workbench .pane-body.integrated-terminal .terminal-outer-container,.monaco-workbench .pane-body.integrated-terminal .terminal-split-pane,.monaco-workbench .terminal-editor .terminal-outer-container,.monaco-workbench .terminal-editor .terminal-split-pane{height:100%}.monaco-workbench .part.auxiliarybar .pane-body.integrated-terminal .terminal-outer-container,.monaco-workbench .part.sidebar .pane-body.integrated-terminal .terminal-outer-container{background-color:var(--vscode-terminal-background,--vscode-sideBar-background)}.monaco-workbench .pane-body.integrated-terminal .split-view-view:not(:first-child),.monaco-workbench .pane-body.integrated-terminal .tabs-container{border-color:var(--vscode-terminal-border)}.monaco-workbench .pane-body.integrated-terminal .terminal-drop-overlay{background-color:var(--vscode-terminal-dropBackground,--vscode-editorGroup-dropBackground)}.monaco-workbench .pane-body.integrated-terminal .terminal-tabs-entry.is-active:before{background-color:var(--vscode-terminal-tab-activeBorder)}.monaco-workbench .terminal-editor .xterm textarea:focus{opacity:0!important;outline:0!important}.monaco-workbench .terminal-tab:before{font-family:codicon!important;font-size:16px!important}.monaco-workbench .terminal-tab:not(.terminal-uri-icon):before{background-image:none!important}.monaco-workbench .terminal-editor .terminal-wrapper{background-color:var(--vscode-terminal-background,--vscode-editorPane-background)}.monaco-workbench .pane-body.integrated-terminal .terminal-wrapper,.monaco-workbench .terminal-editor .terminal-wrapper{box-sizing:border-box;display:block;height:100%}.monaco-workbench .xterm{padding:0 10px 2px}.monaco-workbench .pane-body.integrated-terminal .xterm,.monaco-workbench .terminal-editor .xterm{bottom:0;left:0;position:absolute;right:0}.terminal-side-view .terminal.xterm{top:0}.monaco-workbench .pane-body.integrated-terminal .terminal-wrapper.fixed-dims .xterm,.monaco-workbench .terminal-editor .terminal-wrapper.fixed-dims .xterm{position:static}.monaco-workbench .pane-body.integrated-terminal .xterm-viewport,.monaco-workbench .terminal-editor .xterm-viewport{z-index:30}.monaco-workbench .pane-body.integrated-terminal .xterm-decoration-overview-ruler,.monaco-workbench .terminal-editor .xterm-decoration-overview-ruler{pointer-events:none;z-index:31}.monaco-workbench .pane-body.integrated-terminal .xterm-screen,.monaco-workbench .terminal-editor .xterm-screen{z-index:31}.xterm .xterm-screen{cursor:text}.monaco-workbench .simple-find-part-wrapper.result-count{z-index:33!important}.xterm .xterm-accessibility{pointer-events:none;z-index:32!important}.xterm.enable-mouse-events .xterm-screen{cursor:default}.xterm.xterm-cursor-pointer .xterm-screen{cursor:pointer}.xterm.column-select.focus .xterm-screen{cursor:crosshair}.integrated-terminal.shell-integration .xterm,.monaco-workbench .pane-body.integrated-terminal .terminal-group .monaco-split-view2.horizontal .split-view-view:first-child .xterm,.monaco-workbench .terminal-editor .xterm{padding-left:20px!important}.monaco-workbench .pane-body.integrated-terminal .terminal-group .monaco-split-view2.horizontal .split-view-view:last-child .xterm,.monaco-workbench .terminal-editor .terminal-group .monaco-split-view2.horizontal .split-view-view:last-child .xterm{padding-right:20px}.monaco-workbench .pane-body.integrated-terminal .xterm a:not(.xterm-invalid-link),.monaco-workbench .terminal-editor .xterm a:not(.xterm-invalid-link){position:relative}.monaco-workbench .pane-body.integrated-terminal .terminal-wrapper>div,.monaco-workbench .terminal-editor .terminal-wrapper>div{height:100%}.monaco-workbench .pane-body.integrated-terminal .xterm-viewport,.monaco-workbench .terminal-editor .xterm-viewport{box-sizing:border-box}.monaco-workbench .pane-body.integrated-terminal .terminal-wrapper.fixed-dims,.monaco-workbench .terminal-editor .terminal-wrapper.fixed-dims{position:relative}.monaco-workbench .pane-body.integrated-terminal .terminal-wrapper:not(.fixed-dims) .xterm-viewport,.monaco-workbench .terminal-editor .terminal-wrapper:not(.fixed-dims) .xterm-viewport{width:auto!important}.monaco-workbench .pane-body.integrated-terminal{font-variant-ligatures:none}.monaco-workbench .pane-body.integrated-terminal .split-view-view{box-sizing:border-box;overflow:hidden}.monaco-workbench .pane-body.integrated-terminal .split-view-view:first-child .tabs-container{border-right-style:solid;border-right-width:1px}.monaco-workbench .pane-body.integrated-terminal .split-view-view:last-child .tabs-container,.monaco-workbench .pane-body.integrated-terminal .terminal-group .monaco-split-view2.horizontal .split-view-view:not(:first-child){border-left-style:solid;border-left-width:1px}.monaco-workbench .pane-body.integrated-terminal .terminal-group .monaco-split-view2.vertical .split-view-view:not(:first-child){border-top-style:solid;border-top-width:1px}.monaco-workbench .pane-body.integrated-terminal .terminal-groups-container.alt-active .xterm{cursor:default}.monaco-workbench .pane-body.integrated-terminal .xterm{user-select:none;-webkit-user-select:none}.monaco-workbench .pane-body.integrated-terminal .monaco-split-view2.vertical .split-view-view:not(:last-child) .xterm{bottom:auto;top:0}.monaco-workbench .pane-body.integrated-terminal .xterm:focus{outline:none}.monaco-workbench.hc-black .pane-body.integrated-terminal .xterm.focus:before,.monaco-workbench.hc-black .pane-body.integrated-terminal .xterm:focus:before,.monaco-workbench.hc-light .pane-body.integrated-terminal .xterm.focus:before,.monaco-workbench.hc-light .pane-body.integrated-terminal .xterm:focus:before{border:1px solid;bottom:0;content:"";display:block;left:0;pointer-events:none;position:absolute;right:0;top:0;z-index:32}.monaco-workbench.hc-black .pane-body.integrated-terminal .monaco-split-view2.horizontal .split-view-view:not(:only-child) .xterm.focus:before,.monaco-workbench.hc-black .pane-body.integrated-terminal .monaco-split-view2.horizontal .split-view-view:not(:only-child) .xterm:focus:before,.monaco-workbench.hc-light .pane-body.integrated-terminal .monaco-split-view2.horizontal .split-view-view:not(:only-child) .xterm.focus:before,.monaco-workbench.hc-light .pane-body.integrated-terminal .monaco-split-view2.horizontal .split-view-view:not(:only-child) .xterm:focus:before{right:0}.monaco-workbench .pane-body.integrated-terminal .xterm .xterm-helpers{position:absolute;top:0}.monaco-workbench .xterm .xterm-helper-textarea:focus{opacity:0!important}.monaco-workbench.hc-black.mac .pane-body.integrated-terminal .terminal-groups-container:not(.alt-active) .terminal:not(.enable-mouse-events),.monaco-workbench.vs-dark.mac .pane-body.integrated-terminal .terminal-groups-container:not(.alt-active) .terminal:not(.enable-mouse-events){cursor:-webkit-image-set(url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAL0lEQVQoz2NgCD3x//9/BhBYBWdhgFVAiVW4JBFKGIa4AqD0//9D3pt4I4tAdAMAHTQ/j5Zom30AAAAASUVORK5CYII=") 1x,url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAAz0lEQVRIx2NgYGBY/R8I/vx5eelX3n82IJ9FxGf6tksvf/8FiTMQAcAGQMDvSwu09abffY8QYSAScNk45G198eX//yev73/4///701eh//kZSARckrNBRvz//+8+6ZohwCzjGNjdgQxkAg7B9WADeBjIBqtJCbhRA0YNoIkBSNmaPEMoNmA0FkYNoFKhapJ6FGyAH3nauaSmPfwI0v/3OukVi0CIZ+F25KrtYcx/CTIy0e+rC7R1Z4KMICVTQQ14feVXIbR695u14+Ir4gwAAD49E54wc1kWAAAAAElFTkSuQmCC") 2x) 5 8,text}.xterm .xterm-cursor-pointer,.xterm.xterm-cursor-pointer{cursor:pointer!important}.monaco-pane-view .pane>.pane-header .monaco-action-bar .switch-terminal,.monaco-workbench .part.sidebar>.title>.title-actions .switch-terminal,.part.panel>.title>.title-actions .switch-terminal>.monaco-select-box{border-style:solid;border-width:1px}.xterm-screen .xterm-decoration-container .xterm-decoration.quick-fix{z-index:7}.monaco-workbench .part.sidebar>.title>.title-actions .switch-terminal{align-items:center;display:flex;flex-shrink:1;font-size:11px;height:20px;margin-right:.3em;margin-top:7px}.monaco-workbench.mac .part.sidebar>.title>.title-actions .switch-terminal{border-radius:4px}.monaco-workbench .part.sidebar>.title>.title-actions .switch-terminal>.monaco-select-box{background-color:unset!important;border:none!important;display:block!important}.monaco-pane-view .pane>.pane-header .monaco-action-bar .switch-terminal.action-item.select-container{border:none!important}.monaco-workbench .part.sidebar>.title>.title-actions .switch-terminal>.monaco-select-box{padding:0 22px 0 6px}.monaco-workbench .pane-body.integrated-terminal .tabs-container{display:flex;flex-direction:column;height:100%}.monaco-workbench .terminal-overflow-guard{height:100%;overflow:hidden;position:relative}.monaco-workbench .pane-body.integrated-terminal .tabs-list-container{height:100%;overflow:hidden}.monaco-workbench .pane-body.integrated-terminal .tabs-container>.monaco-toolbar{margin:auto;padding:4px 0 2px}.monaco-workbench .pane-body.integrated-terminal .terminal-tabs-entry.is-active:before{bottom:0;content:"";display:block;left:0;position:absolute;top:0;width:1px}.monaco-workbench .pane-body.integrated-terminal .tabs-container.has-text>.monaco-toolbar{margin:0;padding:4px 7px 2px;text-align:left}.monaco-workbench .pane-body.integrated-terminal .tabs-list{height:100%}.monaco-workbench .pane-body.integrated-terminal .tabs-list .terminal-tabs-entry{text-align:center}.monaco-workbench .pane-body.integrated-terminal .tabs-container.has-text .tabs-list .terminal-tabs-entry{padding-left:10px;padding-right:10px;text-align:left}.monaco-workbench .pane-body.integrated-terminal .tabs-container.has-text .tabs-list .terminal-tabs-entry .monaco-icon-label:after{margin-right:0}.monaco-workbench .pane-body.integrated-terminal .tabs-container:not(.has-text) .terminal-tabs-entry .codicon{color:inherit}.monaco-workbench .pane-body.integrated-terminal .tabs-container:not(.has-text) .monaco-icon-description-container{display:none}.monaco-workbench .pane-body.integrated-terminal .tabs-list .codicon{vertical-align:text-bottom}.monaco-workbench .pane-body.integrated-terminal .tabs-list .actions,.monaco-workbench .pane-body.integrated-terminal .tabs-list .editable-tab .monaco-icon-name-container{display:none}.monaco-workbench .pane-body.integrated-terminal .tabs-list .actions .action-label{padding:2px}.monaco-workbench .pane-body.integrated-terminal .tabs-list .monaco-list-row:hover .actions,.monaco-workbench .pane-body.integrated-terminal .tabs-list:focus-within .monaco-list-row.focused .actions,.monaco-workbench .pane-body.integrated-terminal .tabs-list:focus-within .monaco-list-row.selected .actions{display:block}.monaco-action-bar .action-item .single-terminal-tab{align-items:center;display:flex!important}.monaco-action-bar .action-item .single-terminal-tab .codicon:first-child{margin-right:4px}.monaco-action-bar .action-item .single-terminal-tab .codicon:nth-child(2){color:inherit;margin-left:4px}.monaco-workbench .pane-body.integrated-terminal .tabs-container.has-text .tabs-list .terminal-tabs-entry .uri-icon{background-repeat:no-repeat;background-size:contain;height:100%;margin-right:4px}.monaco-action-bar .terminal-uri-icon.single-terminal-tab.action-label .codicon,.monaco-workbench .terminal-uri-icon .monaco-highlighted-label .codicon{background-size:16px}.monaco-action-bar .terminal-uri-icon.single-terminal-tab.action-label:not(.alt-command) .codicon:before,.monaco-workbench .terminal-uri-icon .monaco-highlighted-label .codicon:before{content:"";display:inline-block;height:16px;width:16px}.monaco-workbench .pane-body.integrated-terminal .terminal-drop-overlay{bottom:0;display:block;left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;z-index:34}.monaco-workbench:not(.reduce-motion) .pane-body.integrated-terminal .terminal-drop-overlay{transition:left 70ms ease-out,right 70ms ease-out,top 70ms ease-out,bottom 70ms ease-out,opacity .15s ease-out}.monaco-workbench .pane-body.integrated-terminal .terminal-group>.monaco-split-view2.horizontal .terminal-drop-overlay.drop-before{right:50%}.monaco-workbench .pane-body.integrated-terminal .terminal-group>.monaco-split-view2.horizontal .terminal-drop-overlay.drop-after{left:50%}.monaco-workbench .pane-body.integrated-terminal .terminal-group>.monaco-split-view2.vertical .terminal-drop-overlay.drop-before{bottom:50%}.monaco-workbench .pane-body.integrated-terminal .terminal-group>.monaco-split-view2.vertical .terminal-drop-overlay.drop-after{top:50%}.monaco-workbench .terminal .terminal-command-decoration:not(.default):hover{background-color:var(--vscode-toolbar-hoverBackground);border-radius:5px;cursor:pointer}.monaco-workbench .terminal .terminal-command-decoration{color:var(--vscode-terminalCommandDecoration-successBackground)}.monaco-workbench .terminal .terminal-command-decoration.error{color:var(--vscode-terminalCommandDecoration-errorBackground)}.monaco-workbench .terminal .terminal-command-decoration.default{color:var(--vscode-terminalCommandDecoration-defaultBackground);pointer-events:none}.monaco-workbench .terminal .terminal-command-decoration.quick-fix{background-color:var(--vscode-terminal-background,--vscode-panel-background);color:var(--vscode-editorLightBulb-foreground)!important}.terminal-scroll-highlight{border-left:5px solid #fff;border-left-width:5px!important;left:0;pointer-events:none;right:0}.terminal-scroll-highlight-outline{border:1px solid #fff;pointer-events:none}.terminal-scroll-highlight{border-color:var(--vscode-focusBorder)}.hc-black .xterm-find-result-decoration,.hc-light .xterm-find-result-decoration{outline-style:dotted!important;outline-style:solid!important}.xterm-find-active-result-decoration{outline-style:solid!important;outline-width:2px!important;z-index:7!important}.monaco-workbench.hc-black .editor-instance .xterm.focus:before,.monaco-workbench.hc-black .editor-instance .xterm:focus:before,.monaco-workbench.hc-black .pane-body.integrated-terminal .xterm.focus:before,.monaco-workbench.hc-black .pane-body.integrated-terminal .xterm:focus:before,.monaco-workbench.hc-light .editor-instance .xterm.focus:before,.monaco-workbench.hc-light .editor-instance .xterm:focus:before,.monaco-workbench.hc-light .pane-body.integrated-terminal .xterm.focus:before,.monaco-workbench.hc-light .pane-body.integrated-terminal .xterm:focus:before{border-color:var(--vscode-contrastActiveBorder)}.monaco-workbench .integrated-terminal .hoverHighlight{background-color:var(--vscode-terminal-hoverHighlightBackground)}.force-scrollbar .xterm .xterm-viewport,.monaco-workbench .xterm.focus .xterm-viewport,.monaco-workbench .xterm:focus .xterm-viewport,.monaco-workbench .xterm:hover .xterm-viewport{background-color:var(--vscode-scrollbarSlider-background)!important}.monaco-workbench .xterm-viewport{scrollbar-color:var(--vscode-scrollbarSlider-background) transparent}.monaco-workbench .xterm .xterm-viewport::-webkit-scrollbar-thumb:hover{background-color:var(--vscode-scrollbarSlider-hoverBackground)}.monaco-workbench .xterm-viewport:hover{scrollbar-color:var(--vscode-scrollbarSlider-hoverBackground) transparent}.monaco-workbench .xterm .xterm-viewport::-webkit-scrollbar-thumb:active{background-color:var(--vscode-scrollbarSlider-activeBackground)}.monaco-workbench .terminal-accessible-widget{bottom:0;cursor:default;left:10px;opacity:0;overflow:initial;overflow-x:initial;padding:0;pointer-events:none;position:absolute;right:0;top:0;z-index:0}.monaco-workbench .terminal-accessible-widget div{white-space:pre-wrap}.monaco-workbench .terminal-accessible-widget.active,.monaco-workbench .terminal-accessible-widget.focus-within{background-color:var(--vscode-terminal-background,--vscode-panel-background);opacity:1;pointer-events:all;z-index:33}.monaco-workbench .xterm.terminal.hide{visibility:hidden}';
Wi(mu, {});
var fu = ".monaco-workbench .terminal-widget-container{bottom:0;left:0;overflow:visible;position:absolute;right:0;top:0}.monaco-workbench .terminal-overlay-widget{bottom:0;color:#3794ff;left:0;position:absolute}.monaco-workbench .terminal-hover-target{position:absolute;z-index:33}.monaco-workbench .terminal-env-var-info{height:28px;opacity:.5;position:absolute;right:10px;text-align:center;top:0;width:28px;z-index:32}.monaco-workbench .terminal-env-var-info.requires-action,.monaco-workbench .terminal-env-var-info:hover{opacity:1}.monaco-workbench .terminal-env-var-info.codicon{line-height:28px}";
Wi(fu, {});
var _u = ".xterm{cursor:text;position:relative;user-select:none;-ms-user-select:none;-webkit-user-select:none}.xterm.focus,.xterm:focus{outline:none}.xterm .xterm-helpers{position:absolute;top:0;z-index:5}.xterm .xterm-helper-textarea{border:0;height:0;left:-9999em;margin:0;opacity:0;overflow:hidden;padding:0;position:absolute;resize:none;top:0;white-space:nowrap;width:0;z-index:-5}.xterm .composition-view{background:#000;color:#fff;display:none;position:absolute;white-space:nowrap;z-index:1}.xterm .composition-view.active{display:block}.xterm .xterm-viewport{background-color:#000;bottom:0;cursor:default;left:0;overflow-y:scroll;position:absolute;right:0;top:0}.xterm .xterm-screen{position:relative}.xterm .xterm-screen canvas{left:0;position:absolute;top:0}.xterm .xterm-scroll-area{visibility:hidden}.xterm-char-measure-element{display:inline-block;left:-9999em;line-height:normal;position:absolute;top:0;visibility:hidden}.xterm.enable-mouse-events{cursor:default}.xterm .xterm-cursor-pointer,.xterm.xterm-cursor-pointer{cursor:pointer}.xterm.column-select.focus{cursor:crosshair}.xterm .xterm-accessibility,.xterm .xterm-message{bottom:0;color:transparent;left:0;pointer-events:none;position:absolute;right:0;top:0;z-index:10}.xterm .live-region{height:1px;left:-9999px;overflow:hidden;position:absolute;width:1px}.xterm-dim{opacity:1!important}.xterm-underline-1{text-decoration:underline}.xterm-underline-2{text-decoration:double underline}.xterm-underline-3{text-decoration:wavy underline}.xterm-underline-4{text-decoration:dotted underline}.xterm-underline-5{text-decoration:dashed underline}.xterm-overline{text-decoration:overline}.xterm-overline.xterm-underline-1{text-decoration:overline underline}.xterm-overline.xterm-underline-2{text-decoration:overline double underline}.xterm-overline.xterm-underline-3{text-decoration:overline wavy underline}.xterm-overline.xterm-underline-4{text-decoration:overline dotted underline}.xterm-overline.xterm-underline-5{text-decoration:overline dashed underline}.xterm-strikethrough{text-decoration:line-through}.xterm-screen .xterm-decoration-container .xterm-decoration{position:absolute;z-index:6}.xterm-screen .xterm-decoration-container .xterm-decoration.xterm-decoration-top-layer{z-index:7}.xterm-decoration-overview-ruler{pointer-events:none;position:absolute;right:0;top:0;z-index:8}.xterm-decoration-top{position:relative;z-index:2}";
Wi(_u, {});
function rs(h) {
  var n;
  let e = "";
  const t = h.statusList.statuses, i = [];
  for (const r of t)
    e += `

---

${r.icon ? `$(${(n = r.icon) == null ? void 0 : n.id}) ` : ""}${r.tooltip || r.id}`, r.hoverActions && i.push(...r.hoverActions);
  const s = pu(h, !0), c = gu(h, !0);
  return { content: new de(
    h.title + s + c + e,
    { supportThemeIcons: !0 }
  ), actions: i };
}
function gu(h, e) {
  const t = [];
  h.capabilities.has(2) && t.push(2), h.capabilities.has(0) && t.push(0);
  let i = "";
  return t.length > 0 ? i += `${e ? `

---

` : `

`}${g("shellIntegration.enabled", "Shell integration activated")}` : h.shellLaunchConfig.ignoreShellIntegration ? i += `${e ? `

---

` : `

`}${g(
    "launchFailed.exitCodeOnlyShellIntegration",
    "The terminal process failed to launch. Disabling shell integration with terminal.integrated.shellIntegration.enabled might help."
  )}` : h.usedShellIntegrationInjection && (i += `${e ? `

---

` : `

`}${g(
    "shellIntegration.activationFailed",
    "Shell integration failed to activate"
  )}`), i;
}
function pu(h, e) {
  const t = [];
  if (h.processId && t.push(g(
    { key: "shellProcessTooltip.processId", comment: [`The first arg is "PID" which shouldn't be translated`] },
    "Process ID ({0}): {1}",
    "PID",
    h.processId
  ) + `
`), h.shellLaunchConfig.executable) {
    let i = h.shellLaunchConfig.executable;
    const s = ih(h.injectedArgs || h.shellLaunchConfig.args || []).map((c) => `'${c}'`).join(" ");
    s && (i += ` ${s}`), t.push(g("shellProcessTooltip.commandLine", "Command line: {0}", i));
  }
  return t.length ? `${e ? `

---

` : `

`}${t.join(`
`)}` : "";
}
const Oo = Ve;
let xr = class extends sh {
  constructor(e, t, i, s, c, l, n, r, a, f, m, C) {
    super("TerminalTabsList", e, {
      getHeight: () => 22,
      getTemplateId: () => "terminal.tabs"
    }, [r.createInstance(kr, e, r.createInstance(rh, oh), () => this.getSelectedElements())], {
      horizontalScrolling: !1,
      supportDynamicHeights: !1,
      selectionNavigation: !0,
      identityProvider: {
        getId: (p) => p == null ? void 0 : p.instanceId
      },
      accessibilityProvider: r.createInstance(Ir),
      smoothScrolling: c.getValue("workbench.list.smoothScrolling"),
      multipleSelectionSupport: !0,
      paddingBottom: 22,
      dnd: r.createInstance(Tr),
      openOnSingleClick: !0
    }, t, i, c, r), this._configurationService = c, this._terminalService = l, this._terminalGroupService = n, this._themeService = f, this._hoverService = C;
    const b = [
      this._terminalGroupService.onDidChangeInstances(() => this.refresh()),
      this._terminalGroupService.onDidChangeGroups(() => this.refresh()),
      this._terminalGroupService.onDidShow(() => this.refresh()),
      this._terminalGroupService.onDidChangeInstanceCapability(() => this.refresh()),
      this._terminalService.onDidChangeInstanceTitle(() => this.refresh()),
      this._terminalService.onDidChangeInstanceIcon(() => this.refresh()),
      this._terminalService.onDidChangeInstancePrimaryStatus(() => this.refresh()),
      this._terminalService.onDidChangeConnectionState(() => this.refresh()),
      this._themeService.onDidColorThemeChange(() => this.refresh()),
      this._terminalGroupService.onDidChangeActiveInstance((p) => {
        if (p) {
          const S = this._terminalGroupService.instances.indexOf(p);
          this.setSelection([S]), this.reveal(S);
        }
        this.refresh();
      })
    ];
    m.onWillShutdown((p) => {
      ye(b);
    }), this.onMouseDblClick(async (p) => {
      var o, _, u;
      if (this.getFocus().length === 0) {
        const d = await this._terminalService.createTerminal({ location: se.Panel });
        this._terminalGroupService.setActiveInstance(d), await d.focusWhenReady();
      }
      ((o = this._terminalService.getEditingTerminal()) == null ? void 0 : o.instanceId) !== ((_ = p.element) == null ? void 0 : _.instanceId) && this._getFocusMode() === "doubleClick" && this.getFocus().length === 1 && ((u = p.element) == null || u.focus(!0));
    }), this.onMouseClick(async (p) => {
      var S, o, _;
      ((S = this._terminalService.getEditingTerminal()) == null ? void 0 : S.instanceId) !== ((o = p.element) == null ? void 0 : o.instanceId) && (p.browserEvent.altKey && p.element ? await this._terminalService.createTerminal({ location: { parentTerminal: p.element } }) : this._getFocusMode() === "singleClick" && this.getSelection().length <= 1 && ((_ = p.element) == null || _.focus(!0)));
    }), this.onContextMenu((p) => {
      if (!p.element) {
        this.setSelection([]);
        return;
      }
      const S = this.getSelectedElements();
      (!S || !S.find((o) => p.element === o)) && this.setFocus(p.index !== void 0 ? [p.index] : []);
    }), this._terminalTabsSingleSelectedContextKey = E.tabsSingularSelection.bindTo(t), this._isSplitContextKey = E.splitTerminal.bindTo(t), this.onDidChangeSelection((p) => this._updateContextKey()), this.onDidChangeFocus(() => this._updateContextKey()), this.onDidOpen(async (p) => {
      const S = p.element;
      S && (this._terminalGroupService.setActiveInstance(S), p.editorOptions.preserveFocus || await S.focusWhenReady());
    }), this._decorationsProvider || (this._decorationsProvider = r.createInstance(Dr), a.registerDecorationsProvider(this._decorationsProvider)), this.refresh();
  }
  _getFocusMode() {
    return this._configurationService.getValue("terminal.integrated.tabs.focusMode");
  }
  refresh(e = !0) {
    e && this._terminalService.isEditable(void 0) && this.domFocus(), this.splice(0, this.length, this._terminalGroupService.instances.slice());
  }
  focusHover() {
    const e = this.getSelectedElements()[0];
    e && this._hoverService.showHover({
      ...rs(e),
      target: this.getHTMLElement(),
      trapFocus: !0
    }, !0);
  }
  _updateContextKey() {
    this._terminalTabsSingleSelectedContextKey.set(this.getSelectedElements().length === 1);
    const e = this.getFocusedElements();
    this._isSplitContextKey.set(e.length > 0 && this._terminalGroupService.instanceIsSplit(e[0]));
  }
};
xr = X([
  D(1, Fe),
  D(2, Gn),
  D(3, Me),
  D(4, Se),
  D(5, we),
  D(6, Ae),
  D(7, le),
  D(8, nh),
  D(9, Me),
  D(10, is),
  D(11, on)
], xr);
let kr = class {
  constructor(e, t, i, s, c, l, n, r, a, f, m, C) {
    this._container = e, this._labels = t, this._getSelection = i, this._instantiationService = s, this._terminalService = c, this._terminalGroupService = l, this._hoverService = n, this._configurationService = r, this._keybindingService = a, this._listService = f, this._themeService = m, this._contextViewService = C, this.templateId = "terminal.tabs";
  }
  renderTemplate(e) {
    const t = Qe(e, Oo(".terminal-tabs-entry")), i = {}, s = this._labels.create(t, {
      supportHighlights: !0,
      supportDescriptionHighlights: !0,
      supportIcons: !0,
      hoverDelegate: {
        delay: this._configurationService.getValue("workbench.hover.delay"),
        showHover: (n) => this._hoverService.showHover({
          ...n,
          actions: i.hoverActions,
          hideOnHover: !0
        })
      }
    }), c = Qe(s.element, Oo(".actions")), l = new ah(c, {
      actionViewItemProvider: (n) => n instanceof En ? this._instantiationService.createInstance(ga, n, void 0) : void 0
    });
    return {
      element: t,
      label: s,
      actionBar: l,
      context: i,
      elementDisposables: new Zt()
    };
  }
  shouldHideText() {
    return this._container ? this._container.clientWidth < 63 : !1;
  }
  shouldHideActionBar() {
    return this._container ? this._container.clientWidth <= 105 : !1;
  }
  renderElement(e, t, i) {
    var S;
    const s = !this.shouldHideText(), c = this._terminalGroupService.getGroupForInstance(e);
    if (!c)
      throw new Error(`Could not find group for instance "${e.instanceId}"`);
    i.element.classList.toggle("has-text", s), i.element.classList.toggle("is-active", this._terminalGroupService.activeInstance === e);
    let l = "";
    if (c.terminalInstances.length > 1) {
      const o = c.terminalInstances.indexOf(e);
      o === 0 ? l = "┌ " : o === c.terminalInstances.length - 1 ? l = "└ " : l = "├ ";
    }
    const n = rs(e);
    i.context.hoverActions = n.actions;
    const r = this._instantiationService.invokeFunction($r, e), a = !this.shouldHideActionBar();
    let f = "";
    if (s)
      this.fillActionBar(e, i), f = l, e.icon && (f += `$(${r}) ${e.title}`);
    else {
      const o = e.statusList.primary;
      o && o.severity > wt.Ignore ? f = `${l}$(${((S = o.icon) == null ? void 0 : S.id) || r})` : f = `${l}$(${r})`;
    }
    a || i.actionBar.clear(), i.elementDisposables.add(he(i.element, et.AUXCLICK, (o) => {
      o.stopImmediatePropagation(), o.button === 1 && this._terminalService.safeDisposeTerminal(e);
    }));
    const m = [], C = Jt(e);
    C && m.push(C);
    const b = fi(e, this._themeService.getColorTheme().type);
    b && m.push(...b), i.label.setResource({
      resource: e.resource,
      name: f,
      description: s ? e.description : void 0
    }, {
      fileDecorations: {
        colors: !0,
        badges: s
      },
      title: {
        markdown: n.content,
        markdownNotSupportedFallback: void 0
      },
      extraClasses: m
    });
    const p = this._terminalService.getEditableData(e);
    i.label.element.classList.toggle("editable-tab", !!p), p && (i.elementDisposables.add(this._renderInputBox(i.label.element.querySelector(".monaco-icon-label-container"), e, p)), i.actionBar.clear());
  }
  _renderInputBox(e, t, i) {
    const s = t.title || "", c = new ch(e, this._contextViewService, {
      validationOptions: {
        validation: (a) => {
          const f = i.validationMessage(a);
          return !f || f.severity !== wt.Error ? null : {
            content: f.content,
            formatContent: !0,
            type: 3
          };
        }
      },
      ariaLabel: g(
        "terminalInputAriaLabel",
        "Type terminal name. Press Enter to confirm or Escape to cancel."
      ),
      inputBoxStyles: lh
    });
    c.element.style.height = "22px", c.value = s, c.focus(), c.select({ start: 0, end: s.length });
    const l = uh((a, f) => {
      c.element.style.display = "none";
      const m = c.value;
      ye(r), c.element.remove(), f && i.onFinish(m, a);
    }), n = () => {
      if (c.isInputValid()) {
        const a = i.validationMessage(c.value);
        a ? c.showMessage({
          content: a.content,
          formatContent: !0,
          type: a.severity === wt.Info ? 1 : a.severity === wt.Warning ? 2 : 3
        }) : c.hideMessage();
      }
    };
    n();
    const r = [
      c,
      ho(c.inputElement, et.KEY_DOWN, (a) => {
        a.stopPropagation(), a.equals(3) ? l(c.isInputValid(), !0) : a.equals(9) && l(!1, !0);
      }),
      ho(c.inputElement, et.KEY_UP, (a) => {
        n();
      }),
      he(c.inputElement, et.BLUR, () => {
        l(c.isInputValid(), !0);
      })
    ];
    return je(() => {
      l(!1, !1);
    });
  }
  disposeElement(e, t, i) {
    i.elementDisposables.clear(), i.actionBar.clear();
  }
  disposeTemplate(e) {
    e.elementDisposables.dispose(), e.label.dispose(), e.actionBar.dispose();
  }
  fillActionBar(e, t) {
    var s;
    const i = [
      new ve(
        "workbench.action.terminal.splitInstance",
        Q.split.short,
        re.asClassName(te.splitHorizontal),
        !0,
        async () => {
          this._runForSelectionOrInstance(e, async (c) => {
            this._terminalService.createTerminal({ location: { parentTerminal: c } });
          });
        }
      ),
      new ve(
        "workbench.action.terminal.killInstance",
        Q.kill.short,
        re.asClassName(te.trashcan),
        !0,
        async () => {
          this._runForSelectionOrInstance(e, (c) => this._terminalService.safeDisposeTerminal(c));
        }
      )
    ];
    t.actionBar.clear();
    for (const c of i)
      t.actionBar.push(c, { icon: !0, label: !1, keybinding: (s = this._keybindingService.lookupKeybinding(c.id)) == null ? void 0 : s.getLabel() });
  }
  _runForSelectionOrInstance(e, t) {
    var s;
    const i = this._getSelection();
    if (i.includes(e))
      for (const c of i)
        c && t(c);
    else
      t(e);
    this._terminalGroupService.focusTabs(), (s = this._listService.lastFocusedList) == null || s.focusNext();
  }
};
kr = X([
  D(3, le),
  D(4, we),
  D(5, Ae),
  D(6, on),
  D(7, Se),
  D(8, ui),
  D(9, Gn),
  D(10, Me),
  D(11, _a)
], kr);
let Ir = class {
  constructor(e) {
    this._terminalGroupService = e;
  }
  getWidgetAriaLabel() {
    return g("terminal.tabs", "Terminal tabs");
  }
  getAriaLabel(e) {
    var s;
    let t = "";
    const i = this._terminalGroupService.getGroupForInstance(e);
    if (i && ((s = i.terminalInstances) == null ? void 0 : s.length) > 1) {
      const c = i.terminalInstances.indexOf(e);
      t = g({
        key: "splitTerminalAriaLabel",
        comment: [
          "The terminal's ID",
          "The terminal's title",
          "The terminal's split number",
          "The terminal group's total split number"
        ]
      }, "Terminal {0} {1}, split {2} of {3}", e.instanceId, e.title, c + 1, i.terminalInstances.length);
    } else
      t = g({
        key: "terminalAriaLabel",
        comment: [
          "The terminal's ID",
          "The terminal's title"
        ]
      }, "Terminal {0} {1}", e.instanceId, e.title);
    return t;
  }
};
Ir = X([
  D(0, Ae)
], Ir);
let Tr = class {
  constructor(e, t) {
    this._terminalService = e, this._terminalGroupService = t, this._autoFocusDisposable = ue.None, this._primaryBackend = this._terminalService.getPrimaryBackend();
  }
  getDragURI(e) {
    var t;
    return ((t = this._terminalService.getEditingTerminal()) == null ? void 0 : t.instanceId) === e.instanceId ? null : e.resource.toString();
  }
  getDragLabel(e, t) {
    return e.length === 1 ? e[0].title : void 0;
  }
  onDragLeave() {
    this._autoFocusInstance = void 0, this._autoFocusDisposable.dispose(), this._autoFocusDisposable = ue.None;
  }
  onDragStart(e, t) {
    if (!t.dataTransfer)
      return;
    const i = e.getData();
    if (!Array.isArray(i))
      return;
    const s = i.filter((c) => "instanceId" in c);
    s.length > 0 && t.dataTransfer.setData("Terminals", JSON.stringify(s.map((c) => c.resource.toString())));
  }
  onDragOver(e, t, i, s) {
    if (e instanceof hh && !zi(s, wi.FILES, wi.RESOURCES, "Terminals", Tn.FILES))
      return !1;
    const c = this._autoFocusInstance !== t;
    return c && (this._autoFocusDisposable.dispose(), this._autoFocusInstance = t), !t && !zi(s, "Terminals") ? e instanceof uo : (c && t && (this._autoFocusDisposable = dh(() => {
      this._terminalService.setActiveInstance(t), this._autoFocusInstance = void 0;
    }, 500)), {
      feedback: i ? [i] : void 0,
      accept: !0,
      effect: 1
    });
  }
  async drop(e, t, i, s) {
    this._autoFocusDisposable.dispose(), this._autoFocusInstance = void 0;
    let c;
    const l = [], n = Fa(s);
    if (n)
      for (const a of n) {
        const f = this._terminalService.getInstanceFromResource(a);
        if (f)
          c = [f], this._terminalService.moveToTerminalView(f);
        else if (this._primaryBackend) {
          const m = eo(a);
          m.instanceId && l.push(this._primaryBackend.requestDetachInstance(m.workspaceId, m.instanceId));
        }
      }
    if (l.length) {
      let a = await Promise.all(l);
      a = a.filter((m) => m !== void 0);
      let f;
      for (const m of a)
        f = await this._terminalService.createTerminal({ config: { attachPersistentProcess: m } });
      f && this._terminalService.setActiveInstance(f);
      return;
    }
    if (c === void 0) {
      if (!(e instanceof uo)) {
        this._handleExternalDrop(t, s);
        return;
      }
      const a = e.getData();
      if (!a || !Array.isArray(a))
        return;
      c = [];
      for (const f of a)
        "instanceId" in f && c.push(f);
    }
    if (!t) {
      this._terminalGroupService.moveGroupToEnd(c[0]), this._terminalService.setActiveInstance(c[0]);
      return;
    }
    let r = !1;
    for (const a of c)
      this._terminalGroupService.moveGroup(a, t), r || (this._terminalService.setActiveInstance(a), r = !0);
  }
  async _handleExternalDrop(e, t) {
    if (!e || !t.dataTransfer)
      return;
    let i;
    const s = t.dataTransfer.getData(wi.RESOURCES);
    s && (i = oe.parse(JSON.parse(s)[0]));
    const c = t.dataTransfer.getData(Tn.FILES);
    !i && c && (i = oe.file(JSON.parse(c)[0])), !i && t.dataTransfer.files.length > 0 && t.dataTransfer.files[0].path && (i = oe.file(t.dataTransfer.files[0].path)), i && (this._terminalService.setActiveInstance(e), e.focus(), await e.sendPath(i, !1));
  }
};
Tr = X([
  D(0, we),
  D(1, Ae)
], Tr);
let Dr = class {
  constructor(e) {
    this._terminalService = e, this.label = g("label", "Terminal"), this._onDidChange = new V(), this._terminalService.onDidChangeInstancePrimaryStatus((t) => this._onDidChange.fire([t.resource]));
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  provideDecorations(e) {
    var s;
    if (e.scheme !== me.vscodeTerminal)
      return;
    const t = this._terminalService.getInstanceFromResource(e);
    if (!t)
      return;
    const i = (s = t == null ? void 0 : t.statusList) == null ? void 0 : s.primary;
    if (i != null && i.icon)
      return {
        color: Va(i.severity),
        letter: i.icon,
        tooltip: i.tooltip
      };
  }
  dispose() {
    this.dispose();
  }
};
Dr = X([
  D(0, we)
], Dr);
function Xi(h, e, t, i, s) {
  const c = new mh(h), l = [];
  pa(t, void 0, l), s && l.push(...s), i.showContextMenu({
    getAnchor: () => c,
    getActions: () => l,
    getActionsContext: () => e
  });
}
const $i = Ve;
let Er = class extends ue {
  constructor(e, t, i, s, c, l, n, r, a, f, m) {
    super(), this._terminalService = t, this._terminalGroupService = i, this._instantiationService = s, this._notificationService = c, this._contextMenuService = l, this._configurationService = n, this._storageService = a, this._hoverService = m, this._cancelContextMenu = !1, this._parentElement = e, this._tabContainer = $i(".tabs-container");
    const C = $i(".tabs-list-container");
    this._tabListElement = $i(".tabs-list"), C.appendChild(this._tabListElement), this._tabContainer.appendChild(C), this._instanceMenu = this._register(r.createMenu(J.TerminalInstanceContext, f)), this._tabsListMenu = this._register(r.createMenu(J.TerminalTabContext, f)), this._tabsListEmptyMenu = this._register(r.createMenu(J.TerminalTabEmptyAreaContext, f)), this._tabList = this._register(this._instantiationService.createInstance(xr, this._tabListElement));
    const b = $i(".terminal-outer-container");
    this._terminalContainer = $i(".terminal-groups-container"), b.appendChild(this._terminalContainer), this._terminalService.setContainers(e, this._terminalContainer), this._terminalIsTabsNarrowContextKey = E.tabsNarrow.bindTo(f), this._terminalTabsFocusContextKey = E.tabsFocus.bindTo(f), this._terminalTabsMouseContextKey = E.tabsMouse.bindTo(f), this._tabTreeIndex = this._terminalService.configHelper.config.tabs.location === "left" ? 0 : 1, this._terminalContainerIndex = this._terminalService.configHelper.config.tabs.location === "left" ? 1 : 0, n.onDidChangeConfiguration((p) => {
      p.affectsConfiguration("terminal.integrated.tabs.enabled") || p.affectsConfiguration("terminal.integrated.tabs.hideCondition") ? this._refreshShowTabs() : p.affectsConfiguration("terminal.integrated.tabs.location") && (this._tabTreeIndex = this._terminalService.configHelper.config.tabs.location === "left" ? 0 : 1, this._terminalContainerIndex = this._terminalService.configHelper.config.tabs.location === "left" ? 1 : 0, this._shouldShowTabs() && (this._splitView.swapViews(0, 1), this._removeSashListener(), this._addSashListener(), this._splitView.resizeView(this._tabTreeIndex, this._getLastListWidth())));
    }), this._register(this._terminalGroupService.onDidChangeInstances(() => this._refreshShowTabs())), this._register(this._terminalGroupService.onDidChangeGroups(() => this._refreshShowTabs())), this._attachEventListeners(e, this._terminalContainer), this._terminalGroupService.onDidChangePanelOrientation((p) => {
      this._panelOrientation = p, this._panelOrientation === 0 ? this._terminalContainer.classList.add("terminal-side-view") : this._terminalContainer.classList.remove("terminal-side-view");
    }), this._splitView = new ua(
      e,
      { orientation: 1, proportionalLayout: !1 }
    ), this._setupSplitView(b);
  }
  _shouldShowTabs() {
    const e = this._terminalService.configHelper.config.tabs.enabled, t = this._terminalService.configHelper.config.tabs.hideCondition;
    return e ? t === "never" || t === "singleTerminal" && this._terminalGroupService.instances.length > 1 || t === "singleGroup" && this._terminalGroupService.groups.length > 1 : !1;
  }
  _refreshShowTabs() {
    this._shouldShowTabs() ? this._splitView.length === 1 && (this._addTabTree(), this._addSashListener(), this._splitView.resizeView(this._tabTreeIndex, this._getLastListWidth()), this.rerenderTabs()) : this._splitView.length === 2 && !this._terminalTabsMouseContextKey.get() && (this._splitView.removeView(this._tabTreeIndex), this._plusButton && this._tabContainer.removeChild(this._plusButton), this._removeSashListener());
  }
  _getLastListWidth() {
    const e = this._panelOrientation === 0 ? "tabs-list-width-vertical" : "tabs-list-width-horizontal", t = this._storageService.get(e, 0);
    return !t || !parseInt(t) ? this._panelOrientation === 0 ? 46 : 120 : parseInt(t);
  }
  _handleOnDidSashReset() {
    let e = 80;
    const t = document.createElement("canvas");
    t.width = 1, t.height = 1;
    const i = t.getContext("2d");
    if (i) {
      const c = window.getComputedStyle(this._tabListElement);
      i.font = `${c.fontStyle} ${c.fontSize} ${c.fontFamily}`;
      const l = this._terminalGroupService.instances.reduce((n, r) => Math.max(n, i.measureText(r.title + (r.description || "")).width + this._getAdditionalWidth(r)), 0);
      e = Math.ceil(Math.max(l, 80));
    }
    Math.ceil(this._splitView.getViewSize(this._tabTreeIndex)) === e && (e = 46), this._splitView.resizeView(this._tabTreeIndex, e), this._updateListWidth(e);
  }
  _getAdditionalWidth(e) {
    var c;
    const i = e.statusList.statuses.length > 0 ? 30 : 0;
    return 40 + ((((c = this._terminalGroupService.getGroupForInstance(e)) == null ? void 0 : c.terminalInstances.length) || 0) > 1 ? 30 : 0) + i;
  }
  _handleOnDidSashChange() {
    const e = this._splitView.getViewSize(this._tabTreeIndex);
    !this._width || e <= 0 || this._updateListWidth(e);
  }
  _updateListWidth(e) {
    e < 63 && e >= 46 ? (e = 46, this._splitView.resizeView(this._tabTreeIndex, e)) : e >= 63 && e < 80 && (e = 80, this._splitView.resizeView(this._tabTreeIndex, e)), this.rerenderTabs();
    const t = this._panelOrientation === 0 ? "tabs-list-width-vertical" : "tabs-list-width-horizontal";
    this._storageService.store(t, e, 0, 0);
  }
  _setupSplitView(e) {
    this._register(this._splitView.onDidSashReset(() => this._handleOnDidSashReset())), this._register(this._splitView.onDidSashChange(() => this._handleOnDidSashChange())), this._shouldShowTabs() && this._addTabTree(), this._splitView.addView({
      element: e,
      layout: (t) => this._terminalGroupService.groups.forEach((i) => i.layout(t, this._height || 0)),
      minimumSize: 120,
      maximumSize: Number.POSITIVE_INFINITY,
      onDidChange: () => ue.None,
      priority: 2
    }, Dn.Distribute, this._terminalContainerIndex), this._shouldShowTabs() && this._addSashListener();
  }
  _addTabTree() {
    this._splitView.addView({
      element: this._tabContainer,
      layout: (e) => this._tabList.layout(this._height || 0, e),
      minimumSize: 46,
      maximumSize: 500,
      onDidChange: () => ue.None,
      priority: 1
    }, Dn.Distribute, this._tabTreeIndex), this.rerenderTabs();
  }
  rerenderTabs() {
    this._updateHasText(), this._tabList.refresh();
  }
  _addSashListener() {
    let e;
    this._sashDisposables = [
      this._splitView.sashes[0].onDidStart((t) => {
        e = window.setInterval(() => {
          this.rerenderTabs();
        }, 100);
      }),
      this._splitView.sashes[0].onDidEnd((t) => {
        window.clearInterval(e), e = 0;
      })
    ];
  }
  _removeSashListener() {
    this._sashDisposables && (ye(this._sashDisposables), this._sashDisposables = void 0);
  }
  _updateHasText() {
    const e = this._tabListElement.clientWidth > 63;
    this._tabContainer.classList.toggle("has-text", e), this._terminalIsTabsNarrowContextKey.set(!e);
  }
  layout(e, t) {
    this._height = t, this._width = e, this._splitView.layout(e), this._shouldShowTabs() && this._splitView.resizeView(this._tabTreeIndex, this._getLastListWidth()), this._updateHasText();
  }
  _attachEventListeners(e, t) {
    this._register(he(this._tabContainer, "mouseleave", async (i) => {
      this._terminalTabsMouseContextKey.set(!1), this._refreshShowTabs(), i.stopPropagation();
    })), this._register(he(this._tabContainer, "mouseenter", async (i) => {
      this._terminalTabsMouseContextKey.set(!0), i.stopPropagation();
    })), this._register(he(t, "mousedown", async (i) => {
      const s = this._terminalGroupService.activeInstance;
      if (this._terminalGroupService.instances.length === 0 || !s) {
        this._cancelContextMenu = !0;
        return;
      }
      if (i.which === 2 && zn)
        s.focus();
      else if (i.which === 3) {
        const c = this._terminalService.configHelper.config.rightClickBehavior;
        if (c === "nothing") {
          i.shiftKey || (this._cancelContextMenu = !0);
          return;
        } else if (c === "copyPaste" || c === "paste") {
          if (c === "copyPaste" && i.shiftKey) {
            Xi(i, this._parentElement, this._instanceMenu, this._contextMenuService);
            return;
          }
          c === "copyPaste" && s.hasSelection() ? (await s.copySelection(), s.clearSelection()) : bi.clipboard.readText ? s.paste() : this._notificationService.info(`This browser doesn't support the clipboard.readText API needed to trigger a paste, try ${rt ? "⌘" : "Ctrl"}+V instead.`), rt && setTimeout(() => {
            s.clearSelection();
          }, 0), this._cancelContextMenu = !0;
        }
      }
    })), this._register(he(t, "contextmenu", (i) => {
      this._terminalService.configHelper.config.rightClickBehavior === "nothing" && !i.shiftKey && (this._cancelContextMenu = !0), this._cancelContextMenu || Xi(i, this._parentElement, this._instanceMenu, this._contextMenuService), i.preventDefault(), i.stopImmediatePropagation(), this._cancelContextMenu = !1;
    })), this._register(he(this._tabContainer, "contextmenu", (i) => {
      if (this._terminalService.configHelper.config.rightClickBehavior === "nothing" && !i.shiftKey && (this._cancelContextMenu = !0), !this._cancelContextMenu) {
        const c = this._tabList.getFocus().length === 0;
        Xi(i, this._parentElement, c ? this._tabsListEmptyMenu : this._tabsListMenu, this._contextMenuService, c ? this._getTabActions() : void 0);
      }
      i.preventDefault(), i.stopImmediatePropagation(), this._cancelContextMenu = !1;
    })), this._register(he(document, "keydown", (i) => {
      t.classList.toggle("alt-active", !!i.altKey);
    })), this._register(he(document, "keyup", (i) => {
      t.classList.toggle("alt-active", !!i.altKey);
    })), this._register(he(e, "keyup", (i) => {
      i.keyCode === 27 && i.stopPropagation();
    })), this._register(he(this._tabContainer, et.FOCUS_IN, () => {
      this._terminalTabsFocusContextKey.set(!0);
    })), this._register(he(this._tabContainer, et.FOCUS_OUT, () => {
      this._terminalTabsFocusContextKey.set(!1);
    }));
  }
  _getTabActions() {
    return [
      new ci(),
      this._configurationService.inspect("terminal.integrated.tabs.location").userValue === "left" ? new ve("moveRight", g("moveTabsRight", "Move Tabs Right"), void 0, void 0, async () => {
        this._configurationService.updateValue("terminal.integrated.tabs.location", "right");
      }) : new ve("moveLeft", g("moveTabsLeft", "Move Tabs Left"), void 0, void 0, async () => {
        this._configurationService.updateValue("terminal.integrated.tabs.location", "left");
      }),
      new ve("hideTabs", g("hideTabs", "Hide Tabs"), void 0, void 0, async () => {
        this._configurationService.updateValue("terminal.integrated.tabs.enabled", !1);
      })
    ];
  }
  setEditable(e) {
    e || this._tabList.domFocus(), this._tabList.refresh(!1);
  }
  focusTabs() {
    if (!this._shouldShowTabs())
      return;
    this._terminalTabsFocusContextKey.set(!0);
    const e = this._tabList.getSelection();
    this._tabList.domFocus(), e && this._tabList.setFocus(e);
  }
  focus() {
    if (this._terminalService.connectionState === 0) {
      const e = document.activeElement;
      this._register(this._terminalService.onDidChangeConnectionState(() => {
        document.activeElement === e && this._focus();
      }));
      return;
    }
    this._focus();
  }
  focusHover() {
    if (this._shouldShowTabs()) {
      this._tabList.focusHover();
      return;
    }
    const e = this._terminalGroupService.activeInstance;
    e && this._hoverService.showHover({
      ...rs(e),
      target: this._terminalContainer,
      trapFocus: !0
    }, !0);
  }
  _focus() {
    var e;
    (e = this._terminalGroupService.activeInstance) == null || e.focusWhenReady();
  }
};
Er = X([
  D(1, we),
  D(2, Ae),
  D(3, le),
  D(4, Ee),
  D(5, _i),
  D(6, Se),
  D(7, Zn),
  D(8, ti),
  D(9, Fe),
  D(10, on)
], Er);
function vu() {
  He.appendMenuItems([
    {
      id: J.MenubarTerminalMenu,
      item: {
        group: "1_create",
        command: {
          id: "workbench.action.terminal.new",
          title: g(
            { key: "miNewTerminal", comment: ["&& denotes a mnemonic"] },
            "&&New Terminal"
          )
        },
        order: 1
      }
    },
    {
      id: J.MenubarTerminalMenu,
      item: {
        group: "1_create",
        command: {
          id: "workbench.action.terminal.split",
          title: g(
            { key: "miSplitTerminal", comment: ["&& denotes a mnemonic"] },
            "&&Split Terminal"
          ),
          precondition: R.has("terminalIsOpen")
        },
        order: 2,
        when: E.processSupported
      }
    },
    {
      id: J.MenubarTerminalMenu,
      item: {
        group: "2_run",
        command: {
          id: "workbench.action.terminal.runActiveFile",
          title: g(
            { key: "miRunActiveFile", comment: ["&& denotes a mnemonic"] },
            "Run &&Active File"
          )
        },
        order: 3,
        when: E.processSupported
      }
    },
    {
      id: J.MenubarTerminalMenu,
      item: {
        group: "2_run",
        command: {
          id: "workbench.action.terminal.runSelectedText",
          title: g(
            { key: "miRunSelectedText", comment: ["&& denotes a mnemonic"] },
            "Run &&Selected Text"
          )
        },
        order: 4,
        when: E.processSupported
      }
    }
  ]), He.appendMenuItems([
    {
      id: J.TerminalInstanceContext,
      item: {
        group: "1_create",
        command: {
          id: "workbench.action.terminal.split",
          title: Q.split.value
        }
      }
    },
    {
      id: J.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.new",
          title: Q.new
        },
        group: "1_create"
      }
    },
    {
      id: J.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.kill",
          title: Q.kill.value
        },
        group: "4_kill"
      }
    },
    {
      id: J.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.copySelection",
          title: g("workbench.action.terminal.copySelection.short", "Copy")
        },
        group: "2_edit",
        order: 1
      }
    },
    {
      id: J.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.copySelectionAsHtml",
          title: g("workbench.action.terminal.copySelectionAsHtml", "Copy as HTML")
        },
        group: "2_edit",
        order: 2
      }
    },
    {
      id: J.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.paste",
          title: g("workbench.action.terminal.paste.short", "Paste")
        },
        group: "2_edit",
        order: 3
      }
    },
    {
      id: J.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.clear",
          title: g("workbench.action.terminal.clear", "Clear")
        },
        group: "3_clear"
      }
    },
    {
      id: J.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.showTabs",
          title: g("workbench.action.terminal.showsTabs", "Show Tabs")
        },
        when: R.not("config.terminal.integrated.tabs.enabled"),
        group: "5_config"
      }
    },
    {
      id: J.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.sizeToContentWidth",
          title: Q.toggleSizeToContentWidth
        },
        group: "5_config"
      }
    },
    {
      id: J.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.selectAll",
          title: g("workbench.action.terminal.selectAll", "Select All")
        },
        group: "2_edit",
        order: 3
      }
    }
  ]), He.appendMenuItems([
    {
      id: J.TerminalEditorInstanceContext,
      item: {
        group: "1_create",
        command: {
          id: "workbench.action.terminal.split",
          title: Q.split.value
        }
      }
    },
    {
      id: J.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.new",
          title: Q.new
        },
        group: "1_create"
      }
    },
    {
      id: J.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.killEditor",
          title: Q.kill.value
        },
        group: "4_kill"
      }
    },
    {
      id: J.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.copySelection",
          title: g("workbench.action.terminal.copySelection.short", "Copy")
        },
        group: "2_edit",
        order: 1
      }
    },
    {
      id: J.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.copySelectionAsHtml",
          title: g("workbench.action.terminal.copySelectionAsHtml", "Copy as HTML")
        },
        group: "2_edit",
        order: 2
      }
    },
    {
      id: J.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.paste",
          title: g("workbench.action.terminal.paste.short", "Paste")
        },
        group: "2_edit",
        order: 3
      }
    },
    {
      id: J.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.clear",
          title: g("workbench.action.terminal.clear", "Clear")
        },
        group: "3_clear"
      }
    },
    {
      id: J.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.selectAll",
          title: g("workbench.action.terminal.selectAll", "Select All")
        },
        group: "2_edit",
        order: 3
      }
    },
    {
      id: J.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.sizeToContentWidth",
          title: Q.toggleSizeToContentWidth
        },
        group: "5_config"
      }
    }
  ]), He.appendMenuItems([
    {
      id: J.TerminalTabEmptyAreaContext,
      item: {
        command: {
          id: "workbench.action.terminal.newWithProfile",
          title: g(
            "workbench.action.terminal.newWithProfile.short",
            "New Terminal With Profile"
          )
        },
        group: "1_create"
      }
    },
    {
      id: J.TerminalTabEmptyAreaContext,
      item: {
        command: {
          id: "workbench.action.terminal.new",
          title: Q.new
        },
        group: "1_create"
      }
    }
  ]), He.appendMenuItems([
    {
      id: J.TerminalNewDropdownContext,
      item: {
        command: {
          id: "workbench.action.terminal.selectDefaultShell",
          title: { value: g("workbench.action.terminal.selectDefaultProfile", "Select Default Profile"), original: "Select Default Profile" }
        },
        group: "3_configure"
      }
    },
    {
      id: J.TerminalNewDropdownContext,
      item: {
        command: {
          id: "workbench.action.terminal.openSettings",
          title: g("workbench.action.terminal.openSettings", "Configure Terminal Settings")
        },
        group: "3_configure"
      }
    },
    {
      id: J.TerminalNewDropdownContext,
      item: {
        command: {
          id: "workbench.action.tasks.runTask",
          title: g("workbench.action.tasks.runTask", "Run Task...")
        },
        when: mo,
        group: "4_tasks",
        order: 1
      }
    },
    {
      id: J.TerminalNewDropdownContext,
      item: {
        command: {
          id: "workbench.action.tasks.configureTaskRunner",
          title: g("workbench.action.tasks.configureTaskRunner", "Configure Tasks...")
        },
        when: mo,
        group: "4_tasks",
        order: 2
      }
    }
  ]), He.appendMenuItems([
    {
      id: J.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.switchTerminal",
          title: { value: g("workbench.action.terminal.switchTerminal", "Switch Terminal"), original: "Switch Terminal" }
        },
        group: "navigation",
        order: 0,
        when: R.and(R.equals("view", fe), R.not("config.terminal.integrated.tabs.enabled"))
      }
    },
    {
      id: J.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.focus",
          title: Q.focus
        },
        alt: {
          id: "workbench.action.terminal.split",
          title: Q.split.value,
          icon: te.splitHorizontal
        },
        group: "navigation",
        order: 0,
        when: R.and(R.equals("view", fe), R.has(
          "config.terminal.integrated.tabs.enabled"
        ), R.or(R.and(R.equals(
          "config.terminal.integrated.tabs.showActiveTerminal",
          "singleTerminal"
        ), R.equals("terminalCount", 1)), R.and(R.equals(
          "config.terminal.integrated.tabs.showActiveTerminal",
          "singleTerminalOrNarrow"
        ), R.or(R.equals("terminalCount", 1), R.has("isTerminalTabsNarrow"))), R.and(R.equals(
          "config.terminal.integrated.tabs.showActiveTerminal",
          "singleGroup"
        ), R.equals("terminalGroupCount", 1)), R.equals(
          "config.terminal.integrated.tabs.showActiveTerminal",
          "always"
        )))
      }
    },
    {
      id: J.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.split",
          title: Q.split,
          icon: te.splitHorizontal
        },
        group: "navigation",
        order: 2,
        when: R.and(R.equals("view", fe), R.notEquals(
          "config.terminal.integrated.tabs.hideCondition",
          "never"
        ), R.or(
          R.not("config.terminal.integrated.tabs.enabled"),
          R.and(R.equals(
            "config.terminal.integrated.tabs.showActions",
            "singleTerminal"
          ), R.equals("terminalCount", 1)),
          R.and(R.equals(
            "config.terminal.integrated.tabs.showActions",
            "singleTerminalOrNarrow"
          ), R.or(R.equals("terminalCount", 1), R.has("isTerminalTabsNarrow"))),
          R.and(R.equals(
            "config.terminal.integrated.tabs.showActions",
            "singleGroup"
          ), R.equals("terminalGroupCount", 1)),
          R.equals(
            "config.terminal.integrated.tabs.showActions",
            "always"
          )
        ))
      }
    },
    {
      id: J.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.kill",
          title: Q.kill,
          icon: te.trash
        },
        group: "navigation",
        order: 3,
        when: R.and(R.equals("view", fe), R.notEquals(
          "config.terminal.integrated.tabs.hideCondition",
          "never"
        ), R.or(
          R.not("config.terminal.integrated.tabs.enabled"),
          R.and(R.equals(
            "config.terminal.integrated.tabs.showActions",
            "singleTerminal"
          ), R.equals("terminalCount", 1)),
          R.and(R.equals(
            "config.terminal.integrated.tabs.showActions",
            "singleTerminalOrNarrow"
          ), R.or(R.equals("terminalCount", 1), R.has("isTerminalTabsNarrow"))),
          R.and(R.equals(
            "config.terminal.integrated.tabs.showActions",
            "singleGroup"
          ), R.equals("terminalGroupCount", 1)),
          R.equals(
            "config.terminal.integrated.tabs.showActions",
            "always"
          )
        ))
      }
    },
    {
      id: J.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.new",
          title: Q.new,
          icon: te.plus
        },
        alt: {
          id: "workbench.action.terminal.split",
          title: Q.split.value,
          icon: te.splitHorizontal
        },
        group: "navigation",
        order: 0,
        when: R.and(R.equals("view", fe), R.or(
          E.webExtensionContributedProfile,
          E.processSupported
        ))
      }
    },
    {
      id: J.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.clear",
          title: g("workbench.action.terminal.clearLong", "Clear Terminal"),
          icon: te.clearAll
        },
        group: "navigation",
        order: 4,
        when: R.equals("view", fe),
        isHiddenByDefault: !0
      }
    },
    {
      id: J.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.runActiveFile",
          title: g("workbench.action.terminal.runActiveFile", "Run Active File"),
          icon: te.run
        },
        group: "navigation",
        order: 5,
        when: R.equals("view", fe),
        isHiddenByDefault: !0
      }
    },
    {
      id: J.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.runSelectedText",
          title: g("workbench.action.terminal.runSelectedText", "Run Selected Text"),
          icon: te.selection
        },
        group: "navigation",
        order: 6,
        when: R.equals("view", fe),
        isHiddenByDefault: !0
      }
    }
  ]), He.appendMenuItems([
    {
      id: J.TerminalInlineTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.split",
          title: Q.split.value
        },
        group: "1_create",
        order: 1
      }
    },
    {
      id: J.TerminalInlineTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.moveToEditor",
          title: Q.moveToEditor.value
        },
        group: "1_create",
        order: 2
      }
    },
    {
      id: J.TerminalInlineTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.changeIconPanel",
          title: Q.changeIcon.value
        },
        group: "2_edit"
      }
    },
    {
      id: J.TerminalInlineTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.changeColorPanel",
          title: Q.changeColor.value
        },
        group: "2_edit"
      }
    },
    {
      id: J.TerminalInlineTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.renamePanel",
          title: Q.rename.value
        },
        group: "2_edit"
      }
    },
    {
      id: J.TerminalInlineTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.sizeToContentWidthInstance",
          title: g(
            "workbench.action.terminal.sizeToContentWidthInstance",
            "Toggle Size to Content Width"
          )
        },
        group: "2_edit"
      }
    },
    {
      id: J.TerminalInlineTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.kill",
          title: Q.kill.value
        },
        group: "4_kill"
      }
    }
  ]), He.appendMenuItems([
    {
      id: J.TerminalTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.splitInstance",
          title: Q.split.value
        },
        group: "1_create",
        order: 1
      }
    },
    {
      id: J.TerminalTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.moveToEditorInstance",
          title: Q.moveToEditor.value
        },
        group: "1_create",
        order: 2
      }
    },
    {
      id: J.TerminalTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.renameInstance",
          title: g("workbench.action.terminal.renameInstance", "Rename...")
        },
        group: "2_edit"
      }
    },
    {
      id: J.TerminalTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.changeIconInstance",
          title: g("workbench.action.terminal.changeIcon", "Change Icon...")
        },
        group: "2_edit"
      }
    },
    {
      id: J.TerminalTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.changeColorInstance",
          title: g("workbench.action.terminal.changeColor", "Change Color...")
        },
        group: "2_edit"
      }
    },
    {
      id: J.TerminalTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.sizeToContentWidthInstance",
          title: g(
            "workbench.action.terminal.sizeToContentWidthInstance",
            "Toggle Size to Content Width"
          )
        },
        group: "2_edit"
      }
    },
    {
      id: J.TerminalTabContext,
      item: {
        group: "5_config",
        command: {
          id: "workbench.action.terminal.joinInstance",
          title: g("workbench.action.terminal.joinInstance", "Join Terminals")
        },
        when: E.tabsSingularSelection.toNegated()
      }
    },
    {
      id: J.TerminalTabContext,
      item: {
        group: "5_config",
        command: {
          id: "workbench.action.terminal.unsplitInstance",
          title: Q.unsplit.value
        },
        when: R.and(
          E.tabsSingularSelection,
          E.splitTerminal
        )
      }
    },
    {
      id: J.TerminalTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.killInstance",
          title: Q.kill.value
        },
        group: "4_kill"
      }
    }
  ]), He.appendMenuItem(J.EditorTitleContext, {
    command: {
      id: "workbench.action.terminal.moveToTerminalPanel",
      title: Q.moveToTerminalPanel
    },
    when: ri.Scheme.isEqualTo(me.vscodeTerminal),
    group: "2_files"
  }), He.appendMenuItem(J.EditorTitleContext, {
    command: {
      id: "workbench.action.terminal.rename",
      title: Q.rename
    },
    when: ri.Scheme.isEqualTo(me.vscodeTerminal),
    group: "3_files"
  }), He.appendMenuItem(J.EditorTitleContext, {
    command: {
      id: "workbench.action.terminal.changeColor",
      title: Q.changeColor
    },
    when: ri.Scheme.isEqualTo(me.vscodeTerminal),
    group: "3_files"
  }), He.appendMenuItem(J.EditorTitleContext, {
    command: {
      id: "workbench.action.terminal.changeIcon",
      title: Q.changeIcon
    },
    when: ri.Scheme.isEqualTo(me.vscodeTerminal),
    group: "3_files"
  }), He.appendMenuItem(J.EditorTitleContext, {
    command: {
      id: "workbench.action.terminal.sizeToContentWidth",
      title: Q.toggleSizeToContentWidth
    },
    when: ri.Scheme.isEqualTo(me.vscodeTerminal),
    group: "3_files"
  }), He.appendMenuItem(J.EditorTitle, {
    command: {
      id: "workbench.action.createTerminalEditorSameGroup",
      title: Q.new,
      icon: te.plus
    },
    alt: {
      id: "workbench.action.terminal.split",
      title: Q.split.value,
      icon: te.splitHorizontal
    },
    group: "navigation",
    order: 0,
    when: ri.Scheme.isEqualTo(me.vscodeTerminal)
  });
}
function Ar(h, e, t, i, s, c) {
  let l = [], n = [];
  e = e.filter((b) => !b.isAutoDetected);
  const r = h === se.Editor || typeof h == "object" && "viewColumn" in h && h.viewColumn === Qr ? { viewColumn: Vn } : { splitActiveTerminal: !0 };
  for (const b of e) {
    const p = b.profileName === t, S = { config: b, location: h }, o = { config: b, location: r }, _ = b.profileName.replace(/[\n\r\t]/g, "");
    l.push(new ve(
      "workbench.action.terminal.newWithProfile",
      p ? g("defaultTerminalProfile", "{0} (Default)", _) : _,
      void 0,
      !0,
      async () => {
        const u = await s.createTerminal(S);
        s.setActiveInstance(u), await s.focusActiveInstance();
      }
    )), n.push(new ve(
      "workbench.action.terminal.split",
      p ? g("defaultTerminalProfile", "{0} (Default)", _) : _,
      void 0,
      !0,
      async () => {
        const u = await s.createTerminal(o);
        s.setActiveInstance(u), await s.focusActiveInstance();
      }
    ));
  }
  for (const b of i) {
    const S = b.title === t ? g(
      "defaultTerminalProfile",
      "{0} (Default)",
      b.title.replace(/[\n\r\t]/g, "")
    ) : b.title.replace(/[\n\r\t]/g, "");
    l.push(new ve(
      "contributed",
      S,
      void 0,
      !0,
      () => s.createTerminal({
        config: {
          extensionIdentifier: b.extensionIdentifier,
          id: b.id,
          title: S
        },
        location: h
      })
    )), n.push(new ve(
      "contributed-split",
      S,
      void 0,
      !0,
      () => s.createTerminal({
        config: {
          extensionIdentifier: b.extensionIdentifier,
          id: b.id,
          title: S
        },
        location: r
      })
    ));
  }
  const a = l.find((b) => b.label.endsWith("(Default)"));
  a && (l = l.filter((b) => b !== a).sort((b, p) => b.label.localeCompare(p.label)), l.unshift(a)), l.length > 0 && (l.push(new Jo("split.profile", g("splitTerminal", "Split Terminal"), n)), l.push(new ci()));
  const f = c.getActions();
  l.push(...ci.join(...f.map((b) => b[1])));
  const m = n.find((b) => b.label.endsWith("(Default)"));
  return m && (n = n.filter((b) => b !== m).sort((b, p) => b.label.localeCompare(p.label)), n.unshift(m)), { dropdownAction: new ve("refresh profiles", "Launch Profile...", "codicon-chevron-down", !0), dropdownMenuActions: l, className: `terminal-tab-actions-${s.resolveLocation(h)}` };
}
let Lr = class extends fh {
  get terminalTabbedView() {
    return this._terminalTabbedView;
  }
  constructor(e, t, i, s, c, l, n, r, a, f, m, C, b, p, S, o, _, u, d) {
    super(e, t, l, c, i, s, n, p, f, m), this._contextKeyService = i, this._configurationService = c, this._contextMenuService = l, this._instantiationService = n, this._terminalService = r, this._terminalGroupService = a, this._notificationService = C, this._keybindingService = b, this._menuService = S, this._terminalProfileService = o, this._terminalProfileResolverService = _, this._themeService = u, this._accessibilityService = d, this._isWelcomeShowing = !1, this._register(this._terminalService.onDidRegisterProcessSupport(() => {
      this._onDidChangeViewWelcomeState.fire();
    })), this._register(this._terminalService.onDidChangeInstances(() => {
      this._isWelcomeShowing && (this._isWelcomeShowing = !0, this._onDidChangeViewWelcomeState.fire(), !this._terminalTabbedView && this._parentDomElement && (this._createTabsView(), this.layoutBody(this._parentDomElement.offsetHeight, this._parentDomElement.offsetWidth)));
    })), this._dropdownMenu = this._register(this._menuService.createMenu(J.TerminalNewDropdownContext, this._contextKeyService)), this._singleTabMenu = this._register(this._menuService.createMenu(J.TerminalInlineTabContext, this._contextKeyService)), this._register(this._terminalProfileService.onDidChangeAvailableProfiles((v) => this._updateTabActionBar(v))), this._viewShowing = E.viewShowing.bindTo(this._contextKeyService), this._register(this.onDidChangeBodyVisibility((v) => {
      var w;
      v && ((w = this._terminalTabbedView) == null || w.rerenderTabs());
    })), this._register(this._configurationService.onDidChangeConfiguration((v) => {
      this._parentDomElement && (v.affectsConfiguration("terminal.integrated.shellIntegration.decorationsEnabled") || v.affectsConfiguration("terminal.integrated.shellIntegration.enabled")) && this._updateForShellIntegration(this._parentDomElement);
    })), this._register(this._terminalService.onDidCreateInstance((v) => {
      v.capabilities.onDidAddCapability((w) => {
        var x;
        w === 2 && this._gutterDecorationsEnabled() && ((x = this._parentDomElement) == null || x.classList.add("shell-integration"));
      });
    }));
  }
  _updateForShellIntegration(e) {
    e.classList.toggle("shell-integration", this._gutterDecorationsEnabled());
  }
  _gutterDecorationsEnabled() {
    const e = this._configurationService.getValue("terminal.integrated.shellIntegration.decorationsEnabled");
    return (e === "both" || e === "gutter") && this._configurationService.getValue("terminal.integrated.shellIntegration.enabled");
  }
  _initializeTerminal(e) {
    if (this.isBodyVisible() && this._terminalService.isProcessSupportRegistered && this._terminalService.connectionState === 1) {
      let t = this._terminalGroupService.groups.length === 0;
      e && t && (t = this._terminalService.restoredGroupCount === 0), t && this._terminalService.createTerminal({ location: se.Panel });
    }
  }
  renderBody(e) {
    super.renderBody(e), this._parentDomElement || this._updateForShellIntegration(e), this._parentDomElement = e, this._parentDomElement.classList.add("integrated-terminal"), this._fontStyleElement = document.createElement("style"), this._instantiationService.createInstance(Mr, this._parentDomElement), this.shouldShowWelcome() || this._createTabsView(), this._parentDomElement.appendChild(this._fontStyleElement), this._register(this.configurationService.onDidChangeConfiguration((t) => {
      if ((t.affectsConfiguration("terminal.integrated.fontFamily") || t.affectsConfiguration("editor.fontFamily")) && !this._terminalService.configHelper.configFontIsMonospace()) {
        const s = [{
          label: g("terminal.useMonospace", "Use 'monospace'"),
          run: () => this.configurationService.updateValue("terminal.integrated.fontFamily", "monospace")
        }];
        this._notificationService.prompt(Te.Warning, g(
          "terminal.monospaceOnly",
          "The terminal only supports monospace fonts. Be sure to restart VS Code if this is a newly installed font."
        ), s);
      }
    })), this._register(this.onDidChangeBodyVisibility(async (t) => {
      if (this._viewShowing.set(t), t)
        this._terminalService.isProcessSupportRegistered || this._onDidChangeViewWelcomeState.fire(), this._initializeTerminal(!1), this._terminalGroupService.showPanel(!1);
      else
        for (const i of this._terminalGroupService.instances)
          i.resetFocusContextKey();
      this._terminalGroupService.updateVisibility();
    })), this._register(this._terminalService.onDidChangeConnectionState(() => this._initializeTerminal(!0))), this.layoutBody(this._parentDomElement.offsetHeight, this._parentDomElement.offsetWidth);
  }
  _createTabsView() {
    this._parentDomElement && (this._terminalTabbedView = this.instantiationService.createInstance(Er, this._parentDomElement));
  }
  layoutBody(e, t) {
    var i;
    super.layoutBody(e, t), (i = this._terminalTabbedView) == null || i.layout(t, e);
  }
  getActionViewItem(e) {
    var t;
    switch (e.id) {
      case "workbench.action.terminal.split": {
        const i = this, s = new class extends ve {
          constructor() {
            super(e.id, e.label, e.class, e.enabled), this.checked = e.checked, this.tooltip = e.tooltip;
          }
          dispose() {
            e.dispose();
          }
          async run() {
            const c = i._terminalGroupService.activeInstance;
            if (c) {
              const l = await i._terminalService.createTerminal({ location: { parentTerminal: c } });
              return l == null ? void 0 : l.focusWhenReady();
            }
          }
        }();
        return new Yo(
          e,
          s,
          { icon: !0, label: !1, keybinding: this._getKeybindingLabel(e) }
        );
      }
      case "workbench.action.terminal.switchTerminal":
        return this._instantiationService.createInstance(Pr, e);
      case "workbench.action.terminal.focus":
        if (e instanceof En) {
          const i = [];
          return pa(this._singleTabMenu, void 0, i), this._instantiationService.createInstance(Rr, e, i);
        }
      case "workbench.action.terminal.new":
        if (e instanceof En) {
          const i = Ar(se.Panel, this._terminalProfileService.availableProfiles, this._getDefaultProfileName(), this._terminalProfileService.contributedProfiles, this._terminalService, this._dropdownMenu);
          return (t = this._newDropdown) == null || t.dispose(), this._newDropdown = new Ca(
            e,
            i.dropdownAction,
            i.dropdownMenuActions,
            i.className,
            this._contextMenuService,
            {},
            this._keybindingService,
            this._notificationService,
            this._contextKeyService,
            this._themeService,
            this._accessibilityService
          ), this._updateTabActionBar(this._terminalProfileService.availableProfiles), this._newDropdown;
        }
    }
    return super.getActionViewItem(e);
  }
  _getDefaultProfileName() {
    let e;
    try {
      e = this._terminalProfileService.getDefaultProfileName();
    } catch {
      e = this._terminalProfileResolverService.defaultProfileName;
    }
    return e;
  }
  _getKeybindingLabel(e) {
    var t;
    return Pt((t = this._keybindingService.lookupKeybinding(e.id)) == null ? void 0 : t.getLabel());
  }
  _updateTabActionBar(e) {
    var i;
    const t = Ar(se.Panel, e, this._getDefaultProfileName(), this._terminalProfileService.contributedProfiles, this._terminalService, this._dropdownMenu);
    (i = this._newDropdown) == null || i.update(t.dropdownAction, t.dropdownMenuActions);
  }
  focus() {
    if (this._terminalService.connectionState === 0) {
      const e = document.activeElement;
      this._register(this._terminalService.onDidChangeConnectionState(() => {
        document.activeElement === e && this._terminalGroupService.showPanel(!0);
      }));
      return;
    }
    this._terminalGroupService.showPanel(!0);
  }
  shouldShowWelcome() {
    return this._isWelcomeShowing = !this._terminalService.isProcessSupportRegistered && this._terminalService.instances.length === 0, this._isWelcomeShowing;
  }
};
Lr = X([
  D(1, ui),
  D(2, Fe),
  D(3, an),
  D(4, Se),
  D(5, _i),
  D(6, le),
  D(7, we),
  D(8, Ae),
  D(9, Me),
  D(10, Ni),
  D(11, Ee),
  D(12, ui),
  D(13, tn),
  D(14, Zn),
  D(15, Bt),
  D(16, ii),
  D(17, Me),
  D(18, ns)
], Lr);
let Pr = class extends _h {
  constructor(e, t, i, s, c) {
    super(null, e, Fo(t, i), i.activeGroupIndex, s, gh, { ariaLabel: g("terminals", "Open Terminals."), optionsAsChildren: !0 }), this._terminalService = t, this._terminalGroupService = i, this._register(t.onDidChangeInstances(() => this._updateItems(), this)), this._register(t.onDidChangeActiveGroup(() => this._updateItems(), this)), this._register(t.onDidChangeActiveInstance(() => this._updateItems(), this)), this._register(t.onDidChangeInstanceTitle(() => this._updateItems(), this)), this._register(i.onDidChangeGroups(() => this._updateItems(), this)), this._register(t.onDidChangeConnectionState(() => this._updateItems(), this)), this._register(c.onDidChangeAvailableProfiles(() => this._updateItems(), this)), this._register(t.onDidChangeInstancePrimaryStatus(() => this._updateItems(), this));
  }
  render(e) {
    super.render(e), e.classList.add("switch-terminal"), e.style.borderColor = vn(ph);
  }
  _updateItems() {
    const e = Fo(this._terminalService, this._terminalGroupService);
    this.setOptions(e, this._terminalGroupService.activeGroupIndex);
  }
};
Pr = X([
  D(1, we),
  D(2, Ae),
  D(3, _a),
  D(4, Bt)
], Pr);
function Fo(h, e) {
  let t;
  return h.connectionState === 1 ? t = e.getGroupLabels().map((i) => ({ text: i })) : t = [{ text: g("terminalConnectingLabel", "Starting...") }], t.push({ text: Ta, isDisabled: !0 }), t.push({ text: Da }), t;
}
let Rr = class extends ga {
  constructor(e, t, i, s, c, l, n, r, a, f, m, C) {
    super(e, {
      draggable: !0,
      hoverDelegate: m.createInstance(Br)
    }, i, s, c, l, a, C), this._actions = t, this._terminalService = n, this._terminalGroupService = r, this._commandService = f, this._instantiationService = m, this._elementDisposables = [], this._register(be.debounce(be.any(this._terminalService.onDidChangeInstancePrimaryStatus, this._terminalGroupService.onDidChangeActiveInstance, be.map(this._terminalService.onDidChangeInstanceIcon, (b) => b.instance), be.map(this._terminalService.onDidChangeInstanceColor, (b) => b.instance), this._terminalService.onDidChangeInstanceTitle, this._terminalService.onDidChangeInstanceCapability), (b, p) => (b || (b = /* @__PURE__ */ new Set()), p && b.add(p), b))((b) => {
      for (const p of b)
        this.updateLabel(p);
    })), this._register(je(() => ye(this._elementDisposables)));
  }
  async onClick(e) {
    e.altKey && this._menuItemAction.alt ? this._commandService.executeCommand(this._menuItemAction.alt.id, { target: se.Panel }) : this._openContextMenu();
  }
  updateLabel(e) {
    if (!(e && e !== this._terminalGroupService.activeInstance) && (this._elementDisposables.length === 0 && this.element && this.label && (this._elementDisposables.push(he(this.element, et.CONTEXT_MENU, (t) => {
      t.button === 2 && (this._openContextMenu(), t.preventDefault());
    })), this._elementDisposables.push(he(this.element, et.AUXCLICK, (t) => {
      if (t.button === 1) {
        const i = this._terminalGroupService.activeInstance;
        i && this._terminalService.safeDisposeTerminal(i), t.preventDefault();
      }
    })), this._elementDisposables.push(he(this.element, et.DRAG_START, (t) => {
      const i = this._terminalGroupService.activeInstance;
      t.dataTransfer && i && t.dataTransfer.setData("Terminals", JSON.stringify([i.resource.toString()]));
    }))), this.label)) {
      const t = this.label, i = this._terminalGroupService.activeInstance;
      if (!i) {
        fo(t, "");
        return;
      }
      t.classList.add("single-terminal-tab");
      let s = "";
      const c = i.statusList.primary;
      if (c) {
        const r = Va(c.severity);
        this._themeService.getColorTheme();
        const a = this._themeService.getColorTheme().getColor(r);
        a && (s = a.toString());
      }
      t.style.color = s, fo(t, ...vh(this._instantiationService.invokeFunction(Su, i, this._terminalService.configHelper.config.tabs.separator, re.isThemeIcon(this._commandAction.item.icon) ? this._commandAction.item.icon : void 0))), this._altCommand && (t.classList.remove(this._altCommand), this._altCommand = void 0), this._color && (t.classList.remove(this._color), this._color = void 0), this._class && (t.classList.remove(this._class), t.classList.remove("terminal-uri-icon"), this._class = void 0);
      const l = Jt(i);
      l && (this._color = l, t.classList.add(l));
      const n = fi(i, this._themeService.getColorTheme().type);
      n && (this._class = n == null ? void 0 : n[0], t.classList.add(...n)), this._commandAction.item.icon && (this._altCommand = "alt-command", t.classList.add(this._altCommand)), this.updateTooltip();
    }
  }
  _openContextMenu() {
    this._contextMenuService.showContextMenu({
      getAnchor: () => this.element,
      getActions: () => this._actions,
      getActionsContext: () => this.label
    });
  }
};
Rr = X([
  D(2, ui),
  D(3, Ee),
  D(4, Fe),
  D(5, Me),
  D(6, we),
  D(7, Ae),
  D(8, _i),
  D(9, dt),
  D(10, le),
  D(11, ns)
], Rr);
function Su(h, e, t, i) {
  if (!e || !e.title)
    return "";
  const s = re.isThemeIcon(e.icon) ? e.icon.id : h.get(ii).getDefaultIcon().id, c = `$(${(i == null ? void 0 : i.id) || s}) ${bu(e, t)}`, l = e.statusList.primary;
  return l != null && l.icon ? `${c} $(${l.icon.id})` : c;
}
function bu(h, e) {
  return h ? h.description ? `${h.title} ${e} ${h.description}` : h.title : "";
}
let Mr = class extends la {
  constructor(e, t, i, s) {
    super(t), this._themeService = t, this._terminalService = i, this._terminalGroupService = s, this._registerListeners(), this._styleElement = document.createElement("style"), e.appendChild(this._styleElement), this._register(je(() => e.removeChild(this._styleElement))), this.updateStyles();
  }
  _registerListeners() {
    this._register(this._terminalService.onDidChangeInstanceIcon(() => this.updateStyles())), this._register(this._terminalService.onDidChangeInstanceColor(() => this.updateStyles())), this._register(this._terminalService.onDidChangeInstances(() => this.updateStyles())), this._register(this._terminalGroupService.onDidChangeGroups(() => this.updateStyles()));
  }
  updateStyles() {
    super.updateStyles();
    const e = this._themeService.getColorTheme();
    let t = "";
    for (const i of this._terminalService.instances) {
      const s = i.icon;
      if (!s)
        continue;
      let c;
      s instanceof oe ? c = s : s instanceof Object && "light" in s && "dark" in s && (c = e.type === ha.LIGHT ? s.light : s.dark);
      const l = fi(i, e.type);
      c instanceof oe && l && l.length > 1 && (t += `.monaco-workbench .${l[0]} .monaco-highlighted-label .codicon, .monaco-action-bar .terminal-uri-icon.single-terminal-tab.action-label:not(.alt-command) .codicon{background-image: ${da(c)};}`);
    }
    for (const i of this._terminalService.instances) {
      const s = Jt(i);
      if (!s || !i.color)
        continue;
      const c = e.getColor(i.color);
      c && (t += `.monaco-workbench .${s} .codicon:first-child:not(.codicon-split-horizontal):not(.codicon-trashcan):not(.file-icon){ color: ${c} !important; }`);
    }
    this._styleElement.textContent = t;
  }
};
Mr = X([
  D(1, Me),
  D(2, we),
  D(3, Ae)
], Mr);
let Br = class {
  constructor(e, t, i) {
    this._configurationService = e, this._hoverService = t, this._terminalGroupService = i, this._lastHoverHideTime = 0, this.placement = "element";
  }
  get delay() {
    return Date.now() - this._lastHoverHideTime < 200 ? 0 : this._configurationService.getValue("workbench.hover.delay");
  }
  showHover(e, t) {
    const i = this._terminalGroupService.activeInstance;
    if (!i)
      return;
    const s = rs(i);
    return this._hoverService.showHover({
      ...e,
      content: s.content,
      actions: s.actions
    }, t);
  }
  onDidHideHover() {
    this._lastHoverHideTime = Date.now();
  }
};
Br = X([
  D(0, Se),
  D(1, on),
  D(2, Ae)
], Br);
function wu() {
  Cu();
}
function Cu() {
  for (let h = 0; h < 9; h++) {
    const e = h, t = h + 1;
    va.registerCommandAndKeybindingRule({
      id: `workbench.action.terminal.focusAtIndex${t}`,
      weight: 200,
      when: void 0,
      primary: 0,
      handler: (i) => (i.get(Ae).setActiveInstanceByIndex(e), i.get(Ae).showPanel(!0))
    });
  }
}
const Ka = `
- ` + [
  "`${cwd}`: " + g("cwd", "the terminal's current working directory"),
  "`${cwdFolder}`: " + g(
    "cwdFolder",
    "the terminal's current working directory, displayed for multi-root workspaces or in a single root workspace when the value differs from the initial working directory. On Windows, this will only be displayed when shell integration is enabled."
  ),
  "`${workspaceFolder}`: " + g("workspaceFolder", "the workspace in which the terminal was launched"),
  "`${local}`: " + g("local", "indicates a local terminal in a remote workspace"),
  "`${process}`: " + g("process", "the name of the terminal process"),
  "`${separator}`: " + g(
    "separator",
    "a conditional separator {0} that only shows when surrounded by variables with values or static text.",
    "(` - `)"
  ),
  "`${sequence}`: " + g("sequence", "the name provided to the terminal by the process"),
  "`${task}`: " + g("task", "indicates this terminal is associated with a task")
].join(`
- `);
let qa = g(
  "terminalTitle",
  "Controls the terminal title. Variables are substituted based on the context:"
);
qa += Ka;
let ja = g(
  "terminalDescription",
  "Controls the terminal description, which appears to the right of the title. Variables are substituted based on the context:"
);
ja += Ka;
const yu = {
  id: "terminal",
  order: 100,
  title: g("terminalIntegratedConfigurationTitle", "Integrated Terminal"),
  type: "object",
  properties: {
    "terminal.integrated.sendKeybindingsToShell": {
      markdownDescription: g(
        "terminal.integrated.sendKeybindingsToShell",
        "Dispatches most keybindings to the terminal instead of the workbench, overriding {0}, which can be used alternatively for fine tuning.",
        "`#terminal.integrated.commandsToSkipShell#`"
      ),
      type: "boolean",
      default: !1
    },
    "terminal.integrated.tabs.defaultColor": {
      description: g(
        "terminal.integrated.tabs.defaultColor",
        "A theme color ID to associate with terminal icons by default."
      ),
      ...Ua,
      scope: 4
    },
    "terminal.integrated.tabs.defaultIcon": {
      description: g(
        "terminal.integrated.tabs.defaultIcon",
        "A codicon ID to associate with terminal icons by default."
      ),
      ...Ga,
      default: te.terminal.id,
      scope: 4
    },
    "terminal.integrated.tabs.enabled": {
      description: g(
        "terminal.integrated.tabs.enabled",
        "Controls whether terminal tabs display as a list to the side of the terminal. When this is disabled a dropdown will display instead."
      ),
      type: "boolean",
      default: !0
    },
    "terminal.integrated.tabs.enableAnimation": {
      description: g(
        "terminal.integrated.tabs.enableAnimation",
        "Controls whether terminal tab statuses support animation (eg. in progress tasks)."
      ),
      type: "boolean",
      default: !0
    },
    "terminal.integrated.tabs.hideCondition": {
      description: g(
        "terminal.integrated.tabs.hideCondition",
        "Controls whether the terminal tabs view will hide under certain conditions."
      ),
      type: "string",
      enum: ["never", "singleTerminal", "singleGroup"],
      enumDescriptions: [
        g(
          "terminal.integrated.tabs.hideCondition.never",
          "Never hide the terminal tabs view"
        ),
        g(
          "terminal.integrated.tabs.hideCondition.singleTerminal",
          "Hide the terminal tabs view when there is only a single terminal opened"
        ),
        g(
          "terminal.integrated.tabs.hideCondition.singleGroup",
          "Hide the terminal tabs view when there is only a single terminal group opened"
        )
      ],
      default: "singleTerminal"
    },
    "terminal.integrated.tabs.showActiveTerminal": {
      description: g(
        "terminal.integrated.tabs.showActiveTerminal",
        "Shows the active terminal information in the view. This is particularly useful when the title within the tabs aren't visible."
      ),
      type: "string",
      enum: ["always", "singleTerminal", "singleTerminalOrNarrow", "never"],
      enumDescriptions: [
        g(
          "terminal.integrated.tabs.showActiveTerminal.always",
          "Always show the active terminal"
        ),
        g(
          "terminal.integrated.tabs.showActiveTerminal.singleTerminal",
          "Show the active terminal when it is the only terminal opened"
        ),
        g(
          "terminal.integrated.tabs.showActiveTerminal.singleTerminalOrNarrow",
          "Show the active terminal when it is the only terminal opened or when the tabs view is in its narrow textless state"
        ),
        g(
          "terminal.integrated.tabs.showActiveTerminal.never",
          "Never show the active terminal"
        )
      ],
      default: "singleTerminalOrNarrow"
    },
    "terminal.integrated.tabs.showActions": {
      description: g(
        "terminal.integrated.tabs.showActions",
        "Controls whether terminal split and kill buttons are displays next to the new terminal button."
      ),
      type: "string",
      enum: ["always", "singleTerminal", "singleTerminalOrNarrow", "never"],
      enumDescriptions: [
        g("terminal.integrated.tabs.showActions.always", "Always show the actions"),
        g(
          "terminal.integrated.tabs.showActions.singleTerminal",
          "Show the actions when it is the only terminal opened"
        ),
        g(
          "terminal.integrated.tabs.showActions.singleTerminalOrNarrow",
          "Show the actions when it is the only terminal opened or when the tabs view is in its narrow textless state"
        ),
        g("terminal.integrated.tabs.showActions.never", "Never show the actions")
      ],
      default: "singleTerminalOrNarrow"
    },
    "terminal.integrated.tabs.location": {
      type: "string",
      enum: ["left", "right"],
      enumDescriptions: [
        g(
          "terminal.integrated.tabs.location.left",
          "Show the terminal tabs view to the left of the terminal"
        ),
        g(
          "terminal.integrated.tabs.location.right",
          "Show the terminal tabs view to the right of the terminal"
        )
      ],
      default: "right",
      description: g(
        "terminal.integrated.tabs.location",
        "Controls the location of the terminal tabs, either to the left or right of the actual terminal(s)."
      )
    },
    "terminal.integrated.tabFocusMode": {
      markdownDescription: g(
        "tabFocusMode",
        "Controls whether the terminal receives tabs or defers them to the workbench for navigation. When set, this overrides {0} when the terminal is focused.",
        "`#editor.tabFocusMode#`"
      ),
      type: ["boolean", "null"],
      default: null
    },
    "terminal.integrated.defaultLocation": {
      type: "string",
      enum: ["editor", "view"],
      enumDescriptions: [
        g(
          "terminal.integrated.defaultLocation.editor",
          "Create terminals in the editor"
        ),
        g(
          "terminal.integrated.defaultLocation.view",
          "Create terminals in the terminal view"
        )
      ],
      default: "view",
      description: g(
        "terminal.integrated.defaultLocation",
        "Controls where newly created terminals will appear."
      )
    },
    "terminal.integrated.tabs.focusMode": {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      enumDescriptions: [
        g(
          "terminal.integrated.tabs.focusMode.singleClick",
          "Focus the terminal when clicking a terminal tab"
        ),
        g(
          "terminal.integrated.tabs.focusMode.doubleClick",
          "Focus the terminal when double-clicking a terminal tab"
        )
      ],
      default: "doubleClick",
      description: g(
        "terminal.integrated.tabs.focusMode",
        "Controls whether focusing the terminal of a tab happens on double or single click."
      )
    },
    "terminal.integrated.macOptionIsMeta": {
      description: g(
        "terminal.integrated.macOptionIsMeta",
        "Controls whether to treat the option key as the meta key in the terminal on macOS."
      ),
      type: "boolean",
      default: !1
    },
    "terminal.integrated.macOptionClickForcesSelection": {
      description: g(
        "terminal.integrated.macOptionClickForcesSelection",
        "Controls whether to force selection when using Option+click on macOS. This will force a regular (line) selection and disallow the use of column selection mode. This enables copying and pasting using the regular terminal selection, for example, when mouse mode is enabled in tmux."
      ),
      type: "boolean",
      default: !1
    },
    "terminal.integrated.altClickMovesCursor": {
      markdownDescription: g(
        "terminal.integrated.altClickMovesCursor",
        "If enabled, alt/option + click will reposition the prompt cursor to underneath the mouse when {0} is set to {1} (the default value). This may not work reliably depending on your shell.",
        "`#editor.multiCursorModifier#`",
        "`'alt'`"
      ),
      type: "boolean",
      default: !0
    },
    "terminal.integrated.copyOnSelection": {
      description: g(
        "terminal.integrated.copyOnSelection",
        "Controls whether text selected in the terminal will be copied to the clipboard."
      ),
      type: "boolean",
      default: !1
    },
    "terminal.integrated.enableMultiLinePasteWarning": {
      markdownDescription: g(
        "terminal.integrated.enableMultiLinePasteWarning",
        `Show a warning dialog when pasting multiple lines into the terminal. The dialog does not show when:

- Bracketed paste mode is enabled (the shell supports multi-line paste natively)
- The paste is handled by the shell's readline (in the case of pwsh)`
      ),
      type: "boolean",
      default: !0
    },
    "terminal.integrated.drawBoldTextInBrightColors": {
      description: g(
        "terminal.integrated.drawBoldTextInBrightColors",
        'Controls whether bold text in the terminal will always use the "bright" ANSI color variant.'
      ),
      type: "boolean",
      default: !0
    },
    "terminal.integrated.fontFamily": {
      markdownDescription: g(
        "terminal.integrated.fontFamily",
        "Controls the font family of the terminal. Defaults to {0}'s value.",
        "`#editor.fontFamily#`"
      ),
      type: "string"
    },
    "terminal.integrated.fontSize": {
      description: g(
        "terminal.integrated.fontSize",
        "Controls the font size in pixels of the terminal."
      ),
      type: "number",
      default: rt ? 12 : 14,
      minimum: 6,
      maximum: 100
    },
    "terminal.integrated.letterSpacing": {
      description: g(
        "terminal.integrated.letterSpacing",
        "Controls the letter spacing of the terminal. This is an integer value which represents the number of additional pixels to add between characters."
      ),
      type: "number",
      default: Zo
    },
    "terminal.integrated.lineHeight": {
      description: g(
        "terminal.integrated.lineHeight",
        "Controls the line height of the terminal. This number is multiplied by the terminal font size to get the actual line-height in pixels."
      ),
      type: "number",
      default: ea
    },
    "terminal.integrated.minimumContrastRatio": {
      markdownDescription: g(
        "terminal.integrated.minimumContrastRatio",
        `When set, the foreground color of each cell will change to try meet the contrast ratio specified. Note that this will not apply to \`powerline\` characters per #146406. Example values:

- 1: Do nothing and use the standard theme colors.
- 4.5: [WCAG AA compliance (minimum)](https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html) (default).
- 7: [WCAG AAA compliance (enhanced)](https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast7.html).
- 21: White on black or black on white.`
      ),
      type: "number",
      default: 4.5,
      tags: ["accessibility"]
    },
    "terminal.integrated.tabStopWidth": {
      markdownDescription: g("terminal.integrated.tabStopWidth", "The number of cells in a tab stop."),
      type: "number",
      minimum: 1,
      default: 8
    },
    "terminal.integrated.fastScrollSensitivity": {
      markdownDescription: g(
        "terminal.integrated.fastScrollSensitivity",
        "Scrolling speed multiplier when pressing `Alt`."
      ),
      type: "number",
      default: 5
    },
    "terminal.integrated.mouseWheelScrollSensitivity": {
      markdownDescription: g(
        "terminal.integrated.mouseWheelScrollSensitivity",
        "A multiplier to be used on the `deltaY` of mouse wheel scroll events."
      ),
      type: "number",
      default: 1
    },
    "terminal.integrated.bellDuration": {
      markdownDescription: g(
        "terminal.integrated.bellDuration",
        "The number of milliseconds to show the bell within a terminal tab when triggered."
      ),
      type: "number",
      default: 1e3
    },
    "terminal.integrated.fontWeight": {
      anyOf: [
        {
          type: "number",
          minimum: Ds,
          maximum: Es,
          errorMessage: g(
            "terminal.integrated.fontWeightError",
            'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.'
          )
        },
        {
          type: "string",
          pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
        },
        {
          enum: _o
        }
      ],
      description: g(
        "terminal.integrated.fontWeight",
        'The font weight to use within the terminal for non-bold text. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.'
      ),
      default: "normal"
    },
    "terminal.integrated.fontWeightBold": {
      anyOf: [
        {
          type: "number",
          minimum: Ds,
          maximum: Es,
          errorMessage: g(
            "terminal.integrated.fontWeightError",
            'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.'
          )
        },
        {
          type: "string",
          pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
        },
        {
          enum: _o
        }
      ],
      description: g(
        "terminal.integrated.fontWeightBold",
        'The font weight to use within the terminal for bold text. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.'
      ),
      default: "bold"
    },
    "terminal.integrated.cursorBlinking": {
      description: g(
        "terminal.integrated.cursorBlinking",
        "Controls whether the terminal cursor blinks."
      ),
      type: "boolean",
      default: !1
    },
    "terminal.integrated.cursorStyle": {
      description: g(
        "terminal.integrated.cursorStyle",
        "Controls the style of terminal cursor."
      ),
      enum: [mn.BLOCK, mn.LINE, mn.UNDERLINE],
      default: mn.BLOCK
    },
    "terminal.integrated.cursorWidth": {
      markdownDescription: g(
        "terminal.integrated.cursorWidth",
        "Controls the width of the cursor when {0} is set to {1}.",
        "`#terminal.integrated.cursorStyle#`",
        "`line`"
      ),
      type: "number",
      default: 1
    },
    "terminal.integrated.scrollback": {
      description: g(
        "terminal.integrated.scrollback",
        "Controls the maximum number of lines the terminal keeps in its buffer. We pre-allocate memory based on this value in order to ensure a smooth experience. As such, as the value increases, so will the amount of memory."
      ),
      type: "number",
      default: 1e3
    },
    "terminal.integrated.detectLocale": {
      markdownDescription: g(
        "terminal.integrated.detectLocale",
        "Controls whether to detect and set the `$LANG` environment variable to a UTF-8 compliant option since VS Code's terminal only supports UTF-8 encoded data coming from the shell."
      ),
      type: "string",
      enum: ["auto", "off", "on"],
      markdownEnumDescriptions: [
        g(
          "terminal.integrated.detectLocale.auto",
          "Set the `$LANG` environment variable if the existing variable does not exist or it does not end in `'.UTF-8'`."
        ),
        g(
          "terminal.integrated.detectLocale.off",
          "Do not set the `$LANG` environment variable."
        ),
        g(
          "terminal.integrated.detectLocale.on",
          "Always set the `$LANG` environment variable."
        )
      ],
      default: "auto"
    },
    "terminal.integrated.gpuAcceleration": {
      type: "string",
      enum: ["auto", "on", "off", "canvas"],
      markdownEnumDescriptions: [
        g(
          "terminal.integrated.gpuAcceleration.auto",
          "Let VS Code detect which renderer will give the best experience."
        ),
        g(
          "terminal.integrated.gpuAcceleration.on",
          "Enable GPU acceleration within the terminal."
        ),
        g(
          "terminal.integrated.gpuAcceleration.off",
          "Disable GPU acceleration within the terminal. The terminal will render much slower when GPU acceleration is off but it should reliably work on all systems."
        ),
        g(
          "terminal.integrated.gpuAcceleration.canvas",
          "Use the terminal's fallback canvas renderer which uses a 2d context instead of webgl which may perform better on some systems. Note that some features are limited in the canvas renderer like opaque selection."
        )
      ],
      default: "auto",
      description: g(
        "terminal.integrated.gpuAcceleration",
        "Controls whether the terminal will leverage the GPU to do its rendering."
      )
    },
    "terminal.integrated.tabs.separator": {
      type: "string",
      default: " - ",
      markdownDescription: g(
        "terminal.integrated.tabs.separator",
        "Separator used by {0} and {0}.",
        "`terminal.integrated.tabs.title`",
        "`terminal.integrated.tabs.description`"
      )
    },
    "terminal.integrated.tabs.title": {
      type: "string",
      default: "${process}",
      markdownDescription: qa
    },
    "terminal.integrated.tabs.description": {
      type: "string",
      default: "${task}${separator}${local}${separator}${cwdFolder}",
      markdownDescription: ja
    },
    "terminal.integrated.rightClickBehavior": {
      type: "string",
      enum: ["default", "copyPaste", "paste", "selectWord", "nothing"],
      enumDescriptions: [
        g("terminal.integrated.rightClickBehavior.default", "Show the context menu."),
        g(
          "terminal.integrated.rightClickBehavior.copyPaste",
          "Copy when there is a selection, otherwise paste."
        ),
        g("terminal.integrated.rightClickBehavior.paste", "Paste on right click."),
        g(
          "terminal.integrated.rightClickBehavior.selectWord",
          "Select the word under the cursor and show the context menu."
        ),
        g(
          "terminal.integrated.rightClickBehavior.nothing",
          "Do nothing and pass event to terminal."
        )
      ],
      default: rt ? "selectWord" : Le ? "copyPaste" : "default",
      description: g(
        "terminal.integrated.rightClickBehavior",
        "Controls how terminal reacts to right click."
      )
    },
    "terminal.integrated.cwd": {
      restricted: !0,
      description: g(
        "terminal.integrated.cwd",
        "An explicit start path where the terminal will be launched, this is used as the current working directory (cwd) for the shell process. This may be particularly useful in workspace settings if the root directory is not a convenient cwd."
      ),
      type: "string",
      default: void 0,
      scope: 4
    },
    "terminal.integrated.confirmOnExit": {
      description: g(
        "terminal.integrated.confirmOnExit",
        "Controls whether to confirm when the window closes if there are active terminal sessions."
      ),
      type: "string",
      enum: ["never", "always", "hasChildProcesses"],
      enumDescriptions: [
        g("terminal.integrated.confirmOnExit.never", "Never confirm."),
        g(
          "terminal.integrated.confirmOnExit.always",
          "Always confirm if there are terminals."
        ),
        g(
          "terminal.integrated.confirmOnExit.hasChildProcesses",
          "Confirm if there are any terminals that have child processes."
        )
      ],
      default: "never"
    },
    "terminal.integrated.confirmOnKill": {
      description: g(
        "terminal.integrated.confirmOnKill",
        "Controls whether to confirm killing terminals when they have child processes. When set to editor, terminals in the editor area will be marked as changed when they have child processes. Note that child process detection may not work well for shells like Git Bash which don't run their processes as child processes of the shell."
      ),
      type: "string",
      enum: ["never", "editor", "panel", "always"],
      enumDescriptions: [
        g("terminal.integrated.confirmOnKill.never", "Never confirm."),
        g(
          "terminal.integrated.confirmOnKill.editor",
          "Confirm if the terminal is in the editor."
        ),
        g(
          "terminal.integrated.confirmOnKill.panel",
          "Confirm if the terminal is in the panel."
        ),
        g(
          "terminal.integrated.confirmOnKill.always",
          "Confirm if the terminal is either in the editor or panel."
        )
      ],
      default: "editor"
    },
    "terminal.integrated.enableBell": {
      description: g(
        "terminal.integrated.enableBell",
        "Controls whether the terminal bell is enabled. This shows up as a visual bell next to the terminal's name."
      ),
      type: "boolean",
      default: !1
    },
    "terminal.integrated.commandsToSkipShell": {
      markdownDescription: g(
        "terminal.integrated.commandsToSkipShell",
        `A set of command IDs whose keybindings will not be sent to the shell but instead always be handled by VS Code. This allows keybindings that would normally be consumed by the shell to act instead the same as when the terminal is not focused, for example \`Ctrl+P\` to launch Quick Open.

&nbsp;

Many commands are skipped by default. To override a default and pass that command's keybinding to the shell instead, add the command prefixed with the \`-\` character. For example add \`-workbench.action.quickOpen\` to allow \`Ctrl+P\` to reach the shell.

&nbsp;

The following list of default skipped commands is truncated when viewed in Settings Editor. To see the full list, {1} and search for the first command from the list below.

&nbsp;

Default Skipped Commands:

{0}`,
        aa.sort().map((h) => `- ${h}`).join(`
`),
        `[${g("openDefaultSettingsJson", "open the default settings JSON")}](command:workbench.action.openRawDefaultSettings '${g("openDefaultSettingsJson.capitalized", "Open Default Settings (JSON)")}')`
      ),
      type: "array",
      items: {
        type: "string"
      },
      default: []
    },
    "terminal.integrated.allowChords": {
      markdownDescription: g(
        "terminal.integrated.allowChords",
        "Whether or not to allow chord keybindings in the terminal. Note that when this is true and the keystroke results in a chord it will bypass {0}, setting this to false is particularly useful when you want ctrl+k to go to your shell (not VS Code).",
        "`#terminal.integrated.commandsToSkipShell#`"
      ),
      type: "boolean",
      default: !0
    },
    "terminal.integrated.allowMnemonics": {
      markdownDescription: g(
        "terminal.integrated.allowMnemonics",
        "Whether to allow menubar mnemonics (for example Alt+F) to trigger the open of the menubar. Note that this will cause all alt keystrokes to skip the shell when true. This does nothing on macOS."
      ),
      type: "boolean",
      default: !1
    },
    "terminal.integrated.env.osx": {
      restricted: !0,
      markdownDescription: g(
        "terminal.integrated.env.osx",
        "Object with environment variables that will be added to the VS Code process to be used by the terminal on macOS. Set to `null` to delete the environment variable."
      ),
      type: "object",
      additionalProperties: {
        type: ["string", "null"]
      },
      default: {}
    },
    "terminal.integrated.env.linux": {
      restricted: !0,
      markdownDescription: g(
        "terminal.integrated.env.linux",
        "Object with environment variables that will be added to the VS Code process to be used by the terminal on Linux. Set to `null` to delete the environment variable."
      ),
      type: "object",
      additionalProperties: {
        type: ["string", "null"]
      },
      default: {}
    },
    "terminal.integrated.env.windows": {
      restricted: !0,
      markdownDescription: g(
        "terminal.integrated.env.windows",
        "Object with environment variables that will be added to the VS Code process to be used by the terminal on Windows. Set to `null` to delete the environment variable."
      ),
      type: "object",
      additionalProperties: {
        type: ["string", "null"]
      },
      default: {}
    },
    "terminal.integrated.environmentChangesIndicator": {
      markdownDescription: g(
        "terminal.integrated.environmentChangesIndicator",
        "Whether to display the environment changes indicator on each terminal which explains whether extensions have made, or want to make changes to the terminal's environment."
      ),
      type: "string",
      enum: ["off", "on", "warnonly"],
      enumDescriptions: [
        g(
          "terminal.integrated.environmentChangesIndicator.off",
          "Disable the indicator."
        ),
        g(
          "terminal.integrated.environmentChangesIndicator.on",
          "Enable the indicator."
        ),
        g(
          "terminal.integrated.environmentChangesIndicator.warnonly",
          "Only show the warning indicator when a terminal's environment is 'stale', not the information indicator that shows a terminal has had its environment modified by an extension."
        )
      ],
      default: "warnonly"
    },
    "terminal.integrated.environmentChangesRelaunch": {
      markdownDescription: g(
        "terminal.integrated.environmentChangesRelaunch",
        "Whether to relaunch terminals automatically if extension want to contribute to their environment and have not been interacted with yet."
      ),
      type: "boolean",
      default: !0
    },
    "terminal.integrated.showExitAlert": {
      description: g(
        "terminal.integrated.showExitAlert",
        'Controls whether to show the alert "The terminal process terminated with exit code" when exit code is non-zero.'
      ),
      type: "boolean",
      default: !0
    },
    "terminal.integrated.splitCwd": {
      description: g(
        "terminal.integrated.splitCwd",
        "Controls the working directory a split terminal starts with."
      ),
      type: "string",
      enum: ["workspaceRoot", "initial", "inherited"],
      enumDescriptions: [
        g(
          "terminal.integrated.splitCwd.workspaceRoot",
          "A new split terminal will use the workspace root as the working directory. In a multi-root workspace a choice for which root folder to use is offered."
        ),
        g(
          "terminal.integrated.splitCwd.initial",
          "A new split terminal will use the working directory that the parent terminal started with."
        ),
        g(
          "terminal.integrated.splitCwd.inherited",
          "On macOS and Linux, a new split terminal will use the working directory of the parent terminal. On Windows, this behaves the same as initial."
        )
      ],
      default: "inherited"
    },
    "terminal.integrated.windowsEnableConpty": {
      description: g(
        "terminal.integrated.windowsEnableConpty",
        "Whether to use ConPTY for Windows terminal process communication (requires Windows 10 build number 18309+). Winpty will be used if this is false."
      ),
      type: "boolean",
      default: !0
    },
    "terminal.integrated.wordSeparators": {
      markdownDescription: g(
        "terminal.integrated.wordSeparators",
        "A string containing all characters to be considered word separators when double-clicking to select word and in the fallback 'word' link detection. Since this is used for link detection, including characters such as `:` that are used when detecting links will cause the line and column part of links like `file:10:5` to be ignored."
      ),
      type: "string",
      default: " ()[]{}',\"`─‘’|"
    },
    "terminal.integrated.enableFileLinks": {
      description: g(
        "terminal.integrated.enableFileLinks",
        "Whether to enable file links in terminals. Links can be slow when working on a network drive in particular because each file link is verified against the file system. Changing this will take effect only in new terminals."
      ),
      type: "string",
      enum: ["off", "on", "notRemote"],
      enumDescriptions: [
        g("enableFileLinks.off", "Always off."),
        g("enableFileLinks.on", "Always on."),
        g("enableFileLinks.notRemote", "Enable only when not in a remote workspace.")
      ],
      default: "on"
    },
    "terminal.integrated.unicodeVersion": {
      type: "string",
      enum: ["6", "11"],
      enumDescriptions: [
        g(
          "terminal.integrated.unicodeVersion.six",
          "Version 6 of Unicode. This is an older version which should work better on older systems."
        ),
        g(
          "terminal.integrated.unicodeVersion.eleven",
          "Version 11 of Unicode. This version provides better support on modern systems that use modern versions of Unicode."
        )
      ],
      default: "11",
      description: g(
        "terminal.integrated.unicodeVersion",
        "Controls what version of Unicode to use when evaluating the width of characters in the terminal. If you experience emoji or other wide characters not taking up the right amount of space or backspace either deleting too much or too little then you may want to try tweaking this setting."
      )
    },
    "terminal.integrated.localEchoLatencyThreshold": {
      description: g(
        "terminal.integrated.localEchoLatencyThreshold",
        "Length of network delay, in milliseconds, where local edits will be echoed on the terminal without waiting for server acknowledgement. If '0', local echo will always be on, and if '-1' it will be disabled."
      ),
      type: "integer",
      minimum: -1,
      default: 30
    },
    "terminal.integrated.localEchoEnabled": {
      markdownDescription: g(
        "terminal.integrated.localEchoEnabled",
        "When local echo should be enabled. This will override {0}",
        "`#terminal.integrated.localEchoLatencyThreshold#`"
      ),
      type: "string",
      enum: ["on", "off", "auto"],
      enumDescriptions: [
        g("terminal.integrated.localEchoEnabled.on", "Always enabled"),
        g("terminal.integrated.localEchoEnabled.off", "Always disabled"),
        g(
          "terminal.integrated.localEchoEnabled.auto",
          "Enabled only for remote workspaces"
        )
      ],
      default: "auto"
    },
    "terminal.integrated.localEchoExcludePrograms": {
      description: g(
        "terminal.integrated.localEchoExcludePrograms",
        "Local echo will be disabled when any of these program names are found in the terminal title."
      ),
      type: "array",
      items: {
        type: "string",
        uniqueItems: !0
      },
      default: Sh
    },
    "terminal.integrated.localEchoStyle": {
      description: g(
        "terminal.integrated.localEchoStyle",
        "Terminal style of locally echoed text; either a font style or an RGB color."
      ),
      default: "dim",
      oneOf: [
        {
          type: "string",
          default: "dim",
          enum: ["bold", "dim", "italic", "underlined", "inverted"]
        },
        {
          type: "string",
          format: "color-hex",
          default: "#ff0000"
        }
      ]
    },
    "terminal.integrated.enablePersistentSessions": {
      description: g(
        "terminal.integrated.enablePersistentSessions",
        "Persist terminal sessions/history for the workspace across window reloads."
      ),
      type: "boolean",
      default: !0
    },
    "terminal.integrated.persistentSessionReviveProcess": {
      markdownDescription: g(
        "terminal.integrated.persistentSessionReviveProcess",
        `When the terminal process must be shut down (for example on window or application close), this determines when the previous terminal session contents/history should be restored and processes be recreated when the workspace is next opened.

Caveats:

- Restoring of the process current working directory depends on whether it is supported by the shell.
- Time to persist the session during shutdown is limited, so it may be aborted when using high-latency remote connections.`
      ),
      type: "string",
      enum: ["onExit", "onExitAndWindowClose", "never"],
      markdownEnumDescriptions: [
        g(
          "terminal.integrated.persistentSessionReviveProcess.onExit",
          "Revive the processes after the last window is closed on Windows/Linux or when the `workbench.action.quit` command is triggered (command palette, keybinding, menu)."
        ),
        g(
          "terminal.integrated.persistentSessionReviveProcess.onExitAndWindowClose",
          "Revive the processes after the last window is closed on Windows/Linux or when the `workbench.action.quit` command is triggered (command palette, keybinding, menu), or when the window is closed."
        ),
        g(
          "terminal.integrated.persistentSessionReviveProcess.never",
          "Never restore the terminal buffers or recreate the process."
        )
      ],
      default: "onExit"
    },
    "terminal.integrated.customGlyphs": {
      description: g(
        "terminal.integrated.customGlyphs",
        "Whether to draw custom glyphs for block element and box drawing characters instead of using the font, which typically yields better rendering with continuous lines. Note that this doesn't work when {0} is disabled.",
        "`#terminal.integrated.gpuAcceleration#`"
      ),
      type: "boolean",
      default: !0
    },
    "terminal.integrated.autoReplies": {
      markdownDescription: g(
        "terminal.integrated.autoReplies",
        `A set of messages that, when encountered in the terminal, will be automatically responded to. Provided the message is specific enough, this can help automate away common responses.

Remarks:

- Use {0} to automatically respond to the terminate batch job prompt on Windows.
- The message includes escape sequences so the reply might not happen with styled text.
- Each reply can only happen once every second.
- Use {1} in the reply to mean the enter key.
- To unset a default key, set the value to null.
- Restart VS Code if new don't apply.`,
        '`"Terminate batch job (Y/N)": "Y\\r"`',
        '`"\\r"`'
      ),
      type: "object",
      additionalProperties: {
        oneOf: [
          {
            type: "string",
            description: g(
              "terminal.integrated.autoReplies.reply",
              "The reply to send to the process."
            )
          },
          { type: "null" }
        ]
      },
      default: {}
    },
    "terminal.integrated.shellIntegration.enabled": {
      restricted: !0,
      markdownDescription: g(
        "terminal.integrated.shellIntegration.enabled",
        `Determines whether or not shell integration is auto-injected to support features like enhanced command tracking and current working directory detection. 

Shell integration works by injecting the shell with a startup script. The script gives VS Code insight into what is happening within the terminal.

Supported shells:

- Linux/macOS: bash, fish, pwsh, zsh
 - Windows: pwsh

This setting applies only when terminals are created, so you will need to restart your terminals for it to take effect.

 Note that the script injection may not work if you have custom arguments defined in the terminal profile, have enabled {1}, have a [complex bash \`PROMPT_COMMAND\`](https://code.visualstudio.com/docs/editor/integrated-terminal#_complex-bash-promptcommand), or other unsupported setup. To disable decorations, see {0}`,
        "`#terminal.integrated.shellIntegrations.decorationsEnabled#`",
        "`#editor.accessibilitySupport#`"
      ),
      type: "boolean",
      default: !0
    },
    "terminal.integrated.shellIntegration.decorationsEnabled": {
      restricted: !0,
      markdownDescription: g(
        "terminal.integrated.shellIntegration.decorationsEnabled",
        "When shell integration is enabled, adds a decoration for each command."
      ),
      type: "string",
      enum: ["both", "gutter", "overviewRuler", "never"],
      enumDescriptions: [
        g(
          "terminal.integrated.shellIntegration.decorationsEnabled.both",
          "Show decorations in the gutter (left) and overview ruler (right)"
        ),
        g(
          "terminal.integrated.shellIntegration.decorationsEnabled.gutter",
          "Show gutter decorations to the left of the terminal"
        ),
        g(
          "terminal.integrated.shellIntegration.decorationsEnabled.overviewRuler",
          "Show overview ruler decorations to the right of the terminal"
        ),
        g(
          "terminal.integrated.shellIntegration.decorationsEnabled.never",
          "Do not show decorations"
        )
      ],
      default: "both"
    },
    "terminal.integrated.shellIntegration.history": {
      restricted: !0,
      markdownDescription: g(
        "terminal.integrated.shellIntegration.history",
        "Controls the number of recently used commands to keep in the terminal command history. Set to 0 to disable terminal command history."
      ),
      type: "number",
      default: 100
    },
    "terminal.integrated.shellIntegration.suggestEnabled": {
      restricted: !0,
      markdownDescription: g(
        "terminal.integrated.shellIntegration.suggestEnabled",
        "Enables experimental terminal Intellisense suggestions for supported shells when {0} is set to {1}. If shell integration is installed manually, {2} needs to be set to {3} before calling the script.",
        "`#terminal.integrated.shellIntegration.enabled#`",
        "`true`",
        "`VSCODE_SUGGEST`",
        "`1`"
      ),
      type: "boolean",
      default: !1
    },
    "terminal.integrated.smoothScrolling": {
      markdownDescription: g(
        "terminal.integrated.smoothScrolling",
        "Controls whether the terminal will scroll using an animation."
      ),
      type: "boolean",
      default: !1
    },
    "terminal.integrated.enableImages": {
      restricted: !0,
      markdownDescription: g(
        "terminal.integrated.enableImages",
        "Enables image support in the terminal, this will only work when {0} is enabled. Both sixel and iTerm's inline image protocol are supported on Linux and macOS, Windows support will light up automatically when ConPTY passes through the sequences. Images will currently not be restored between window reloads/reconnects.",
        "`#terminal.integrated.gpuAcceleration#`"
      ),
      type: "boolean",
      default: !0
    }
  }
};
function xu() {
  Oe.as(Jr.Configuration).registerConfiguration(yu);
}
let Or = class extends bh {
  constructor(e, t, i, s, c, l, n, r, a, f, m, C, b) {
    super(An, e, t, i), this._terminalEditorService = s, this._terminalProfileResolverService = c, this._terminalService = l, this._instantiationService = a, this._contextMenuService = f, this._notificationService = m, this._terminalProfileService = C, this._workbenchLayoutService = b, this._editorInput = void 0, this._cancelContextMenu = !1, this._dropdownMenu = this._register(r.createMenu(J.TerminalNewDropdownContext, n)), this._instanceMenu = this._register(r.createMenu(J.TerminalEditorInstanceContext, n));
  }
  async setInput(e, t, i, s) {
    var c, l, n, r;
    (l = (c = this._editorInput) == null ? void 0 : c.terminalInstance) == null || l.detachFromElement(), this._editorInput = e, await super.setInput(e, t, i, s), (n = this._editorInput.terminalInstance) == null || n.attachToElement(this._overflowGuardElement), this._lastDimension && this.layout(this._lastDimension), (r = this._editorInput.terminalInstance) == null || r.setVisible(this.isVisible() && this._workbenchLayoutService.isVisible("workbench.parts.editor")), this._editorInput.terminalInstance && (this._register(this._editorInput.terminalInstance.onDidFocus(() => this._setActiveInstance())), this._editorInput.setCopyLaunchConfig(this._editorInput.terminalInstance.shellLaunchConfig));
  }
  clearInput() {
    var e, t;
    super.clearInput(), (t = (e = this._editorInput) == null ? void 0 : e.terminalInstance) == null || t.detachFromElement(), this._editorInput = void 0;
  }
  _setActiveInstance() {
    var e;
    (e = this._editorInput) != null && e.terminalInstance && this._terminalEditorService.setActiveInstance(this._editorInput.terminalInstance);
  }
  focus() {
    var e, t;
    (t = (e = this._editorInput) == null ? void 0 : e.terminalInstance) == null || t.focus();
  }
  createEditor(e) {
    this._editorInstanceElement = e, this._overflowGuardElement = Ve(".terminal-overflow-guard.terminal-editor"), this._editorInstanceElement.appendChild(this._overflowGuardElement), this._registerListeners();
  }
  _registerListeners() {
    this._editorInstanceElement && (this._register(he(this._editorInstanceElement, "mousedown", async (e) => {
      if (this._terminalEditorService.instances.length !== 0) {
        if (e.which === 2 && zn) {
          const t = this._terminalEditorService.activeInstance;
          t == null || t.focus();
        } else if (e.which === 3) {
          const t = this._terminalService.configHelper.config.rightClickBehavior;
          if (t === "nothing") {
            e.shiftKey || (this._cancelContextMenu = !0);
            return;
          } else if (t === "copyPaste" || t === "paste") {
            const i = this._terminalEditorService.activeInstance;
            if (!i)
              return;
            if (t === "copyPaste" && e.shiftKey) {
              Xi(e, this._editorInstanceElement, this._instanceMenu, this._contextMenuService);
              return;
            }
            t === "copyPaste" && i.hasSelection() ? (await i.copySelection(), i.clearSelection()) : bi.clipboard.readText ? i.paste() : this._notificationService.info(`This browser doesn't support the clipboard.readText API needed to trigger a paste, try ${rt ? "⌘" : "Ctrl"}+V instead.`), rt && setTimeout(() => {
              i.clearSelection();
            }, 0), this._cancelContextMenu = !0;
          }
        }
      }
    })), this._register(he(this._editorInstanceElement, "contextmenu", (e) => {
      const t = this._terminalService.configHelper.config.rightClickBehavior;
      if (t === "nothing" && !e.shiftKey) {
        e.preventDefault(), e.stopImmediatePropagation(), this._cancelContextMenu = !1;
        return;
      } else
        !this._cancelContextMenu && t !== "copyPaste" && t !== "paste" && (this._cancelContextMenu || Xi(e, this._editorInstanceElement, this._instanceMenu, this._contextMenuService), e.preventDefault(), e.stopImmediatePropagation(), this._cancelContextMenu = !1);
    })));
  }
  layout(e) {
    var t, i;
    (i = (t = this._editorInput) == null ? void 0 : t.terminalInstance) == null || i.layout(e), this._lastDimension = e;
  }
  setVisible(e, t) {
    var i, s;
    super.setVisible(e, t), (s = (i = this._editorInput) == null ? void 0 : i.terminalInstance) == null || s.setVisible(e && this._workbenchLayoutService.isVisible("workbench.parts.editor"));
  }
  getActionViewItem(e) {
    switch (e.id) {
      case "workbench.action.createTerminalEditor":
        if (e instanceof En) {
          const i = Ar({ viewColumn: Qr }, this._terminalProfileService.availableProfiles, this._getDefaultProfileName(), this._terminalProfileService.contributedProfiles, this._terminalService, this._dropdownMenu);
          return this._instantiationService.createInstance(Ca, e, i.dropdownAction, i.dropdownMenuActions, i.className, this._contextMenuService, {});
        }
    }
    return super.getActionViewItem(e);
  }
  _getDefaultProfileName() {
    let e;
    try {
      e = this._terminalProfileService.getDefaultProfileName();
    } catch {
      e = this._terminalProfileResolverService.defaultProfileName;
    }
    return e;
  }
};
Or = X([
  D(0, Ni),
  D(1, Me),
  D(2, ti),
  D(3, li),
  D(4, ii),
  D(5, we),
  D(6, Fe),
  D(7, Zn),
  D(8, le),
  D(9, _i),
  D(10, Ee),
  D(11, Bt),
  D(12, ss)
], Or);
let Fr = class extends ue {
  constructor(e, t, i, s, c, l, n) {
    super(), e.registerEditor(`${me.vscodeTerminal}:/**`, {
      id: An,
      label: Q.terminal,
      priority: yh.exclusive
    }, {
      canSupportResource: (r) => r.scheme === me.vscodeTerminal,
      singlePerResource: !0
    }, {
      createEditorInput: async ({ resource: r, options: a }) => {
        let f = s.getInstanceFromResource(r);
        if (f) {
          const b = l.getGroupForInstance(f);
          b == null || b.removeInstance(f);
        } else {
          const b = eo(r);
          if (!b.instanceId)
            throw new Error("Terminal identifier without instanceId");
          const p = s.getPrimaryBackend();
          if (!p)
            throw new Error("No terminal primary backend");
          const S = await p.requestDetachInstance(b.workspaceId, b.instanceId);
          if (!S)
            throw new Error("No terminal persistent process to attach");
          f = n.createInstance({ attachPersistentProcess: S }, se.Editor);
        }
        const m = c.resolveResource(f);
        return {
          editor: c.getInputFromResource(m),
          options: {
            ...a,
            pinned: !0,
            forceReload: !0,
            override: An
          }
        };
      }
    }), i.registerFormatter({
      scheme: me.vscodeTerminal,
      formatting: {
        label: "${path}",
        separator: ""
      }
    }), t.onDidCreateTerminal(async (r) => {
      const a = await s.createTerminal({
        config: r,
        location: se.Panel
      });
      s.setActiveInstance(a), await s.revealActiveTerminal();
    });
  }
};
Fr = X([
  D(0, wh),
  D(1, Ch),
  D(2, Un),
  D(3, we),
  D(4, li),
  D(5, Ae),
  D(6, yt)
], Fr);
const ku = Oe.as(xh.Quickaccess), Iu = "inTerminalPicker";
ku.registerQuickAccessProvider({
  ctor: Yi,
  prefix: Yi.PREFIX,
  contextKey: Iu,
  placeholder: g("tasksQuickAccessPlaceholder", "Type the name of a terminal to open."),
  helpEntries: [{ description: g("tasksQuickAccessHelp", "Show All Opened Terminals"), commandId: "workbench.action.quickOpenTerm" }]
});
const Ho = "workbench.action.quickOpenNavigateNextInTerminalPicker";
Jn.registerCommand({ id: Ho, handler: Sa(Ho, !0) });
const Wo = "workbench.action.quickOpenNavigatePreviousInTerminalPicker";
Jn.registerCommand({ id: Wo, handler: Sa(Wo, !1) });
const Tu = Oe.as(kh.Workbench);
Tu.registerWorkbenchContribution(Fr, 3);
ou();
xu();
Oe.as(Ih.EditorPane).registerEditorPane(Th.create(Or, An, Q.terminal), [
  new We(it)
]);
Oe.as(Dh.DragAndDropContribution).register({
  dataFormatKey: "Terminals",
  getEditorInputs(h) {
    const e = [];
    try {
      const t = JSON.parse(h);
      for (const i of t)
        e.push({ resource: oe.parse(i) });
    } catch {
    }
    return e;
  },
  setData(h, e) {
    var i;
    const t = h.filter(({ resource: s }) => s.scheme === me.vscodeTerminal);
    t.length && ((i = e.dataTransfer) == null || i.setData("Terminals", JSON.stringify(t.map(({ resource: s }) => s.toString()))));
  }
});
const Du = Oe.as(ba.ViewContainersRegistry).registerViewContainer({
  id: fe,
  title: g("terminal", "Terminal"),
  icon: ya,
  ctorDescriptor: new We(
    Eh,
    [fe, { mergeViewWithContainerWhenSingleView: !0 }]
  ),
  storageId: fe,
  hideIfEmpty: !0,
  order: 3
}, 1, { doNotRegisterOpenCommand: !0, isDefault: !0 });
Oe.as(ba.ViewsRegistry).registerViews([{
  id: fe,
  name: g("terminal", "Terminal"),
  containerIcon: ya,
  canToggleVisibility: !1,
  canMoveView: !0,
  ctorDescriptor: new We(Lr),
  openCommandActionDescriptor: {
    id: "workbench.action.terminal.toggleTerminal",
    mnemonicTitle: g(
      { key: "miToggleIntegratedTerminal", comment: ["&& denotes a mnemonic"] },
      "&&Terminal"
    ),
    keybindings: {
      primary: 2139,
      mac: { primary: 347 }
    },
    order: 3
  }
}], Du);
_d();
function xe(h, e) {
  va.registerCommandAndKeybindingRule({
    id: "workbench.action.terminal.sendSequence",
    weight: 200,
    when: e.when || E.focus,
    primary: e.primary,
    mac: e.mac,
    linux: e.linux,
    win: e.win,
    handler: Aa,
    args: { text: h }
  });
}
Le && xe(String.fromCharCode("V".charCodeAt(0) - 64), {
  when: R.and(E.focus, R.equals(
    "terminalShellType",
    "pwsh"
  ), De.negate()),
  primary: 2100
});
xe("\x1B[24~a", {
  when: R.and(E.focus, R.equals(
    "terminalShellType",
    "pwsh"
  ), E.terminalShellIntegrationEnabled, De.negate()),
  primary: 2058,
  mac: { primary: 266 }
});
xe("\x1B[24~b", {
  when: R.and(E.focus, R.equals(
    "terminalShellType",
    "pwsh"
  ), E.terminalShellIntegrationEnabled, De.negate()),
  primary: 522
});
xe("\x1B[24~c", {
  when: R.and(E.focus, R.equals(
    "terminalShellType",
    "pwsh"
  ), E.terminalShellIntegrationEnabled, De.negate()),
  primary: 1027
});
xe("\x1B[24~d", {
  when: R.and(E.focus, R.equals(
    "terminalShellType",
    "pwsh"
  ), E.terminalShellIntegrationEnabled, De.negate()),
  mac: { primary: 3089 }
});
xe("\x1B[24~e", {
  when: R.and(E.focus, R.equals(
    "terminalShellType",
    "pwsh"
  ), E.terminalShellIntegrationEnabled, De.negate(), R.equals(
    "config.terminal.integrated.shellIntegration.suggestEnabled",
    !0
  )),
  primary: 2058,
  mac: { primary: 266 }
});
xe("\x1B[1;2H", {
  when: R.and(E.focus, R.equals(
    "terminalShellType",
    "pwsh"
  )),
  mac: { primary: 3087 }
});
xe("", {
  when: R.and(E.focus, De),
  primary: 2608,
  mac: { primary: 816 }
});
xe("\x07", {
  when: E.focus,
  primary: 2597,
  mac: { primary: 805 }
});
Xo && xe(String.fromCharCode("C".charCodeAt(0) - 64), {
  when: R.and(E.focus),
  primary: 289
});
xe(String.fromCharCode("W".charCodeAt(0) - 64), {
  primary: 2049,
  mac: { primary: 513 }
});
Le && xe(String.fromCharCode("H".charCodeAt(0) - 64), {
  when: R.and(E.focus, R.equals(
    "terminalShellType",
    "cmd"
  )),
  primary: 2049
});
xe("\x1Bd", {
  primary: 2068,
  mac: { primary: 532 }
});
xe("", {
  mac: { primary: 2049 }
});
xe(String.fromCharCode("A".charCodeAt(0) - 64), {
  mac: { primary: 2063 }
});
xe(String.fromCharCode("E".charCodeAt(0) - 64), {
  mac: { primary: 2065 }
});
xe("\0", {
  primary: 3095,
  mac: { primary: 1303 }
});
xe("", {
  primary: 3099,
  mac: { primary: 1307 }
});
xe("", {
  primary: 2138,
  mac: { primary: 346 }
});
wu();
vu();
Ah();
let Hr = class extends ue {
  onClose() {
    this._instance.focus(), this.dispose();
  }
  constructor(e, t, i, s, c) {
    super(), this._instance = e, this._keybindingService = s, this._accessibilityService = c, this._hasShellIntegration = !1, this.options = {
      type: "help",
      ariaLabel: g("terminal-help-label", "terminal accessibility help"),
      readMoreUrl: "https://code.visualstudio.com/docs/editor/accessibility#_terminal-accessibility"
    }, this.verbositySettingKey = "accessibility.verbosity.terminal", this._hasShellIntegration = t.shellIntegration.status === 2;
  }
  _descriptionForCommand(e, t, i) {
    const s = this._keybindingService.lookupKeybindings(e);
    switch (s.length) {
      case 0:
        return fn(i, e);
      case 1:
        return fn(t, s[0].getAriaLabel());
    }
    return this._accessibilityService.isScreenReaderOptimized() ? fn(t, s[1].getAriaLabel()) : fn(t, s[0].getAriaLabel());
  }
  provideContent() {
    const e = [];
    return e.push(this._descriptionForCommand("workbench.action.terminal.focusAccessibleBuffer", g(
      "focusAccessibleBuffer",
      "The Focus Accessible Buffer ({0}) command enables screen readers to read terminal contents."
    ), g(
      "focusAccessibleBufferNoKb",
      "The Focus Accessible Buffer command enables screen readers to read terminal contents and is currently not triggerable by a keybinding."
    ))), this._instance.shellType === "cmd" && e.push(g(
      "commandPromptMigration",
      "Consider using powershell instead of command prompt for an improved experience"
    )), this._hasShellIntegration ? (e.push(g(
      "shellIntegration",
      "The terminal has a feature called shell integration that offers an enhanced experience and provides useful commands for screen readers such as:"
    )), e.push("- " + this._descriptionForCommand("workbench.action.terminal.accessibleBufferGoToNextCommand", g("goToNextCommand", "Go to Next Command ({0})"), g(
      "goToNextCommandNoKb",
      "Go to Next Command is currently not triggerable by a keybinding."
    ))), e.push("- " + this._descriptionForCommand("workbench.action.terminal.accessibleBufferGoToPreviousCommand", g("goToPreviousCommand", "Go to Previous Command ({0})"), g(
      "goToPreviousCommandNoKb",
      "Go to Previous Command is currently not triggerable by a keybinding."
    ))), e.push("- " + this._descriptionForCommand("workbench.action.terminal.navigateAccessibleBuffer", g("navigateAccessibleBuffer", "Navigate Accessible Buffer ({0})"), g(
      "navigateAccessibleBufferNoKb",
      "Navigate Accessible Buffer is currently not triggerable by a keybinding."
    ))), e.push("- " + this._descriptionForCommand("workbench.action.terminal.runRecentCommand", g("runRecentCommand", "Run Recent Command ({0})"), g(
      "runRecentCommandNoKb",
      "Run Recent Command is currently not triggerable by a keybinding."
    ))), e.push("- " + this._descriptionForCommand("workbench.action.terminal.goToRecentDirectory", g("goToRecentDirectory", "Go to Recent Directory ({0})"), g(
      "goToRecentDirectoryNoKb",
      "Go to Recent Directory is currently not triggerable by a keybinding."
    )))) : e.push(this._descriptionForCommand("workbench.action.terminal.runRecentCommand", g(
      "goToRecentDirectoryNoShellIntegration",
      "The Go to Recent Directory command ({0}) enables screen readers to easily navigate to a directory that has been used in the terminal."
    ), g(
      "goToRecentDirectoryNoKbNoShellIntegration",
      "The Go to Recent Directory command enables screen readers to easily navigate to a directory that has been used in the terminal and is currently not triggerable by a keybinding."
    ))), e.push(this._descriptionForCommand("workbench.action.terminal.openDetectedLink", g(
      "openDetectedLink",
      "The Open Detected Link ({0}) command enables screen readers to easily open links found in the terminal."
    ), g(
      "openDetectedLinkNoKb",
      "The Open Detected Link command enables screen readers to easily open links found in the terminal and is currently not triggerable by a keybinding."
    ))), e.push(this._descriptionForCommand("workbench.action.terminal.newWithProfile", g(
      "newWithProfile",
      "The Create New Terminal (With Profile) ({0}) command allows for easy terminal creation using a specific profile."
    ), g(
      "newWithProfileNoKb",
      "The Create New Terminal (With Profile) command allows for easy terminal creation using a specific profile and is currently not triggerable by a keybinding."
    ))), e.push(g(
      "accessibilitySettings",
      "Access accessibility settings such as `terminal.integrated.tabFocusMode` via the Preferences: Open Accessibility Settings command."
    )), e.join(`
`);
  }
};
Hr = X([
  D(2, le),
  D(3, ui),
  D(4, ns)
], Hr);
let Wr = class {
  get lines() {
    return this._lines;
  }
  constructor(e, t, i) {
    this._xterm = e, this._logService = t, this._configurationService = i, this._priorEditorViewportLineCount = 0, this._lines = [], this.bufferToEditorLineMapping = /* @__PURE__ */ new Map();
  }
  reset() {
    this._lines = [], this._lastCachedMarker = void 0, this.update();
  }
  update() {
    var e;
    (e = this._lastCachedMarker) != null && e.isDisposed && (this._lines = [], this._lastCachedMarker = void 0), this._removeViewportContent(), this._updateCachedContent(), this._updateViewportContent(), this._lastCachedMarker = this._xterm.raw.registerMarker(), this._logService.debug("Buffer content tracker: set ", this._lines.length, " lines");
  }
  _updateCachedContent() {
    var a, f;
    const e = this._xterm.raw.buffer.active, t = (a = this._lastCachedMarker) != null && a.line ? this._lastCachedMarker.line - this._xterm.raw.rows + 1 : 0, i = e.baseY;
    if (t < 0 || t > i)
      return;
    const c = this._configurationService.getValue("terminal.integrated.scrollback") + this._xterm.raw.rows - 1, l = i - t;
    if (l + this._lines.length > c) {
      const m = l + this._lines.length - c;
      for (let C = 0; C < m; C++)
        this._lines.shift();
      this._logService.debug("Buffer content tracker: removed ", m, " lines from top of cached lines, now ", this._lines.length, " lines");
    }
    const n = [];
    let r = "";
    for (let m = t; m < i; m++) {
      const C = e.getLine(m);
      if (!C)
        continue;
      this.bufferToEditorLineMapping.set(m, this._lines.length + n.length);
      const b = (f = e.getLine(m + 1)) == null ? void 0 : f.isWrapped;
      r += C.translateToString(!b), (r && !b || m === e.baseY + this._xterm.raw.rows - 1) && C.length && (n.push(r), r = "");
    }
    this._logService.debug("Buffer content tracker:", n.length, " lines cached"), this._lines.push(...n);
  }
  _removeViewportContent() {
    if (!this._lines.length)
      return;
    let e = this._priorEditorViewportLineCount, t = 1;
    for (; e; )
      this.bufferToEditorLineMapping.forEach((i, s) => {
        i === this._lines.length - t && this.bufferToEditorLineMapping.delete(s);
      }), this._lines.pop(), t++, e--;
    this._logService.debug("Buffer content tracker: removed lines from viewport, now ", this._lines.length, " lines cached");
  }
  _updateViewportContent() {
    var i;
    const e = this._xterm.raw.buffer.active;
    this._priorEditorViewportLineCount = 0;
    let t = "";
    for (let s = e.baseY; s < e.baseY + this._xterm.raw.rows; s++) {
      const c = e.getLine(s);
      if (!c)
        continue;
      this.bufferToEditorLineMapping.set(s, this._lines.length);
      const l = (i = e.getLine(s + 1)) == null ? void 0 : i.isWrapped;
      t += c.translateToString(!l), (t && !l || s === e.baseY + this._xterm.raw.rows - 1) && t.length && (this._priorEditorViewportLineCount++, this._lines.push(t), t = "");
    }
    this._logService.debug("Viewport content update complete, ", this._lines.length, " lines in the viewport");
  }
};
Wr = X([
  D(1, Ot),
  D(2, Se)
], Wr);
let Nr = class extends Zt {
  get element() {
    return this._element;
  }
  get editorWidget() {
    return this._editorWidget;
  }
  constructor(e, t, i, s, c, l, n, r, a) {
    super(), this._className = e, this._instance = t, this._xterm = i, this._focusContextKey = s, this._instantiationService = c, this._modelService = l, this._configurationService = n, this._contextKeyService = r, this._terminalService = a, this._listeners = [], this._xtermElement = i.raw.element, this._element = document.createElement("div"), this._element.setAttribute("role", "document"), this._element.classList.add(e), this._element.classList.add("terminal-accessible-widget"), this._editorContainer = document.createElement("div");
    const f = {
      contributions: Lh.getEditorContributions().filter((b) => b.id !== Ph.ID)
    }, m = i.getFont(), C = {
      ...Rh(this._configurationService),
      lineDecorationsWidth: 6,
      dragAndDrop: !0,
      cursorWidth: 1,
      fontSize: m.fontSize,
      lineHeight: m.charHeight ? m.charHeight * m.lineHeight : 1,
      letterSpacing: m.letterSpacing,
      fontFamily: m.fontFamily,
      wrappingStrategy: "advanced",
      wrappingIndent: "none",
      padding: { top: 2, bottom: 2 },
      quickSuggestions: !1,
      renderWhitespace: "none",
      dropIntoEditor: { enabled: !0 },
      readOnly: !0
    };
    this._editorWidget = this.add(this._instantiationService.createInstance(Mh, this._editorContainer, C, f)), this._element.replaceChildren(this._editorContainer), this._xtermElement.insertAdjacentElement("beforebegin", this._element), this._focusContextKey && (this._focusTracker = this.add(Bh(this._editorContainer)), this._focusedContextKey = this._focusContextKey.bindTo(this._contextKeyService), this.add(this._focusTracker.onDidFocus(() => {
      var b;
      return (b = this._focusedContextKey) == null ? void 0 : b.set(!0);
    })), this.add(this._focusTracker.onDidBlur(() => {
      var b;
      return (b = this._focusedContextKey) == null ? void 0 : b.reset();
    }))), this.add(be.runAndSubscribe(this._xterm.raw.onResize, () => this.layout())), this.add(this._configurationService.onDidChangeConfiguration((b) => {
      if (b.affectedKeys.has("terminal.integrated.fontFamily") || b.affectedKeys.has("terminal.integrated.fontSize") || b.affectedKeys.has("terminal.integrated.lineHeight") || b.affectedKeys.has("terminal.integrated.letterSpacing")) {
        const p = this._xterm.getFont();
        this._editorWidget.updateOptions({ fontFamily: p.fontFamily, fontSize: p.fontSize, lineHeight: p.charHeight ? p.charHeight * p.lineHeight : 1, letterSpacing: p.letterSpacing });
      }
    })), this.add(this._editorWidget.onKeyDown((b) => {
      switch (b.keyCode) {
        case 9:
          this.hide(), this._xterm.raw.focus();
          break;
        case 2:
          this.hide();
          break;
      }
    })), this.add(this._editorWidget.onDidFocusEditorText(async () => {
      this._terminalService.setActiveInstance(this._instance), this._xtermElement.classList.add("hide");
    }));
  }
  registerListeners() {
    this._listeners.push(this._instance.onDidRequestFocus(() => this.editorWidget.focus()));
  }
  layout() {
    this._editorWidget.layout({ width: this._xtermElement.clientWidth, height: this._xtermElement.clientHeight });
  }
  async show() {
    this.registerListeners(), await this.updateEditor(), this.element.tabIndex = -1, this.layout(), this.element.classList.add("active"), this._xtermElement.classList.add("hide"), this.editorWidget.focus();
  }
  dispose() {
    this._disposeListeners(), super.dispose();
  }
  _disposeListeners() {
    for (const e of this._listeners)
      e.dispose();
  }
  hide() {
    this._disposeListeners(), this.element.classList.remove("active"), this._xtermElement.classList.remove("hide");
  }
  async getTextModel(e) {
    const t = this._modelService.getModel(e);
    return t && !t.isDisposed() ? t : this._modelService.createModel(`${this._className}-${e.fragment}`, null, e, !1);
  }
};
Nr = X([
  D(4, le),
  D(5, Kn),
  D(6, Se),
  D(7, Fe),
  D(8, we)
], Nr);
let Vr = class extends Nr {
  constructor(e, t, i, s, c, l, n, r, a, f) {
    super("accessible-buffer", e, t, E.accessibleBufferFocus, i, s, c, r, f), this._quickInputService = l, this._audioCueService = n, this._logService = a, this._isUpdating = !1, this._pendingUpdates = 0, this._bufferTracker = i.createInstance(Wr, t), this.element.ariaRoleDescription = g("terminal.integrated.accessibleBuffer", "Terminal buffer"), this.updateEditor(), this.add(this.editorWidget.onDidFocusEditorText(async () => {
      this.element.classList.contains("active") || (this.registerListeners(), await this.updateEditor(), this.element.classList.add("active"));
    })), this.layout();
  }
  navigateToCommand(e) {
    var c, l;
    const t = ((c = this.editorWidget.getPosition()) == null ? void 0 : c.lineNumber) || ((l = this._getDefaultCursorPosition()) == null ? void 0 : l.lineNumber), i = this._getCommandsWithEditorLine();
    if (!(i != null && i.length) || !t)
      return;
    const s = e === "previous" ? i.filter((n) => n.lineNumber < t).sort((n, r) => r.lineNumber - n.lineNumber) : i.filter((n) => n.lineNumber > t).sort((n, r) => n.lineNumber - r.lineNumber);
    s.length && (this._cursorPosition = { lineNumber: s[0].lineNumber, column: 1 }, this._resetPosition());
  }
  _getEditorLineForCommand(e) {
    var i;
    let t = (i = e.marker) == null ? void 0 : i.line;
    if (!(t === void 0 || !e.command.length || t < 0) && (t = this._bufferTracker.bufferToEditorLineMapping.get(t), t !== void 0))
      return t + 1;
  }
  _getCommandsWithEditorLine() {
    var i;
    const e = (i = this._instance.capabilities.get(2)) == null ? void 0 : i.commands;
    if (!(e != null && e.length))
      return;
    const t = [];
    for (const s of e) {
      const c = this._getEditorLineForCommand(s);
      c && t.push({ command: s, lineNumber: c });
    }
    return t;
  }
  async createQuickPick() {
    this._cursorPosition = Pt(this.editorWidget.getPosition());
    const e = this._getCommandsWithEditorLine();
    if (!e)
      return;
    const t = [];
    for (const { command: s, lineNumber: c } of e)
      this._getEditorLineForCommand(s) && t.push({
        label: g(
          "terminal.integrated.symbolQuickPick.labelNoExitCode",
          "{0}",
          s.command
        ),
        lineNumber: c,
        exitCode: s.exitCode
      });
    const i = this._quickInputService.createQuickPick();
    return i.canSelectMany = !1, i.onDidChangeActive(() => {
      const s = i.activeItems[0];
      s && (s.exitCode && this._audioCueService.playAudioCue(Xr.error, !0), this.editorWidget.revealLine(s.lineNumber, 0));
    }), i.onDidHide(() => {
      this._resetPosition(), i.dispose();
    }), i.onDidAccept(() => {
      const s = i.activeItems[0];
      this.editorWidget.getModel() && (!s && this._cursorPosition ? this._resetPosition() : this._cursorPosition = { lineNumber: s.lineNumber, column: 1 }, i.dispose(), this.editorWidget.focus());
    }), i.items = t.reverse(), i;
  }
  _resetPosition() {
    this._cursorPosition = this._cursorPosition ?? this._getDefaultCursorPosition(), this._cursorPosition && (this.editorWidget.setPosition(this._cursorPosition), this.editorWidget.setScrollPosition({ scrollTop: this.editorWidget.getTopForLineNumber(this._cursorPosition.lineNumber) }));
  }
  layout() {
    this._bufferTracker && this._bufferTracker.reset(), super.layout();
  }
  async updateEditor(e) {
    if (this._isUpdating) {
      this._pendingUpdates++;
      return;
    }
    this._isUpdating = !0, await this._updateModel(e) && (this._isUpdating = !1, this._pendingUpdates && (this._logService.debug("TerminalAccessibleBuffer._updateEditor: pending updates", this._pendingUpdates), this._pendingUpdates--, await this.updateEditor(e)));
  }
  registerListeners() {
    super.registerListeners(), this._xterm.raw.onWriteParsed(async () => {
      this._xterm.raw.buffer.active.baseY === 0 && await this.updateEditor(!0);
    });
    const e = be.latch(this._xterm.raw.onScroll);
    this._listeners.push(e(async () => await this.updateEditor(!0)));
  }
  _getDefaultCursorPosition() {
    var t;
    const e = (t = this.editorWidget.getModel()) == null ? void 0 : t.getLineCount();
    return e ? { lineNumber: e, column: 1 } : void 0;
  }
  async _updateModel(e) {
    var a, f;
    const t = this._bufferTracker.lines.length;
    this._bufferTracker.update();
    const i = this._bufferTracker.lines.length, s = t !== i;
    let c;
    e && (c = Pt(this.editorWidget.saveViewState()));
    let l = this.editorWidget.getModel();
    const n = this._bufferTracker.lines.join(`
`);
    l ? l.setValue(n) : l = await this.getTextModel(this._instance.resource.with({ fragment: `accessible-buffer-${n}` })), this.editorWidget.setModel(l);
    const r = ((a = this.editorWidget.getPosition()) == null ? void 0 : a.lineNumber) === 1 && ((f = this.editorWidget.getPosition()) == null ? void 0 : f.column) === 1;
    if (c)
      this.editorWidget.restoreViewState(c);
    else if (s || r) {
      const m = this._getDefaultCursorPosition();
      m && (this.editorWidget.setPosition(m), this.editorWidget.setScrollPosition({ scrollTop: this.editorWidget.getTopForLineNumber(m.lineNumber) }));
    }
    return l;
  }
};
Vr = X([
  D(2, le),
  D(3, Kn),
  D(4, Se),
  D(5, qe),
  D(6, jr),
  D(7, Fe),
  D(8, Ot),
  D(9, we)
], Vr);
var Mi;
let ei = (Mi = class extends Zt {
  static get(e) {
    return e.getContribution(Mi.ID);
  }
  constructor(e, t, i, s) {
    super(), this._instance = e, this._instantiationService = s;
  }
  layout(e) {
    this._xterm = e;
  }
  async show() {
    this._xterm && (this._accessibleBufferWidget || (this._accessibleBufferWidget = this.add(this._instantiationService.createInstance(Vr, this._instance, this._xterm))), await this._accessibleBufferWidget.show());
  }
  async createCommandQuickPick() {
    var e;
    return (e = this._accessibleBufferWidget) == null ? void 0 : e.createQuickPick();
  }
  navigateToCommand(e) {
    var t;
    return (t = this._accessibleBufferWidget) == null ? void 0 : t.navigateToCommand(e);
  }
}, Mi.ID = "terminal.accessible-buffer", Mi);
ei = X([
  D(3, le)
], ei);
Ha(ei.ID, ei);
class No extends ue {
  constructor() {
    super(), this._register(Fh.addImplementation(105, "terminal", async (e) => {
      const t = e.get(le), i = e.get(we), s = e.get(Hh), c = await i.getActiveOrCreateInstance();
      await i.revealActiveTerminal();
      const l = c == null ? void 0 : c.xterm;
      l && s.show(t.createInstance(Hr, c, l));
    }, E.focus));
  }
}
Ha(No.ID, No);
ie({
  id: "workbench.action.terminal.focusAccessibleBuffer",
  title: { value: g(
    "workbench.action.terminal.focusAccessibleBuffer",
    "Focus Accessible Buffer"
  ), original: "Focus Accessible Buffer" },
  precondition: R.or(
    E.processSupported,
    E.terminalHasBeenCreated
  ),
  keybinding: [
    {
      primary: 1026,
      weight: 200,
      when: R.and(
        De,
        E.focus,
        R.or(Oh, E.accessibleBufferFocus.negate())
      )
    }
  ],
  run: async (h) => {
    var t;
    const e = await h.service.getActiveOrCreateInstance();
    await h.service.revealActiveTerminal(), e && await ((t = ei.get(e)) == null ? void 0 : t.show());
  }
});
ie({
  id: "workbench.action.terminal.navigateAccessibleBuffer",
  title: { value: g(
    "workbench.action.terminal.navigateAccessibleBuffer",
    "Navigate Accessible Buffer"
  ), original: "Navigate Accessible Buffer" },
  precondition: R.or(
    E.processSupported,
    E.terminalHasBeenCreated
  ),
  keybinding: [
    {
      primary: 3109,
      weight: 200 + 2,
      when: E.accessibleBufferFocus
    }
  ],
  run: async (h) => {
    var i;
    const e = await h.service.getActiveOrCreateInstance();
    if (await h.service.revealActiveTerminal(), !e)
      return;
    const t = await ((i = ei.get(e)) == null ? void 0 : i.createCommandQuickPick());
    t == null || t.show();
  }
});
ie({
  id: "workbench.action.terminal.accessibleBufferGoToNextCommand",
  title: { value: g(
    "workbench.action.terminal.accessibleBufferGoToNextCommand",
    "Accessible Buffer Go to Next Command"
  ), original: "Accessible Buffer Go to Next Command" },
  precondition: R.or(
    E.processSupported,
    E.terminalHasBeenCreated,
    E.accessibleBufferFocus
  ),
  keybinding: [
    {
      primary: 2066,
      when: R.and(E.accessibleBufferFocus, De.negate()),
      weight: 200 + 2
    },
    {
      primary: 2066,
      mac: { primary: 530 },
      when: R.and(
        E.accessibleBufferFocus,
        De
      ),
      weight: 200 + 2
    }
  ],
  run: async (h) => {
    var t;
    const e = await h.service.getActiveOrCreateInstance();
    await h.service.revealActiveTerminal(), e && await ((t = ei.get(e)) == null ? void 0 : t.navigateToCommand("next"));
  }
});
ie({
  id: "workbench.action.terminal.accessibleBufferGoToPreviousCommand",
  title: { value: g(
    "workbench.action.terminal.accessibleBufferGoToPreviousCommand",
    "Accessible Buffer Go to Previous Command"
  ), original: "Accessible Buffer Go to Previous Command" },
  precondition: R.and(R.or(
    E.processSupported,
    E.terminalHasBeenCreated
  ), E.accessibleBufferFocus),
  keybinding: [
    {
      primary: 2064,
      when: R.and(E.accessibleBufferFocus, De.negate()),
      weight: 200 + 2
    },
    {
      primary: 2064,
      mac: { primary: 528 },
      when: R.and(
        E.accessibleBufferFocus,
        De
      ),
      weight: 200 + 2
    }
  ],
  run: async (h) => {
    var t;
    const e = await h.service.getActiveOrCreateInstance();
    await h.service.revealActiveTerminal(), e && await ((t = ei.get(e)) == null ? void 0 : t.navigateToCommand("previous"));
  }
});
class Pm {
  constructor() {
    this.getLatency = async () => [], this.isResponsive = !0, this._whenConnected = new ca(), this.restartPtyHost = _t, this.remoteAuthority = void 0, this.onPtyHostUnresponsive = be.None, this.onPtyHostResponsive = be.None, this.onPtyHostRestart = be.None, this.onDidRequestDetach = be.None, this.attachToProcess = _t, this.attachToRevivedProcess = _t, this.listProcesses = _t, this.getProfiles = async () => [], this.getWslPath = _t, this.getEnvironment = async () => ({}), this.getShellEnvironment = async () => {
    }, this.setTerminalLayoutInfo = async () => {
    }, this.updateTitle = async () => {
    }, this.updateIcon = async () => {
    }, this.getTerminalLayoutInfo = async () => {
    }, this.reduceConnectionGraceTime = _t, this.requestDetachInstance = _t, this.acceptDetachInstanceReply = _t, this.persistTerminalState = _t;
  }
  get whenReady() {
    return this._whenConnected.p;
  }
  setReady() {
    this._whenConnected.complete();
  }
  async getPerformanceMarks() {
    return [];
  }
}
class Rm {
  constructor(e, t, i, s) {
    this.id = e, this.pid = t, this.cwd = i, this.onData = s, this.onReady = new V(), this.shouldPersist = !1, this.onProcessData = this.onData, this.onProcessReady = this.onReady.event, this.onDidChangeProperty = be.None, this.onProcessExit = be.None, this.processBinary = _t, this.refreshProperty = async () => {
    }, setTimeout(() => {
      this.onReady.fire({
        cwd: i,
        pid: t,
        windowsPty: void 0
      });
    });
  }
  acknowledgeDataEvent() {
  }
  async setUnicodeVersion() {
  }
  async getInitialCwd() {
    return this.cwd;
  }
  async getCwd() {
    return this.cwd;
  }
  async getLatency() {
    return 0;
  }
  async updateProperty() {
  }
}
function Mm(h) {
  return Oe.as(Ki.Backend).registerTerminalBackend(h), {
    [we.toString()]: new We(Rt, [], !0),
    [Ot.toString()]: new We(yr, [], !0),
    [li.toString()]: new We(gr, [], !0),
    [Ae.toString()]: new We(Sr, [], !0),
    [yt.toString()]: new We(br, [], !0),
    [Bt.toString()]: new We(en, [], !0),
    [fa.toString()]: new We(Wh, [], !0),
    [Nh.toString()]: new We(lu, [], !0),
    [ii.toString()]: new We(Cr, [], !0),
    [oa.toString()]: new We(mi, [], !0),
    [Vh.toString()]: new We(hu, [], !0)
  };
}
export {
  Pm as SimpleTerminalBackend,
  Rm as SimpleTerminalProcess,
  Mm as default
};

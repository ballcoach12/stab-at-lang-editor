import { _ as I, a as h, ag as H, aE as x, B as c, aL as O, rg as Ga, rh as Ka, an as nr, r5 as T, ri as pl, U as ue, S as ft, rj as fl, rk as ja, rl as bl, pB as bt, iU as Xa, rm as Ri, N as ee, pT as Ya, cP as ae, bB as Ys, e as K, bW as We, ah as Yt, bE as or, bF as Jt, e_ as Js, D as Qt, E as B, rn as J, ro as ml, rp as Sl, rq as Ja, oO as wl, hQ as Je, eW as fe, bC as _e, aa as it, ls as vl, h as Le, g as rr, f as Qa, bU as Cl, rr as kl, rs as Gi, rt as yl, cM as Qe, au as L, w as te, jT as Za, ru as ec, L as Ze, fw as St, d as U, ao as Dl, dv as tc, dQ as Oi, m3 as Zi, pN as El, hf as Il, t as ic, rv as xl, rw as Tl, rx as ve, ry as Ce, rz as _l, q_ as Ll, rA as Kn, rB as jn, rC as sc, cx as st, a9 as Ct, bS as nc, rD as Xn, rE as Al, rF as Bl, rG as oc, aS as Ml, rH as rc, rI as ac, c9 as $e, aC as Zt, aI as we, bv as cc, aK as dc, aU as Nl, rJ as Rl, aX as ei, o as Ol, bc as oe, eh as Vl, rK as Pl, rL as Fl, oX as lc, kP as Rt, rM as Yn, rN as Wl, iZ as De, rO as Ul, l_ as Hl, fS as Ae, hC as $l, aP as Z, rP as zl, rQ as uc, rR as ar, rS as Te, rT as hc, rU as cr, rV as dr, rW as lr, rX as ur, rY as gc, rZ as nt, r_ as es, r$ as Yi, s0 as pc, s1 as fc, af as Ue, ac as hr, aJ as ql, oz as Gl, s2 as ts, c4 as Kl, s3 as jl, s4 as N, s5 as bc, s6 as F, s7 as ti, s8 as mc, s9 as Xl, sa as Qs, sb as Qr, sc as X, y as Sc, sd as Yl, se as Zr, ga as Jl, e7 as Ql, ph as Zl, sf as eu, sg as R, sh as tu, dq as ea, dr as ta, hR as iu, ax as ia, bD as Vi, eC as gr, n as ot, si as su, cF as rt, ae as ce, I as pr, gi as wc, hJ as ii, ad as at, sj as vc, sk as fr, sl as Cc, fO as Be, sm as si, sn as kc, so as yc, sp as Dc, sq as Ec, sr as br, H as E, u as Ic, ss as xc, st as Tc, su as vi, sv as nu, sw as ou, sx as Ci, hh as re, sy as _c, d7 as Lc, $ as ie, pk as Ac, sz as Zs, ab as Me, sA as ru, sB as ni, aZ as Bc, sC as M, bf as Oe, fi as au, c1 as cu, eK as du, aQ as In, aR as lu, dx as Mc, a0 as le, a2 as ne, a1 as Jn, k7 as uu, sD as hu, z as Nc, jg as sa, ho as mr, hq as Sr, sE as en, bi as tn, hH as kt, b8 as oi, de as Fe, b6 as sn, oF as gu, kH as pu, c$ as Ke, kr as fu, lf as bu, b4 as ki, sF as je, sG as na, sH as mu, sI as Su, sJ as z, sK as oa, sL as xn, sM as Ki, ck as wu, cl as vu, sN as Cu, sO as ku, V as yu, ef as Du, sP as Eu, cT as ht, aN as Ne, bM as he, aG as k, dE as Iu, J as Rc, b5 as nn, cZ as xu, sQ as ra, fz as Tu, sR as _u, ds as Qn, sS as Lu, da as Au, db as Bu, x as Mu, G as Nu, b$ as aa, sT as Ru, bO as Ou, sU as Vu, sV as Oc, ai as ge, sW as ct, sX as G, sY as Vc, sZ as yt, s_ as wr, s$ as Pu, dl as Ot, hT as Pi, t0 as Fu, bZ as ri, t1 as Pc, t2 as Fc, t3 as fi, hv as Wu, cs as Wc, t4 as Uc, aj as Fi, t5 as pe, t6 as Hc, t7 as Vt, t8 as ca, du as Uu, t9 as de, fH as Hu, ta as on, tb as $c, e0 as vr, kS as $u, kC as is, tc as zu, bz as dt, cO as ai, av as Cr, cR as kr, dj as qu, td as Zn, di as rn, te as Gu, tf as eo, tg as zc, th as qc, ti as Ku, tj as an, tk as cn, tl as dn, tm as da, c_ as ju, cG as Xu, tn as Yu, to as Ju, b9 as Gc, kM as Qu, tp as Zu, p2 as eh, tq as th, pM as Kc, tr as la, l5 as jc, kN as ua, ts as ih, tt as ha, tu as ga, tv as sh, tw as nh, jv as oh, tx as pa, aH as Xc, ar as Wi, ty as Yc, aF as rh, aA as Jc, tz as ah, tA as Qc, dP as ch, tB as Zc, tC as fa, tD as dh, eM as lh, tE as uh, jw as ed, tF as hh, b as td, tG as ba, l2 as gh, fd as ph, bm as fh, tH as bh, bK as Tn, tI as mh, dg as Sh, tJ as wh, hV as vh, tK as Ch, tL as to, tM as ma, tN as kh, tO as yh, tP as Dh, tQ as Eh, tR as Ih, tS as id, tT as xh, cC as Th, tU as _h, l as Lh, tV as Ah, tW as Bh, d0 as Mh, tX as Nh, tY as ln, tZ as Rh, t_ as Oh, ka as _n, kd as ji, ji as Vh, t$ as et, u0 as yr, u1 as Ph, u2 as Sa, hM as ci, mt as sd, hu as Dr, u3 as Ln, k as Se, u4 as Fh, eT as Wh, j5 as Uh, hY as Hh, li as $h } from "./index-4b7b8e94.js";
import { d as nd, E as yi, M as zh, S as Ji, T as Ve, D as ss, a as od, B as rd, F as ad, b as qh, c as cd, e as Y, f as Gh, g as ns, I as Qi, h as Er, i as An, j as Kh, k as Di, l as os, m as rs, n as dd, V as q, o as ld, A as ud, p as as, q as Pt, r as Xe, s as cs, t as io, u as ds, v as bi, w as mi, x as ls, y as so, z as no, C as un, G as hn, P as gn, H as pn, J as lt, K as Ui, L as di, N as He, O as fn, Q as bn, R as mn, U as Sn, W as wn, X as vn, Y as jh, Z as Xh, _ as hd, $ as gd, a0 as Yh, a1 as Ir, a2 as xr, a3 as Tr, a4 as Jh, a5 as Qh, a6 as ye, a7 as Ei, a8 as pd, a9 as Cn, aa as Zh, ab as eg, ac as tg, ad as fd, ae as bd, af as ig, ag as _r, ah as sg, ai as ng, aj as og, ak as rg, al as ag, am as cg, an as md, ao as Sd, ap as dg, aq as lg, ar as ug, as as wd, at as vd, au as hg, av as gg, aw as pg, ax as fg, ay as bg, az as mg, aA as Sg, aB as wg, aC as vg, aD as Cg, aE as kg, aF as yg, aG as Dg, aH as Eg, aI as Ig, aJ as Cd, aK as xg, aL as Tg, aM as _g, aN as Lg, aO as Ag, aP as Bg, aQ as Mg, aR as Ng, aS as Rg, aT as Og, aU as Vg, aV as Pg, aW as Fg, aX as Wg, aY as Ug, aZ as Hg, a_ as $g, a$ as kd, b0 as zg } from "./debugCommands-5995116a.js";
import { M as wa } from "./markers-5db92049.js";
import { D as qg } from "./dropdownWithPrimaryActionViewItem-a70537db.js";
let oo = class {
  constructor(e, t) {
    this.breakpointContribution = e, this.contextKeyService = t, this.breakpointsWhen = typeof e.when == "string" ? x.deserialize(e.when) : void 0;
  }
  get language() {
    return this.breakpointContribution.language;
  }
  get enabled() {
    return !this.breakpointsWhen || this.contextKeyService.contextMatchesRules(this.breakpointsWhen);
  }
};
oo = I([
  h(1, H)
], oo);
function Gg(l) {
  l.pattern = l.pattern || "^(?!.*\\$\\{(env|config|command)\\.)", l.patternErrorMessage = l.patternErrorMessage || c(
    "deprecatedVariables",
    "'env.', 'config.' and 'command.' are deprecated, use 'env:', 'config:' and 'command:' instead."
  );
}
let ro = class {
  constructor(e, t, i, s, n, o, r, a, d) {
    this.adapterManager = e, this.configurationService = s, this.resourcePropertiesService = n, this.configurationResolverService = o, this.environmentService = r, this.debugService = a, this.contextKeyService = d, this.mergedExtensionDescriptions = [], this.debuggerContribution = { type: t.type }, this.merge(t, i), this.debuggerWhen = typeof this.debuggerContribution.when == "string" ? x.deserialize(this.debuggerContribution.when) : void 0;
  }
  merge(e, t) {
    function i(s, n, o, r = 0) {
      return bt(s) ? (bt(n) && Object.keys(n).forEach((a) => {
        a !== "__proto__" && (bt(s[a]) && bt(n[a]) ? i(s[a], n[a], o, r + 1) : a in s ? o && (r === 0 && a === "type" || (s[a] = n[a])) : s[a] = n[a]);
      }), s) : n;
    }
    this.mergedExtensionDescriptions.indexOf(t) < 0 && (this.mergedExtensionDescriptions.push(t), i(this.debuggerContribution, e, t.isBuiltin), pl(e) && (this.mainExtensionDescription = t));
  }
  async startDebugging(e, t) {
    const i = this.debugService.getModel().getSession(t);
    return await this.debugService.startDebugging(void 0, e, { parentSession: i }, void 0);
  }
  async createDebugAdapter(e) {
    await this.adapterManager.activateDebuggers("onDebugAdapterProtocolTracker", this.type);
    const t = this.adapterManager.createDebugAdapter(e);
    if (t)
      return Promise.resolve(t);
    throw new Error(c("cannot.find.da", "Cannot find debug adapter for type '{0}'.", this.type));
  }
  async substituteVariables(e, t) {
    const i = await this.adapterManager.substituteVariables(this.type, e, t);
    return await this.configurationResolverService.resolveWithInteractionReplace(e, i, "launch", this.variables, i.__configurationTarget);
  }
  runInTerminal(e, t) {
    return this.adapterManager.runInTerminal(this.type, e, t);
  }
  get label() {
    return this.debuggerContribution.label || this.debuggerContribution.type;
  }
  get type() {
    return this.debuggerContribution.type;
  }
  get variables() {
    return this.debuggerContribution.variables;
  }
  get configurationSnippets() {
    return this.debuggerContribution.configurationSnippets;
  }
  get languages() {
    return this.debuggerContribution.languages;
  }
  get when() {
    return this.debuggerWhen;
  }
  get enabled() {
    return !this.debuggerWhen || this.contextKeyService.contextMatchesRules(this.debuggerWhen);
  }
  get strings() {
    return this.debuggerContribution.strings ?? this.debuggerContribution.uiMessages;
  }
  interestedInLanguage(e) {
    return !!(this.languages && this.languages.indexOf(e) >= 0);
  }
  hasInitialConfiguration() {
    return !!this.debuggerContribution.initialConfigurations;
  }
  hasConfigurationProvider() {
    return this.debugService.getConfigurationManager().hasDebugConfigurationProvider(this.type);
  }
  getInitialConfigurationContent(e) {
    let t = this.debuggerContribution.initialConfigurations || [];
    e && (t = t.concat(e));
    const i = this.resourcePropertiesService.getEOL(ue.from({ scheme: ft.untitled, path: "1" })) === `\r
` ? `\r
` : `
`, s = JSON.stringify(t, null, "	").split(`
`).map((u) => "	" + u).join(i).trim(), n = c(
      "launch.config.comment1",
      "Use IntelliSense to learn about possible attributes."
    ), o = c(
      "launch.config.comment2",
      "Hover to view descriptions of existing attributes."
    ), r = c(
      "launch.config.comment3",
      "For more information, visit: {0}",
      "https://go.microsoft.com/fwlink/?linkid=830387"
    );
    let a = [
      "{",
      `	// ${n}`,
      `	// ${o}`,
      `	// ${r}`,
      '	"version": "0.2.0",',
      `	"configurations": ${s}`,
      "}"
    ].join(i);
    const d = this.configurationService.getValue();
    return d.editor && d.editor.insertSpaces && (a = a.replace(new RegExp("	", "g"), " ".repeat(d.editor.tabSize))), Promise.resolve(a);
  }
  getMainExtensionDescriptor() {
    return this.mainExtensionDescription || this.mergedExtensionDescriptions[0];
  }
  getCustomTelemetryEndpoint() {
    const e = this.debuggerContribution.aiKey;
    if (!e)
      return;
    const t = fl(this.environmentService.remoteAuthority) !== "other";
    return {
      id: `${this.getMainExtensionDescriptor().publisher}.${this.type}`,
      aiKey: e,
      sendErrorTelemetry: t
    };
  }
  getSchemaAttributes(e) {
    return this.debuggerContribution.configurationAttributes ? Object.keys(this.debuggerContribution.configurationAttributes).map((t) => {
      const i = `${this.type}:${t}`, s = `${this.type}:${t}:platform`, n = this.debuggerContribution.configurationAttributes[t], o = ["name", "type", "request"];
      n.required = n.required && n.required.length ? o.concat(n.required) : o, n.additionalProperties = !1, n.type = "object", n.properties || (n.properties = {});
      const r = n.properties;
      r.type = {
        enum: [this.type],
        enumDescriptions: [this.label],
        description: c("debugType", "Type of configuration."),
        pattern: "^(?!node2)",
        deprecationMessage: this.debuggerContribution.deprecated || (this.enabled ? void 0 : ja(this.type)),
        doNotSuggest: !!this.debuggerContribution.deprecated,
        errorMessage: c(
          "debugTypeNotRecognised",
          "The debug type is not recognized. Make sure that you have a corresponding debug extension installed and that it is enabled."
        ),
        patternErrorMessage: c(
          "node2NotSupported",
          '"node2" is no longer supported, use "node" instead and set the "protocol" attribute to "inspector".'
        )
      }, r.request = {
        enum: [t],
        description: c(
          "debugRequest",
          'Request type of configuration. Can be "launch" or "attach".'
        )
      };
      for (const d in e.common.properties)
        r[d] = {
          $ref: `#/definitions/common/properties/${d}`
        };
      Object.keys(r).forEach((d) => {
        Gg(r[d]);
      }), e[i] = { ...n }, e[s] = {
        type: "object",
        additionalProperties: !1,
        properties: bl(r, (d) => d !== "type" && d !== "request" && d !== "name")
      };
      const a = { ...n };
      return a.properties = {
        ...r,
        windows: {
          $ref: `#/definitions/${s}`,
          description: c(
            "debugWindowsConfiguration",
            "Windows specific launch configuration attributes."
          )
        },
        osx: {
          $ref: `#/definitions/${s}`,
          description: c("debugOSXConfiguration", "OS X specific launch configuration attributes.")
        },
        linux: {
          $ref: `#/definitions/${s}`,
          description: c(
            "debugLinuxConfiguration",
            "Linux specific launch configuration attributes."
          )
        }
      }, a;
    }) : null;
  }
};
ro = I([
  h(3, O),
  h(4, Ga),
  h(5, Ka),
  h(6, nr),
  h(7, T),
  h(8, H)
], ro);
const Bn = c(
  "JsonSchema.input.id",
  "The input's id is used to associate an input with a variable of the form ${input:id}."
), Mn = c("JsonSchema.input.type", "The type of user input prompt to use."), va = c(
  "JsonSchema.input.description",
  "The description is shown when the user is prompted for input."
), Ca = c("JsonSchema.input.default", "The default value for the input."), Kg = {
  definitions: {
    inputs: {
      type: "array",
      description: c(
        "JsonSchema.inputs",
        "User inputs. Used for defining user input prompts, such as free string input or a choice from several options."
      ),
      items: {
        oneOf: [
          {
            type: "object",
            required: ["id", "type", "description"],
            additionalProperties: !1,
            properties: {
              id: {
                type: "string",
                description: Bn
              },
              type: {
                type: "string",
                description: Mn,
                enum: ["promptString"],
                enumDescriptions: [
                  c(
                    "JsonSchema.input.type.promptString",
                    "The 'promptString' type opens an input box to ask the user for input."
                  )
                ]
              },
              description: {
                type: "string",
                description: va
              },
              default: {
                type: "string",
                description: Ca
              },
              password: {
                type: "boolean",
                description: c(
                  "JsonSchema.input.password",
                  "Controls if a password input is shown. Password input hides the typed text."
                )
              }
            }
          },
          {
            type: "object",
            required: ["id", "type", "description", "options"],
            additionalProperties: !1,
            properties: {
              id: {
                type: "string",
                description: Bn
              },
              type: {
                type: "string",
                description: Mn,
                enum: ["pickString"],
                enumDescriptions: [
                  c(
                    "JsonSchema.input.type.pickString",
                    "The 'pickString' type shows a selection list."
                  )
                ]
              },
              description: {
                type: "string",
                description: va
              },
              default: {
                type: "string",
                description: Ca
              },
              options: {
                type: "array",
                description: c(
                  "JsonSchema.input.options",
                  "An array of strings that defines the options for a quick pick."
                ),
                items: {
                  oneOf: [
                    {
                      type: "string"
                    },
                    {
                      type: "object",
                      required: ["value"],
                      additionalProperties: !1,
                      properties: {
                        label: {
                          type: "string",
                          description: c("JsonSchema.input.pickString.optionLabel", "Label for the option.")
                        },
                        value: {
                          type: "string",
                          description: c("JsonSchema.input.pickString.optionValue", "Value for the option.")
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          {
            type: "object",
            required: ["id", "type", "command"],
            additionalProperties: !1,
            properties: {
              id: {
                type: "string",
                description: Bn
              },
              type: {
                type: "string",
                description: Mn,
                enum: ["command"],
                enumDescriptions: [
                  c("JsonSchema.input.type.command", "The 'command' type executes a command.")
                ]
              },
              command: {
                type: "string",
                description: c(
                  "JsonSchema.input.command.command",
                  "The command to execute for this input variable."
                )
              },
              args: {
                oneOf: [
                  {
                    type: "object",
                    description: c(
                      "JsonSchema.input.command.args",
                      "Optional arguments passed to the command."
                    )
                  },
                  {
                    type: "array",
                    description: c(
                      "JsonSchema.input.command.args",
                      "Optional arguments passed to the command."
                    )
                  },
                  {
                    type: "string",
                    description: c(
                      "JsonSchema.input.command.args",
                      "Optional arguments passed to the command."
                    )
                  }
                ]
              }
            }
          }
        ]
      }
    }
  }
}, jg = Xa.registerExtensionPoint({
  extensionPoint: "debuggers",
  defaultExtensionKind: ["workspace"],
  jsonSchema: {
    description: c("vscode.extension.contributes.debuggers", "Contributes debug adapters."),
    type: "array",
    defaultSnippets: [{ body: [{ type: "" }] }],
    items: {
      additionalProperties: !1,
      type: "object",
      defaultSnippets: [{ body: { type: "", program: "", runtime: "" } }],
      properties: {
        type: {
          description: c(
            "vscode.extension.contributes.debuggers.type",
            "Unique identifier for this debug adapter."
          ),
          type: "string"
        },
        label: {
          description: c(
            "vscode.extension.contributes.debuggers.label",
            "Display name for this debug adapter."
          ),
          type: "string"
        },
        program: {
          description: c(
            "vscode.extension.contributes.debuggers.program",
            "Path to the debug adapter program. Path is either absolute or relative to the extension folder."
          ),
          type: "string"
        },
        args: {
          description: c(
            "vscode.extension.contributes.debuggers.args",
            "Optional arguments to pass to the adapter."
          ),
          type: "array"
        },
        runtime: {
          description: c(
            "vscode.extension.contributes.debuggers.runtime",
            "Optional runtime in case the program attribute is not an executable but requires a runtime."
          ),
          type: "string"
        },
        runtimeArgs: {
          description: c(
            "vscode.extension.contributes.debuggers.runtimeArgs",
            "Optional runtime arguments."
          ),
          type: "array"
        },
        variables: {
          description: c(
            "vscode.extension.contributes.debuggers.variables",
            "Mapping from interactive variables (e.g. ${action.pickProcess}) in `launch.json` to a command."
          ),
          type: "object"
        },
        initialConfigurations: {
          description: c(
            "vscode.extension.contributes.debuggers.initialConfigurations",
            "Configurations for generating the initial 'launch.json'."
          ),
          type: ["array", "string"]
        },
        languages: {
          description: c(
            "vscode.extension.contributes.debuggers.languages",
            'List of languages for which the debug extension could be considered the "default debugger".'
          ),
          type: "array"
        },
        configurationSnippets: {
          description: c(
            "vscode.extension.contributes.debuggers.configurationSnippets",
            "Snippets for adding new configurations in 'launch.json'."
          ),
          type: "array"
        },
        configurationAttributes: {
          description: c(
            "vscode.extension.contributes.debuggers.configurationAttributes",
            "JSON schema configurations for validating 'launch.json'."
          ),
          type: "object"
        },
        when: {
          description: c(
            "vscode.extension.contributes.debuggers.when",
            "Condition which must be true to enable this type of debugger. Consider using 'shellExecutionSupported', 'virtualWorkspace', 'resourceScheme' or an extension-defined context key as appropriate for this."
          ),
          type: "string",
          default: ""
        },
        deprecated: {
          description: c(
            "vscode.extension.contributes.debuggers.deprecated",
            "Optional message to mark this debug type as being deprecated."
          ),
          type: "string",
          default: ""
        },
        windows: {
          description: c(
            "vscode.extension.contributes.debuggers.windows",
            "Windows specific settings."
          ),
          type: "object",
          properties: {
            runtime: {
              description: c(
                "vscode.extension.contributes.debuggers.windows.runtime",
                "Runtime used for Windows."
              ),
              type: "string"
            }
          }
        },
        osx: {
          description: c("vscode.extension.contributes.debuggers.osx", "macOS specific settings."),
          type: "object",
          properties: {
            runtime: {
              description: c(
                "vscode.extension.contributes.debuggers.osx.runtime",
                "Runtime used for macOS."
              ),
              type: "string"
            }
          }
        },
        linux: {
          description: c("vscode.extension.contributes.debuggers.linux", "Linux specific settings."),
          type: "object",
          properties: {
            runtime: {
              description: c(
                "vscode.extension.contributes.debuggers.linux.runtime",
                "Runtime used for Linux."
              ),
              type: "string"
            }
          }
        },
        strings: {
          description: c(
            "vscode.extension.contributes.debuggers.strings",
            "UI strings contributed by this debug adapter."
          ),
          type: "object",
          properties: {
            unverifiedBreakpoints: {
              description: c(
                "vscode.extension.contributes.debuggers.strings.unverifiedBreakpoints",
                "When there are unverified breakpoints in a language supported by this debug adapter, this message will appear on the breakpoint hover and in the breakpoints view. Markdown and command links are supported."
              ),
              type: "string"
            }
          }
        }
      }
    }
  }
}), Xg = Xa.registerExtensionPoint({
  extensionPoint: "breakpoints",
  jsonSchema: {
    description: c("vscode.extension.contributes.breakpoints", "Contributes breakpoints."),
    type: "array",
    defaultSnippets: [{ body: [{ language: "" }] }],
    items: {
      type: "object",
      additionalProperties: !1,
      defaultSnippets: [{ body: { language: "" } }],
      properties: {
        language: {
          description: c(
            "vscode.extension.contributes.breakpoints.language",
            "Allow breakpoints for this language."
          ),
          type: "string"
        },
        when: {
          description: c(
            "vscode.extension.contributes.breakpoints.when",
            "Condition which must be true to enable breakpoints in this language. Consider matching this to the debugger when clause as appropriate."
          ),
          type: "string",
          default: ""
        }
      }
    }
  }
}), yd = {
  type: "object",
  description: c(
    "presentation",
    "Presentation options on how to show this configuration in the debug configuration dropdown and the command palette."
  ),
  properties: {
    hidden: {
      type: "boolean",
      default: !1,
      description: c(
        "presentation.hidden",
        "Controls if this configuration should be shown in the configuration dropdown and the command palette."
      )
    },
    group: {
      type: "string",
      default: "",
      description: c(
        "presentation.group",
        "Group that this configuration belongs to. Used for grouping and sorting in the configuration dropdown and the command palette."
      )
    },
    order: {
      type: "number",
      default: 1,
      description: c(
        "presentation.order",
        "Order of this configuration within a group. Used for grouping and sorting in the configuration dropdown and the command palette."
      )
    }
  },
  default: {
    hidden: !1,
    group: "",
    order: 1
  }
}, ka = { name: "Compound", configurations: [] }, Nt = {
  id: Ri,
  type: "object",
  title: c("app.launch.json.title", "Launch"),
  allowTrailingCommas: !0,
  allowComments: !0,
  required: [],
  default: { version: "0.2.0", configurations: [], compounds: [] },
  properties: {
    version: {
      type: "string",
      description: c("app.launch.json.version", "Version of this file format."),
      default: "0.2.0"
    },
    configurations: {
      type: "array",
      description: c(
        "app.launch.json.configurations",
        "List of configurations. Add new configurations or edit existing ones by using IntelliSense."
      ),
      items: {
        defaultSnippets: [],
        type: "object",
        oneOf: []
      }
    },
    compounds: {
      type: "array",
      description: c(
        "app.launch.json.compounds",
        "List of compounds. Each compound references multiple configurations which will get launched together."
      ),
      items: {
        type: "object",
        required: ["name", "configurations"],
        properties: {
          name: {
            type: "string",
            description: c(
              "app.launch.json.compound.name",
              "Name of compound. Appears in the launch configuration drop down menu."
            )
          },
          presentation: yd,
          configurations: {
            type: "array",
            default: [],
            items: {
              oneOf: [{
                enum: [],
                description: c("useUniqueNames", "Please use unique configuration names.")
              }, {
                type: "object",
                required: ["name"],
                properties: {
                  name: {
                    enum: [],
                    description: c(
                      "app.launch.json.compound.name",
                      "Name of compound. Appears in the launch configuration drop down menu."
                    )
                  },
                  folder: {
                    enum: [],
                    description: c(
                      "app.launch.json.compound.folder",
                      "Name of folder in which the compound is located."
                    )
                  }
                }
              }]
            },
            description: c(
              "app.launch.json.compounds.configurations",
              "Names of configurations that will be started as part of this compound."
            )
          },
          stopAll: {
            type: "boolean",
            default: !1,
            description: c(
              "app.launch.json.compound.stopAll",
              "Controls whether manually terminating one session will stop all of the compound sessions."
            )
          },
          preLaunchTask: {
            type: "string",
            default: "",
            description: c(
              "compoundPrelaunchTask",
              "Task to run before any of the compound configurations start."
            )
          }
        },
        default: ka
      },
      default: [
        ka
      ]
    },
    inputs: Kg.definitions.inputs
  }
}, Yg = ee.as(Ya.JSONContribution);
let ao = class extends Qt {
  constructor(e, t, i, s, n, o, r, a, d, u, g) {
    super(), this.editorService = t, this.configurationService = i, this.quickInputService = s, this.instantiationService = n, this.commandService = o, this.extensionService = r, this.contextKeyService = a, this.languageService = d, this.dialogService = u, this.lifecycleService = g, this.debugAdapterFactories = /* @__PURE__ */ new Map(), this._onDidRegisterDebugger = new B(), this._onDidDebuggersExtPointRead = new B(), this.breakpointContributions = [], this.debuggerWhenKeys = /* @__PURE__ */ new Set(), this.usedDebugTypes = /* @__PURE__ */ new Set(), this.adapterDescriptorFactories = [], this.debuggers = [], this.registerListeners(), this.contextKeyService.bufferChangeEvents(() => {
      this.debuggersAvailable = J.bindTo(a), this.debugExtensionsAvailable = ml.bindTo(a);
    }), this._register(this.contextKeyService.onDidChangeContext((p) => {
      p.affectsSome(this.debuggerWhenKeys) && (this.debuggersAvailable.set(this.hasEnabledDebuggers()), this.updateDebugAdapterSchema());
    })), this._register(this.onDidDebuggersExtPointRead(() => {
      this.debugExtensionsAvailable.set(this.debuggers.length > 0);
    })), this.lifecycleService.when(4).then(() => this.debugExtensionsAvailable.set(this.debuggers.length > 0)), this._register(e.onDidNewSession((p) => {
      this.usedDebugTypes.add(p.configuration.type);
    }));
  }
  registerListeners() {
    jg.setHandler((e, t) => {
      t.added.forEach((i) => {
        i.value.forEach((s) => {
          var n;
          if ((!s.type || typeof s.type != "string") && i.collector.error(c(
            "debugNoType",
            "Debugger 'type' can not be omitted and must be of type 'string'."
          )), s.type !== "*") {
            const o = this.getDebugger(s.type);
            if (o)
              o.merge(s, i.description);
            else {
              const r = this.instantiationService.createInstance(ro, this, s, i.description);
              (n = r.when) == null || n.keys().forEach((a) => this.debuggerWhenKeys.add(a)), this.debuggers.push(r);
            }
          }
        });
      }), e.forEach((i) => {
        i.value.forEach((s) => {
          s.type === "*" && this.debuggers.forEach((n) => n.merge(s, i.description));
        });
      }), t.removed.forEach((i) => {
        const s = i.value.map((n) => n.type);
        this.debuggers = this.debuggers.filter((n) => s.indexOf(n.type) === -1);
      }), this.updateDebugAdapterSchema(), this._onDidDebuggersExtPointRead.fire();
    }), Xg.setHandler((e) => {
      this.breakpointContributions = e.flatMap((t) => t.value.map(
        (i) => this.instantiationService.createInstance(oo, i)
      ));
    });
  }
  updateDebugAdapterSchema() {
    const e = Nt.properties.configurations.items, t = Sl.getJsonSchema(), i = {
      common: {
        properties: {
          name: {
            type: "string",
            description: c(
              "debugName",
              "Name of configuration; appears in the launch configuration dropdown menu."
            ),
            default: "Launch"
          },
          debugServer: {
            type: "number",
            description: c(
              "debugServer",
              "For debug extension development only: if a port is specified VS Code tries to connect to a debug adapter running in server mode"
            ),
            default: 4711
          },
          preLaunchTask: {
            anyOf: [t, {
              type: ["string"]
            }],
            default: "",
            defaultSnippets: [{ body: { task: "", type: "" } }],
            description: c("debugPrelaunchTask", "Task to run before debug session starts.")
          },
          postDebugTask: {
            anyOf: [t, {
              type: ["string"]
            }],
            default: "",
            defaultSnippets: [{ body: { task: "", type: "" } }],
            description: c("debugPostDebugTask", "Task to run after debug session ends.")
          },
          presentation: yd,
          internalConsoleOptions: Ja,
          suppressMultipleSessionWarning: {
            type: "boolean",
            description: c(
              "suppressMultipleSessionWarning",
              "Disable the warning when trying to start the same debug configuration more than once."
            ),
            default: !0
          }
        }
      }
    };
    Nt.definitions = i, e.oneOf = [], e.defaultSnippets = [], this.debuggers.forEach((s) => {
      const n = s.getSchemaAttributes(i);
      n && e.oneOf && e.oneOf.push(...n);
      const o = s.configurationSnippets;
      o && e.defaultSnippets && e.defaultSnippets.push(...o);
    }), Yg.registerSchema(Ri, Nt);
  }
  registerDebugAdapterFactory(e, t) {
    return e.forEach((i) => this.debugAdapterFactories.set(i, t)), this.debuggersAvailable.set(this.hasEnabledDebuggers()), this._onDidRegisterDebugger.fire(), {
      dispose: () => {
        e.forEach((i) => this.debugAdapterFactories.delete(i));
      }
    };
  }
  hasEnabledDebuggers() {
    for (const [e] of this.debugAdapterFactories) {
      const t = this.getDebugger(e);
      if (t && t.enabled)
        return !0;
    }
    return !1;
  }
  createDebugAdapter(e) {
    const t = this.debugAdapterFactories.get(e.configuration.type);
    if (t)
      return t.createDebugAdapter(e);
  }
  substituteVariables(e, t, i) {
    const s = this.debugAdapterFactories.get(e);
    return s ? s.substituteVariables(t, i) : Promise.resolve(i);
  }
  runInTerminal(e, t, i) {
    const s = this.debugAdapterFactories.get(e);
    return s ? s.runInTerminal(t, i) : Promise.resolve(void 0);
  }
  registerDebugAdapterDescriptorFactory(e) {
    return this.adapterDescriptorFactories.push(e), {
      dispose: () => {
        this.unregisterDebugAdapterDescriptorFactory(e);
      }
    };
  }
  unregisterDebugAdapterDescriptorFactory(e) {
    const t = this.adapterDescriptorFactories.indexOf(e);
    t >= 0 && this.adapterDescriptorFactories.splice(t, 1);
  }
  getDebugAdapterDescriptor(e) {
    const t = e.configuration, i = this.adapterDescriptorFactories.filter((s) => s.type === t.type && s.createDebugAdapterDescriptor);
    return i.length === 1 ? i[0].createDebugAdapterDescriptor(e) : Promise.resolve(void 0);
  }
  getDebuggerLabel(e) {
    const t = this.getDebugger(e);
    if (t)
      return t.label;
  }
  get onDidRegisterDebugger() {
    return this._onDidRegisterDebugger.event;
  }
  get onDidDebuggersExtPointRead() {
    return this._onDidDebuggersExtPointRead.event;
  }
  canSetBreakpointsIn(e) {
    const t = e.getLanguageId();
    return !t || t === "jsonc" || t === "log" ? !1 : this.configurationService.getValue("debug").allowBreakpointsEverywhere ? !0 : this.breakpointContributions.some((i) => i.language === t && i.enabled);
  }
  getDebugger(e) {
    return this.debuggers.find((t) => wl(t.type, e));
  }
  getEnabledDebugger(e) {
    const t = this.getDebugger(e);
    return t && t.enabled ? t : void 0;
  }
  someDebuggerInterestedInLanguage(e) {
    return !!this.debuggers.filter((t) => t.enabled).find((t) => t.interestedInLanguage(e));
  }
  async guessDebugger(e) {
    const t = this.editorService.activeTextEditorControl;
    let i = [], s = null, n = null;
    if (Je(t)) {
      n = t.getModel();
      const u = n ? n.getLanguageId() : void 0;
      u && (s = this.languageService.getLanguageName(u));
      const g = this.debuggers.filter((p) => p.enabled).filter((p) => u && p.interestedInLanguage(u));
      if (g.length === 1)
        return g[0];
      g.length > 1 && (i = g);
    }
    if ((!s || e || n && this.canSetBreakpointsIn(n)) && i.length === 0 && (await this.activateDebuggers("onDebugInitialConfigurations"), i = this.debuggers.filter((u) => u.enabled).filter((u) => u.hasInitialConfiguration() || u.hasConfigurationProvider())), i.length === 0 && s) {
      s.indexOf(" ") >= 0 && (s = `'${s}'`);
      const { confirmed: u } = await this.dialogService.confirm({
        type: fe.Warning,
        message: c(
          "CouldNotFindLanguage",
          "You don't have an extension for debugging {0}. Should we find a {0} extension in the Marketplace?",
          s
        ),
        primaryButton: c(
          { key: "findExtension", comment: ["&& denotes a mnemonic"] },
          "&&Find {0} extension",
          s
        )
      });
      u && await this.commandService.executeCommand("debug.installAdditionalDebuggers", s);
      return;
    }
    this.initExtensionActivationsIfNeeded(), i.sort((u, g) => u.label.localeCompare(g.label));
    const o = [], r = [];
    i.forEach((u) => {
      var p;
      const g = u.getMainExtensionDescriptor();
      g.id && ((p = this.earlyActivatedExtensions) != null && p.has(g.id)) || this.usedDebugTypes.has(u.type) ? o.push(u) : r.push(u);
    });
    const a = [];
    o.length > 0 && a.push({ type: "separator", label: c("suggestedDebuggers", "Suggested") }, ...o.map((u) => ({ label: u.label, debugger: u }))), r.length > 0 && (a.length > 0 && a.push({ type: "separator", label: "" }), a.push(...r.map((u) => ({ label: u.label, debugger: u })))), a.push({ type: "separator", label: "" }, { label: s ? c("installLanguage", "Install an extension for {0}...", s) : c("installExt", "Install extension...") });
    const d = c("selectDebug", "Select debugger");
    return this.quickInputService.pick(a, { activeItem: a[0], placeHolder: d }).then((u) => {
      if (u && u.debugger)
        return u.debugger;
      u && this.commandService.executeCommand("debug.installAdditionalDebuggers", s);
    });
  }
  initExtensionActivationsIfNeeded() {
    if (!this.earlyActivatedExtensions) {
      this.earlyActivatedExtensions = /* @__PURE__ */ new Set();
      const e = this.extensionService.getExtensionsStatus();
      for (const t in e)
        e[t].activationTimes && this.earlyActivatedExtensions.add(t);
    }
  }
  async activateDebuggers(e, t) {
    this.initExtensionActivationsIfNeeded();
    const i = [
      this.extensionService.activateByEvent(e),
      this.extensionService.activateByEvent("onDebug")
    ];
    t && i.push(this.extensionService.activateByEvent(`${e}:${t}`)), await Promise.all(i);
  }
};
ao = I([
  h(1, ae),
  h(2, O),
  h(3, Ys),
  h(4, K),
  h(5, We),
  h(6, Yt),
  h(7, H),
  h(8, or),
  h(9, Jt),
  h(10, Js)
], ao);
const Dd = ee.as(Ya.JSONContribution);
Dd.registerSchema(Ri, Nt);
const Nn = "debug.selectedconfigname", Rn = "debug.selectedroot", ya = "debug.selectedtype", On = "debug.recentdynamicconfigurations";
let co = class {
  constructor(e, t, i, s, n, o, r, a, d, u) {
    this.adapterManager = e, this.contextService = t, this.configurationService = i, this.quickInputService = s, this.instantiationService = n, this.storageService = o, this.extensionService = r, this.historyService = a, this.uriIdentityService = d, this.getSelectedConfig = () => Promise.resolve(void 0), this.selectedDynamic = !1, this._onDidSelectConfigurationName = new B(), this.configProviders = [], this.toDispose = [], this.initLaunches(), this.setCompoundSchemaValues(), this.registerListeners();
    const g = this.storageService.get(Rn, 1), p = this.storageService.get(ya, 1), f = this.launches.find((m) => m.uri.toString() === g), S = this.storageService.get(Nn, 1);
    this.debugConfigurationTypeContext = kl.bindTo(u);
    const w = p ? { type: p } : void 0;
    f && f.getConfigurationNames().length ? this.selectConfiguration(f, S, void 0, w) : this.launches.length > 0 && this.selectConfiguration(void 0, S, void 0, w);
  }
  registerDebugConfigurationProvider(e) {
    return this.configProviders.push(e), {
      dispose: () => {
        this.unregisterDebugConfigurationProvider(e);
      }
    };
  }
  unregisterDebugConfigurationProvider(e) {
    const t = this.configProviders.indexOf(e);
    t >= 0 && this.configProviders.splice(t, 1);
  }
  hasDebugConfigurationProvider(e, t) {
    return t === void 0 && (t = Gi.Initial), !!this.configProviders.find((s) => s.provideDebugConfigurations && s.type === e && s.triggerKind === t);
  }
  async resolveConfigurationByProviders(e, t, i, s) {
    const n = async (a, d) => {
      a !== "*" && await this.adapterManager.activateDebuggers("onDebugResolve", a);
      for (const u of this.configProviders)
        u.type === a && u.resolveDebugConfiguration && d && (d = await u.resolveDebugConfiguration(e, d, s));
      return d;
    };
    let o = i.type ?? t, r = i;
    for (let a = /* @__PURE__ */ new Set(); r && !a.has(o); )
      a.add(o), r = await n(o, r), r = await n("*", r), o = (r == null ? void 0 : r.type) ?? t;
    return r;
  }
  async resolveDebugConfigurationWithSubstitutedVariables(e, t, i, s) {
    const n = this.configProviders.filter((r) => r.type === t && r.resolveDebugConfigurationWithSubstitutedVariables).concat(this.configProviders.filter((r) => r.type === "*" && r.resolveDebugConfigurationWithSubstitutedVariables));
    let o = i;
    return await yl(n.map((r) => async () => {
      o && (o = await r.resolveDebugConfigurationWithSubstitutedVariables(e, o, s));
    })), o;
  }
  async provideDebugConfigurations(e, t, i) {
    return await this.adapterManager.activateDebuggers("onDebugInitialConfigurations"), (await Promise.all(this.configProviders.filter((n) => n.type === t && n.triggerKind === Gi.Initial && n.provideDebugConfigurations).map((n) => n.provideDebugConfigurations(e, i)))).reduce((n, o) => n.concat(o), []);
  }
  async getDynamicProviders() {
    await this.extensionService.whenInstalledExtensionsRegistered();
    const e = "onDebugDynamicConfigurations";
    return this.extensionService.extensions.reduce((i, s) => {
      var r, a;
      if (!s.activationEvents)
        return i;
      const n = [];
      let o = !1;
      for (const d of s.activationEvents)
        d === e ? o = !0 : d.startsWith(`${e}:`) && n.push(d.slice(e.length + 1));
      if (n.length)
        return i.concat(n);
      if (o) {
        const d = (a = (r = s.contributes) == null ? void 0 : r.debuggers) == null ? void 0 : a[0].type;
        return d ? i.concat(d) : i;
      }
      return i;
    }, []).map((i) => ({
      label: this.adapterManager.getDebuggerLabel(i),
      getProvider: async () => (await this.adapterManager.activateDebuggers(e, i), this.configProviders.find((s) => s.type === i && s.triggerKind === Gi.Dynamic && s.provideDebugConfigurations)),
      type: i,
      pick: async () => {
        await this.adapterManager.activateDebuggers(e, i);
        const s = new Qe(), n = [], o = this.configProviders.find((f) => f.type === i && f.triggerKind === Gi.Dynamic && f.provideDebugConfigurations);
        this.getLaunches().forEach((f) => {
          f.workspace && o && n.push(o.provideDebugConfigurations(f.workspace.uri, s.token).then((S) => S.map((w) => ({
            label: w.name,
            description: f.name,
            config: w,
            buttons: [{
              iconClass: L.asClassName(nd),
              tooltip: c("editLaunchConfig", "Edit Debug Configuration in launch.json")
            }],
            launch: f
          }))));
        });
        const r = new te(), a = r.add(this.quickInputService.createQuickPick());
        a.busy = !0, a.placeholder = c("selectConfiguration", "Select Launch Configuration");
        const d = new Promise((f) => {
          r.add(a.onDidAccept(() => f(a.activeItems[0]))), r.add(a.onDidTriggerItemButton(async (S) => {
            f(void 0);
            const { launch: w, config: m } = S.item;
            await w.openConfigFile({ preserveFocus: !1, type: m.type, suppressInitialConfigs: !0 }), await w.writeConfiguration(m), await this.selectConfiguration(w, m.name), this.removeRecentDynamicConfigurations(m.name, m.type);
          }));
        }), u = await Promise.all(n), g = Za(u);
        a.items = g, a.busy = !1, a.show();
        const p = await d;
        if (r.dispose(), !p) {
          s.cancel();
          return;
        }
        return p;
      }
    }));
  }
  getAllConfigurations() {
    const e = [];
    for (const t of this.launches)
      for (const i of t.getConfigurationNames()) {
        const s = t.getConfiguration(i) || t.getCompound(i);
        s && e.push({ launch: t, name: i, presentation: s.presentation });
      }
    return ec(e);
  }
  removeRecentDynamicConfigurations(e, t) {
    const i = this.getRecentDynamicConfigurations().filter((s) => s.name !== e || s.type !== t);
    this.storageService.store(On, JSON.stringify(i), 1, 1), this.selectedConfiguration.name === e && this.selectedType === t && this.selectedDynamic ? this.selectConfiguration(void 0, void 0) : this._onDidSelectConfigurationName.fire();
  }
  getRecentDynamicConfigurations() {
    return JSON.parse(this.storageService.get(On, 1, "[]"));
  }
  registerListeners() {
    this.toDispose.push(Ze.any(this.contextService.onDidChangeWorkspaceFolders, this.contextService.onDidChangeWorkbenchState)(() => {
      this.initLaunches(), this.selectConfiguration(void 0), this.setCompoundSchemaValues();
    })), this.toDispose.push(this.configurationService.onDidChangeConfiguration(async (e) => {
      e.affectsConfiguration("launch") && (await this.selectConfiguration(void 0), this.setCompoundSchemaValues());
    })), this.toDispose.push(this.adapterManager.onDidDebuggersExtPointRead(() => {
      this.setCompoundSchemaValues();
    }));
  }
  initLaunches() {
    this.launches = this.contextService.getWorkspace().folders.map(
      (e) => this.instantiationService.createInstance(lo, this, this.adapterManager, e)
    ), this.contextService.getWorkbenchState() === 3 && this.launches.push(this.instantiationService.createInstance(us, this, this.adapterManager)), this.launches.push(this.instantiationService.createInstance(hs, this, this.adapterManager)), this.selectedLaunch && this.launches.indexOf(this.selectedLaunch) === -1 && this.selectConfiguration(void 0);
  }
  setCompoundSchemaValues() {
    const e = Nt.properties.compounds.items.properties.configurations, t = this.launches.map((s) => s.getConfigurationNames(!0)).reduce((s, n) => s.concat(n), []);
    e.items.oneOf[0].enum = t, e.items.oneOf[1].properties.name.enum = t;
    const i = this.contextService.getWorkspace().folders.map((s) => s.name);
    e.items.oneOf[1].properties.folder.enum = i, Dd.registerSchema(Ri, Nt);
  }
  getLaunches() {
    return this.launches;
  }
  getLaunch(e) {
    if (ue.isUri(e))
      return this.launches.find((t) => t.workspace && this.uriIdentityService.extUri.isEqual(t.workspace.uri, e));
  }
  get selectedConfiguration() {
    return {
      launch: this.selectedLaunch,
      name: this.selectedName,
      getConfig: this.getSelectedConfig,
      type: this.selectedType
    };
  }
  get onDidSelectConfiguration() {
    return this._onDidSelectConfigurationName.event;
  }
  getWorkspaceLaunch() {
    if (this.contextService.getWorkbenchState() === 3)
      return this.launches[this.launches.length - 1];
  }
  async selectConfiguration(e, t, i, s) {
    if (typeof e > "u") {
      const u = this.historyService.getLastActiveWorkspaceRoot();
      e = this.getLaunch(u), (!e || e.getConfigurationNames().length === 0) && (e = this.launches.find((g) => !!(g && g.getConfigurationNames().length)) || e || this.launches[0]);
    }
    const n = this.selectedLaunch, o = this.selectedName, r = this.selectedDynamic;
    this.selectedLaunch = e, this.selectedLaunch ? this.storageService.store(Rn, this.selectedLaunch.uri.toString(), 1, 1) : this.storageService.remove(Rn, 1);
    const a = e ? e.getConfigurationNames() : [];
    this.getSelectedConfig = () => {
      const u = this.selectedName ? e == null ? void 0 : e.getConfiguration(this.selectedName) : void 0;
      return Promise.resolve(u || i);
    };
    let d = i == null ? void 0 : i.type;
    if (t && a.indexOf(t) >= 0)
      this.setSelectedLaunchName(t);
    else if (s && s.type) {
      if (d = s.type, !i) {
        const g = (await this.getDynamicProviders()).filter((p) => p.type === d);
        this.getSelectedConfig = async () => {
          const p = await Promise.all(g.map((S) => S.getProvider())), f = p.length > 0 ? p[0] : void 0;
          if (f && e && e.workspace) {
            const S = new Qe(), m = (await f.provideDebugConfigurations(e.workspace.uri, S.token)).find((y) => y.name === t);
            if (m)
              return m;
          }
        };
      }
      this.setSelectedLaunchName(t);
      let u = this.getRecentDynamicConfigurations();
      t && s.type && (u.unshift({ name: t, type: s.type }), u = St(u, (g) => `${g.name} : ${g.type}`), this.storageService.store(On, JSON.stringify(u), 1, 1));
    } else if (!this.selectedName || a.indexOf(this.selectedName) === -1) {
      const u = a.length ? a[0] : void 0;
      this.setSelectedLaunchName(u);
    }
    !i && e && this.selectedName && (i = e.getConfiguration(this.selectedName), d = i == null ? void 0 : i.type), this.selectedType = (s == null ? void 0 : s.type) || (i == null ? void 0 : i.type), this.selectedDynamic = !!s, this.storageService.store(ya, s ? this.selectedType : void 0, 1, 1), d ? this.debugConfigurationTypeContext.set(d) : this.debugConfigurationTypeContext.reset(), (this.selectedLaunch !== n || this.selectedName !== o || r !== this.selectedDynamic) && this._onDidSelectConfigurationName.fire();
  }
  setSelectedLaunchName(e) {
    this.selectedName = e, this.selectedName ? this.storageService.store(Nn, this.selectedName, 1, 1) : this.storageService.remove(Nn, 1);
  }
  dispose() {
    this.toDispose = U(this.toDispose);
  }
};
co = I([
  h(1, _e),
  h(2, O),
  h(3, Ys),
  h(4, K),
  h(5, it),
  h(6, Yt),
  h(7, vl),
  h(8, Le),
  h(9, H)
], co);
class Lr {
  constructor(e, t) {
    this.configurationManager = e, this.adapterManager = t;
  }
  getCompound(e) {
    const t = this.getConfig();
    if (!(!t || !t.compounds))
      return t.compounds.find((i) => i.name === e);
  }
  getConfigurationNames(e = !1) {
    const t = this.getConfig();
    if (!t || !Array.isArray(t.configurations) && !Array.isArray(t.compounds))
      return [];
    {
      const i = [];
      return t.configurations && i.push(...t.configurations.filter((s) => s && typeof s.name == "string")), e ? i.map((s) => s.name) : (t.compounds && i.push(...t.compounds.filter((s) => typeof s.name == "string" && s.configurations && s.configurations.length)), ec(i).map((s) => s.name));
    }
  }
  getConfiguration(e) {
    const t = Zi(this.getConfig());
    if (!t || !t.configurations)
      return;
    const i = t.configurations.find((s) => s && s.name === e);
    return i && (this instanceof hs ? i.__configurationTarget = 2 : this instanceof us ? i.__configurationTarget = 5 : i.__configurationTarget = 6), i;
  }
  async getInitialConfigurationContent(e, t, i, s) {
    let n = "";
    const o = t ? this.adapterManager.getEnabledDebugger(t) : await this.adapterManager.guessDebugger(!0);
    if (o) {
      const r = i ? await this.configurationManager.provideDebugConfigurations(e, o.type, s || Il.None) : [];
      n = await o.getInitialConfigurationContent(r);
    }
    return n;
  }
  get hidden() {
    return !1;
  }
}
let lo = class extends Lr {
  constructor(e, t, i, s, n, o, r) {
    super(e, t), this.workspace = i, this.fileService = s, this.textFileService = n, this.editorService = o, this.configurationService = r;
  }
  get uri() {
    return Dl(this.workspace.uri, "/.vscode/launch.json");
  }
  get name() {
    return this.workspace.name;
  }
  getConfig() {
    return this.configurationService.inspect("launch", { resource: this.workspace.uri }).workspaceFolderValue;
  }
  async openConfigFile({ preserveFocus: e, type: t, suppressInitialConfigs: i }, s) {
    const n = this.uri;
    let o = !1, r = "";
    try {
      r = (await this.fileService.readFile(n)).value.toString();
    } catch {
      if (r = await this.getInitialConfigurationContent(this.workspace.uri, t, !i, s), !r)
        return { editor: null, created: !1 };
      o = !0;
      try {
        await this.textFileService.write(n, r);
      } catch (p) {
        throw new Error(c("DebugConfig.failed", "Unable to create 'launch.json' file inside the '.vscode' folder ({0}).", p.message));
      }
    }
    const a = r.indexOf(`"${this.configurationManager.selectedConfiguration.name}"`);
    let d = 1;
    for (let p = 0; p < a; p++)
      r.charAt(p) === `
` && d++;
    const u = d > 1 ? { startLineNumber: d, startColumn: 4 } : void 0, g = await this.editorService.openEditor({
      resource: n,
      options: {
        selection: u,
        preserveFocus: e,
        pinned: o,
        revealIfVisible: !0
      }
    }, tc);
    return {
      editor: Oi(g),
      created: o
    };
  }
  async writeConfiguration(e) {
    const t = Zi(this.getConfig());
    t.configurations || (t.configurations = []), t.configurations.push(e), await this.configurationService.updateValue("launch", t, { resource: this.workspace.uri }, 6);
  }
};
lo = I([
  h(3, rr),
  h(4, Qa),
  h(5, ae),
  h(6, O)
], lo);
let us = class extends Lr {
  constructor(e, t, i, s, n) {
    super(e, t), this.editorService = i, this.configurationService = s, this.contextService = n;
  }
  get workspace() {
  }
  get uri() {
    return this.contextService.getWorkspace().configuration;
  }
  get name() {
    return c("workspace", "workspace");
  }
  getConfig() {
    return this.configurationService.inspect("launch").workspaceValue;
  }
  async openConfigFile({ preserveFocus: e, type: t, useInitialConfigs: i }, s) {
    if (!!!this.getConfig()) {
      const r = await this.getInitialConfigurationContent(void 0, t, i, s);
      if (r)
        await this.configurationService.updateValue("launch", El(r), 5);
      else
        return { editor: null, created: !1 };
    }
    const o = await this.editorService.openEditor({
      resource: this.contextService.getWorkspace().configuration,
      options: { preserveFocus: e }
    }, tc);
    return {
      editor: Oi(o),
      created: !1
    };
  }
};
us = I([
  h(2, ae),
  h(3, O),
  h(4, _e)
], us);
let hs = class extends Lr {
  constructor(e, t, i, s) {
    super(e, t), this.configurationService = i, this.preferencesService = s;
  }
  get workspace() {
  }
  get uri() {
    return this.preferencesService.userSettingsResource;
  }
  get name() {
    return c("user settings", "user settings");
  }
  get hidden() {
    return !0;
  }
  getConfig() {
    return this.configurationService.inspect("launch").userValue;
  }
  async openConfigFile({ preserveFocus: e, type: t, useInitialContent: i }) {
    const s = await this.preferencesService.openUserSettings({ jsonEditor: !0, preserveFocus: e, revealSetting: { key: "launch" } });
    return {
      editor: Oi(s),
      created: !1
    };
  }
};
hs = I([
  h(2, O),
  h(3, Cl)
], hs);
const Jg = /range=([0-9]+):([0-9]+)/;
class Qg {
  constructor(e) {
    this.debugService = e, this.memoryFdCounter = 0, this.fdMemory = /* @__PURE__ */ new Map(), this.changeEmitter = new B(), this.onDidChangeCapabilities = Ze.None, this.onDidChangeFile = this.changeEmitter.event, this.capabilities = 1028, e.onDidEndSession((t) => {
      for (const [i, s] of this.fdMemory)
        s.session === t && this.close(i);
    });
  }
  watch(e, t) {
    if (t.recursive)
      return ic(() => {
      });
    const { session: i, memoryReference: s, offset: n } = this.parseUri(e), o = new te();
    return o.add(i.onDidChangeState(() => {
      (i.state === 3 || i.state === 0) && this.changeEmitter.fire([{ type: 2, resource: e }]);
    })), o.add(i.onDidInvalidateMemory((r) => {
      r.body.memoryReference === s && (n && (r.body.offset >= n.toOffset || r.body.offset + r.body.count < n.fromOffset) || this.changeEmitter.fire([{ resource: e, type: 0 }]));
    })), o;
  }
  stat(e) {
    const { readOnly: t } = this.parseUri(e);
    return Promise.resolve({
      type: xl.File,
      mtime: 0,
      ctime: 0,
      size: 0,
      permissions: t ? Tl.Readonly : void 0
    });
  }
  mkdir() {
    throw ve("Not allowed", Ce.NoPermissions);
  }
  readdir() {
    throw ve("Not allowed", Ce.NoPermissions);
  }
  delete() {
    throw ve("Not allowed", Ce.NoPermissions);
  }
  rename() {
    throw ve("Not allowed", Ce.NoPermissions);
  }
  open(e, t) {
    const { session: i, memoryReference: s, offset: n } = this.parseUri(e), o = this.memoryFdCounter++;
    let r = i.getMemory(s);
    return n && (r = new Zg(r, n)), this.fdMemory.set(o, { session: i, region: r }), Promise.resolve(o);
  }
  close(e) {
    var t;
    return (t = this.fdMemory.get(e)) == null || t.region.dispose(), this.fdMemory.delete(e), Promise.resolve();
  }
  async writeFile(e, t) {
    const { offset: i } = this.parseUri(e);
    if (!i)
      throw ve("Range must be present to read a file", Ce.FileNotFound);
    const s = await this.open(e, { create: !1 });
    try {
      await this.write(s, i.fromOffset, t, 0, t.length);
    } finally {
      this.close(s);
    }
  }
  async readFile(e) {
    const { offset: t } = this.parseUri(e);
    if (!t)
      throw ve("Range must be present to read a file", Ce.FileNotFound);
    const i = new Uint8Array(t.toOffset - t.fromOffset), s = await this.open(e, { create: !1 });
    try {
      return await this.read(s, t.fromOffset, i, 0, i.length), i;
    } finally {
      this.close(s);
    }
  }
  async read(e, t, i, s, n) {
    const o = this.fdMemory.get(e);
    if (!o)
      throw ve("No file with that descriptor open", Ce.Unavailable);
    const r = await o.region.read(t, n);
    let a = 0;
    for (const d of r)
      switch (d.type) {
        case 1:
          return a;
        case 2:
          if (a > 0)
            return a;
          throw ve(d.error, Ce.Unknown);
        case 0: {
          const u = Math.max(0, t - d.offset), g = d.data.slice(u, Math.min(d.data.byteLength, u + (n - a)));
          i.set(g.buffer, s + a), a += g.byteLength;
          break;
        }
        default:
          _l();
      }
    return a;
  }
  write(e, t, i, s, n) {
    const o = this.fdMemory.get(e);
    if (!o)
      throw ve("No file with that descriptor open", Ce.Unavailable);
    return o.region.write(t, Ll.wrap(i).slice(s, s + n));
  }
  parseUri(e) {
    if (e.scheme !== Kn)
      throw ve(`Cannot open file with scheme ${e.scheme}`, Ce.FileNotFound);
    const t = this.debugService.getModel().getSession(e.authority);
    if (!t)
      throw ve("Debug session not found", Ce.FileNotFound);
    let i;
    const s = Jg.exec(e.query);
    s && (i = { fromOffset: Number(s[1]), toOffset: Number(s[2]) });
    const [, n] = e.path.split("/");
    return {
      session: t,
      offset: i,
      readOnly: !t.capabilities.supportsWriteMemoryRequest,
      sessionId: e.authority,
      memoryReference: decodeURIComponent(n)
    };
  }
}
class Zg extends Qt {
  constructor(e, t) {
    super(), this.parent = e, this.range = t, this.invalidateEmitter = new B(), this.onDidInvalidate = this.invalidateEmitter.event, this.width = this.range.toOffset - this.range.fromOffset, this.writable = e.writable, this._register(e), this._register(e.onDidInvalidate((i) => {
      const s = jn(i.fromOffset - t.fromOffset, 0, this.width), n = jn(i.toOffset - t.fromOffset, 0, this.width);
      n > s && this.invalidateEmitter.fire({ fromOffset: s, toOffset: n });
    }));
  }
  read(e, t) {
    if (e < 0)
      throw new RangeError(`Invalid fromOffset: ${e}`);
    return this.parent.read(this.range.fromOffset + e, this.range.fromOffset + Math.min(t, this.width));
  }
  write(e, t) {
    return this.parent.write(this.range.fromOffset + e, t);
  }
}
let uo = class {
  constructor(e, t, i, s, n, o, r, a) {
    this.dbgr = t, this.sessionId = i, this.name = s, this.extensionHostDebugService = n, this.openerService = o, this.notificationService = r, this.dialogSerivce = a, this.allThreadsContinued = !0, this._readyForBreakpoints = !1, this.debugAdapterStopped = !1, this.inShutdown = !1, this.terminated = !1, this.firedAdapterExitEvent = !1, this.startTime = 0, this.didReceiveStoppedEvent = !1, this._onDidInitialize = new B(), this._onDidStop = new B(), this._onDidContinued = new B(), this._onDidTerminateDebugee = new B(), this._onDidExitDebugee = new B(), this._onDidThread = new B(), this._onDidOutput = new B(), this._onDidBreakpoint = new B(), this._onDidLoadedSource = new B(), this._onDidProgressStart = new B(), this._onDidProgressUpdate = new B(), this._onDidProgressEnd = new B(), this._onDidInvalidated = new B(), this._onDidInvalidateMemory = new B(), this._onDidCustomEvent = new B(), this._onDidEvent = new B(), this._onDidExitAdapter = new B(), this.stoppedSinceLastStep = !1, this.toDispose = [], this.debugAdapter = e, this._capabilities = /* @__PURE__ */ Object.create(null), this.toDispose.push(this.debugAdapter.onError((d) => {
      this.shutdown(d);
    })), this.toDispose.push(this.debugAdapter.onExit((d) => {
      d !== 0 ? this.shutdown(new Error(`exit code: ${d}`)) : this.shutdown();
    })), this.debugAdapter.onEvent((d) => {
      switch (d.event) {
        case "initialized":
          this._readyForBreakpoints = !0, this._onDidInitialize.fire(d);
          break;
        case "loadedSource":
          this._onDidLoadedSource.fire(d);
          break;
        case "capabilities":
          if (d.body) {
            const u = d.body.capabilities;
            this.mergeCapabilities(u);
          }
          break;
        case "stopped":
          this.didReceiveStoppedEvent = !0, this.stoppedSinceLastStep = !0, this._onDidStop.fire(d);
          break;
        case "continued":
          this.allThreadsContinued = d.body.allThreadsContinued !== !1, this._onDidContinued.fire(d);
          break;
        case "thread":
          this._onDidThread.fire(d);
          break;
        case "output":
          this._onDidOutput.fire(d);
          break;
        case "breakpoint":
          this._onDidBreakpoint.fire(d);
          break;
        case "terminated":
          this._onDidTerminateDebugee.fire(d);
          break;
        case "exit":
          this._onDidExitDebugee.fire(d);
          break;
        case "progressStart":
          this._onDidProgressStart.fire(d);
          break;
        case "progressUpdate":
          this._onDidProgressUpdate.fire(d);
          break;
        case "progressEnd":
          this._onDidProgressEnd.fire(d);
          break;
        case "invalidated":
          this._onDidInvalidated.fire(d);
          break;
        case "memory":
          this._onDidInvalidateMemory.fire(d);
          break;
        case "process":
          break;
        case "module":
          break;
        default:
          this._onDidCustomEvent.fire(d);
          break;
      }
      this._onDidEvent.fire(d);
    }), this.debugAdapter.onRequest((d) => this.dispatchRequest(d));
  }
  get isInShutdown() {
    return this.inShutdown;
  }
  get onDidExitAdapter() {
    return this._onDidExitAdapter.event;
  }
  get capabilities() {
    return this._capabilities;
  }
  get readyForBreakpoints() {
    return this._readyForBreakpoints;
  }
  get onDidInitialize() {
    return this._onDidInitialize.event;
  }
  get onDidStop() {
    return this._onDidStop.event;
  }
  get onDidContinued() {
    return this._onDidContinued.event;
  }
  get onDidTerminateDebugee() {
    return this._onDidTerminateDebugee.event;
  }
  get onDidExitDebugee() {
    return this._onDidExitDebugee.event;
  }
  get onDidThread() {
    return this._onDidThread.event;
  }
  get onDidOutput() {
    return this._onDidOutput.event;
  }
  get onDidBreakpoint() {
    return this._onDidBreakpoint.event;
  }
  get onDidLoadedSource() {
    return this._onDidLoadedSource.event;
  }
  get onDidCustomEvent() {
    return this._onDidCustomEvent.event;
  }
  get onDidProgressStart() {
    return this._onDidProgressStart.event;
  }
  get onDidProgressUpdate() {
    return this._onDidProgressUpdate.event;
  }
  get onDidProgressEnd() {
    return this._onDidProgressEnd.event;
  }
  get onDidInvalidated() {
    return this._onDidInvalidated.event;
  }
  get onDidInvalidateMemory() {
    return this._onDidInvalidateMemory.event;
  }
  get onDidEvent() {
    return this._onDidEvent.event;
  }
  async start() {
    if (!this.debugAdapter)
      return Promise.reject(new Error(c("noDebugAdapterStart", "No debug adapter, can not start debug session.")));
    await this.debugAdapter.startSession(), this.startTime = (/* @__PURE__ */ new Date()).getTime();
  }
  async initialize(e) {
    const t = await this.send("initialize", e, void 0, void 0, !1);
    return t && this.mergeCapabilities(t.body), t;
  }
  disconnect(e) {
    const t = this.capabilities.supportTerminateDebuggee ? e.terminateDebuggee : void 0, i = this.capabilities.supportTerminateDebuggee && this.capabilities.supportSuspendDebuggee ? e.suspendDebuggee : void 0;
    return this.shutdown(void 0, e.restart, t, i);
  }
  async launchOrAttach(e) {
    const t = await this.send(e.request, e, void 0, void 0, !1);
    return t && this.mergeCapabilities(t.body), t;
  }
  terminate(e = !1) {
    return this.capabilities.supportsTerminateRequest ? this.terminated ? this.disconnect({ terminateDebuggee: !0, restart: e }) : (this.terminated = !0, this.send("terminate", { restart: e }, void 0)) : Promise.reject(new Error("terminated not supported"));
  }
  restart(e) {
    return this.capabilities.supportsRestartRequest ? this.send("restart", e) : Promise.reject(new Error("restart not supported"));
  }
  async next(e) {
    this.stoppedSinceLastStep = !1;
    const t = await this.send("next", e);
    return this.stoppedSinceLastStep || this.fireSimulatedContinuedEvent(e.threadId), t;
  }
  async stepIn(e) {
    this.stoppedSinceLastStep = !1;
    const t = await this.send("stepIn", e);
    return this.stoppedSinceLastStep || this.fireSimulatedContinuedEvent(e.threadId), t;
  }
  async stepOut(e) {
    this.stoppedSinceLastStep = !1;
    const t = await this.send("stepOut", e);
    return this.stoppedSinceLastStep || this.fireSimulatedContinuedEvent(e.threadId), t;
  }
  async continue(e) {
    this.stoppedSinceLastStep = !1;
    const t = await this.send("continue", e);
    return t && t.body && t.body.allThreadsContinued !== void 0 && (this.allThreadsContinued = t.body.allThreadsContinued), this.stoppedSinceLastStep || this.fireSimulatedContinuedEvent(e.threadId, this.allThreadsContinued), t;
  }
  pause(e) {
    return this.send("pause", e);
  }
  terminateThreads(e) {
    return this.capabilities.supportsTerminateThreadsRequest ? this.send("terminateThreads", e) : Promise.reject(new Error("terminateThreads not supported"));
  }
  setVariable(e) {
    return this.capabilities.supportsSetVariable ? this.send("setVariable", e) : Promise.reject(new Error("setVariable not supported"));
  }
  setExpression(e) {
    return this.capabilities.supportsSetExpression ? this.send("setExpression", e) : Promise.reject(new Error("setExpression not supported"));
  }
  async restartFrame(e, t) {
    if (this.capabilities.supportsRestartFrame) {
      this.stoppedSinceLastStep = !1;
      const i = await this.send("restartFrame", e);
      return this.stoppedSinceLastStep || this.fireSimulatedContinuedEvent(t), i;
    }
    return Promise.reject(new Error("restartFrame not supported"));
  }
  stepInTargets(e) {
    return this.capabilities.supportsStepInTargetsRequest ? this.send("stepInTargets", e) : Promise.reject(new Error("stepInTargets not supported"));
  }
  completions(e, t) {
    return this.capabilities.supportsCompletionsRequest ? this.send("completions", e, t) : Promise.reject(new Error("completions not supported"));
  }
  setBreakpoints(e) {
    return this.send("setBreakpoints", e);
  }
  setFunctionBreakpoints(e) {
    return this.capabilities.supportsFunctionBreakpoints ? this.send("setFunctionBreakpoints", e) : Promise.reject(new Error("setFunctionBreakpoints not supported"));
  }
  dataBreakpointInfo(e) {
    return this.capabilities.supportsDataBreakpoints ? this.send("dataBreakpointInfo", e) : Promise.reject(new Error("dataBreakpointInfo not supported"));
  }
  setDataBreakpoints(e) {
    return this.capabilities.supportsDataBreakpoints ? this.send("setDataBreakpoints", e) : Promise.reject(new Error("setDataBreakpoints not supported"));
  }
  setExceptionBreakpoints(e) {
    return this.send("setExceptionBreakpoints", e);
  }
  breakpointLocations(e) {
    return this.capabilities.supportsBreakpointLocationsRequest ? this.send("breakpointLocations", e) : Promise.reject(new Error("breakpointLocations is not supported"));
  }
  configurationDone() {
    return this.capabilities.supportsConfigurationDoneRequest ? this.send("configurationDone", null) : Promise.reject(new Error("configurationDone not supported"));
  }
  stackTrace(e, t) {
    return this.send("stackTrace", e, t);
  }
  exceptionInfo(e) {
    return this.capabilities.supportsExceptionInfoRequest ? this.send("exceptionInfo", e) : Promise.reject(new Error("exceptionInfo not supported"));
  }
  scopes(e, t) {
    return this.send("scopes", e, t);
  }
  variables(e, t) {
    return this.send("variables", e, t);
  }
  source(e) {
    return this.send("source", e);
  }
  loadedSources(e) {
    return this.capabilities.supportsLoadedSourcesRequest ? this.send("loadedSources", e) : Promise.reject(new Error("loadedSources not supported"));
  }
  threads() {
    return this.send("threads", null);
  }
  evaluate(e) {
    return this.send("evaluate", e);
  }
  async stepBack(e) {
    if (this.capabilities.supportsStepBack) {
      this.stoppedSinceLastStep = !1;
      const t = await this.send("stepBack", e);
      return this.stoppedSinceLastStep || this.fireSimulatedContinuedEvent(e.threadId), t;
    }
    return Promise.reject(new Error("stepBack not supported"));
  }
  async reverseContinue(e) {
    if (this.capabilities.supportsStepBack) {
      this.stoppedSinceLastStep = !1;
      const t = await this.send("reverseContinue", e);
      return this.stoppedSinceLastStep || this.fireSimulatedContinuedEvent(e.threadId), t;
    }
    return Promise.reject(new Error("reverseContinue not supported"));
  }
  gotoTargets(e) {
    return this.capabilities.supportsGotoTargetsRequest ? this.send("gotoTargets", e) : Promise.reject(new Error("gotoTargets is not supported"));
  }
  async goto(e) {
    if (this.capabilities.supportsGotoTargetsRequest) {
      this.stoppedSinceLastStep = !1;
      const t = await this.send("goto", e);
      return this.stoppedSinceLastStep || this.fireSimulatedContinuedEvent(e.threadId), t;
    }
    return Promise.reject(new Error("goto is not supported"));
  }
  async setInstructionBreakpoints(e) {
    return this.capabilities.supportsInstructionBreakpoints ? await this.send("setInstructionBreakpoints", e) : Promise.reject(new Error("setInstructionBreakpoints is not supported"));
  }
  async disassemble(e) {
    return this.capabilities.supportsDisassembleRequest ? await this.send("disassemble", e) : Promise.reject(new Error("disassemble is not supported"));
  }
  async readMemory(e) {
    return this.capabilities.supportsReadMemoryRequest ? await this.send("readMemory", e) : Promise.reject(new Error("readMemory is not supported"));
  }
  async writeMemory(e) {
    return this.capabilities.supportsWriteMemoryRequest ? await this.send("writeMemory", e) : Promise.reject(new Error("writeMemory is not supported"));
  }
  cancel(e) {
    return this.send("cancel", e);
  }
  custom(e, t) {
    return this.send(e, t);
  }
  async shutdown(e, t = !1, i = void 0, s = void 0) {
    if (!this.inShutdown)
      if (this.inShutdown = !0, this.debugAdapter)
        try {
          const n = { restart: t };
          typeof i == "boolean" && (n.terminateDebuggee = i), typeof s == "boolean" && (n.suspendDebuggee = s), await this.send("disconnect", n, void 0, e ? 200 : 2e3);
        } catch {
        } finally {
          await this.stopAdapter(e);
        }
      else
        return this.stopAdapter(e);
  }
  async stopAdapter(e) {
    try {
      if (this.debugAdapter) {
        const t = this.debugAdapter;
        this.debugAdapter = null, await t.stopSession(), this.debugAdapterStopped = !0;
      }
    } finally {
      this.fireAdapterExitEvent(e);
    }
  }
  fireAdapterExitEvent(e) {
    if (!this.firedAdapterExitEvent) {
      this.firedAdapterExitEvent = !0;
      const t = {
        emittedStopped: this.didReceiveStoppedEvent,
        sessionLengthInSeconds: ((/* @__PURE__ */ new Date()).getTime() - this.startTime) / 1e3
      };
      e && !this.debugAdapterStopped && (t.error = e), this._onDidExitAdapter.fire(t);
    }
  }
  async dispatchRequest(e) {
    const t = {
      type: "response",
      seq: 0,
      command: e.command,
      request_seq: e.seq,
      success: !0
    }, i = (s) => this.debugAdapter && this.debugAdapter.sendResponse(s);
    if (e.command === "launchVSCode")
      try {
        let s = await this.launchVsCode(e.arguments);
        if (!s.success) {
          const { confirmed: n } = await this.dialogSerivce.confirm({
            type: nc.Warning,
            message: c(
              "canNotStart",
              "The debugger needs to open a new tab or window for the debuggee but the browser prevented this. You must give permission to continue."
            ),
            primaryButton: c({ key: "continue", comment: ["&& denotes a mnemonic"] }, "&&Continue")
          });
          n ? s = await this.launchVsCode(e.arguments) : (t.success = !1, i(t), await this.shutdown());
        }
        t.body = {
          rendererDebugPort: s.rendererDebugPort
        }, i(t);
      } catch (s) {
        t.success = !1, t.message = s.message, i(t);
      }
    else if (e.command === "runInTerminal")
      try {
        const s = await this.dbgr.runInTerminal(e.arguments, this.sessionId), n = t;
        n.body = {}, typeof s == "number" && (n.body.shellProcessId = s), i(n);
      } catch (s) {
        t.success = !1, t.message = s.message, i(t);
      }
    else if (e.command === "startDebugging")
      try {
        const s = e.arguments, n = {
          ...s.configuration,
          request: s.request,
          type: this.dbgr.type,
          name: s.configuration.name || this.name
        };
        await this.dbgr.startDebugging(n, this.sessionId) || (t.success = !1, t.message = "Failed to start debugging"), i(t);
      } catch (s) {
        t.success = !1, t.message = s.message, i(t);
      }
    else
      t.success = !1, t.message = `unknown request '${e.command}'`, i(t);
  }
  launchVsCode(e) {
    const t = [];
    for (const i of e.args) {
      const s = (i.prefix || "") + (i.path || ""), n = /^--(.+)=(.+)$/.exec(s);
      if (n && n.length === 3) {
        const o = n[1];
        let r = n[2];
        (o === "file-uri" || o === "folder-uri") && !Xn(i.path) && (r = Xn(r) ? r : ue.file(r).toString()), t.push(`--${o}=${r}`);
      } else
        t.push(s);
    }
    return e.env && t.push(`--extensionEnvironment=${JSON.stringify(e.env)}`), this.extensionHostDebugService.openExtensionDevelopmentHostWindow(t, !!e.debugRenderer);
  }
  send(e, t, i, s, n = !0) {
    return new Promise((o, r) => {
      if (!this.debugAdapter) {
        this.inShutdown ? o(void 0) : r(new Error(c(
          "noDebugAdapter",
          "No debugger available found. Can not send '{0}'.",
          e
        )));
        return;
      }
      let a;
      const d = this.debugAdapter.sendRequest(e, t, (u) => {
        a == null || a.dispose(), u.success ? o(u) : r(u);
      }, s);
      i && (a = i.onCancellationRequested(() => {
        a.dispose(), this.capabilities.supportsCancelRequest && this.cancel({ requestId: d });
      }));
    }).then(void 0, (o) => Promise.reject(this.handleErrorResponse(o, n)));
  }
  handleErrorResponse(e, t) {
    var a;
    if (e.command === "canceled" && e.message === "canceled")
      return new Al();
    const i = (a = e == null ? void 0 : e.body) == null ? void 0 : a.error, s = (e == null ? void 0 : e.message) || "", n = i ? Bl(i.format, !1, i.variables) : s, o = i == null ? void 0 : i.url;
    if (i && o) {
      const d = i.urlLabel ? i.urlLabel : c("moreInfo", "More Info"), u = ue.parse(o), g = u.scheme === ft.command ? "debug.moreInfo.command" : "debug.moreInfo";
      return oc(n, [Ml({ id: g, label: d, run: () => this.openerService.open(u, { allowCommands: !0 }) })]);
    }
    t && i && i.format && i.showUser && this.notificationService.error(n);
    const r = new rc(n);
    return r.showUser = i == null ? void 0 : i.showUser, r;
  }
  mergeCapabilities(e) {
    e && (this._capabilities = ac(this._capabilities, e));
  }
  fireSimulatedContinuedEvent(e, t = !1) {
    this._onDidContinued.fire({
      type: "event",
      event: "continued",
      body: {
        threadId: e,
        allThreadsContinued: t
      },
      seq: void 0
    });
  }
  dispose() {
    U(this.toDispose);
  }
};
uo = I([
  h(4, sc),
  h(5, st),
  h(6, Ct),
  h(7, Jt)
], uo);
const Da = 1e4;
let ep = 0;
const Vn = () => `topReplElement:${ep++}`;
class ze {
  constructor(e, t, i, s, n, o) {
    this.session = e, this.id = t, this.value = i, this.severity = s, this.sourceData = n, this.expression = o, this._count = 1, this._onDidChangeCount = new B();
  }
  toString(e = !1) {
    let t = this.value;
    for (let s = 1; s < this.count; s++)
      t += (t.endsWith(`
`) ? "" : `
`) + this.value;
    const i = this.sourceData && e ? ` ${this.sourceData.source.name}` : "";
    return t + i;
  }
  getId() {
    return this.id;
  }
  getChildren() {
    var e;
    return ((e = this.expression) == null ? void 0 : e.getChildren()) || Promise.resolve([]);
  }
  set count(e) {
    this._count = e, this._onDidChangeCount.fire();
  }
  get count() {
    return this._count;
  }
  get onDidChangeCount() {
    return this._onDidChangeCount.event;
  }
  get hasChildren() {
    var e;
    return !!((e = this.expression) != null && e.hasChildren);
  }
}
class gs {
  constructor(e, t, i) {
    this.expression = e, this.severity = t, this.sourceData = i, this.id = Zt(), this.hasChildren = e.hasChildren;
  }
  getChildren() {
    return this.expression.getChildren();
  }
  toString() {
    return this.expression.toString();
  }
  getId() {
    return this.id;
  }
}
const pt = class pt {
  constructor(e, t, i, s, n) {
    this.id = e, this.name = t, this.valueObj = i, this.sourceData = s, this.annotation = n;
  }
  getId() {
    return this.id;
  }
  get value() {
    return this.valueObj === null ? "null" : Array.isArray(this.valueObj) ? `Array[${this.valueObj.length}]` : bt(this.valueObj) ? "Object" : $e(this.valueObj) ? `"${this.valueObj}"` : String(this.valueObj) || "";
  }
  get hasChildren() {
    return Array.isArray(this.valueObj) && this.valueObj.length > 0 || bt(this.valueObj) && Object.getOwnPropertyNames(this.valueObj).length > 0;
  }
  evaluateLazy() {
    throw new Error("Method not implemented.");
  }
  getChildren() {
    let e = [];
    return Array.isArray(this.valueObj) ? e = this.valueObj.slice(0, pt.MAX_CHILDREN).map((t, i) => new pt(`${this.id}:${i}`, String(i), t)) : bt(this.valueObj) && (e = Object.getOwnPropertyNames(this.valueObj).slice(0, pt.MAX_CHILDREN).map((t, i) => new pt(`${this.id}:${i}`, t, this.valueObj[t]))), Promise.resolve(e);
  }
  toString() {
    return `${this.name}
${this.value}`;
  }
};
pt.MAX_CHILDREN = 1e3;
let ho = pt;
class kn {
  constructor(e) {
    this.value = e, this.id = Zt();
  }
  toString() {
    return this.value;
  }
  getId() {
    return this.id;
  }
}
class Dt extends yi {
  get available() {
    return this._available;
  }
  constructor(e) {
    super(void 0, void 0, 0, Zt()), this.originalExpression = e, this._available = !0;
  }
  async evaluateExpression(e, t, i, s) {
    const n = await super.evaluateExpression(e, t, i, s);
    return this._available = n, n;
  }
  toString() {
    return `${this.value}`;
  }
}
const xt = class xt {
  constructor(e, t, i) {
    this.name = e, this.autoExpand = t, this.sourceData = i, this.children = [], this.ended = !1, this.id = `replGroup:${xt.COUNTER++}`;
  }
  get hasChildren() {
    return !0;
  }
  getId() {
    return this.id;
  }
  toString(e = !1) {
    const t = e && this.sourceData ? ` ${this.sourceData.source.name}` : "";
    return this.name + t;
  }
  addChild(e) {
    const t = this.children.length ? this.children[this.children.length - 1] : void 0;
    t instanceof xt && !t.hasEnded ? t.addChild(e) : this.children.push(e);
  }
  getChildren() {
    return this.children;
  }
  end() {
    const e = this.children.length ? this.children[this.children.length - 1] : void 0;
    e instanceof xt && !e.hasEnded ? e.end() : this.ended = !0;
  }
  get hasEnded() {
    return this.ended;
  }
};
xt.COUNTER = 0;
let Ye = xt;
function tp(l, e) {
  return !l && !e ? !0 : l && e ? l.column === e.column && l.lineNumber === e.lineNumber && l.source.uri.toString() === e.source.uri.toString() : !1;
}
class Ar {
  constructor(e) {
    this.configurationService = e, this.replElements = [], this._onDidChangeElements = new B(), this.onDidChangeElements = this._onDidChangeElements.event;
  }
  getReplElements() {
    return this.replElements;
  }
  async addReplExpression(e, t, i) {
    this.addReplElement(new kn(i));
    const s = new Dt(i);
    await s.evaluateExpression(i, e, t, "repl"), this.addReplElement(s);
  }
  appendToRepl(e, { output: t, expression: i, sev: s, source: n }) {
    const o = "\x1B[2J", r = t.lastIndexOf(o);
    if (r !== -1 && (this.removeReplExpressions(), this.appendToRepl(e, { output: c("consoleCleared", "Console was cleared"), sev: fe.Ignore }), t = t.substring(r + o.length)), i) {
      this.addReplElement(t ? new ze(e, Vn(), t, s, n, i) : new gs(i, s, n));
      return;
    }
    const a = this.replElements.length ? this.replElements[this.replElements.length - 1] : void 0;
    if (a instanceof ze && a.severity === s) {
      const u = this.configurationService.getValue("debug");
      if (a.value === t && tp(a.sourceData, n) && u.console.collapseIdenticalLines) {
        a.count++;
        return;
      }
      if (!a.value.endsWith(`
`) && !a.value.endsWith(`\r
`) && a.count === 1) {
        this.replElements[this.replElements.length - 1] = new ze(e, Vn(), a.value + t, s, n), this._onDidChangeElements.fire();
        return;
      }
    }
    const d = new ze(e, Vn(), t, s, n);
    this.addReplElement(d);
  }
  startGroup(e, t, i) {
    const s = new Ye(e, t, i);
    this.addReplElement(s);
  }
  endGroup() {
    const e = this.replElements[this.replElements.length - 1];
    e instanceof Ye && e.end();
  }
  addReplElement(e) {
    const t = this.replElements.length ? this.replElements[this.replElements.length - 1] : void 0;
    t instanceof Ye && !t.hasEnded ? t.addChild(e) : (this.replElements.push(e), this.replElements.length > Da && this.replElements.splice(0, this.replElements.length - Da)), this._onDidChangeElements.fire();
  }
  removeReplExpressions() {
    this.replElements.length > 0 && (this.replElements = [], this._onDidChangeElements.fire());
  }
  clone() {
    const e = new Ar(this.configurationService);
    return e.replElements = this.replElements.slice(), e;
  }
}
let go = class {
  constructor(e, t, i, s, n, o, r, a, d, u, g, p, f, S, w, m, y, _, v) {
    this.id = e, this._configuration = t, this.root = i, this.model = s, this.debugService = o, this.telemetryService = r, this.hostService = a, this.configurationService = d, this.paneCompositeService = u, this.workspaceContextService = g, this.productService = p, this.notificationService = f, this.uriIdentityService = w, this.instantiationService = m, this.customEndpointTelemetryService = y, this.workbenchEnvironmentService = _, this.logService = v, this.initialized = !1, this.sources = /* @__PURE__ */ new Map(), this.threads = /* @__PURE__ */ new Map(), this.threadIds = [], this.cancellationMap = /* @__PURE__ */ new Map(), this.rawListeners = [], this.stoppedDetails = [], this._onDidChangeState = new B(), this._onDidEndAdapter = new B(), this._onDidLoadedSource = new B(), this._onDidCustomEvent = new B(), this._onDidProgressStart = new B(), this._onDidProgressUpdate = new B(), this._onDidProgressEnd = new B(), this._onDidInvalidMemory = new B(), this._onDidChangeREPLElements = new B(), this._onDidChangeName = new B(), this._options = n || {}, this.parentSession = this._options.parentSession, this.hasSeparateRepl() ? this.repl = new Ar(this.configurationService) : this.repl = this.parentSession.repl;
    const C = new te(), b = C.add(new Ol());
    b.value = this.repl.onDidChangeElements(() => this._onDidChangeREPLElements.fire()), S && C.add(S.onWillShutdown(() => {
      this.shutdown(), U(C);
    }));
    const D = this._options.compoundRoot;
    D && C.add(D.onDidSessionStop(() => this.terminate())), this.passFocusScheduler = new oe(() => {
      var se;
      if (this.debugService.getModel().getSessions().some((A) => A.state === 2) || this.getAllThreads().some((A) => A.stopped))
        if (typeof this.lastContinuedThreadId == "number") {
          const A = this.debugService.getViewModel().focusedThread;
          if (A && A.threadId === this.lastContinuedThreadId && !A.stopped) {
            const j = (se = this.getStoppedDetails()) == null ? void 0 : se.threadId, ui = typeof j == "number" ? this.getThread(j) : void 0;
            this.debugService.focusStackFrame(void 0, ui);
          }
        } else {
          const A = this.debugService.getViewModel().focusedSession;
          A && A.getId() === this.getId() && A.state !== 2 && this.debugService.focusStackFrame(void 0);
        }
    }, 800);
    const P = this._options.parentSession;
    P && C.add(P.onDidEndAdapter(() => {
      var se;
      !this.hasSeparateRepl() && ((se = this.raw) == null ? void 0 : se.isInShutdown) === !1 && (this.repl = this.repl.clone(), b.value = this.repl.onDidChangeElements(() => this._onDidChangeREPLElements.fire()), this.parentSession = void 0);
    }));
  }
  getId() {
    return this.id;
  }
  setSubId(e) {
    this._subId = e;
  }
  getMemory(e) {
    return new zh(e, this);
  }
  get subId() {
    return this._subId;
  }
  get configuration() {
    return this._configuration.resolved;
  }
  get unresolvedConfiguration() {
    return this._configuration.unresolved;
  }
  get lifecycleManagedByParent() {
    return !!this._options.lifecycleManagedByParent;
  }
  get compact() {
    return !!this._options.compact;
  }
  get saveBeforeRestart() {
    var e;
    return this._options.saveBeforeRestart ?? !((e = this._options) != null && e.parentSession);
  }
  get compoundRoot() {
    return this._options.compoundRoot;
  }
  get suppressDebugStatusbar() {
    return this._options.suppressDebugStatusbar ?? !1;
  }
  get suppressDebugToolbar() {
    return this._options.suppressDebugToolbar ?? !1;
  }
  get suppressDebugView() {
    return this._options.suppressDebugView ?? !1;
  }
  get autoExpandLazyVariables() {
    return this.configurationService.getValue("debug").autoExpandLazyVariables;
  }
  setConfiguration(e) {
    this._configuration = e;
  }
  getLabel() {
    return this.workspaceContextService.getWorkspace().folders.length > 1 && this.root ? `${this.name} (${Vl(this.root.uri)})` : this.name;
  }
  setName(e) {
    this._name = e, this._onDidChangeName.fire(e);
  }
  get name() {
    return this._name || this.configuration.name;
  }
  get state() {
    if (!this.initialized)
      return 1;
    if (!this.raw)
      return 0;
    const e = this.debugService.getViewModel().focusedThread;
    return e && e.session === this ? e.stopped ? 2 : 3 : this.getAllThreads().some((t) => t.stopped) ? 2 : 3;
  }
  get capabilities() {
    return this.raw ? this.raw.capabilities : /* @__PURE__ */ Object.create(null);
  }
  get onDidChangeState() {
    return this._onDidChangeState.event;
  }
  get onDidEndAdapter() {
    return this._onDidEndAdapter.event;
  }
  get onDidChangeReplElements() {
    return this._onDidChangeREPLElements.event;
  }
  get onDidChangeName() {
    return this._onDidChangeName.event;
  }
  get onDidCustomEvent() {
    return this._onDidCustomEvent.event;
  }
  get onDidLoadedSource() {
    return this._onDidLoadedSource.event;
  }
  get onDidProgressStart() {
    return this._onDidProgressStart.event;
  }
  get onDidProgressUpdate() {
    return this._onDidProgressUpdate.event;
  }
  get onDidProgressEnd() {
    return this._onDidProgressEnd.event;
  }
  get onDidInvalidateMemory() {
    return this._onDidInvalidMemory.event;
  }
  async initialize(e) {
    this.raw && await this.shutdown();
    try {
      const t = await e.createDebugAdapter(this);
      this.raw = this.instantiationService.createInstance(uo, t, e, this.id, this.configuration.name), await this.raw.start(), this.registerListeners(), await this.raw.initialize({
        clientID: "vscode",
        clientName: this.productService.nameLong,
        adapterID: this.configuration.type,
        pathFormat: "path",
        linesStartAt1: !0,
        columnsStartAt1: !0,
        supportsVariableType: !0,
        supportsVariablePaging: !0,
        supportsRunInTerminalRequest: !0,
        locale: Pl,
        supportsProgressReporting: !0,
        supportsInvalidatedEvent: !0,
        supportsMemoryReferences: !0,
        supportsArgsCanBeInterpretedByShell: !0,
        supportsMemoryEvent: !0,
        supportsStartDebuggingRequest: !0
      }), this.initialized = !0, this._onDidChangeState.fire(), this.debugService.setExceptionBreakpointsForSession(this, this.raw && this.raw.capabilities.exceptionBreakpointFilters || []);
    } catch (t) {
      throw this.initialized = !0, this._onDidChangeState.fire(), await this.shutdown(), t;
    }
  }
  async launchOrAttach(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "launch or attach"));
    if (this.parentSession && this.parentSession.state === 0)
      throw Fl();
    e.__sessionId = this.getId();
    try {
      await this.raw.launchOrAttach(e);
    } catch (t) {
      throw this.shutdown(), t;
    }
  }
  async terminate(e = !1) {
    var t;
    this.raw || this.onDidExitAdapter(), this.cancelAllRequests(), this._options.lifecycleManagedByParent && this.parentSession ? await this.parentSession.terminate(e) : this.raw && (this.raw.capabilities.supportsTerminateRequest && this._configuration.resolved.request === "launch" ? await this.raw.terminate(e) : await this.raw.disconnect({ restart: e, terminateDebuggee: !0 })), e || (t = this._options.compoundRoot) == null || t.sessionStopped();
  }
  async disconnect(e = !1, t = !1) {
    var i;
    this.raw || this.onDidExitAdapter(), this.cancelAllRequests(), this._options.lifecycleManagedByParent && this.parentSession ? await this.parentSession.disconnect(e, t) : this.raw && await this.raw.disconnect({ restart: e, terminateDebuggee: !1, suspendDebuggee: t }), e || (i = this._options.compoundRoot) == null || i.sessionStopped();
  }
  async restart() {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "restart"));
    this.cancelAllRequests(), this._options.lifecycleManagedByParent && this.parentSession ? await this.parentSession.restart() : await this.raw.restart({ arguments: this.configuration });
  }
  async sendBreakpoints(e, t, i) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "breakpoints"));
    if (!this.raw.readyForBreakpoints)
      return Promise.resolve(void 0);
    const s = this.getRawSource(e);
    t.length && !s.adapterData && (s.adapterData = t[0].adapterData), s.path && (s.path = lc(s.path));
    const n = await this.raw.setBreakpoints({
      source: s,
      lines: t.map((o) => o.sessionAgnosticData.lineNumber),
      breakpoints: t.map(
        (o) => ({ line: o.sessionAgnosticData.lineNumber, column: o.sessionAgnosticData.column, condition: o.condition, hitCondition: o.hitCondition, logMessage: o.logMessage })
      ),
      sourceModified: i
    });
    if (n && n.body) {
      const o = /* @__PURE__ */ new Map();
      for (let r = 0; r < t.length; r++)
        o.set(t[r].getId(), n.body.breakpoints[r]);
      this.model.setBreakpointSessionData(this.getId(), this.capabilities, o);
    }
  }
  async sendFunctionBreakpoints(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "function breakpoints"));
    if (this.raw.readyForBreakpoints) {
      const t = await this.raw.setFunctionBreakpoints({ breakpoints: e });
      if (t && t.body) {
        const i = /* @__PURE__ */ new Map();
        for (let s = 0; s < e.length; s++)
          i.set(e[s].getId(), t.body.breakpoints[s]);
        this.model.setBreakpointSessionData(this.getId(), this.capabilities, i);
      }
    }
  }
  async sendExceptionBreakpoints(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "exception breakpoints"));
    if (this.raw.readyForBreakpoints) {
      const t = this.capabilities.supportsExceptionFilterOptions ? {
        filters: [],
        filterOptions: e.map((s) => s.condition ? { filterId: s.filter, condition: s.condition } : { filterId: s.filter })
      } : { filters: e.map((s) => s.filter) }, i = await this.raw.setExceptionBreakpoints(t);
      if (i && i.body && i.body.breakpoints) {
        const s = /* @__PURE__ */ new Map();
        for (let n = 0; n < e.length; n++)
          s.set(e[n].getId(), i.body.breakpoints[n]);
        this.model.setBreakpointSessionData(this.getId(), this.capabilities, s);
      }
    }
  }
  async dataBreakpointInfo(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "data breakpoints info"));
    if (!this.raw.readyForBreakpoints)
      throw new Error(c("sessionNotReadyForBreakpoints", "Session is not ready for breakpoints"));
    const i = await this.raw.dataBreakpointInfo({ name: e, variablesReference: t });
    return i == null ? void 0 : i.body;
  }
  async sendDataBreakpoints(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "data breakpoints"));
    if (this.raw.readyForBreakpoints) {
      const t = await this.raw.setDataBreakpoints({ breakpoints: e });
      if (t && t.body) {
        const i = /* @__PURE__ */ new Map();
        for (let s = 0; s < e.length; s++)
          i.set(e[s].getId(), t.body.breakpoints[s]);
        this.model.setBreakpointSessionData(this.getId(), this.capabilities, i);
      }
    }
  }
  async sendInstructionBreakpoints(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "instruction breakpoints"));
    if (this.raw.readyForBreakpoints) {
      const t = await this.raw.setInstructionBreakpoints({ breakpoints: e });
      if (t && t.body) {
        const i = /* @__PURE__ */ new Map();
        for (let s = 0; s < e.length; s++)
          i.set(e[s].getId(), t.body.breakpoints[s]);
        this.model.setBreakpointSessionData(this.getId(), this.capabilities, i);
      }
    }
  }
  async breakpointsLocations(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "breakpoints locations"));
    const i = this.getRawSource(e), s = await this.raw.breakpointLocations({ source: i, line: t });
    if (!s || !s.body || !s.body.breakpoints)
      return [];
    const n = s.body.breakpoints.map((o) => ({ lineNumber: o.line, column: o.column || 1 }));
    return St(n, (o) => `${o.lineNumber}:${o.column}`);
  }
  getDebugProtocolBreakpoint(e) {
    return this.model.getDebugProtocolBreakpoint(e, this.getId());
  }
  customRequest(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", e));
    return this.raw.custom(e, t);
  }
  stackTrace(e, t, i, s) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "stackTrace"));
    const n = this.getNewCancellationToken(e, s);
    return this.raw.stackTrace({ threadId: e, startFrame: t, levels: i }, n);
  }
  async exceptionInfo(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "exceptionInfo"));
    const t = await this.raw.exceptionInfo({ threadId: e });
    if (t)
      return {
        id: t.body.exceptionId,
        description: t.body.description,
        breakMode: t.body.breakMode,
        details: t.body.details
      };
  }
  scopes(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "scopes"));
    const i = this.getNewCancellationToken(t);
    return this.raw.scopes({ frameId: e }, i);
  }
  variables(e, t, i, s, n) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "variables"));
    const o = t ? this.getNewCancellationToken(t) : void 0;
    return this.raw.variables({ variablesReference: e, filter: i, start: s, count: n }, o);
  }
  evaluate(e, t, i) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "evaluate"));
    return this.raw.evaluate({ expression: e, frameId: t, context: i });
  }
  async restartFrame(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "restartFrame"));
    await this.raw.restartFrame({ frameId: e }, t);
  }
  setLastSteppingGranularity(e, t) {
    const i = this.getThread(e);
    i && (i.lastSteppingGranularity = t);
  }
  async next(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "next"));
    this.setLastSteppingGranularity(e, t), await this.raw.next({ threadId: e, granularity: t });
  }
  async stepIn(e, t, i) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "stepIn"));
    this.setLastSteppingGranularity(e, i), await this.raw.stepIn({ threadId: e, targetId: t, granularity: i });
  }
  async stepOut(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "stepOut"));
    this.setLastSteppingGranularity(e, t), await this.raw.stepOut({ threadId: e, granularity: t });
  }
  async stepBack(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "stepBack"));
    this.setLastSteppingGranularity(e, t), await this.raw.stepBack({ threadId: e, granularity: t });
  }
  async continue(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "continue"));
    await this.raw.continue({ threadId: e });
  }
  async reverseContinue(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "reverse continue"));
    await this.raw.reverseContinue({ threadId: e });
  }
  async pause(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "pause"));
    await this.raw.pause({ threadId: e });
  }
  async terminateThreads(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "terminateThreads"));
    await this.raw.terminateThreads({ threadIds: e });
  }
  setVariable(e, t, i) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "setVariable"));
    return this.raw.setVariable({ variablesReference: e, name: t, value: i });
  }
  setExpression(e, t, i) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "setExpression"));
    return this.raw.setExpression({ expression: t, value: i, frameId: e });
  }
  gotoTargets(e, t, i) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "gotoTargets"));
    return this.raw.gotoTargets({ source: e, line: t, column: i });
  }
  goto(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "goto"));
    return this.raw.goto({ threadId: e, targetId: t });
  }
  loadSource(e) {
    if (!this.raw)
      return Promise.reject(new Error(c(
        "noDebugAdapter",
        "No debugger available, can not send '{0}'",
        "loadSource"
      )));
    const t = this.getSourceForUri(e);
    let i;
    if (t)
      i = t.raw;
    else {
      const s = Ji.getEncodedDebugData(e);
      i = { path: s.path, sourceReference: s.sourceReference };
    }
    return this.raw.source({ sourceReference: i.sourceReference || 0, source: i });
  }
  async getLoadedSources() {
    if (!this.raw)
      return Promise.reject(new Error(c(
        "noDebugAdapter",
        "No debugger available, can not send '{0}'",
        "getLoadedSources"
      )));
    const e = await this.raw.loadedSources({});
    return e && e.body && e.body.sources ? e.body.sources.map((t) => this.getSource(t)) : [];
  }
  async completions(e, t, i, s, n, o) {
    if (!this.raw)
      return Promise.reject(new Error(c(
        "noDebugAdapter",
        "No debugger available, can not send '{0}'",
        "completions"
      )));
    const r = this.getNewCancellationToken(t, o);
    return this.raw.completions({
      frameId: e,
      text: i,
      column: s.column,
      line: s.lineNumber
    }, r);
  }
  async stepInTargets(e) {
    if (!this.raw)
      return Promise.reject(new Error(c(
        "noDebugAdapter",
        "No debugger available, can not send '{0}'",
        "stepInTargets"
      )));
    const t = await this.raw.stepInTargets({ frameId: e });
    return t == null ? void 0 : t.body.targets;
  }
  async cancel(e) {
    return this.raw ? this.raw.cancel({ progressId: e }) : Promise.reject(new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "cancel")));
  }
  async disassemble(e, t, i, s) {
    var o;
    if (!this.raw)
      return Promise.reject(new Error(c(
        "noDebugAdapter",
        "No debugger available, can not send '{0}'",
        "disassemble"
      )));
    const n = await this.raw.disassemble({ memoryReference: e, offset: t, instructionOffset: i, instructionCount: s, resolveSymbols: !0 });
    return (o = n == null ? void 0 : n.body) == null ? void 0 : o.instructions;
  }
  readMemory(e, t, i) {
    return this.raw ? this.raw.readMemory({ count: i, memoryReference: e, offset: t }) : Promise.reject(new Error(c(
      "noDebugAdapter",
      "No debugger available, can not send '{0}'",
      "readMemory"
    )));
  }
  writeMemory(e, t, i, s) {
    return this.raw ? this.raw.writeMemory({ memoryReference: e, offset: t, allowPartial: s, data: i }) : Promise.reject(new Error(c(
      "noDebugAdapter",
      "No debugger available, can not send '{0}'",
      "disassemble"
    )));
  }
  getThread(e) {
    return this.threads.get(e);
  }
  getAllThreads() {
    const e = [];
    return this.threadIds.forEach((t) => {
      const i = this.threads.get(t);
      i && e.push(i);
    }), e;
  }
  clearThreads(e, t = void 0) {
    if (t != null) {
      const i = this.threads.get(t);
      i && (i.clearCallStack(), i.stoppedDetails = void 0, i.stopped = !1, e && this.threads.delete(t));
    } else
      this.threads.forEach((i) => {
        i.clearCallStack(), i.stoppedDetails = void 0, i.stopped = !1;
      }), e && (this.threads.clear(), this.threadIds = [], yi.allValues.clear());
  }
  getStoppedDetails() {
    return this.stoppedDetails.length >= 1 ? this.stoppedDetails[0] : void 0;
  }
  rawUpdate(e) {
    this.threadIds = [], e.threads.forEach((i) => {
      if (this.threadIds.push(i.id), !this.threads.has(i.id))
        this.threads.set(i.id, new Ve(this, i.name, i.id));
      else if (i.name) {
        const s = this.threads.get(i.id);
        s && (s.name = i.name);
      }
    }), this.threads.forEach((i) => {
      this.threadIds.indexOf(i.threadId) === -1 && this.threads.delete(i.threadId);
    });
    const t = e.stoppedDetails;
    if (t)
      if (t.allThreadsStopped)
        this.threads.forEach((i) => {
          var s;
          i.stoppedDetails = i.threadId === t.threadId ? t : { reason: (s = i.stoppedDetails) == null ? void 0 : s.reason }, i.stopped = !0, i.clearCallStack();
        });
      else {
        const i = typeof t.threadId == "number" ? this.threads.get(t.threadId) : void 0;
        i && (i.stoppedDetails = t, i.clearCallStack(), i.stopped = !0);
      }
  }
  async fetchThreads(e) {
    if (this.raw) {
      const t = await this.raw.threads();
      t && t.body && t.body.threads && this.model.rawUpdate({
        sessionId: this.getId(),
        threads: t.body.threads,
        stoppedDetails: e
      });
    }
  }
  initializeForTest(e) {
    this.raw = e, this.registerListeners();
  }
  registerListeners() {
    if (!this.raw)
      return;
    this.rawListeners.push(this.raw.onDidInitialize(async () => {
      Rt(c("debuggingStarted", "Debugging started."));
      const i = async () => {
        var s;
        if (this.raw && this.raw.capabilities.supportsConfigurationDoneRequest)
          try {
            await this.raw.configurationDone();
          } catch (n) {
            this.notificationService.error(n), (s = this.raw) == null || s.disconnect({});
          }
      };
      try {
        await this.debugService.sendAllBreakpoints(this);
      } finally {
        await i(), await this.fetchThreads();
      }
    }));
    const e = new Yn();
    this.rawListeners.push(this.raw.onDidStop(async (i) => {
      e.queue(async () => {
        this.passFocusScheduler.cancel(), this.stoppedDetails.push(i.body), await this.fetchThreads(i.body);
        const s = this.debugService.getViewModel().focusedThread, n = s !== void 0 && s.session === this && !this.threads.has(s.threadId);
        n && this.debugService.focusStackFrame(void 0, void 0);
        const o = typeof i.body.threadId == "number" ? this.getThread(i.body.threadId) : void 0;
        if (o) {
          const r = this.model.refreshTopOfCallstack(o), a = async () => {
            if (n || !i.body.preserveFocusHint && o.getCallStack().length) {
              const u = this.debugService.getViewModel().focusedStackFrame;
              if (!u || u.thread.session === this) {
                const g = !this.configurationService.getValue("debug").focusEditorOnBreak;
                await this.debugService.focusStackFrame(void 0, o, void 0, { preserveFocus: g });
              }
              o.stoppedDetails && (o.stoppedDetails.reason === "breakpoint" && this.configurationService.getValue("debug").openDebug === "openOnDebugBreak" && !this.suppressDebugView && await this.paneCompositeService.openPaneComposite(De, 0), this.configurationService.getValue("debug").focusWindowOnBreak && !this.workbenchEnvironmentService.extensionTestsLocationURI && await this.hostService.focus({ force: !0 }));
            }
          };
          await r.topCallStack, a(), await r.wholeCallStack;
          const d = this.debugService.getViewModel().focusedStackFrame;
          (!d || !d.source || d.source.presentationHint === "deemphasize" || d.presentationHint === "deemphasize") && a();
        }
        this._onDidChangeState.fire();
      });
    })), this.rawListeners.push(this.raw.onDidThread((i) => {
      e.queue(async () => {
        if (i.body.reason === "started")
          this.fetchThreadsScheduler || (this.fetchThreadsScheduler = new oe(() => {
            this.fetchThreads();
          }, 100), this.rawListeners.push(this.fetchThreadsScheduler)), this.fetchThreadsScheduler.isScheduled() || this.fetchThreadsScheduler.schedule();
        else if (i.body.reason === "exited") {
          this.model.clearThreads(this.getId(), !0, i.body.threadId);
          const s = this.debugService.getViewModel(), n = s.focusedThread;
          this.passFocusScheduler.cancel(), n && i.body.threadId === n.threadId && this.debugService.focusStackFrame(void 0, void 0, s.focusedSession, { explicit: !1 });
        }
      });
    })), this.rawListeners.push(this.raw.onDidTerminateDebugee(async (i) => {
      Rt(c("debuggingStopped", "Debugging stopped.")), i.body && i.body.restart ? await this.debugService.restartSession(this, i.body.restart) : this.raw && await this.raw.disconnect({ terminateDebuggee: !1 });
    })), this.rawListeners.push(this.raw.onDidContinued((i) => {
      e.queue(async () => {
        const s = i.body.allThreadsContinued !== !1 ? void 0 : i.body.threadId;
        if (typeof s == "number") {
          this.stoppedDetails = this.stoppedDetails.filter((o) => o.threadId !== s);
          const n = this.cancellationMap.get(s);
          this.cancellationMap.delete(s), n == null || n.forEach((o) => o.cancel());
        } else
          this.stoppedDetails = [], this.cancelAllRequests();
        this.lastContinuedThreadId = s, this.passFocusScheduler.schedule(), this.model.clearThreads(this.getId(), !1, s), this._onDidChangeState.fire();
      });
    }));
    const t = new Yn();
    this.rawListeners.push(this.raw.onDidOutput(async (i) => {
      const s = i.body.category === "stderr" ? fe.Error : i.body.category === "console" ? fe.Warning : fe.Info;
      if (i.body.variablesReference) {
        const n = i.body.source && i.body.line ? {
          lineNumber: i.body.line,
          column: i.body.column ? i.body.column : 1,
          source: this.getSource(i.body.source)
        } : void 0, r = new yi(this, void 0, i.body.variablesReference, Zt()).getChildren();
        t.queue(async () => {
          const a = await r;
          if (a.length === 1) {
            this.appendToRepl({ output: i.body.output, expression: a[0], sev: s, source: n }, i.body.category === "important");
            return;
          }
          a.forEach((d) => {
            d.name = null, this.appendToRepl({ output: "", expression: d, sev: s, source: n }, i.body.category === "important");
          });
        });
        return;
      }
      t.queue(async () => {
        if (!i.body || !this.raw)
          return;
        if (i.body.category === "telemetry") {
          const o = this.raw.dbgr.getCustomTelemetryEndpoint();
          if (o && this.telemetryService.telemetryLevel !== 0) {
            let r = i.body.data;
            !o.sendErrorTelemetry && i.body.data && (r = Wl(i.body.data)), this.customEndpointTelemetryService.publicLog(o, i.body.output, r);
          }
          return;
        }
        const n = i.body.source && i.body.line ? {
          lineNumber: i.body.line,
          column: i.body.column ? i.body.column : 1,
          source: this.getSource(i.body.source)
        } : void 0;
        if (i.body.group === "start" || i.body.group === "startCollapsed") {
          const o = i.body.group === "start";
          this.repl.startGroup(i.body.output || "", o, n);
          return;
        }
        i.body.group === "end" && (this.repl.endGroup(), !i.body.output) || typeof i.body.output == "string" && this.appendToRepl({ output: i.body.output, sev: s, source: n }, i.body.category === "important");
      });
    })), this.rawListeners.push(this.raw.onDidBreakpoint((i) => {
      const s = i.body && i.body.breakpoint ? i.body.breakpoint.id : void 0, n = this.model.getBreakpoints().find((d) => d.getIdFromAdapter(this.getId()) === s), o = this.model.getFunctionBreakpoints().find((d) => d.getIdFromAdapter(this.getId()) === s), r = this.model.getDataBreakpoints().find((d) => d.getIdFromAdapter(this.getId()) === s), a = this.model.getExceptionBreakpoints().find((d) => d.getIdFromAdapter(this.getId()) === s);
      if (i.body.reason === "new" && i.body.breakpoint.source && i.body.breakpoint.line) {
        const d = this.getSource(i.body.breakpoint.source), u = this.model.addBreakpoints(d.uri, [{
          column: i.body.breakpoint.column,
          enabled: !0,
          lineNumber: i.body.breakpoint.line
        }], !1);
        if (u.length === 1) {
          const g = /* @__PURE__ */ new Map([[u[0].getId(), i.body.breakpoint]]);
          this.model.setBreakpointSessionData(this.getId(), this.capabilities, g);
        }
      }
      if (i.body.reason === "removed" && (n && this.model.removeBreakpoints([n]), o && this.model.removeFunctionBreakpoints(o.getId()), r && this.model.removeDataBreakpoints(r.getId())), i.body.reason === "changed") {
        if (n) {
          n.column || (i.body.breakpoint.column = void 0);
          const d = /* @__PURE__ */ new Map([[n.getId(), i.body.breakpoint]]);
          this.model.setBreakpointSessionData(this.getId(), this.capabilities, d);
        }
        if (o) {
          const d = /* @__PURE__ */ new Map([[o.getId(), i.body.breakpoint]]);
          this.model.setBreakpointSessionData(this.getId(), this.capabilities, d);
        }
        if (r) {
          const d = /* @__PURE__ */ new Map([[r.getId(), i.body.breakpoint]]);
          this.model.setBreakpointSessionData(this.getId(), this.capabilities, d);
        }
        if (a) {
          const d = /* @__PURE__ */ new Map([[a.getId(), i.body.breakpoint]]);
          this.model.setBreakpointSessionData(this.getId(), this.capabilities, d);
        }
      }
    })), this.rawListeners.push(this.raw.onDidLoadedSource((i) => {
      this._onDidLoadedSource.fire({
        reason: i.body.reason,
        source: this.getSource(i.body.source)
      });
    })), this.rawListeners.push(this.raw.onDidCustomEvent((i) => {
      this._onDidCustomEvent.fire(i);
    })), this.rawListeners.push(this.raw.onDidProgressStart((i) => {
      this._onDidProgressStart.fire(i);
    })), this.rawListeners.push(this.raw.onDidProgressUpdate((i) => {
      this._onDidProgressUpdate.fire(i);
    })), this.rawListeners.push(this.raw.onDidProgressEnd((i) => {
      this._onDidProgressEnd.fire(i);
    })), this.rawListeners.push(this.raw.onDidInvalidateMemory((i) => {
      this._onDidInvalidMemory.fire(i);
    })), this.rawListeners.push(this.raw.onDidInvalidated(async (i) => {
      i.body.areas && i.body.areas.length === 1 && (i.body.areas[0] === "variables" || i.body.areas[0] === "watch") || (this.cancelAllRequests(), this.model.clearThreads(this.getId(), !0), await this.fetchThreads(this.getStoppedDetails()));
      const s = this.debugService.getViewModel();
      s.focusedSession === this && s.updateViews();
    })), this.rawListeners.push(this.raw.onDidExitAdapter((i) => this.onDidExitAdapter(i)));
  }
  onDidExitAdapter(e) {
    this.initialized = !0, this.model.setBreakpointSessionData(this.getId(), this.capabilities, void 0), this.shutdown(), this._onDidEndAdapter.fire(e);
  }
  shutdown() {
    var e;
    U(this.rawListeners), this.raw && (this.raw.disconnect({}), this.raw.dispose(), this.raw = void 0), (e = this.fetchThreadsScheduler) == null || e.dispose(), this.fetchThreadsScheduler = void 0, this.passFocusScheduler.cancel(), this.passFocusScheduler.dispose(), this.model.clearThreads(this.getId(), !0), this._onDidChangeState.fire();
  }
  getSourceForUri(e) {
    return this.sources.get(this.uriIdentityService.asCanonicalUri(e).toString());
  }
  getSource(e) {
    let t = new Ji(e, this.getId(), this.uriIdentityService, this.logService);
    const i = t.uri.toString(), s = this.sources.get(i);
    return s ? (t = s, t.raw = ac(t.raw, e), t.raw && e && (t.raw.presentationHint = e.presentationHint)) : this.sources.set(i, t), t;
  }
  getRawSource(e) {
    const t = this.getSourceForUri(e);
    if (t)
      return t.raw;
    {
      const i = Ji.getEncodedDebugData(e);
      return { name: i.name, path: i.path, sourceReference: i.sourceReference };
    }
  }
  getNewCancellationToken(e, t) {
    const i = new Qe(t), s = this.cancellationMap.get(e) || [];
    return s.push(i), this.cancellationMap.set(e, s), i.token;
  }
  cancelAllRequests() {
    this.cancellationMap.forEach((e) => e.forEach((t) => t.cancel())), this.cancellationMap.clear();
  }
  getReplElements() {
    return this.repl.getReplElements();
  }
  hasSeparateRepl() {
    return !this.parentSession || this._options.repl !== "mergeWithParent";
  }
  removeReplExpressions() {
    this.repl.removeReplExpressions();
  }
  async addReplExpression(e, t) {
    await this.repl.addReplExpression(this, e, t), this.debugService.getViewModel().updateViews();
  }
  appendToRepl(e, t) {
    this.repl.appendToRepl(this, e), t && this.notificationService.notify({ message: e.output.toString(), severity: e.sev, source: this.name });
  }
};
go = I([
  h(5, T),
  h(6, we),
  h(7, cc),
  h(8, O),
  h(9, dc),
  h(10, _e),
  h(11, Nl),
  h(12, Ct),
  h(13, Js),
  h(14, Le),
  h(15, K),
  h(16, Rl),
  h(17, nr),
  h(18, ei)
], go);
function Pn(l, e) {
  return (t, i = null, s) => {
    const n = e((o) => {
      if (l(o))
        return n.dispose(), t.call(i, o);
    }, null, s);
    return n;
  };
}
const Ea = "debug.taskerrorchoice";
let po = class {
  constructor(e, t, i, s, n, o, r) {
    this.taskService = e, this.markerService = t, this.configurationService = i, this.viewsService = s, this.dialogService = n, this.storageService = o, this.commandService = r, this.canceled = !1;
  }
  cancel() {
    this.canceled = !0;
  }
  async runTaskAndCheckErrors(e, t) {
    try {
      this.canceled = !1;
      const i = await this.runTask(e, t);
      if (this.canceled || i && i.exitCode === void 0)
        return 0;
      const s = t ? this.markerService.read({ severities: $l.Error, take: 2 }).length : 0, n = i && i.exitCode === 0, o = i && i.exitCode !== 0, r = this.configurationService.getValue("debug").onTaskErrors;
      if (n || r === "debugAnyway" || s === 0 && !o)
        return 1;
      if (r === "showErrors")
        return await this.viewsService.openView(wa.MARKERS_VIEW_ID, !0), Promise.resolve(0);
      if (r === "abort")
        return Promise.resolve(0);
      const a = typeof t == "string" ? t : t ? t.name : "", d = s > 1 ? c(
        "preLaunchTaskErrors",
        "Errors exist after running preLaunchTask '{0}'.",
        a
      ) : s === 1 ? c(
        "preLaunchTaskError",
        "Error exists after running preLaunchTask '{0}'.",
        a
      ) : i && typeof i.exitCode == "number" ? c(
        "preLaunchTaskExitCode",
        "The preLaunchTask '{0}' terminated with exit code {1}.",
        a,
        i.exitCode
      ) : c(
        "preLaunchTaskTerminated",
        "The preLaunchTask '{0}' terminated.",
        a
      );
      let u;
      (function(w) {
        w[w.DebugAnyway = 1] = "DebugAnyway", w[w.ShowErrors = 2] = "ShowErrors", w[w.Cancel = 0] = "Cancel";
      })(u || (u = {}));
      const { result: g, checkboxChecked: p } = await this.dialogService.prompt({
        type: fe.Warning,
        message: d,
        buttons: [
          {
            label: c(
              { key: "debugAnyway", comment: ["&& denotes a mnemonic"] },
              "&&Debug Anyway"
            ),
            run: () => u.DebugAnyway
          },
          {
            label: c({ key: "showErrors", comment: ["&& denotes a mnemonic"] }, "&&Show Errors"),
            run: () => u.ShowErrors
          }
        ],
        cancelButton: {
          label: c("abort", "Abort"),
          run: () => u.Cancel
        },
        checkbox: {
          label: c("remember", "Remember my choice in user settings")
        }
      }), f = g === u.DebugAnyway, S = g === u.Cancel;
      return p && this.configurationService.updateValue("debug.onTaskErrors", g === u.DebugAnyway ? "debugAnyway" : S ? "abort" : "showErrors"), S ? Promise.resolve(0) : f ? 1 : (await this.viewsService.openView(wa.MARKERS_VIEW_ID, !0), Promise.resolve(0));
    } catch (i) {
      const s = this.taskService.configureAction(), n = JSON.parse(this.storageService.get(Ea, 1, "{}"));
      let o = -1, r;
      if (function(a) {
        a[a.DebugAnyway = 0] = "DebugAnyway", a[a.ConfigureTask = 1] = "ConfigureTask", a[a.Cancel = 2] = "Cancel";
      }(r || (r = {})), n[i.message] !== void 0)
        o = n[i.message];
      else {
        const { result: a, checkboxChecked: d } = await this.dialogService.prompt({
          type: fe.Error,
          message: i.message,
          buttons: [
            {
              label: c(
                { key: "debugAnyway", comment: ["&& denotes a mnemonic"] },
                "&&Debug Anyway"
              ),
              run: () => r.DebugAnyway
            },
            {
              label: s.label,
              run: () => r.ConfigureTask
            }
          ],
          cancelButton: {
            run: () => r.Cancel
          },
          checkbox: {
            label: c("rememberTask", "Remember my choice for this task")
          }
        });
        o = a, d && (n[i.message] = o, this.storageService.store(Ea, JSON.stringify(n), 1, 1));
      }
      return o === r.ConfigureTask && await s.run(), o === r.DebugAnyway ? 1 : 0;
    }
  }
  async runTask(e, t) {
    if (!t)
      return Promise.resolve(null);
    if (!e)
      return Promise.reject(new Error(c(
        "invalidTaskReference",
        "Task '{0}' can not be referenced from a launch configuration that is in a different workspace folder.",
        typeof t == "string" ? t : t.type
      )));
    const i = await this.taskService.getTask(e, t);
    if (!i) {
      const r = typeof t == "string" ? c("DebugTaskNotFoundWithTaskId", "Could not find the task '{0}'.", t) : c("DebugTaskNotFound", "Could not find the specified task.");
      return Promise.reject(oc(r, [new Z(
        ss,
        od,
        void 0,
        !0,
        () => this.commandService.executeCommand(ss)
      )]));
    }
    let s = !1;
    const n = new Promise((r, a) => Pn((d) => (d.kind === "inactive" || d.kind === "processEnded" && d.exitCode === void 0) && d.taskId === i._id, this.taskService.onDidStateChange)((d) => {
      s = !0, r(d.kind === "processEnded" ? { exitCode: d.exitCode } : null);
    })), o = this.taskService.getActiveTasks().then(async (r) => {
      if (r.find((d) => d._id === i._id))
        return (await this.taskService.getBusyTasks()).find((u) => u._id === i._id) ? (s = !0, n) : Promise.resolve(null);
      Pn((d) => (d.kind === "active" || d.kind === "dependsOnStarted") && d.taskId === i._id, this.taskService.onDidStateChange)(() => {
        s = !0;
      });
      const a = this.taskService.run(i);
      return i.configurationProperties.isBackground ? n : a.then(Oi);
    });
    return new Promise((r, a) => {
      const d = new Promise(
        (u) => Pn((g) => g.kind === "acquiredInput" && g.taskId === i._id, this.taskService.onDidStateChange)(() => {
          u();
        })
      );
      o.then((u) => {
        s = !0, r(u);
      }, (u) => a(u)), d.then(() => {
        const u = i.configurationProperties.isBackground ? 5e3 : 1e4;
        setTimeout(() => {
          if (!s) {
            const g = typeof t == "string" ? c(
              "taskNotTrackedWithTaskId",
              "The task '{0}' cannot be tracked. Make sure to have a problem matcher defined.",
              t
            ) : c(
              "taskNotTracked",
              "The task '{0}' cannot be tracked. Make sure to have a problem matcher defined.",
              JSON.stringify(t)
            );
            a({ severity: fe.Error, message: g });
          }
        }, u);
      });
    });
  }
};
po = I([
  h(0, Ul),
  h(1, Hl),
  h(2, O),
  h(3, Ae),
  h(4, Jt),
  h(5, it),
  h(6, We)
], po);
class ip {
  constructor() {
    this.stopped = !1, this.stopEmitter = new B(), this.onDidSessionStop = this.stopEmitter.event;
  }
  sessionStopped() {
    this.stopped || (this.stopped = !0, this.stopEmitter.fire());
  }
}
const Fn = "debug.breakpoint", Wn = "debug.functionbreakpoint", Un = "debug.databreakpoint", Hn = "debug.exceptionbreakpoint", $n = "debug.watchexpressions", Ia = "debug.chosenenvironment", xa = "debug.uxstate";
let fo = class {
  constructor(e, t, i, s) {
    this.storageService = e, this.textFileService = t, this.uriIdentityService = i, this.logService = s;
  }
  loadDebugUxState() {
    return this.storageService.get(xa, 1, "default");
  }
  storeDebugUxState(e) {
    this.storageService.store(xa, e, 1, 1);
  }
  loadBreakpoints() {
    let e;
    try {
      e = JSON.parse(this.storageService.get(Fn, 1, "[]")).map((t) => new rd(ue.parse(t.uri.external || t.source.uri.external), t.lineNumber, t.column, t.enabled, t.condition, t.hitCondition, t.logMessage, t.adapterData, this.textFileService, this.uriIdentityService, this.logService, t.id));
    } catch {
    }
    return e || [];
  }
  loadFunctionBreakpoints() {
    let e;
    try {
      e = JSON.parse(this.storageService.get(Wn, 1, "[]")).map((t) => new ad(t.name, t.enabled, t.hitCondition, t.condition, t.logMessage, t.id));
    } catch {
    }
    return e || [];
  }
  loadExceptionBreakpoints() {
    let e;
    try {
      e = JSON.parse(this.storageService.get(Hn, 1, "[]")).map((t) => new qh(
        t.filter,
        t.label,
        t.enabled,
        t.supportsCondition,
        t.condition,
        t.description,
        t.conditionDescription,
        !!t.fallback
      ));
    } catch {
    }
    return e || [];
  }
  loadDataBreakpoints() {
    let e;
    try {
      e = JSON.parse(this.storageService.get(Un, 1, "[]")).map((t) => new cd(
        t.description,
        t.dataId,
        !0,
        t.enabled,
        t.hitCondition,
        t.condition,
        t.logMessage,
        t.accessTypes,
        t.accessType,
        t.id
      ));
    } catch {
    }
    return e || [];
  }
  loadWatchExpressions() {
    let e;
    try {
      e = JSON.parse(this.storageService.get($n, 1, "[]")).map((t) => new Y(t.name, t.id));
    } catch {
    }
    return e || [];
  }
  loadChosenEnvironments() {
    return JSON.parse(this.storageService.get(Ia, 1, "{}"));
  }
  storeChosenEnvironments(e) {
    this.storageService.store(Ia, JSON.stringify(e), 1, 1);
  }
  storeWatchExpressions(e) {
    e.length ? this.storageService.store($n, JSON.stringify(e.map((t) => ({ name: t.name, id: t.getId() }))), 1, 1) : this.storageService.remove($n, 1);
  }
  storeBreakpoints(e) {
    const t = e.getBreakpoints();
    t.length ? this.storageService.store(Fn, JSON.stringify(t), 1, 1) : this.storageService.remove(Fn, 1);
    const i = e.getFunctionBreakpoints();
    i.length ? this.storageService.store(Wn, JSON.stringify(i), 1, 1) : this.storageService.remove(Wn, 1);
    const s = e.getDataBreakpoints().filter((o) => o.canPersist);
    s.length ? this.storageService.store(Un, JSON.stringify(s), 1, 1) : this.storageService.remove(Un, 1);
    const n = e.getExceptionBreakpoints();
    n.length ? this.storageService.store(Hn, JSON.stringify(n), 1, 1) : this.storageService.remove(Hn, 1);
  }
};
fo = I([
  h(0, it),
  h(1, Qa),
  h(2, Le),
  h(3, ei)
], fo);
let bo = class {
  constructor(e, t) {
    this.model = e, this.telemetryService = t;
  }
  logDebugSessionStart(e, t) {
    const i = e.getMainExtensionDescriptor();
    this.telemetryService.publicLog("debugSessionStart", {
      type: e.type,
      breakpointCount: this.model.getBreakpoints().length,
      exceptionBreakpoints: this.model.getExceptionBreakpoints(),
      watchExpressionsCount: this.model.getWatchExpressions().length,
      extensionName: i.identifier.value,
      isBuiltin: i.isBuiltin,
      launchJsonExists: t
    });
  }
  logDebugSessionStop(e, t) {
    const i = this.model.getBreakpoints();
    this.telemetryService.publicLog("debugSessionStop", {
      type: e && e.configuration.type,
      success: t.emittedStopped || i.length === 0,
      sessionLengthInSeconds: t.sessionLengthInSeconds,
      breakpointCount: i.length,
      watchExpressionsCount: this.model.getWatchExpressions().length
    });
  }
};
bo = I([
  h(1, we)
], bo);
class sp {
  constructor(e) {
    this.contextKeyService = e, this.firstSessionStart = !0, this._onDidFocusSession = new B(), this._onDidFocusThread = new B(), this._onDidFocusStackFrame = new B(), this._onDidSelectExpression = new B(), this._onDidEvaluateLazyExpression = new B(), this._onWillUpdateViews = new B(), e.bufferChangeEvents(() => {
      this.expressionSelectedContextKey = zl.bindTo(e), this.loadedScriptsSupportedContextKey = uc.bindTo(e), this.stepBackSupportedContextKey = ar.bindTo(e), this.focusedSessionIsAttach = Te.bindTo(e), this.restartFrameSupportedContextKey = hc.bindTo(e), this.stepIntoTargetsSupported = cr.bindTo(e), this.jumpToCursorSupported = dr.bindTo(e), this.setVariableSupported = lr.bindTo(e), this.setExpressionSupported = ur.bindTo(e), this.multiSessionDebug = gc.bindTo(e), this.terminateDebuggeeSupported = nt.bindTo(e), this.suspendDebuggeeSupported = es.bindTo(e), this.disassembleRequestSupported = Yi.bindTo(e), this.focusedStackFrameHasInstructionPointerReference = pc.bindTo(e);
    });
  }
  getId() {
    return "root";
  }
  get focusedSession() {
    return this._focusedSession;
  }
  get focusedThread() {
    return this._focusedThread;
  }
  get focusedStackFrame() {
    return this._focusedStackFrame;
  }
  setFocus(e, t, i, s) {
    const n = this._focusedStackFrame !== e, o = this._focusedSession !== i, r = this._focusedThread !== t;
    this._focusedStackFrame = e, this._focusedThread = t, this._focusedSession = i, this.contextKeyService.bufferChangeEvents(() => {
      this.loadedScriptsSupportedContextKey.set(i ? !!i.capabilities.supportsLoadedSourcesRequest : !1), this.stepBackSupportedContextKey.set(i ? !!i.capabilities.supportsStepBack : !1), this.restartFrameSupportedContextKey.set(i ? !!i.capabilities.supportsRestartFrame : !1), this.stepIntoTargetsSupported.set(i ? !!i.capabilities.supportsStepInTargetsRequest : !1), this.jumpToCursorSupported.set(i ? !!i.capabilities.supportsGotoTargetsRequest : !1), this.setVariableSupported.set(i ? !!i.capabilities.supportsSetVariable : !1), this.setExpressionSupported.set(i ? !!i.capabilities.supportsSetExpression : !1), this.terminateDebuggeeSupported.set(i ? !!i.capabilities.supportTerminateDebuggee : !1), this.suspendDebuggeeSupported.set(i ? !!i.capabilities.supportSuspendDebuggee : !1), this.disassembleRequestSupported.set(!!(i != null && i.capabilities.supportsDisassembleRequest)), this.focusedStackFrameHasInstructionPointerReference.set(!!(e != null && e.instructionPointerReference));
      const a = !!i && fc(i);
      this.focusedSessionIsAttach.set(a);
    }), o && this._onDidFocusSession.fire(i), n ? this._onDidFocusStackFrame.fire({ stackFrame: e, explicit: s, session: i }) : r && this._onDidFocusThread.fire({ thread: t, explicit: s, session: i });
  }
  get onDidFocusSession() {
    return this._onDidFocusSession.event;
  }
  get onDidFocusThread() {
    return this._onDidFocusThread.event;
  }
  get onDidFocusStackFrame() {
    return this._onDidFocusStackFrame.event;
  }
  getSelectedExpression() {
    return this.selectedExpression;
  }
  setSelectedExpression(e, t) {
    this.selectedExpression = e ? { expression: e, settingWatch: t } : void 0, this.expressionSelectedContextKey.set(!!e), this._onDidSelectExpression.fire(this.selectedExpression);
  }
  get onDidSelectExpression() {
    return this._onDidSelectExpression.event;
  }
  get onDidEvaluateLazyExpression() {
    return this._onDidEvaluateLazyExpression.event;
  }
  updateViews() {
    this._onWillUpdateViews.fire();
  }
  get onWillUpdateViews() {
    return this._onWillUpdateViews.event;
  }
  isMultiSessionView() {
    return !!this.multiSessionDebug.get();
  }
  setMultiSessionView(e) {
    this.multiSessionDebug.set(e);
  }
  async evaluateLazyExpression(e) {
    await e.evaluateLazy(), this._onDidEvaluateLazyExpression.fire(e);
  }
}
let Ii = class {
  constructor(e, t, i, s, n, o, r, a, d, u, g, p, f, S, w, m, y, _, v, C) {
    this.editorService = e, this.paneCompositeService = t, this.viewsService = i, this.viewDescriptorService = s, this.notificationService = n, this.dialogService = o, this.layoutService = r, this.contextService = a, this.contextKeyService = d, this.lifecycleService = u, this.instantiationService = g, this.extensionService = p, this.fileService = f, this.configurationService = S, this.extensionHostDebugService = w, this.activityService = m, this.commandService = y, this.quickInputService = _, this.workspaceTrustRequestService = v, this.uriIdentityService = C, this.disposables = new te(), this.initializing = !1, this.sessionCancellationTokens = /* @__PURE__ */ new Map(), this.haveDoneLazySetup = !1, this.breakpointsToSendOnResourceSaved = /* @__PURE__ */ new Set(), this._onDidChangeState = new B(), this._onDidNewSession = new B(), this._onWillNewSession = new B(), this._onDidEndSession = new B(), this.adapterManager = this.instantiationService.createInstance(ao, { onDidNewSession: this.onDidNewSession }), this.disposables.add(this.adapterManager), this.configurationManager = this.instantiationService.createInstance(co, this.adapterManager), this.disposables.add(this.configurationManager), this.debugStorage = this.instantiationService.createInstance(fo), this.chosenEnvironments = this.debugStorage.loadChosenEnvironments(), this.model = this.instantiationService.createInstance(Gh, this.debugStorage), this.telemetry = this.instantiationService.createInstance(bo, this.model), this.viewModel = new sp(d), this.taskRunner = this.instantiationService.createInstance(po), this.disposables.add(this.fileService.onDidFilesChange((b) => this.onFileChanges(b))), this.disposables.add(this.lifecycleService.onWillShutdown(this.dispose, this)), this.disposables.add(this.extensionHostDebugService.onAttachSession((b) => {
      const D = this.model.getSession(b.sessionId, !0);
      D && (D.configuration.request = "attach", D.configuration.port = b.port, D.setSubId(b.subId), this.launchOrAttachToSession(D));
    })), this.disposables.add(this.extensionHostDebugService.onTerminateSession((b) => {
      const D = this.model.getSession(b.sessionId);
      D && D.subId === b.subId && D.disconnect();
    })), this.disposables.add(this.viewModel.onDidFocusStackFrame(() => {
      this.onStateChange();
    })), this.disposables.add(this.viewModel.onDidFocusSession((b) => {
      this.onStateChange(), b && this.setExceptionBreakpointFallbackSession(b.getId());
    })), this.disposables.add(Ze.any(this.adapterManager.onDidRegisterDebugger, this.configurationManager.onDidSelectConfiguration)(() => {
      const b = this.state !== 0 || this.configurationManager.getAllConfigurations().length > 0 && this.adapterManager.hasEnabledDebuggers() ? "default" : "simple";
      this.debugUx.set(b), this.debugStorage.storeDebugUxState(b);
    })), this.disposables.add(this.model.onDidChangeCallStack(() => {
      var D;
      const b = this.model.getSessions().filter((P) => !P.parentSession).length;
      if ((D = this.activity) == null || D.dispose(), b > 0) {
        const P = this.viewDescriptorService.getViewContainerByViewId(ts);
        P && (this.activity = this.activityService.showViewContainerActivity(P.id, { badge: new Kl(b, (se) => se === 1 ? c("1activeSession", "1 active session") : c("nActiveSessions", "{0} active sessions", se)) }));
      }
    })), this.disposables.add(e.onDidActiveEditorChange(() => {
      this.contextKeyService.bufferChangeEvents(() => {
        var b;
        e.activeEditor === ns.instance ? this.disassemblyViewFocus.set(!0) : (b = this.disassemblyViewFocus) == null || b.reset();
      });
    })), this.disposables.add(this.lifecycleService.onBeforeShutdown(() => {
      var b;
      for (const D of e.editors)
        ((b = D.resource) == null ? void 0 : b.scheme) === Kn && D.dispose();
    })), this.initContextKeys(d);
  }
  initContextKeys(e) {
    queueMicrotask(() => {
      e.bufferChangeEvents(() => {
        this.debugType = jl.bindTo(e), this.debugState = N.bindTo(e), this.hasDebugged = bc.bindTo(e), this.inDebugMode = F.bindTo(e), this.debugUx = ti.bindTo(e), this.debugUx.set(this.debugStorage.loadDebugUxState()), this.breakpointsExist = mc.bindTo(e), this.disassemblyViewFocus = Xl.bindTo(e);
      });
      const t = () => this.breakpointsExist.set(!!(this.model.getBreakpoints().length || this.model.getDataBreakpoints().length || this.model.getFunctionBreakpoints().length));
      t(), this.disposables.add(this.model.onDidChangeBreakpoints(() => t()));
    });
  }
  getModel() {
    return this.model;
  }
  getViewModel() {
    return this.viewModel;
  }
  getConfigurationManager() {
    return this.configurationManager;
  }
  getAdapterManager() {
    return this.adapterManager;
  }
  sourceIsNotAvailable(e) {
    this.model.sourceIsNotAvailable(e);
  }
  dispose() {
    this.disposables.dispose();
  }
  get state() {
    const e = this.viewModel.focusedSession;
    return e ? e.state : this.initializing ? 1 : 0;
  }
  get initializingOptions() {
    return this._initializingOptions;
  }
  startInitializingState(e) {
    this.initializing || (this.initializing = !0, this._initializingOptions = e, this.onStateChange());
  }
  endInitializingState() {
    this.initializing && (this.initializing = !1, this._initializingOptions = void 0, this.onStateChange());
  }
  cancelTokens(e) {
    if (e) {
      const t = this.sessionCancellationTokens.get(e);
      t && (t.cancel(), this.sessionCancellationTokens.delete(e));
    } else
      this.sessionCancellationTokens.forEach((t) => t.cancel()), this.sessionCancellationTokens.clear();
  }
  onStateChange() {
    const e = this.state;
    this.previousState !== e && (this.contextKeyService.bufferChangeEvents(() => {
      this.debugState.set(Qs(e)), this.inDebugMode.set(e !== 0);
      const t = e !== 0 && e !== 1 || this.adapterManager.hasEnabledDebuggers() && this.configurationManager.selectedConfiguration.name ? "default" : "simple";
      this.debugUx.set(t), this.debugStorage.storeDebugUxState(t);
    }), this.previousState = e, this._onDidChangeState.fire(e));
  }
  get onDidChangeState() {
    return this._onDidChangeState.event;
  }
  get onDidNewSession() {
    return this._onDidNewSession.event;
  }
  get onWillNewSession() {
    return this._onWillNewSession.event;
  }
  get onDidEndSession() {
    return this._onDidEndSession.event;
  }
  lazySetup() {
    this.haveDoneLazySetup || (this.disposables.add(this.fileService.registerProvider(Kn, new Qg(this))), this.haveDoneLazySetup = !0);
  }
  async startDebugging(e, t, i, s = !(i != null && i.parentSession)) {
    const n = i && i.noDebug ? c(
      "runTrust",
      "Running executes build tasks and program code from your workspace."
    ) : c(
      "debugTrust",
      "Debugging executes build tasks and program code from your workspace."
    );
    if (!await this.workspaceTrustRequestService.requestWorkspaceTrust({ message: n }))
      return !1;
    this.lazySetup(), this.startInitializingState(i), this.hasDebugged.set(!0);
    try {
      await this.extensionService.activateByEvent("onDebug"), s && await Qr(this.configurationService, this.editorService), await this.extensionService.whenInstalledExtensionsRegistered();
      let r, a;
      if (t || (t = this.configurationManager.selectedConfiguration.name), typeof t == "string" && e ? (r = e.getConfiguration(t), a = e.getCompound(t)) : typeof t != "string" && (r = t), a) {
        if (!a.configurations)
          throw new Error(c({ key: "compoundMustHaveConfigurations", comment: ['compound indicates a "compounds" configuration item', '"configurations" is an attribute and should not be localized'] }, 'Compound must have "configurations" attribute set in order to start multiple configurations.'));
        if (a.preLaunchTask && await this.taskRunner.runTaskAndCheckErrors((e == null ? void 0 : e.workspace) || this.contextService.getWorkspace(), a.preLaunchTask) === 0)
          return this.endInitializingState(), !1;
        a.stopAll && (i = { ...i, compoundRoot: new ip() });
        const g = (await Promise.all(a.configurations.map((p) => {
          const f = typeof p == "string" ? p : p.name;
          if (f === a.name)
            return Promise.resolve(!1);
          let S;
          if (typeof p == "string") {
            const w = this.configurationManager.getLaunches().filter((m) => !!m.getConfiguration(f));
            if (w.length === 1)
              S = w[0];
            else if (e && w.length > 1 && w.indexOf(e) >= 0)
              S = e;
            else
              throw new Error(w.length === 0 ? c("noConfigurationNameInWorkspace", "Could not find launch configuration '{0}' in the workspace.", f) : c("multipleConfigurationNamesInWorkspace", "There are multiple launch configurations '{0}' in the workspace. Use folder name to qualify the configuration.", f));
          } else if (p.folder) {
            const w = this.configurationManager.getLaunches().filter((m) => m.workspace && m.workspace.name === p.folder && !!m.getConfiguration(p.name));
            if (w.length === 1)
              S = w[0];
            else
              throw new Error(c("noFolderWithName", "Can not find folder with name '{0}' for configuration '{1}' in compound '{2}'.", p.folder, p.name, a.name));
          }
          return this.createSession(S, S.getConfiguration(f), i);
        }))).every((p) => !!p);
        return this.endInitializingState(), g;
      }
      if (t && !r) {
        const u = e ? c(
          "configMissing",
          "Configuration '{0}' is missing in 'launch.json'.",
          typeof t == "string" ? t : t.name
        ) : c(
          "launchJsonDoesNotExist",
          "'launch.json' does not exist for passed workspace folder."
        );
        throw new Error(u);
      }
      const d = await this.createSession(e, r, i);
      return this.endInitializingState(), d;
    } catch (r) {
      return this.notificationService.error(r), this.endInitializingState(), Promise.reject(r);
    }
  }
  async createSession(e, t, i) {
    let s;
    t ? s = t.type : t = /* @__PURE__ */ Object.create(null), (i && i.noDebug || i && typeof i.noDebug > "u" && i.parentSession && i.parentSession.configuration.noDebug) && (t.noDebug = !0);
    const n = Zi(t);
    let o, r;
    s || (r = this.editorService.activeEditor, r && r.resource && (s = this.chosenEnvironments[r.resource.toString()]), s || (o = await this.adapterManager.guessDebugger(!1), o && (s = o.type)));
    const a = new Qe(), d = Zt();
    this.sessionCancellationTokens.set(d, a);
    const u = await this.configurationManager.resolveConfigurationByProviders(e && e.workspace ? e.workspace.uri : void 0, s, t, a.token);
    if (u && u.type)
      try {
        let g = await this.substituteVariables(e, u);
        if (!g || a.token.isCancellationRequested)
          return !1;
        const p = (e == null ? void 0 : e.workspace) || this.contextService.getWorkspace();
        if (await this.taskRunner.runTaskAndCheckErrors(p, g.preLaunchTask) === 0)
          return !1;
        const S = await this.configurationManager.resolveDebugConfigurationWithSubstitutedVariables(e && e.workspace ? e.workspace.uri : void 0, s, g, a.token);
        if (!S)
          return e && s && S === null && !a.token.isCancellationRequested && await e.openConfigFile({ preserveFocus: !0, type: s }, a.token), !1;
        g = S;
        const w = this.adapterManager.getDebugger(g.type);
        if (!w || u.request !== "attach" && u.request !== "launch") {
          let y;
          u.request !== "attach" && u.request !== "launch" ? y = u.request ? c(
            "debugRequestNotSupported",
            "Attribute '{0}' has an unsupported value '{1}' in the chosen debug configuration.",
            "request",
            u.request
          ) : c(
            "debugRequesMissing",
            "Attribute '{0}' is missing from the chosen debug configuration.",
            "request"
          ) : y = g.type ? c(
            "debugTypeNotSupported",
            "Configured debug type '{0}' is not supported.",
            g.type
          ) : c(
            "debugTypeMissing",
            "Missing property 'type' for the chosen launch configuration."
          );
          const _ = [];
          return _.push(new Z("installAdditionalDebuggers", c(
            { key: "installAdditionalDebuggers", comment: ['Placeholder is the debug type, so for example "node", "python"'] },
            "Install {0} Extension",
            g.type
          ), void 0, !0, async () => this.commandService.executeCommand("debug.installAdditionalDebuggers", g == null ? void 0 : g.type))), await this.showError(y, _), !1;
        }
        if (!w.enabled)
          return await this.showError(ja(w.type), []), !1;
        const m = await this.doCreateSession(d, e == null ? void 0 : e.workspace, { resolved: g, unresolved: n }, i);
        return m && o && r && r.resource && (this.chosenEnvironments[r.resource.toString()] = o.type, this.debugStorage.storeChosenEnvironments(this.chosenEnvironments)), m;
      } catch (g) {
        return g && g.message ? await this.showError(g.message) : this.contextService.getWorkbenchState() === 1 && await this.showError(c(
          "noFolderWorkspaceDebugError",
          "The active file can not be debugged. Make sure it is saved and that you have a debug extension installed for that file type."
        )), e && !a.token.isCancellationRequested && await e.openConfigFile({ preserveFocus: !0 }, a.token), !1;
      }
    return e && s && u === null && !a.token.isCancellationRequested && await e.openConfigFile({ preserveFocus: !0, type: s }, a.token), !1;
  }
  async doCreateSession(e, t, i, s) {
    const n = this.instantiationService.createInstance(go, e, i, t, this.model, s);
    if (s != null && s.startedByUser && this.model.getSessions().some((r) => r.getLabel() === n.getLabel()) && i.resolved.suppressMultipleSessionWarning !== !0 && !(await this.dialogService.confirm({ message: c(
      "multipleSession",
      "'{0}' is already running. Do you want to start another instance?",
      n.getLabel()
    ) })).confirmed)
      return !1;
    this.model.addSession(n), this.registerSessionListeners(n), this._onWillNewSession.fire(n);
    const o = this.configurationService.getValue("debug").openDebug;
    !i.resolved.noDebug && (o === "openOnSessionStart" || o !== "neverOpen" && this.viewModel.firstSessionStart) && !n.suppressDebugView && await this.paneCompositeService.openPaneComposite(De, 0);
    try {
      await this.launchOrAttachToSession(n);
      const r = n.configuration.internalConsoleOptions || this.configurationService.getValue("debug").internalConsoleOptions;
      (r === "openOnSessionStart" || this.viewModel.firstSessionStart && r === "openOnFirstSessionStart") && this.viewsService.openView(X, !1), this.viewModel.firstSessionStart = !1;
      const a = this.configurationService.getValue("debug").showSubSessionsInToolBar, d = this.model.getSessions();
      return (a ? d : d.filter((g) => !g.parentSession)).length > 1 && this.viewModel.setMultiSessionView(!0), this._onDidNewSession.fire(n), !0;
    } catch (r) {
      if (Sc(r) || (n && n.getReplElements().length > 0 && this.viewsService.openView(X, !1), n.configuration && n.configuration.request === "attach" && n.configuration.__autoAttach))
        return !1;
      const a = r instanceof Error ? r.message : r;
      return r.showUser !== !1 && await this.showError(a, Yl(r) ? r.actions : []), !1;
    }
  }
  async launchOrAttachToSession(e, t = !1) {
    const i = this.adapterManager.getDebugger(e.configuration.type);
    try {
      await e.initialize(i), await e.launchOrAttach(e.configuration);
      const s = !!e.root && !!this.configurationService.getValue("launch", { resource: e.root.uri });
      await this.telemetry.logDebugSessionStart(i, s), (t || !this.viewModel.focusedSession || e.parentSession === this.viewModel.focusedSession && e.compact) && await this.focusStackFrame(void 0, void 0, e);
    } catch (s) {
      return this.viewModel.focusedSession === e && await this.focusStackFrame(void 0), Promise.reject(s);
    }
  }
  registerSessionListeners(e) {
    const t = new oe(() => {
      e.state === 3 && this.viewModel.focusedSession === e && this.viewModel.setFocus(void 0, this.viewModel.focusedThread, e, !1);
    }, 200);
    this.disposables.add(e.onDidChangeState(() => {
      e.state === 3 && this.viewModel.focusedSession === e && t.schedule(), e === this.viewModel.focusedSession && this.onStateChange();
    })), this.disposables.add(e.onDidEndAdapter(async (i) => {
      i && (i.error && this.notificationService.error(c(
        "debugAdapterCrash",
        "Debug adapter process has terminated unexpectedly ({0})",
        i.error.message || i.error.toString()
      )), this.telemetry.logDebugSessionStop(e, i));
      const s = Zr(e);
      if (s && s.state === 3 && s.configuration.noDebug && this.extensionHostDebugService.close(s.getId()), e.configuration.postDebugTask) {
        const o = e.root ?? this.contextService.getWorkspace();
        try {
          await this.taskRunner.runTask(o, e.configuration.postDebugTask);
        } catch (r) {
          this.notificationService.error(r);
        }
      }
      this.endInitializingState(), this.cancelTokens(e.getId()), this._onDidEndSession.fire(e);
      const n = this.viewModel.focusedSession;
      if (n && n.getId() === e.getId()) {
        const { session: o, thread: r, stackFrame: a } = Ta(this.model, void 0, void 0, void 0, n);
        this.viewModel.setFocus(a, r, o, !1);
      }
      if (this.model.getSessions().length === 0 && (this.viewModel.setMultiSessionView(!1), this.layoutService.isVisible("workbench.parts.sidebar") && this.configurationService.getValue("debug").openExplorerOnEnd && this.paneCompositeService.openPaneComposite(Jl, 0), this.model.getDataBreakpoints().filter((r) => !r.canPersist).forEach((r) => this.model.removeDataBreakpoints(r.getId())), this.configurationService.getValue("debug").console.closeOnEnd)) {
        const r = this.viewDescriptorService.getViewContainerByViewId(X);
        r && this.viewsService.isViewContainerVisible(r.id) && this.viewsService.closeViewContainer(r.id);
      }
      this.model.removeExceptionBreakpointsForSession(e.getId());
    }));
  }
  async restartSession(e, t) {
    e.saveBeforeRestart && await Qr(this.configurationService, this.editorService);
    const i = !!t, s = async () => {
      if (i)
        return Promise.resolve(1);
      const g = e.root || this.contextService.getWorkspace();
      await this.taskRunner.runTask(g, e.configuration.preRestartTask), await this.taskRunner.runTask(g, e.configuration.postDebugTask);
      const p = await this.taskRunner.runTaskAndCheckErrors(g, e.configuration.preLaunchTask);
      return p !== 1 ? p : this.taskRunner.runTaskAndCheckErrors(g, e.configuration.postRestartTask);
    }, n = Zr(e);
    if (n) {
      await s() === 1 && this.extensionHostDebugService.reload(n.getId());
      return;
    }
    let o = !1, r;
    const a = e.root ? this.configurationManager.getLaunch(e.root.uri) : void 0;
    a && (r = a.getConfiguration(e.configuration.name), r && !Ql(r, e.unresolvedConfiguration) && (r.type = e.configuration.type, r.noDebug = e.configuration.noDebug, o = !0));
    let d = e.configuration;
    if (a && o && r) {
      const g = new Qe();
      this.sessionCancellationTokens.set(e.getId(), g);
      const p = await this.configurationManager.resolveConfigurationByProviders(a.workspace ? a.workspace.uri : void 0, r.type, r, g.token);
      p ? (d = await this.substituteVariables(a, p), d && !g.token.isCancellationRequested && (d = await this.configurationManager.resolveDebugConfigurationWithSubstitutedVariables(a && a.workspace ? a.workspace.uri : void 0, r.type, d, g.token))) : d = p;
    }
    if (d && e.setConfiguration({ resolved: d, unresolved: r }), e.configuration.__restart = t, e.capabilities.supportsRestartRequest) {
      await s() === 1 && await e.restart();
      return;
    }
    const u = !!this.viewModel.focusedSession && e.getId() === this.viewModel.focusedSession.getId();
    return i ? await e.disconnect(!0) : await e.terminate(!0), new Promise((g, p) => {
      setTimeout(async () => {
        if (await s() === 1) {
          if (!d)
            return g(void 0);
          try {
            await this.launchOrAttachToSession(e, u), this._onDidNewSession.fire(e), g(void 0);
          } catch (S) {
            p(S);
          }
        }
      }, 300);
    });
  }
  async stopSession(e, t = !1, i = !1) {
    if (e)
      return t ? e.disconnect(void 0, i) : e.terminate();
    const s = this.model.getSessions();
    return s.length === 0 && (this.taskRunner.cancel(), await this.quickInputService.cancel(), this.endInitializingState(), this.cancelTokens(void 0)), Promise.all(s.map((n) => t ? n.disconnect(void 0, i) : n.terminate()));
  }
  async substituteVariables(e, t) {
    const i = this.adapterManager.getDebugger(t.type);
    if (i) {
      let s;
      if (e && e.workspace)
        s = e.workspace;
      else {
        const n = this.contextService.getWorkspace().folders;
        n.length === 1 && (s = n[0]);
      }
      try {
        return await i.substituteVariables(s, t);
      } catch (n) {
        this.showError(n.message, void 0, !!(e != null && e.getConfiguration(t.name)));
        return;
      }
    }
    return Promise.resolve(t);
  }
  async showError(e, t = [], i = !0) {
    const s = new Z(
      ss,
      od,
      void 0,
      !0,
      () => this.commandService.executeCommand(ss)
    ), n = t.filter((o) => o.id.endsWith(".command")).length > 0 ? t : [...t, ...i ? [s] : []];
    await this.dialogService.prompt({
      type: fe.Error,
      message: e,
      buttons: n.map((o) => ({
        label: o.label,
        run: () => o.run()
      })),
      cancelButton: !0
    });
  }
  async focusStackFrame(e, t, i, s) {
    const { stackFrame: n, thread: o, session: r } = Ta(this.model, e, t, i);
    if (n) {
      const a = await n.openInEditor(this.editorService, (s == null ? void 0 : s.preserveFocus) ?? !0, s == null ? void 0 : s.sideBySide, s == null ? void 0 : s.pinned);
      if (a && a.input !== ns.instance) {
        const d = a.getControl();
        if (n && Je(d) && d.hasModel()) {
          const u = d.getModel(), g = n.range.startLineNumber;
          if (g >= 1 && g <= u.getLineCount()) {
            const p = d.getModel().getLineContent(g);
            Zl(c(
              { key: "debuggingPaused", comment: ['First placeholder is the file line content, second placeholder is the reason why debugging is stopped, for example "breakpoint", third is the stack frame name, and last is the line number.'] },
              "{0}, debugging paused {1}, {2}:{3}",
              p,
              o && o.stoppedDetails ? `, reason ${o.stoppedDetails.reason}` : "",
              n.source ? n.source.name : "",
              n.range.startLineNumber
            ));
          }
        }
      }
    }
    r ? this.debugType.set(r.configuration.type) : this.debugType.reset(), this.viewModel.setFocus(n, o, r, !!(s != null && s.explicit));
  }
  addWatchExpression(e) {
    const t = this.model.addWatchExpression(e);
    e || this.viewModel.setSelectedExpression(t, !1), this.debugStorage.storeWatchExpressions(this.model.getWatchExpressions());
  }
  renameWatchExpression(e, t) {
    this.model.renameWatchExpression(e, t), this.debugStorage.storeWatchExpressions(this.model.getWatchExpressions());
  }
  moveWatchExpression(e, t) {
    this.model.moveWatchExpression(e, t), this.debugStorage.storeWatchExpressions(this.model.getWatchExpressions());
  }
  removeWatchExpressions(e) {
    this.model.removeWatchExpressions(e), this.debugStorage.storeWatchExpressions(this.model.getWatchExpressions());
  }
  canSetBreakpointsIn(e) {
    return this.adapterManager.canSetBreakpointsIn(e);
  }
  async enableOrDisableBreakpoints(e, t) {
    t ? (this.model.setEnablement(t, e), this.debugStorage.storeBreakpoints(this.model), t instanceof rd ? await this.sendBreakpoints(t.originalUri) : t instanceof ad ? await this.sendFunctionBreakpoints() : t instanceof cd ? await this.sendDataBreakpoints() : t instanceof Qi ? await this.sendInstructionBreakpoints() : await this.sendExceptionBreakpoints()) : (this.model.enableOrDisableAllBreakpoints(e), this.debugStorage.storeBreakpoints(this.model), await this.sendAllBreakpoints()), this.debugStorage.storeBreakpoints(this.model);
  }
  async addBreakpoints(e, t, i = !0) {
    const s = this.model.addBreakpoints(e, t);
    return i && s.forEach((n) => Rt(c(
      "breakpointAdded",
      "Added breakpoint, line {0}, file {1}",
      n.lineNumber,
      e.fsPath
    ))), this.debugStorage.storeBreakpoints(this.model), await this.sendBreakpoints(e), this.debugStorage.storeBreakpoints(this.model), s;
  }
  async updateBreakpoints(e, t, i) {
    this.model.updateBreakpoints(t), this.debugStorage.storeBreakpoints(this.model), i ? this.breakpointsToSendOnResourceSaved.add(e) : (await this.sendBreakpoints(e), this.debugStorage.storeBreakpoints(this.model));
  }
  async removeBreakpoints(e) {
    const t = this.model.getBreakpoints().filter((s) => !e || s.getId() === e);
    t.forEach((s) => Rt(c(
      "breakpointRemoved",
      "Removed breakpoint, line {0}, file {1}",
      s.lineNumber,
      s.uri.fsPath
    )));
    const i = St(t, (s) => s.originalUri.toString()).map((s) => s.originalUri);
    this.model.removeBreakpoints(t), this.debugStorage.storeBreakpoints(this.model), await Promise.all(i.map((s) => this.sendBreakpoints(s)));
  }
  setBreakpointsActivated(e) {
    return this.model.setBreakpointsActivated(e), this.sendAllBreakpoints();
  }
  addFunctionBreakpoint(e, t) {
    this.model.addFunctionBreakpoint(e || "", t);
  }
  async updateFunctionBreakpoint(e, t) {
    this.model.updateFunctionBreakpoint(e, t), this.debugStorage.storeBreakpoints(this.model), await this.sendFunctionBreakpoints();
  }
  async removeFunctionBreakpoints(e) {
    this.model.removeFunctionBreakpoints(e), this.debugStorage.storeBreakpoints(this.model), await this.sendFunctionBreakpoints();
  }
  async addDataBreakpoint(e, t, i, s, n) {
    this.model.addDataBreakpoint(e, t, i, s, n), this.debugStorage.storeBreakpoints(this.model), await this.sendDataBreakpoints(), this.debugStorage.storeBreakpoints(this.model);
  }
  async removeDataBreakpoints(e) {
    this.model.removeDataBreakpoints(e), this.debugStorage.storeBreakpoints(this.model), await this.sendDataBreakpoints();
  }
  async addInstructionBreakpoint(e, t, i, s) {
    this.model.addInstructionBreakpoint(e, t, i, s), this.debugStorage.storeBreakpoints(this.model), await this.sendInstructionBreakpoints(), this.debugStorage.storeBreakpoints(this.model);
  }
  async removeInstructionBreakpoints(e) {
    this.model.removeInstructionBreakpoints(e), this.debugStorage.storeBreakpoints(this.model), await this.sendInstructionBreakpoints();
  }
  setExceptionBreakpointFallbackSession(e) {
    this.model.setExceptionBreakpointFallbackSession(e), this.debugStorage.storeBreakpoints(this.model);
  }
  setExceptionBreakpointsForSession(e, t) {
    this.model.setExceptionBreakpointsForSession(e.getId(), t), this.debugStorage.storeBreakpoints(this.model);
  }
  async setExceptionBreakpointCondition(e, t) {
    this.model.setExceptionBreakpointCondition(e, t), this.debugStorage.storeBreakpoints(this.model), await this.sendExceptionBreakpoints();
  }
  async sendAllBreakpoints(e) {
    const t = St(this.model.getBreakpoints(), (i) => i.originalUri.toString()).map((i) => this.sendBreakpoints(i.originalUri, !1, e));
    e != null && e.capabilities.supportsConfigurationDoneRequest ? await Promise.all([
      ...t,
      this.sendFunctionBreakpoints(e),
      this.sendDataBreakpoints(e),
      this.sendInstructionBreakpoints(e),
      this.sendExceptionBreakpoints(e)
    ]) : (await Promise.all(t), await this.sendFunctionBreakpoints(e), await this.sendDataBreakpoints(e), await this.sendInstructionBreakpoints(e), await this.sendExceptionBreakpoints(e));
  }
  async sendBreakpoints(e, t = !1, i) {
    const s = this.model.getBreakpoints({ originalUri: e, enabledOnly: !0 });
    await hi(this.model, i, async (n) => {
      n.configuration.noDebug || await n.sendBreakpoints(e, s, t);
    });
  }
  async sendFunctionBreakpoints(e) {
    const t = this.model.getFunctionBreakpoints().filter((i) => i.enabled && this.model.areBreakpointsActivated());
    await hi(this.model, e, async (i) => {
      i.capabilities.supportsFunctionBreakpoints && !i.configuration.noDebug && await i.sendFunctionBreakpoints(t);
    });
  }
  async sendDataBreakpoints(e) {
    const t = this.model.getDataBreakpoints().filter((i) => i.enabled && this.model.areBreakpointsActivated());
    await hi(this.model, e, async (i) => {
      i.capabilities.supportsDataBreakpoints && !i.configuration.noDebug && await i.sendDataBreakpoints(t);
    });
  }
  async sendInstructionBreakpoints(e) {
    const t = this.model.getInstructionBreakpoints().filter((i) => i.enabled && this.model.areBreakpointsActivated());
    await hi(this.model, e, async (i) => {
      i.capabilities.supportsInstructionBreakpoints && !i.configuration.noDebug && await i.sendInstructionBreakpoints(t);
    });
  }
  sendExceptionBreakpoints(e) {
    return hi(this.model, e, async (t) => {
      const i = this.model.getExceptionBreakpointsForSession(t.getId()).filter((s) => s.enabled);
      t.capabilities.supportsConfigurationDoneRequest && (!t.capabilities.exceptionBreakpointFilters || t.capabilities.exceptionBreakpointFilters.length === 0) || t.configuration.noDebug || await t.sendExceptionBreakpoints(i);
    });
  }
  onFileChanges(e) {
    const t = this.model.getBreakpoints().filter((s) => e.contains(s.originalUri, 2));
    t.length && this.model.removeBreakpoints(t);
    const i = [];
    for (const s of this.breakpointsToSendOnResourceSaved)
      e.contains(s, 0) && i.push(s);
    for (const s of i)
      this.breakpointsToSendOnResourceSaved.delete(s), this.sendBreakpoints(s, !0);
  }
  async runTo(e, t, i) {
    let s, n = this.getViewModel().focusedThread;
    const o = async () => {
      if (!!!this.getModel().getBreakpoints({ column: i, lineNumber: t, uri: e }).length) {
        const d = await this.addAndValidateBreakpoints(e, t, i);
        d.thread && (n = d.thread), d.breakpoint && (s = d.breakpoint);
      }
      return { threadToContinue: n, breakpointToRemove: s };
    }, r = (a) => a === 2 || a === 0 ? (s && this.removeBreakpoints(s.getId()), !0) : !1;
    if (await o(), this.state === 0) {
      const { launch: a, name: d, getConfig: u } = this.getConfigurationManager().selectedConfiguration, g = await u(), p = g ? Object.assign(Zi(g), {}) : d, f = this.onDidChangeState((S) => {
        r(S) && f.dispose();
      });
      await this.startDebugging(a, p, void 0, !0);
    }
    if (this.state === 2) {
      const a = this.getViewModel().focusedSession;
      if (!a || !n)
        return;
      const d = n.session.onDidChangeState(() => {
        r(a.state) && d.dispose();
      });
      await n.continue();
    }
  }
  async addAndValidateBreakpoints(e, t, i) {
    const s = this.getModel(), n = this.getViewModel(), o = await this.addBreakpoints(e, [{ lineNumber: t, column: i }], !1), r = o == null ? void 0 : o[0];
    if (!r)
      return { breakpoint: void 0, thread: n.focusedThread };
    if (!r.verified) {
      let u;
      await eu(new Promise((g) => {
        u = s.onDidChangeBreakpoints(() => {
          r.verified && g();
        });
      }), 2e3), u.dispose();
    }
    let a = n.focusedThread, d = 0;
    for (const u of r.sessionsThatVerified) {
      const g = s.getSession(u);
      if (!g)
        continue;
      const p = g.getAllThreads().filter((f) => f.stopped);
      if (d < 3 && n.focusedThread && p.includes(n.focusedThread) && (a = n.focusedThread, d = 3), d < 2) {
        const f = p.find((S) => {
          const w = S.getTopStackFrame();
          return w && this.uriIdentityService.extUri.isEqual(w.source.uri, e);
        });
        f && (a = f, d = 2);
      }
      d < 1 && (a = p[0], d = 2);
    }
    return { thread: a, breakpoint: r };
  }
};
Ii = I([
  h(0, ae),
  h(1, dc),
  h(2, Ae),
  h(3, Ue),
  h(4, Ct),
  h(5, Jt),
  h(6, hr),
  h(7, _e),
  h(8, H),
  h(9, Js),
  h(10, K),
  h(11, Yt),
  h(12, rr),
  h(13, O),
  h(14, sc),
  h(15, ql),
  h(16, We),
  h(17, Ys),
  h(18, Gl),
  h(19, Le)
], Ii);
function Ta(l, e, t, i, s) {
  if (!i)
    if (e || t)
      i = e ? e.thread.session : t.session;
    else {
      const n = l.getSessions();
      i = n.find((r) => r.state === 2) || n.find((r) => r !== s && r !== (s == null ? void 0 : s.parentSession)) || (n.length ? n[0] : void 0);
    }
  if (!t)
    if (e)
      t = e.thread;
    else {
      const n = i ? i.getAllThreads() : void 0;
      t = n && n.find((r) => r.stopped) || (n && n.length ? n[0] : void 0);
    }
  return !e && t && (e = t.getTopStackFrame()), { session: i, thread: t, stackFrame: e };
}
async function hi(l, e, t) {
  e ? await t(e) : await Promise.all(l.getSessions().map((i) => t(i)));
}
class np {
  constructor() {
    this.referenceProvider = new R(this._score.bind(this)), this.renameProvider = new R(this._score.bind(this)), this.codeActionProvider = new R(this._score.bind(this)), this.definitionProvider = new R(this._score.bind(this)), this.typeDefinitionProvider = new R(this._score.bind(this)), this.declarationProvider = new R(this._score.bind(this)), this.implementationProvider = new R(this._score.bind(this)), this.documentSymbolProvider = new R(this._score.bind(this)), this.inlayHintsProvider = new R(this._score.bind(this)), this.colorProvider = new R(this._score.bind(this)), this.codeLensProvider = new R(this._score.bind(this)), this.documentFormattingEditProvider = new R(this._score.bind(this)), this.documentRangeFormattingEditProvider = new R(this._score.bind(this)), this.onTypeFormattingEditProvider = new R(this._score.bind(this)), this.signatureHelpProvider = new R(this._score.bind(this)), this.hoverProvider = new R(this._score.bind(this)), this.documentHighlightProvider = new R(this._score.bind(this)), this.selectionRangeProvider = new R(this._score.bind(this)), this.foldingRangeProvider = new R(this._score.bind(this)), this.linkProvider = new R(this._score.bind(this)), this.inlineCompletionsProvider = new R(this._score.bind(this)), this.completionProvider = new R(this._score.bind(this)), this.linkedEditingRangeProvider = new R(this._score.bind(this)), this.inlineValuesProvider = new R(this._score.bind(this)), this.evaluatableExpressionProvider = new R(this._score.bind(this)), this.documentRangeSemanticTokensProvider = new R(this._score.bind(this)), this.documentSemanticTokensProvider = new R(this._score.bind(this)), this.documentOnDropEditProvider = new R(this._score.bind(this)), this.documentPasteEditProvider = new R(this._score.bind(this));
  }
  setNotebookTypeResolver(e) {
    this._notebookTypeResolver = e;
  }
  _score(e) {
    var t;
    return (t = this._notebookTypeResolver) == null ? void 0 : t.call(this, e);
  }
}
const Vs = class Vs extends tu {
  constructor(e, t, i, s, n, o, r, a, d, u) {
    super({
      getFolderUri: (g) => {
        const p = o.getWorkspace().folders.filter((f) => f.name === g).pop();
        return p ? p.uri : void 0;
      },
      getWorkspaceFolderCount: () => o.getWorkspace().folders.length,
      getConfigurationValue: (g, p) => s.getValue(p, g ? { resource: g } : {}),
      getAppRoot: () => e.getAppRoot(),
      getExecPath: () => e.getExecPath(),
      getFilePath: () => {
        const g = ea.getOriginalUri(i.activeEditor, {
          supportSideBySide: ta.PRIMARY,
          filterByScheme: [ft.file, ft.vscodeUserData, this.pathService.defaultUriScheme]
        });
        if (g)
          return this.labelService.getUriLabel(g, { noPrefix: !0 });
      },
      getWorkspaceFolderPathForFile: () => {
        const g = ea.getOriginalUri(i.activeEditor, {
          supportSideBySide: ta.PRIMARY,
          filterByScheme: [ft.file, ft.vscodeUserData, this.pathService.defaultUriScheme]
        });
        if (!g)
          return;
        const p = o.getWorkspaceFolder(g);
        if (p)
          return this.labelService.getUriLabel(p.uri, { noPrefix: !0 });
      },
      getSelectedText: () => {
        const g = i.activeTextEditorControl;
        let p = null;
        if (Je(g))
          p = g;
        else if (iu(g)) {
          const w = g.getOriginalEditor(), m = g.getModifiedEditor();
          p = w.hasWidgetFocus() ? w : m;
        }
        const f = p == null ? void 0 : p.getModel(), S = p == null ? void 0 : p.getSelection();
        if (f && S)
          return f.getValueInRange(S);
      },
      getLineNumber: () => {
        const g = i.activeTextEditorControl;
        if (Je(g)) {
          const p = g.getSelection();
          if (p) {
            const f = p.positionLineNumber;
            return String(f);
          }
        }
      },
      getExtension: (g) => u.getExtension(g)
    }, a, d.userHome().then((g) => g.path), t), this.configurationService = s, this.commandService = n, this.workspaceContextService = o, this.quickInputService = r, this.labelService = a, this.pathService = d, this.userInputAccessQueue = new Yn();
  }
  async resolveWithInteractionReplace(e, t, i, s, n) {
    return t = await this.resolveAnyAsync(e, t), this.resolveWithInteraction(e, t, i, s, n).then((o) => o ? o.size > 0 ? this.resolveAnyAsync(e, t, Object.fromEntries(o)) : t : null);
  }
  async resolveWithInteraction(e, t, i, s, n) {
    const o = await this.resolveAnyMap(e, t);
    t = o.newConfig;
    const r = o.resolvedVariables;
    return this.resolveWithInputAndCommands(e, t, s, i, n).then((a) => {
      if (this.updateMapping(a, r))
        return r;
    });
  }
  updateMapping(e, t) {
    if (!e)
      return !1;
    for (const [i, s] of Object.entries(e))
      t.set(i, s);
    return !0;
  }
  async resolveWithInputAndCommands(e, t, i, s, n) {
    var d, u, g;
    if (!t)
      return Promise.resolve(void 0);
    let o = [];
    if (this.workspaceContextService.getWorkbenchState() !== 1 && s) {
      const p = e ? { resource: e.uri } : {}, f = this.configurationService.inspect(s, p);
      if (f && (f.userValue || f.workspaceValue || f.workspaceFolderValue))
        switch (n) {
          case 2:
            o = (d = f.userValue) == null ? void 0 : d.inputs;
            break;
          case 5:
            o = (u = f.workspaceValue) == null ? void 0 : u.inputs;
            break;
          default:
            o = (g = f.workspaceFolderValue) == null ? void 0 : g.inputs;
        }
      else {
        const S = this.configurationService.getValue(s, p);
        S && (o = S.inputs);
      }
    }
    const r = [];
    this.findVariables(t, r);
    const a = /* @__PURE__ */ Object.create(null);
    for (const p of r) {
      const [f, S] = p.split(":", 2);
      let w;
      switch (f) {
        case "input":
          w = await this.showUserInput(S, o);
          break;
        case "command": {
          const m = (i ? i[S] : void 0) || S;
          if (w = await this.commandService.executeCommand(m, t), typeof w != "string" && !ia(w))
            throw new Error(c("commandVariable.noStringType", "Cannot substitute command variable '{0}' because command did not return a result of type string.", m));
          break;
        }
        default:
          this._contributedVariables.has(p) && (w = await this._contributedVariables.get(p)());
      }
      if (typeof w == "string")
        a[p] = w;
      else
        return;
    }
    return a;
  }
  findVariables(e, t) {
    if (typeof e == "string") {
      let i;
      for (; (i = Vs.INPUT_OR_COMMAND_VARIABLES_PATTERN.exec(e)) !== null; )
        if (i.length === 4) {
          const s = i[1];
          t.indexOf(s) < 0 && t.push(s);
        }
      for (const s of this._contributedVariables.keys())
        t.indexOf(s) < 0 && e.indexOf("${" + s + "}") >= 0 && t.push(s);
    } else if (Array.isArray(e))
      for (const i of e)
        this.findVariables(i, t);
    else if (e)
      for (const i of Object.values(e))
        this.findVariables(i, t);
  }
  showUserInput(e, t) {
    if (!t)
      return Promise.reject(new Error(c(
        "inputVariable.noInputSection",
        "Variable '{0}' must be defined in an '{1}' section of the debug or task configuration.",
        e,
        "input"
      )));
    const i = t.filter((s) => s.id === e).pop();
    if (i) {
      const s = (n) => {
        throw new Error(c("inputVariable.missingAttribute", "Input variable '{0}' is of type '{1}' and must include '{2}'.", e, i.type, n));
      };
      switch (i.type) {
        case "promptString": {
          $e(i.description) || s("description");
          const n = { prompt: i.description, ignoreFocusLost: !0 };
          return i.default && (n.value = i.default), i.password && (n.password = i.password), this.userInputAccessQueue.queue(() => this.quickInputService.input(n)).then((o) => o);
        }
        case "pickString": {
          if ($e(i.description) || s("description"), Array.isArray(i.options))
            for (const r of i.options)
              !$e(r) && !$e(r.value) && s("value");
          else
            s("options");
          const n = new Array();
          for (const r of i.options) {
            const a = $e(r) ? r : r.value, d = $e(r) ? void 0 : r.label, u = {
              label: d ? `${d}: ${a}` : a,
              value: a
            };
            a === i.default ? (u.description = c("inputVariable.defaultInputValue", "(Default)"), n.unshift(u)) : n.push(u);
          }
          const o = { placeHolder: i.description, matchOnDetail: !0, ignoreFocusLost: !0 };
          return this.userInputAccessQueue.queue(() => this.quickInputService.pick(n, o, void 0)).then((r) => {
            if (r)
              return r.value;
          });
        }
        case "command":
          return $e(i.command) || s("command"), this.userInputAccessQueue.queue(() => this.commandService.executeCommand(i.command, i.args)).then((n) => {
            if (typeof n == "string" || ia(n))
              return n;
            throw new Error(c("inputVariable.command.noStringType", "Cannot substitute input variable '{0}' because command '{1}' did not return a result of type string.", e, i.command));
          });
        default:
          throw new Error(c("inputVariable.unknownType", "Input variable '{0}' can only be of type 'promptString', 'pickString', or 'command'.", e));
      }
    }
    return Promise.reject(new Error(c(
      "inputVariable.undefinedVariable",
      "Undefined input variable '{0}' encountered. Remove or define '{0}' to continue.",
      e
    )));
  }
};
Vs.INPUT_OR_COMMAND_VARIABLES_PATTERN = /\${((input|command):(.*?))}/g;
let mo = Vs, So = class extends mo {
  constructor(e, t, i, s, n, o, r, a) {
    super({ getAppRoot: () => {
    }, getExecPath: () => {
    } }, Promise.resolve(/* @__PURE__ */ Object.create(null)), e, t, i, s, n, o, r, a);
  }
};
So = I([
  h(0, ae),
  h(1, O),
  h(2, We),
  h(3, _e),
  h(4, Ys),
  h(5, Vi),
  h(6, gr),
  h(7, Yt)
], So);
var op = '.codicon-debug-hint{cursor:pointer}.codicon-debug-hint:not([class*=codicon-debug-breakpoint]):not([class*=codicon-debug-stackframe]){opacity:.4!important}.inline-breakpoint-widget.codicon{align-items:center;display:flex!important}.inline-breakpoint-widget.codicon-debug-breakpoint-disabled{opacity:.7}.monaco-editor .inline-breakpoint-widget.line-start{left:-8px!important}.monaco-editor .debug-breakpoint-placeholder{display:inline-flex;margin-top:-1px;vertical-align:middle;width:.9em}.codicon-debug-breakpoint.codicon-debug-stackframe-focused:after,.codicon-debug-breakpoint.codicon-debug-stackframe:after{content:"\\eb8a";position:absolute}.monaco-editor .debug-top-stack-frame-column{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;align-items:center;display:inline-flex;font:normal normal normal 16px/1 codicon;margin-left:0;margin-right:4px;margin-top:-1px;text-rendering:auto;vertical-align:middle;width:.9em}.monaco-editor .debug-top-stack-frame-column.start-of-line{margin-top:0;position:absolute;top:50%;transform:translate(-17px,-50%)}.monaco-editor .inline-breakpoint-widget{cursor:pointer}.monaco-workbench .debug-view-content .monaco-list-row .monaco-tl-contents{overflow:hidden;text-overflow:ellipsis}.monaco-workbench .monaco-list-row .expression{display:flex}.monaco-workbench .debug-hover-widget .monaco-list-row .expression,.monaco-workbench .debug-pane .monaco-list-row .expression{font-family:var(--monaco-monospace-font);font-size:13px;overflow:hidden;text-overflow:ellipsis;white-space:pre}.monaco-workbench.mac .debug-hover-widget .monaco-list-row .expression,.monaco-workbench.mac .debug-pane .monaco-list-row .expression{font-size:11px}.monaco-workbench .monaco-list-row .expression .value{margin-left:6px}.monaco-workbench .monaco-list-row .expression .lazy-button{align-self:center;border-radius:5px;display:none;margin-left:3px}.monaco-workbench .monaco-list-row .expression.lazy .lazy-button{display:inline}.monaco-workbench .monaco-list-row .expression .value a.link:hover{text-decoration:underline}.monaco-workbench .monaco-list-row .expression .value a.link.pointer{cursor:pointer}.monaco-workbench .monaco-list:focus .monaco-list-row.selected .expression .name,.monaco-workbench .monaco-list:focus .monaco-list-row.selected .expression .value{color:inherit}.monaco-workbench .monaco-list-row .expression .name.internal,.monaco-workbench .monaco-list-row .expression .name.virtual{opacity:.5}.monaco-workbench .monaco-list-row .expression .unavailable{font-style:italic}.monaco-workbench .debug-inline-value{background-color:var(--vscode-editor-inlineValuesBackground);color:var(--vscode-editor-inlineValuesForeground)}';
ot(op, {});
var rp = ".monaco-editor .debug-hover-widget{animation-duration:.15s;animation-name:fadeIn;position:absolute;user-select:text;-webkit-user-select:text;white-space:pre;word-break:break-all;z-index:50}.monaco-editor .debug-hover-widget .complex-value{max-width:550px}.monaco-editor .debug-hover-widget .complex-value .tip,.monaco-editor .debug-hover-widget .complex-value .title{font-size:11px;height:18px;line-height:18px;overflow:hidden;padding-left:15px;padding-right:2px;text-overflow:ellipsis;white-space:pre;word-break:normal}.monaco-editor .debug-hover-widget .complex-value .title{border-bottom:1px solid hsla(0,0%,50%,.35)}.monaco-editor .debug-hover-widget .complex-value .tip{border-top:1px solid hsla(0,0%,50%,.35);opacity:.5}.monaco-editor .debug-hover-widget .debug-hover-tree{cursor:pointer;line-height:18px}.monaco-editor .debug-hover-widget .debug-hover-tree .monaco-list-row .monaco-tl-contents{user-select:text;-webkit-user-select:text;white-space:pre}.monaco-editor .debug-hover-widget .debug-hover-tree .monaco-list-rows .monaco-list-row:hover:not(.highlighted):not(.selected):not(.focused){background-color:inherit}.monaco-editor .debug-hover-widget pre{margin-bottom:0;margin-top:0}.monaco-editor .debugHoverHighlight{background-color:rgba(173,214,255,.15)}.monaco-editor .debug-hover-widget>.monaco-scrollable-element>.value{color:hsla(0,0%,42%,.8);font-family:var(--monaco-monospace-font);max-height:500px;overflow:auto;padding:4px 5px;white-space:pre-wrap}.monaco-editor.hc-theme .debugHoverHighlight,.monaco-editor.vs-dark .debugHoverHighlight{background-color:rgba(38,79,120,.25)}";
ot(rp, {});
var ap = ".monaco-editor .zone-widget .zone-widget-container.breakpoint-widget{border-color:#007acc;display:flex}.monaco-editor .zone-widget .zone-widget-container.breakpoint-widget .breakpoint-select-container{display:flex;flex-direction:column;flex-shrink:0;justify-content:center;padding:0 10px}.monaco-editor .zone-widget .zone-widget-container.breakpoint-widget .breakpoint-select-container .monaco-select-box{min-height:18px;min-width:100px;padding:2px 20px 2px 8px}.monaco-editor .zone-widget .zone-widget-container.breakpoint-widget .breakpoint-select-container:after{right:14px}.monaco-editor .zone-widget .zone-widget-container.breakpoint-widget .inputContainer{flex:1}";
ot(ap, {});
const _a = ie, Br = su("privateBreakpointWidgetService"), La = "breakpointwidgetdecoration";
function cp(l) {
  return l.getModel().bracketPairs.getBracketPairsInRange(re.fromPositions(l.getPosition())).some((i) => i.openingBracketInfo.bracketText === "{");
}
function dp(l, e) {
  var i;
  const t = (i = l.getColor(Ac)) == null ? void 0 : i.transparent(0.4);
  return [{
    range: {
      startLineNumber: 0,
      endLineNumber: 0,
      startColumn: 0,
      endColumn: 1
    },
    renderOptions: {
      after: {
        contentText: e,
        color: t ? t.toString() : void 0
      }
    }
  }];
}
let wo = class extends yc {
  constructor(e, t, i, s, n, o, r, a, d, u, g, p, f, S) {
    super(e, { showFrame: !0, showArrow: !1, frameWidth: 1, isAccessible: !0 }), this.lineNumber = t, this.column = i, this.contextViewService = n, this.debugService = o, this.themeService = r, this.contextKeyService = a, this.instantiationService = d, this.modelService = u, this.codeEditorService = g, this._configurationService = p, this.languageFeaturesService = f, this.keybindingService = S, this.conditionInput = "", this.hitCountInput = "", this.logMessageInput = "", this.toDispose = [];
    const w = this.editor.getModel();
    if (w) {
      const m = w.uri, y = this.debugService.getModel().getBreakpoints({ lineNumber: this.lineNumber, column: this.column, uri: m });
      this.breakpoint = y.length ? y[0] : void 0;
    }
    s === void 0 ? this.breakpoint && !this.breakpoint.condition && !this.breakpoint.hitCondition && this.breakpoint.logMessage ? this.context = 2 : this.breakpoint && !this.breakpoint.condition && this.breakpoint.hitCondition ? this.context = 1 : this.context = 0 : this.context = s, this.toDispose.push(this.debugService.getModel().onDidChangeBreakpoints((m) => {
      this.breakpoint && m && m.removed && m.removed.indexOf(this.breakpoint) >= 0 && this.dispose();
    })), this.codeEditorService.registerDecorationType("breakpoint-widget", La, {}), this.create();
  }
  get placeholder() {
    var i, s;
    const e = ((i = this.keybindingService.lookupKeybinding(ps.ID)) == null ? void 0 : i.getLabel()) || "Enter", t = ((s = this.keybindingService.lookupKeybinding(fs.ID)) == null ? void 0 : s.getLabel()) || "Escape";
    switch (this.context) {
      case 2:
        return c(
          "breakpointWidgetLogMessagePlaceholder",
          "Message to log when breakpoint is hit. Expressions within {} are interpolated. '{0}' to accept, '{1}' to cancel.",
          e,
          t
        );
      case 1:
        return c(
          "breakpointWidgetHitCountPlaceholder",
          "Break when hit count condition is met. '{0}' to accept, '{1}' to cancel.",
          e,
          t
        );
      default:
        return c(
          "breakpointWidgetExpressionPlaceholder",
          "Break when expression evaluates to true. '{0}' to accept, '{1}' to cancel.",
          e,
          t
        );
    }
  }
  getInputValue(e) {
    switch (this.context) {
      case 2:
        return e && e.logMessage ? e.logMessage : this.logMessageInput;
      case 1:
        return e && e.hitCondition ? e.hitCondition : this.hitCountInput;
      default:
        return e && e.condition ? e.condition : this.conditionInput;
    }
  }
  rememberInput() {
    const e = this.input.getModel().getValue();
    switch (this.context) {
      case 2:
        this.logMessageInput = e;
        break;
      case 1:
        this.hitCountInput = e;
        break;
      default:
        this.conditionInput = e;
    }
  }
  setInputMode() {
    if (this.editor.hasModel()) {
      const e = this.context === 2 ? Dc : this.editor.getModel().getLanguageId();
      this.input.getModel().setLanguage(e);
    }
  }
  show(e) {
    const t = this.input.getModel().getLineCount();
    super.show(e, t + 1);
  }
  fitHeightToContent() {
    const e = this.input.getModel().getLineCount();
    this._relayout(e + 1);
  }
  _fillContainer(e) {
    this.setCssClass("breakpoint-widget");
    const t = new Ec(
      [{ text: c("expression", "Expression") }, { text: c("hitCount", "Hit Count") }, { text: c("logMessage", "Log Message") }],
      this.context,
      this.contextViewService,
      br,
      { ariaLabel: c("breakpointType", "Breakpoint Type") }
    );
    this.selectContainer = _a(".breakpoint-select-container"), t.render(E(e, this.selectContainer)), t.onDidSelect((i) => {
      this.rememberInput(), this.context = i.index, this.setInputMode();
      const s = this.getInputValue(this.breakpoint);
      this.input.getModel().setValue(s), this.input.focus();
    }), this.inputContainer = _a(".inputContainer"), this.createBreakpointInput(E(e, this.inputContainer)), this.input.getModel().setValue(this.getInputValue(this.breakpoint)), this.toDispose.push(this.input.getModel().onDidChangeContent(() => {
      this.fitHeightToContent();
    })), this.input.setPosition({ lineNumber: 1, column: this.input.getModel().getLineMaxColumn(1) }), setTimeout(() => this.input.focus(), 150);
  }
  _doLayout(e, t) {
    this.heightInPx = e, this.input.layout({ height: e, width: t - 113 }), this.centerInputVertically();
  }
  _onWidth(e) {
    typeof this.heightInPx == "number" && this._doLayout(this.heightInPx, e);
  }
  createBreakpointInput(e) {
    const t = this.contextKeyService.createScoped(e);
    this.toDispose.push(t);
    const i = this.instantiationService.createChild(new Ic(
      [H, t],
      [Br, this]
    )), s = this.createEditorOptions(), n = xc();
    this.input = i.createInstance(Tc, e, s, n), Cc.bindTo(t).set(!0);
    const o = this.modelService.createModel("", null, ue.parse(`${vi}:${this.editor.getId()}:breakpointinput`), !0);
    this.editor.hasModel() && o.setLanguage(this.editor.getModel().getLanguageId()), this.input.setModel(o), this.setInputMode(), this.toDispose.push(o);
    const r = () => {
      const d = this.input.getModel().getValue() ? [] : dp(this.themeService.getColorTheme(), this.placeholder);
      this.input.setDecorationsByType("breakpoint-widget", La, d);
    };
    this.input.getModel().onDidChangeContent(() => r()), this.themeService.onDidColorThemeChange(() => r()), this.toDispose.push(this.languageFeaturesService.completionProvider.register({ scheme: vi, hasAccessToAllModels: !0 }, {
      _debugDisplayName: "breakpointWidget",
      provideCompletionItems: (a, d, u, g) => {
        let p;
        const f = this.editor.getModel();
        return f && (this.context === 0 || this.context === 2 && cp(this.input)) ? p = nu(this.languageFeaturesService.completionProvider, f, new Ci(this.lineNumber, 1), new ou(
          void 0,
          (/* @__PURE__ */ new Set()).add(27)
        ), u, g).then((S) => {
          let w = 0;
          if (this.context === 0)
            w = d.column - 1;
          else {
            const m = this.input.getModel().getValue();
            for (; d.column - 2 - w >= 0 && m[d.column - 2 - w] !== "{" && m[d.column - 2 - w] !== " "; )
              w++;
          }
          return {
            suggestions: S.items.map((m) => (m.completion.range = re.fromPositions(d.delta(0, -w), d), m.completion))
          };
        }) : p = Promise.resolve({ suggestions: [] }), p;
      }
    })), this.toDispose.push(this._configurationService.onDidChangeConfiguration((a) => {
      (a.affectsConfiguration("editor.fontSize") || a.affectsConfiguration("editor.lineHeight")) && (this.input.updateOptions(this.createEditorOptions()), this.centerInputVertically());
    }));
  }
  createEditorOptions() {
    const e = this._configurationService.getValue("editor"), t = _c(this._configurationService);
    return t.fontSize = e.fontSize, t.fontFamily = e.fontFamily, t.lineHeight = e.lineHeight, t.fontLigatures = e.fontLigatures, t.ariaLabel = this.placeholder, t;
  }
  centerInputVertically() {
    if (this.container && typeof this.heightInPx == "number") {
      const e = this.input.getOption(65), t = this.input.getModel().getLineCount(), i = (this.heightInPx - t * e) / 2;
      this.inputContainer.style.marginTop = i + "px";
    }
  }
  close(e) {
    if (e) {
      let t = this.breakpoint && this.breakpoint.condition, i = this.breakpoint && this.breakpoint.hitCondition, s = this.breakpoint && this.breakpoint.logMessage;
      if (this.rememberInput(), (this.conditionInput || this.context === 0) && (t = this.conditionInput), (this.hitCountInput || this.context === 1) && (i = this.hitCountInput), (this.logMessageInput || this.context === 2) && (s = this.logMessageInput), this.breakpoint) {
        const n = /* @__PURE__ */ new Map();
        n.set(this.breakpoint.getId(), {
          condition: t,
          hitCondition: i,
          logMessage: s
        }), this.debugService.updateBreakpoints(this.breakpoint.originalUri, n, !1).then(void 0, Lc);
      } else {
        const n = this.editor.getModel();
        n && this.debugService.addBreakpoints(n.uri, [{
          lineNumber: this.lineNumber,
          column: this.column,
          enabled: !0,
          condition: t,
          hitCondition: i,
          logMessage: s
        }]);
      }
    }
    this.dispose();
  }
  dispose() {
    super.dispose(), this.input.dispose(), U(this.toDispose), setTimeout(() => this.editor.focus(), 0);
  }
};
wo = I([
  h(4, rt),
  h(5, T),
  h(6, ce),
  h(7, H),
  h(8, K),
  h(9, pr),
  h(10, wc),
  h(11, O),
  h(12, ii),
  h(13, at)
], wo);
const Ps = class Ps extends vc {
  constructor() {
    super({
      id: Ps.ID,
      precondition: fr,
      kbOpts: {
        kbExpr: Cc,
        primary: 3,
        weight: 100
      }
    });
  }
  runEditorCommand(e, t) {
    e.get(Br).close(!0);
  }
};
Ps.ID = "breakpointWidget.action.acceptInput";
let ps = Ps;
const Fs = class Fs extends vc {
  constructor() {
    super({
      id: Fs.ID,
      precondition: fr,
      kbOpts: {
        kbExpr: Be.textInputFocus,
        primary: 9,
        secondary: [1033],
        weight: 100
      }
    });
  }
  runEditorCommand(e, t, i) {
    const s = t.getContribution(si);
    if (s)
      return s.closeBreakpointWidget();
    e.get(Br).close(!1);
  }
};
Fs.ID = "closeBreakpointWidget";
let fs = Fs;
kc(new ps());
kc(new fs());
const lp = ie, up = {
  description: "breakpoint-helper-decoration",
  glyphMarginClassName: L.asClassName(Er),
  glyphMargin: { position: Zs.Right },
  stickiness: 1
};
function hp(l, e, t, i, s, n) {
  const o = [];
  return t.forEach((r) => {
    if (r.lineNumber > e.getLineCount())
      return;
    const a = t.some((g) => g !== r && g.lineNumber === r.lineNumber), d = e.getLineFirstNonWhitespaceColumn(r.lineNumber), u = e.validateRange(
      r.column ? new re(
        r.lineNumber,
        r.column,
        r.lineNumber,
        r.column + 1
      ) : new re(r.lineNumber, d, r.lineNumber, d + 1)
    );
    o.push({
      options: gp(l, e, r, i, s, n, a),
      range: u
    });
  }), o;
}
function gp(l, e, t, i, s, n, o) {
  const r = l.get(T), a = l.get(or), { icon: d, message: u, showAdapterUnverifiedMessage: g } = dd(i, s, t, void 0);
  let p, f;
  if (g) {
    let m;
    f = r.getModel().getSessions().map((y) => {
      var C;
      const _ = r.getAdapterManager().getDebugger(y.configuration.type), v = (C = _ == null ? void 0 : _.strings) == null ? void 0 : C[hu.UnverifiedBreakpoints];
      if (v)
        return m || (m = Nc(a.guessLanguageIdByFilepathOrFirstLine(t.uri))), m && _.interestedInLanguage(m) ? v : void 0;
    }).find((y) => !!y);
  }
  if (u)
    if (p = new sa(void 0, { isTrusted: !0, supportThemeIcons: !0 }), t.condition || t.hitCondition) {
      const m = e.getLanguageId();
      p.appendCodeblock(m, u), f && p.appendMarkdown("$(warning) " + f);
    } else
      p.appendText(u), f && p.appendMarkdown(`

$(warning) ` + f);
  else
    f && (p = new sa(void 0, { isTrusted: !0, supportThemeIcons: !0 }).appendMarkdown(f));
  let S = null;
  n && (S = {
    color: mr(Ed),
    position: Sr.Left
  });
  const w = t.column && (o || t.column > e.getLineFirstNonWhitespaceColumn(t.lineNumber));
  return {
    description: "breakpoint-decoration",
    glyphMargin: { position: Zs.Right },
    glyphMarginClassName: L.asClassName(d),
    glyphMarginHoverMessage: p,
    stickiness: 1,
    before: w ? {
      content: en,
      inlineClassName: "debug-breakpoint-placeholder",
      inlineClassNameAffectsLetterSpacing: !0
    } : void 0,
    overviewRuler: S,
    zIndex: 9999
  };
}
async function pp(l, e, t) {
  return t.capabilities.supportsBreakpointLocationsRequest ? await Promise.all(St(e, (i) => i).map(async (i) => {
    try {
      return { lineNumber: i, positions: await t.breakpointsLocations(l.uri, i) };
    } catch {
      return { lineNumber: i, positions: [] };
    }
  })) : [];
}
function fp(l, e, t) {
  const i = [];
  for (const { positions: s, lineNumber: n } of t) {
    if (s.length === 0)
      continue;
    const o = l.getLineFirstNonWhitespaceColumn(n), r = l.getLineLastNonWhitespaceColumn(n);
    s.forEach((a) => {
      const d = new re(a.lineNumber, a.column, a.lineNumber, a.column + 1);
      if (a.column <= o && !e.some(
        (g) => g.range.startColumn > o && g.range.startLineNumber === a.lineNumber
      ) || a.column > r)
        return;
      const u = e.find((g) => g.range.equalsRange(d));
      u && u.inlineWidget || i.push({
        range: d,
        options: {
          description: "breakpoint-placeholder-decoration",
          stickiness: 1,
          before: u ? void 0 : {
            content: en,
            inlineClassName: "debug-breakpoint-placeholder",
            inlineClassNameAffectsLetterSpacing: !0
          }
        },
        breakpoint: u ? u.breakpoint : void 0
      });
    });
  }
  return i;
}
let vo = class {
  constructor(e, t, i, s, n, o, r, a) {
    this.editor = e, this.debugService = t, this.contextMenuService = i, this.instantiationService = s, this.dialogService = o, this.configurationService = r, this.labelService = a, this.breakpointHintDecoration = null, this.toDispose = [], this.ignoreDecorationsChangedEvent = !1, this.ignoreBreakpointsChangeEvent = !1, this.breakpointDecorations = [], this.candidateDecorations = [], this.breakpointWidgetVisible = fr.bindTo(n), this.setDecorationsScheduler = new oe(() => this.setDecorations(), 30), this.setDecorationsScheduler.schedule(), this.registerListeners();
  }
  getContextMenuActionsAtPosition(e, t) {
    if (!this.debugService.getAdapterManager().hasEnabledDebuggers())
      return [];
    if (!this.debugService.canSetBreakpointsIn(t))
      return [];
    const i = this.debugService.getModel().getBreakpoints({ lineNumber: e, uri: t.uri });
    return this.getContextMenuActions(i, t.uri, e);
  }
  registerListeners() {
    this.toDispose.push(this.editor.onMouseDown(async (e) => {
      var o;
      if (!this.debugService.getAdapterManager().hasEnabledDebuggers())
        return;
      const t = this.editor.getModel();
      if (!e.target.position || !t || e.target.type !== 2 || e.target.detail.isAfterLines || !this.marginFreeFromNonDebugDecorations(e.target.position.lineNumber) && !((o = e.target.element) != null && o.className.includes("breakpoint")))
        return;
      const i = this.debugService.canSetBreakpointsIn(t), s = e.target.position.lineNumber, n = t.uri;
      if (!(e.event.rightButton || Oe && e.event.leftButton && e.event.ctrlKey)) {
        const r = this.debugService.getModel().getBreakpoints({ uri: n, lineNumber: s });
        if (r.length) {
          const a = e.event.shiftKey, d = r.some((u) => u.enabled);
          if (a)
            r.forEach((u) => this.debugService.enableOrDisableBreakpoints(!d, u));
          else if (!au && r.some((u) => !!u.condition || !!u.logMessage || !!u.hitCondition)) {
            const u = r.every((S) => !!S.logMessage), g = u ? c("logPoint", "Logpoint") : c("breakpoint", "Breakpoint"), p = c(
              "breakpointHasConditionDisabled",
              "This {0} has a {1} that will get lost on remove. Consider enabling the {0} instead.",
              g.toLowerCase(),
              u ? c("message", "message") : c("condition", "condition")
            ), f = c(
              "breakpointHasConditionEnabled",
              "This {0} has a {1} that will get lost on remove. Consider disabling the {0} instead.",
              g.toLowerCase(),
              u ? c("message", "message") : c("condition", "condition")
            );
            await this.dialogService.prompt({
              type: fe.Info,
              message: d ? f : p,
              buttons: [
                {
                  label: c(
                    { key: "removeLogPoint", comment: ["&& denotes a mnemonic"] },
                    "&&Remove {0}",
                    g
                  ),
                  run: () => r.forEach((S) => this.debugService.removeBreakpoints(S.getId()))
                },
                {
                  label: c(
                    "disableLogPoint",
                    "{0} {1}",
                    d ? c({ key: "disable", comment: ["&& denotes a mnemonic"] }, "&&Disable") : c({ key: "enable", comment: ["&& denotes a mnemonic"] }, "&&Enable"),
                    g
                  ),
                  run: () => r.forEach((S) => this.debugService.enableOrDisableBreakpoints(!d, S))
                }
              ],
              cancelButton: !0
            });
          } else
            d ? r.forEach((u) => this.debugService.removeBreakpoints(u.getId())) : r.forEach((u) => this.debugService.enableOrDisableBreakpoints(!d, u));
        } else
          i && this.debugService.addBreakpoints(n, [{ lineNumber: s }]);
      }
    })), cu.pointerEvents && du || (this.toDispose.push(this.editor.onMouseMove((e) => {
      if (!this.debugService.getAdapterManager().hasEnabledDebuggers())
        return;
      let t = -1;
      const i = this.editor.getModel();
      i && e.target.position && (e.target.type === 2 || e.target.type === 3) && this.debugService.canSetBreakpointsIn(i) && this.marginFreeFromNonDebugDecorations(e.target.position.lineNumber) && (e.target.detail.isAfterLines || (t = e.target.position.lineNumber)), this.ensureBreakpointHintDecoration(t);
    })), this.toDispose.push(this.editor.onMouseLeave(() => {
      this.ensureBreakpointHintDecoration(-1);
    }))), this.toDispose.push(this.editor.onDidChangeModel(async () => {
      this.closeBreakpointWidget(), await this.setDecorations();
    })), this.toDispose.push(this.debugService.getModel().onDidChangeBreakpoints(() => {
      !this.ignoreBreakpointsChangeEvent && !this.setDecorationsScheduler.isScheduled() && this.setDecorationsScheduler.schedule();
    })), this.toDispose.push(this.debugService.onDidChangeState(() => {
      this.setDecorationsScheduler.isScheduled() || this.setDecorationsScheduler.schedule();
    })), this.toDispose.push(this.editor.onDidChangeModelDecorations(() => this.onModelDecorationsChanged())), this.toDispose.push(this.configurationService.onDidChangeConfiguration(async (e) => {
      (e.affectsConfiguration("debug.showBreakpointsInOverviewRuler") || e.affectsConfiguration("debug.showInlineBreakpointCandidates")) && await this.setDecorations();
    }));
  }
  getContextMenuActions(e, t, i, s) {
    const n = [];
    if (e.length === 1) {
      const o = e[0].logMessage ? c("logPoint", "Logpoint") : c("breakpoint", "Breakpoint");
      n.push(new Z(
        "debug.removeBreakpoint",
        c("removeBreakpoint", "Remove {0}", o),
        void 0,
        !0,
        async () => {
          await this.debugService.removeBreakpoints(e[0].getId());
        }
      )), n.push(new Z(
        "workbench.debug.action.editBreakpointAction",
        c("editBreakpoint", "Edit {0}...", o),
        void 0,
        !0,
        () => Promise.resolve(this.showBreakpointWidget(e[0].lineNumber, e[0].column))
      )), n.push(new Z(
        "workbench.debug.viewlet.action.toggleBreakpoint",
        e[0].enabled ? c("disableBreakpoint", "Disable {0}", o) : c("enableBreakpoint", "Enable {0}", o),
        void 0,
        !0,
        () => this.debugService.enableOrDisableBreakpoints(!e[0].enabled, e[0])
      ));
    } else if (e.length > 1) {
      const o = e.slice().sort((r, a) => r.column && a.column ? r.column - a.column : 1);
      n.push(new In(
        "debug.removeBreakpoints",
        c("removeBreakpoints", "Remove Breakpoints"),
        o.map(
          (r) => new Z("removeInlineBreakpoint", r.column ? c(
            "removeInlineBreakpointOnColumn",
            "Remove Inline Breakpoint on Column {0}",
            r.column
          ) : c("removeLineBreakpoint", "Remove Line Breakpoint"), void 0, !0, () => this.debugService.removeBreakpoints(r.getId()))
        )
      )), n.push(new In(
        "debug.editBreakpoints",
        c("editBreakpoints", "Edit Breakpoints"),
        o.map(
          (r) => new Z("editBreakpoint", r.column ? c(
            "editInlineBreakpointOnColumn",
            "Edit Inline Breakpoint on Column {0}",
            r.column
          ) : c("editLineBreakpoint", "Edit Line Breakpoint"), void 0, !0, () => Promise.resolve(this.showBreakpointWidget(r.lineNumber, r.column)))
        )
      )), n.push(new In(
        "debug.enableDisableBreakpoints",
        c("enableDisableBreakpoints", "Enable/Disable Breakpoints"),
        o.map((r) => new Z(
          r.enabled ? "disableColumnBreakpoint" : "enableColumnBreakpoint",
          r.enabled ? r.column ? c(
            "disableInlineColumnBreakpoint",
            "Disable Inline Breakpoint on Column {0}",
            r.column
          ) : c("disableBreakpointOnLine", "Disable Line Breakpoint") : r.column ? c("enableBreakpoints", "Enable Inline Breakpoint on Column {0}", r.column) : c("enableBreakpointOnLine", "Enable Line Breakpoint"),
          void 0,
          !0,
          () => this.debugService.enableOrDisableBreakpoints(!r.enabled, r)
        ))
      ));
    } else
      n.push(new Z(
        "addBreakpoint",
        c("addBreakpoint", "Add Breakpoint"),
        void 0,
        !0,
        () => this.debugService.addBreakpoints(t, [{ lineNumber: i, column: s }])
      )), n.push(new Z(
        "addConditionalBreakpoint",
        c("addConditionalBreakpoint", "Add Conditional Breakpoint..."),
        void 0,
        !0,
        () => Promise.resolve(this.showBreakpointWidget(i, s, 0))
      )), n.push(new Z(
        "addLogPoint",
        c("addLogPoint", "Add Logpoint..."),
        void 0,
        !0,
        () => Promise.resolve(this.showBreakpointWidget(i, s, 2))
      ));
    return this.debugService.state === 2 && (n.push(new lu()), n.push(new Z(
      "runToLine",
      c("runToLine", "Run to Line"),
      void 0,
      !0,
      () => this.debugService.runTo(t, i).catch(Lc)
    ))), n;
  }
  marginFreeFromNonDebugDecorations(e) {
    const t = this.editor.getLineDecorations(e);
    if (t)
      for (const { options: i } of t) {
        const s = i.glyphMarginClassName;
        if (s && (!s.includes("codicon-") || s.includes("codicon-testing-") || s.includes("codicon-merge-") || s.includes("codicon-arrow-") || s.includes("codicon-loading") || s.includes("codicon-fold")))
          return !1;
      }
    return !0;
  }
  ensureBreakpointHintDecoration(e) {
    this.editor.changeDecorations((t) => {
      this.breakpointHintDecoration && (t.removeDecoration(this.breakpointHintDecoration), this.breakpointHintDecoration = null), e !== -1 && (this.breakpointHintDecoration = t.addDecoration({
        startLineNumber: e,
        startColumn: 1,
        endLineNumber: e,
        endColumn: 1
      }, up));
    });
  }
  async setDecorations() {
    if (!this.editor.hasModel())
      return;
    const e = (u, g) => {
      const p = fp(i, this.breakpointDecorations, g), f = u.deltaDecorations(this.candidateDecorations.map((S) => S.decorationId), p);
      this.candidateDecorations.forEach((S) => {
        S.inlineWidget.dispose();
      }), this.candidateDecorations = f.map((S, w) => {
        const m = p[w], y = m.breakpoint ? dd(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), m.breakpoint, this.labelService).icon : Di.disabled, _ = () => this.getContextMenuActions(m.breakpoint ? [m.breakpoint] : [], t.getModel().uri, m.range.startLineNumber, m.range.startColumn), v = new bs(
          t,
          S,
          L.asClassName(y),
          m.breakpoint,
          this.debugService,
          this.contextMenuService,
          _
        );
        return {
          decorationId: S,
          inlineWidget: v
        };
      });
    }, t = this.editor, i = t.getModel(), s = this.debugService.getModel().getBreakpoints({ uri: i.uri }), n = this.configurationService.getValue("debug"), o = this.instantiationService.invokeFunction((u) => hp(u, i, s, this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), n.showBreakpointsInOverviewRuler)), r = this.debugService.getViewModel().focusedSession, a = n.showInlineBreakpointCandidates && r ? pp(this.editor.getModel(), o.map((u) => u.range.startLineNumber), r) : Promise.resolve([]), d = await Promise.race([a, Mc(500).then(() => {
    })]);
    d === void 0 && a.then((u) => t.changeDecorations((g) => e(g, u)));
    try {
      this.ignoreDecorationsChangedEvent = !0, t.changeDecorations((u) => {
        const g = u.deltaDecorations(this.breakpointDecorations.map((p) => p.decorationId), o);
        this.breakpointDecorations.forEach((p) => {
          var f;
          (f = p.inlineWidget) == null || f.dispose();
        }), this.breakpointDecorations = g.map((p, f) => {
          let S;
          const w = s[f];
          if (o[f].options.before) {
            const m = () => this.getContextMenuActions([w], t.getModel().uri, w.lineNumber, w.column);
            S = new bs(
              t,
              p,
              o[f].options.glyphMarginClassName,
              w,
              this.debugService,
              this.contextMenuService,
              m
            );
          }
          return {
            decorationId: p,
            breakpoint: w,
            range: o[f].range,
            inlineWidget: S
          };
        }), d && e(u, d);
      });
    } finally {
      this.ignoreDecorationsChangedEvent = !1;
    }
    for (const u of this.breakpointDecorations)
      u.inlineWidget && this.editor.layoutContentWidget(u.inlineWidget);
  }
  async onModelDecorationsChanged() {
    if (this.breakpointDecorations.length === 0 || this.ignoreDecorationsChangedEvent || !this.editor.hasModel())
      return;
    let e = !1;
    const t = this.editor.getModel();
    if (this.breakpointDecorations.forEach((s) => {
      if (e)
        return;
      const n = t.getDecorationRange(s.decorationId);
      n && !s.range.equalsRange(n) && (e = !0, s.range = n);
    }), !e)
      return;
    const i = /* @__PURE__ */ new Map();
    for (let s = 0, n = this.breakpointDecorations.length; s < n; s++) {
      const o = this.breakpointDecorations[s], r = t.getDecorationRange(o.decorationId);
      r && o.breakpoint && i.set(o.breakpoint.getId(), {
        lineNumber: r.startLineNumber,
        column: o.breakpoint.column ? r.startColumn : void 0
      });
    }
    try {
      this.ignoreBreakpointsChangeEvent = !0, await this.debugService.updateBreakpoints(t.uri, i, !0);
    } finally {
      this.ignoreBreakpointsChangeEvent = !1;
    }
  }
  showBreakpointWidget(e, t, i) {
    var s;
    (s = this.breakpointWidget) == null || s.dispose(), this.breakpointWidget = this.instantiationService.createInstance(wo, this.editor, e, t, i), this.breakpointWidget.show({ lineNumber: e, column: 1 }), this.breakpointWidgetVisible.set(!0);
  }
  closeBreakpointWidget() {
    this.breakpointWidget && (this.breakpointWidget.dispose(), this.breakpointWidget = void 0, this.breakpointWidgetVisible.reset(), this.editor.focus());
  }
  dispose() {
    var e;
    (e = this.breakpointWidget) == null || e.dispose(), this.editor.removeDecorations(this.breakpointDecorations.map((t) => t.decorationId)), U(this.toDispose);
  }
};
vo = I([
  h(1, T),
  h(2, Me),
  h(3, K),
  h(4, H),
  h(5, Jt),
  h(6, O),
  h(7, Vi)
], vo);
ru.registerGutterActionsGenerator(({ lineNumber: l, editor: e, accessor: t }, i) => {
  const s = e.getModel(), n = t.get(T);
  if (!s || !n.getAdapterManager().hasEnabledDebuggers() || !n.canSetBreakpointsIn(s))
    return;
  const o = e.getContribution(si);
  if (!o)
    return;
  const r = o.getContextMenuActionsAtPosition(l, s);
  for (const a of r)
    i.push(a, "2_debug");
});
class bs {
  constructor(e, t, i, s, n, o, r) {
    this.editor = e, this.decorationId = t, this.breakpoint = s, this.debugService = n, this.contextMenuService = o, this.getContextMenuActions = r, this.allowEditorOverflow = !1, this.suppressMouseDown = !0, this.toDispose = [], this.range = this.editor.getModel().getDecorationRange(t), this.toDispose.push(this.editor.onDidChangeModelDecorations(() => {
      const d = this.editor.getModel().getDecorationRange(this.decorationId);
      this.range && !this.range.equalsRange(d) && (this.range = d, this.editor.layoutContentWidget(this));
    })), this.create(i), this.editor.addContentWidget(this), this.editor.layoutContentWidget(this);
  }
  create(e) {
    this.domNode = lp(".inline-breakpoint-widget"), e && this.domNode.classList.add(...e.split(" ")), this.toDispose.push(le(this.domNode, ne.CLICK, async (i) => {
      var s;
      switch ((s = this.breakpoint) == null ? void 0 : s.enabled) {
        case void 0:
          await this.debugService.addBreakpoints(this.editor.getModel().uri, [{ lineNumber: this.range.startLineNumber, column: this.range.startColumn }]);
          break;
        case !0:
          await this.debugService.removeBreakpoints(this.breakpoint.getId());
          break;
        case !1:
          this.debugService.enableOrDisableBreakpoints(!0, this.breakpoint);
          break;
      }
    })), this.toDispose.push(le(this.domNode, ne.CONTEXT_MENU, (i) => {
      const s = new Jn(i), n = this.getContextMenuActions();
      this.contextMenuService.showContextMenu({
        getAnchor: () => s,
        getActions: () => n,
        getActionsContext: () => this.breakpoint,
        onHide: () => uu(n)
      });
    }));
    const t = () => {
      const i = this.editor.getOption(65);
      this.domNode.style.height = `${i}px`, this.domNode.style.width = `${Math.ceil(0.8 * i)}px`, this.domNode.style.marginLeft = "4px";
    };
    t(), this.toDispose.push(this.editor.onDidChangeConfiguration((i) => {
      (i.hasChanged(51) || i.hasChanged(65)) && t();
    }));
  }
  getId() {
    return Zt();
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return this.range ? (this.domNode.classList.toggle("line-start", this.range.startColumn === 1), {
      position: { lineNumber: this.range.startLineNumber, column: this.range.startColumn - 1 },
      preference: [0]
    }) : null;
  }
  dispose() {
    this.editor.removeContentWidget(this), U(this.toDispose);
  }
}
bs.__decorator = I([
  ni
], bs.prototype, "getId", null);
Bc((l, e) => {
  const t = l.getColor(Ed);
  t && e.addRule(`
		${An.map((r) => `.monaco-workbench ${L.asCSSSelector(r.regular)}`).join(`,
		`)},
		.monaco-workbench ${L.asCSSSelector(Kh)},
		.monaco-workbench ${L.asCSSSelector(Er)}:not([class*='codicon-debug-breakpoint']):not([class*='codicon-debug-stackframe']),
		.monaco-workbench ${L.asCSSSelector(Di.regular)}${L.asCSSSelector(os)}::after,
		.monaco-workbench ${L.asCSSSelector(Di.regular)}${L.asCSSSelector(rs)}::after {
			color: ${t} !important;
		}
		`);
  const i = l.getColor(bp);
  i && e.addRule(`
		${An.map((r) => `.monaco-workbench ${L.asCSSSelector(r.disabled)}`).join(`,
		`)} {
			color: ${i};
		}
		`);
  const s = l.getColor(mp);
  s && e.addRule(`
		${An.map((r) => `.monaco-workbench ${L.asCSSSelector(r.unverified)}`).join(`,
		`)} {
			color: ${s};
		}
		`);
  const n = l.getColor(Sp);
  n && e.addRule(`
		.monaco-workbench ${L.asCSSSelector(rs)},
		.monaco-editor .debug-top-stack-frame-column {
			color: ${n} !important;
		}
		`);
  const o = l.getColor(wp);
  o && e.addRule(`
		.monaco-workbench ${L.asCSSSelector(os)} {
			color: ${o} !important;
		}
		`);
});
const Ed = M("debugIcon.breakpointForeground", { dark: "#E51400", light: "#E51400", hcDark: "#E51400", hcLight: "#E51400" }, c("debugIcon.breakpointForeground", "Icon color for breakpoints.")), bp = M("debugIcon.breakpointDisabledForeground", { dark: "#848484", light: "#848484", hcDark: "#848484", hcLight: "#848484" }, c(
  "debugIcon.breakpointDisabledForeground",
  "Icon color for disabled breakpoints."
)), mp = M("debugIcon.breakpointUnverifiedForeground", { dark: "#848484", light: "#848484", hcDark: "#848484", hcLight: "#848484" }, c(
  "debugIcon.breakpointUnverifiedForeground",
  "Icon color for unverified breakpoints."
)), Sp = M("debugIcon.breakpointCurrentStackframeForeground", { dark: "#FFCC00", light: "#BE8700", hcDark: "#FFCC00", hcLight: "#BE8700" }, c(
  "debugIcon.breakpointCurrentStackframeForeground",
  "Icon color for the current breakpoint stack frame."
)), wp = M("debugIcon.breakpointStackframeForeground", { dark: "#89D185", light: "#89D185", hcDark: "#89D185", hcLight: "#89D185" }, c(
  "debugIcon.breakpointStackframeForeground",
  "Icon color for all breakpoint stack frames."
));
var vp = ".monaco-editor .view-overlays .debug-top-stack-frame-line{background-color:var(--vscode-editor-stackFrameHighlightBackground)}.monaco-editor .view-overlays .debug-focused-stack-frame-line{background-color:var(--vscode-editor-focusedStackFrameHighlightBackground)}";
ot(vp, {});
const Co = M("editor.stackFrameHighlightBackground", { dark: "#ffff0033", light: "#ffff6673", hcDark: "#ffff0033", hcLight: "#ffff6673" }, c(
  "topStackFrameLineHighlight",
  "Background color for the highlight of line at the top stack frame position."
)), ko = M("editor.focusedStackFrameHighlightBackground", { dark: "#7abd7a4d", light: "#cee7ce73", hcDark: "#7abd7a4d", hcLight: "#cee7ce73" }, c(
  "focusedStackFrameLineHighlight",
  "Background color for the highlight of line at focused stack frame position."
)), yn = 1, Cp = {
  description: "top-stack-frame-margin",
  glyphMarginClassName: L.asClassName(rs),
  glyphMargin: { position: Zs.Right },
  zIndex: 9999,
  stickiness: yn,
  overviewRuler: {
    position: Sr.Full,
    color: mr(Co)
  }
}, kp = {
  description: "focused-stack-frame-margin",
  glyphMarginClassName: L.asClassName(os),
  glyphMargin: { position: Zs.Right },
  zIndex: 9999,
  stickiness: yn,
  overviewRuler: {
    position: Sr.Full,
    color: mr(ko)
  }
}, yp = {
  description: "top-stack-frame-decoration",
  isWholeLine: !0,
  className: "debug-top-stack-frame-line",
  stickiness: yn
}, Dp = {
  description: "focused-stack-frame-decoration",
  isWholeLine: !0,
  className: "debug-focused-stack-frame-line",
  stickiness: yn
};
function Ep(l, e, t) {
  const i = [], s = new re(
    l.range.startLineNumber,
    l.range.startColumn,
    l.range.startLineNumber,
    1073741824
  ), n = new re(
    l.range.startLineNumber,
    l.range.startColumn,
    l.range.startLineNumber,
    l.range.startColumn + 1
  ), o = l.thread.getTopStackFrame();
  return l.getId() === (o == null ? void 0 : o.getId()) ? (e && i.push({
    options: Cp,
    range: n
  }), i.push({
    options: yp,
    range: s
  }), l.range.startColumn > 1 && i.push({
    options: {
      description: "top-stack-frame-inline-decoration",
      before: {
        content: "",
        inlineClassName: t ? "debug-top-stack-frame-column start-of-line" : "debug-top-stack-frame-column",
        inlineClassNameAffectsLetterSpacing: !0
      }
    },
    range: s
  })) : (e && i.push({
    options: kp,
    range: n
  }), i.push({
    options: Dp,
    range: s
  })), i;
}
let yo = class extends Qt {
  constructor(e, t, i, s) {
    super(), this.editor = e, this.debugService = t, this.uriIdentityService = i, this.logService = s, this.decorations = this.editor.createDecorationsCollection();
    const n = () => this.decorations.set(this.createCallStackDecorations());
    this._register(Ze.any(this.debugService.getViewModel().onDidFocusStackFrame, this.debugService.getModel().onDidChangeCallStack)(() => {
      n();
    })), this._register(this.editor.onDidChangeModel((o) => {
      o.newModelUrl && n();
    })), n();
  }
  createCallStackDecorations() {
    const e = this.editor;
    if (!e.hasModel())
      return [];
    const t = this.debugService.getViewModel().focusedStackFrame, i = [];
    return this.debugService.getModel().getSessions().forEach((s) => {
      const n = s === (t == null ? void 0 : t.thread.session);
      s.getAllThreads().forEach((o) => {
        if (o.stopped) {
          const r = o.getCallStack(), a = [];
          r.length > 0 && (t && !t.equals(r[0]) && a.push(t), a.push(r[0])), a.forEach((d) => {
            var u, g;
            if (d && this.uriIdentityService.extUri.isEqual(d.source.uri, (u = e.getModel()) == null ? void 0 : u.uri)) {
              if (d.range.startLineNumber > ((g = e.getModel()) == null ? void 0 : g.getLineCount()) || d.range.startLineNumber < 1) {
                this.logService.warn(`CallStackEditorContribution: invalid stack frame line number: ${d.range.startLineNumber}`);
                return;
              }
              const p = e.getModel().getLineFirstNonWhitespaceColumn(d.range.startLineNumber) >= d.range.startColumn;
              i.push(...Ep(d, n, p));
            }
          });
        }
      });
    }), St(i, (s) => `${s.options.className} ${s.options.glyphMarginClassName} ${s.range.startLineNumber} ${s.range.startColumn}`);
  }
  dispose() {
    super.dispose(), this.decorations.clear();
  }
};
yo = I([
  h(1, T),
  h(2, Le),
  h(3, ei)
], yo);
const Ip = 1024, xp = /^(true|false)$/i, Tp = /^(['"]).*\1$/, gt = ie;
function Dn(l) {
  const e = gt(".");
  return e.classList.add("debug-view-content"), l.appendChild(e), e;
}
function li(l, e, t) {
  let i = typeof l == "string" ? l : l.value;
  if (e.className = "value", i === null || (l instanceof Y || l instanceof q || l instanceof Dt) && !l.available ? (e.classList.add("unavailable"), i !== Y.DEFAULT_VALUE && e.classList.add("error")) : (l instanceof yi && t.showChanged && l.valueChanged && i !== Y.DEFAULT_VALUE && (e.className = "value changed", l.valueChanged = !1), t.colorize && typeof l != "string" && (l.type === "number" || l.type === "boolean" || l.type === "string" ? e.classList.add(l.type) : isNaN(+i) ? xp.test(i) ? e.classList.add("boolean") : Tp.test(i) && e.classList.add("string") : e.classList.add("number"))), t.maxValueLength && i && i.length > t.maxValueLength && (i = i.substring(0, t.maxValueLength) + "..."), i || (i = ""), t.linkDetector) {
    e.textContent = "";
    const s = l instanceof yi ? l.getSession() : void 0;
    e.appendChild(t.linkDetector.linkify(i, !1, s ? s.root : void 0, !0));
  } else
    e.textContent = i;
  t.showHover && (e.title = i || "");
}
function Id(l, e, t, i, s) {
  var n, o, r;
  if (l.available) {
    let a = l.name;
    l.value && typeof l.name == "string" && (a += ":"), e.label.set(a, i, l.type ? l.type : l.name), e.name.classList.toggle("virtual", ((n = l.presentationHint) == null ? void 0 : n.kind) === "virtual"), e.name.classList.toggle("internal", ((o = l.presentationHint) == null ? void 0 : o.visibility) === "internal");
  } else
    l.value && typeof l.name == "string" && l.name && e.label.set(":");
  e.expression.classList.toggle("lazy", !!((r = l.presentationHint) != null && r.lazy)), li(l, e.value, {
    showChanged: t,
    maxValueLength: Ip,
    showHover: !0,
    colorize: !0,
    linkDetector: s
  });
}
let xi = class {
  constructor(e, t) {
    this.debugService = e, this.contextViewService = t;
  }
  renderTemplate(e) {
    const t = E(e, gt(".expression")), i = E(t, gt("span.name")), s = E(t, gt("span.lazy-button"));
    s.classList.add(...L.asClassNameArray(tn.eye)), s.title = c("debug.lazyButton.tooltip", "Click to expand");
    const n = E(t, gt("span.value")), o = new kt(i), r = E(t, gt(".inputBoxContainer")), a = new te();
    let d;
    this.renderActionBar && (E(t, gt(".span.actionbar-spacer")), d = a.add(new oi(t)));
    const u = { expression: t, name: i, value: n, label: o, inputBoxContainer: r, actionBar: d, elementDisposable: [], templateDisposable: a, lazyButton: s, currentElement: void 0 };
    return a.add(le(s, ne.CLICK, () => {
      u.currentElement && this.debugService.getViewModel().evaluateLazyExpression(u.currentElement);
    })), u;
  }
  renderExpressionElement(e, t, i) {
    i.currentElement = e, this.renderExpression(t.element, i, Fe(t.filterData)), i.actionBar && this.renderActionBar(i.actionBar, e, i);
    const s = this.debugService.getViewModel().getSelectedExpression();
    if (e === (s == null ? void 0 : s.expression) || e instanceof q && e.errorMessage) {
      const n = this.getInputBoxOptions(e, !!(s != null && s.settingWatch));
      n && i.elementDisposable.push(this.renderInputBox(i.name, i.value, i.inputBoxContainer, n));
    }
  }
  renderInputBox(e, t, i, s) {
    e.style.display = "none", t.style.display = "none", i.style.display = "initial", sn(i);
    const n = new gu(
      i,
      this.contextViewService,
      { ...s, inputBoxStyles: pu }
    );
    n.value = s.initialValue, n.focus(), n.select();
    const o = fu((a, d) => {
      e.style.display = "", t.style.display = "", i.style.display = "none";
      const u = n.value;
      U(r), d && (this.debugService.getViewModel().setSelectedExpression(void 0, !1), s.onFinish(u, a));
    }), r = [
      n,
      Ke(n.inputElement, ne.KEY_DOWN, (a) => {
        const d = a.equals(9), u = a.equals(3);
        (d || u) && (a.preventDefault(), a.stopPropagation(), o(u, !0));
      }),
      le(n.inputElement, ne.BLUR, () => {
        o(!0, !0);
      }),
      le(n.inputElement, ne.CLICK, (a) => {
        a.preventDefault(), a.stopPropagation();
      })
    ];
    return ic(() => {
      o(!1, !1);
    });
  }
  disposeElement(e, t, i) {
    U(i.elementDisposable), i.elementDisposable = [];
  }
  disposeTemplate(e) {
    U(e.elementDisposable), e.templateDisposable.dispose();
  }
};
xi = I([
  h(0, T),
  h(1, rt)
], xi);
var _p = ".monaco-workbench .debug-toolbar{border-radius:4px;display:flex;height:32px;padding-left:7px;position:absolute;z-index:39}.monaco-workbench .debug-toolbar .monaco-action-bar .action-item{margin-right:4px}.monaco-workbench .debug-toolbar .monaco-action-bar .action-item.select-container{margin-right:7px}.monaco-workbench .debug-toolbar .monaco-action-bar .action-item.select-container .monaco-select-box,.monaco-workbench .start-debug-action-item .select-container .monaco-select-box{padding:0 22px 0 6px}.monaco-workbench .debug-toolbar .drag-area{align-items:center;cursor:grab;display:flex;justify-content:center;opacity:.5;width:16px}.monaco-workbench .debug-toolbar .drag-area.dragged{cursor:grabbing}.monaco-workbench .debug-toolbar .monaco-action-bar .action-item .action-label{align-items:center;background-position:50%;background-repeat:no-repeat;background-size:16px;display:flex;justify-content:center;margin-right:0}";
ot(_p, {});
const Aa = ie;
var mt;
let Do = (mt = class extends bu {
  constructor(e, t, i, s, n, o, r, a) {
    super(e, t), this.context = e, this.debugService = i, this.configurationService = s, this.commandService = n, this.contextService = o, this.keybindingService = a, this.debugOptions = [], this.selected = 0, this.providers = [], this.toDispose = [], this.selectBox = new Ec(
      [],
      -1,
      r,
      br,
      { ariaLabel: c("debugLaunchConfigurations", "Debug Launch Configurations") }
    ), this.selectBox.setFocusable(!1), this.toDispose.push(this.selectBox), this.registerListeners();
  }
  registerListeners() {
    this.toDispose.push(this.configurationService.onDidChangeConfiguration((e) => {
      e.affectsConfiguration("launch") && this.updateOptions();
    })), this.toDispose.push(this.debugService.getConfigurationManager().onDidSelectConfiguration(() => {
      this.updateOptions();
    }));
  }
  render(e) {
    var n;
    this.container = e, e.classList.add("start-debug-action-item"), this.start = E(e, Aa(L.asCSSSelector(ld)));
    const t = (n = this.keybindingService.lookupKeybinding(this.action.id)) == null ? void 0 : n.getLabel(), i = t ? ` (${t})` : "";
    this.start.title = this.action.label + i, this.start.setAttribute("role", "button"), this.start.ariaLabel = this.start.title, this.toDispose.push(le(this.start, ne.CLICK, () => {
      this.start.blur(), this.debugService.state !== 1 && this.actionRunner.run(this.action, this.context);
    })), this.toDispose.push(le(this.start, ne.MOUSE_DOWN, (o) => {
      this.action.enabled && o.button === 0 && this.start.classList.add("active");
    })), this.toDispose.push(le(this.start, ne.MOUSE_UP, () => {
      this.start.classList.remove("active");
    })), this.toDispose.push(le(this.start, ne.MOUSE_OUT, () => {
      this.start.classList.remove("active");
    })), this.toDispose.push(le(this.start, ne.KEY_DOWN, (o) => {
      const r = new ki(o);
      r.equals(17) && (this.start.tabIndex = -1, this.selectBox.focus(), r.stopPropagation());
    })), this.toDispose.push(this.selectBox.onDidSelect(async (o) => {
      const r = this.debugOptions[o.index];
      (r.handler ? await r.handler() : !1) ? this.selected = o.index : this.selectBox.select(this.selected);
    }));
    const s = Aa(".configuration");
    this.selectBox.render(E(e, s)), this.toDispose.push(le(s, ne.KEY_DOWN, (o) => {
      const r = new ki(o);
      r.equals(15) && (this.selectBox.setFocusable(!1), this.start.tabIndex = 0, this.start.focus(), r.stopPropagation());
    })), this.container.style.border = `1px solid ${je(na)}`, s.style.borderLeft = `1px solid ${je(na)}`, this.container.style.backgroundColor = je(mu), this.debugService.getConfigurationManager().getDynamicProviders().then((o) => {
      this.providers = o, this.providers.length > 0 && this.updateOptions();
    }), this.updateOptions();
  }
  setActionContext(e) {
    this.context = e;
  }
  isEnabled() {
    return !0;
  }
  focus(e) {
    e ? this.selectBox.focus() : (this.start.tabIndex = 0, this.start.focus());
  }
  blur() {
    this.start.tabIndex = -1, this.selectBox.blur(), this.container.blur();
  }
  setFocusable(e) {
    e ? this.start.tabIndex = 0 : (this.start.tabIndex = -1, this.selectBox.setFocusable(!1));
  }
  dispose() {
    this.toDispose = U(this.toDispose);
  }
  updateOptions() {
    this.selected = 0, this.debugOptions = [];
    const e = this.debugService.getConfigurationManager(), t = this.contextService.getWorkbenchState() === 3;
    let i;
    const s = [];
    e.getAllConfigurations().forEach(({ launch: n, name: o, presentation: r }) => {
      i !== (r == null ? void 0 : r.group) && (i = r == null ? void 0 : r.group, this.debugOptions.length && (this.debugOptions.push({ label: mt.SEPARATOR, handler: () => Promise.resolve(!1) }), s.push(this.debugOptions.length - 1))), o === e.selectedConfiguration.name && n === e.selectedConfiguration.launch && (this.selected = this.debugOptions.length);
      const a = t ? `${o} (${n.name})` : o;
      this.debugOptions.push({
        label: a,
        handler: async () => (await e.selectConfiguration(n, o), !0)
      });
    }), e.getRecentDynamicConfigurations().slice(0, 3).forEach(({ name: n, type: o }) => {
      o === e.selectedConfiguration.type && e.selectedConfiguration.name === n && (this.selected = this.debugOptions.length), this.debugOptions.push({
        label: n,
        handler: async () => (await e.selectConfiguration(void 0, n, void 0, { type: o }), !0)
      });
    }), this.debugOptions.length === 0 && this.debugOptions.push({ label: c("noConfigurations", "No Configurations"), handler: async () => !1 }), this.debugOptions.push({ label: mt.SEPARATOR, handler: () => Promise.resolve(!1) }), s.push(this.debugOptions.length - 1), this.providers.forEach((n) => {
      this.debugOptions.push({
        label: `${n.label}...`,
        handler: async () => {
          const o = await n.pick();
          return o ? (await e.selectConfiguration(o.launch, o.config.name, o.config, { type: n.type }), !0) : !1;
        }
      });
    }), e.getLaunches().filter((n) => !n.hidden).forEach((n) => {
      const o = t ? c("addConfigTo", "Add Config ({0})...", n.name) : c("addConfiguration", "Add Configuration...");
      this.debugOptions.push({
        label: o,
        handler: async () => (await this.commandService.executeCommand(ud, n.uri.toString()), !1)
      });
    }), this.selectBox.setOptions(this.debugOptions.map(
      (n, o) => ({ text: n.label, isDisabled: s.indexOf(o) !== -1 })
    ), this.selected);
  }
}, mt.SEPARATOR = "─────────", mt);
Do = I([
  h(2, T),
  h(3, O),
  h(4, We),
  h(5, _e),
  h(6, rt),
  h(7, at)
], Do);
let Ti = class extends Su {
  constructor(e, t, i, s, n) {
    super(null, e, [], -1, s, br, { ariaLabel: c("debugSession", "Debug Session") }), this.debugService = i, this.configurationService = n, this._register(this.debugService.getViewModel().onDidFocusSession(() => {
      const r = this.getSelectedSession();
      if (r) {
        const a = this.getSessions().indexOf(r);
        this.select(a);
      }
    })), this._register(this.debugService.onDidNewSession((r) => {
      const a = [];
      a.push(r.onDidChangeName(() => this.update())), a.push(r.onDidEndAdapter(() => U(a))), this.update();
    })), this.getSessions().forEach((r) => {
      this._register(r.onDidChangeName(() => this.update()));
    }), this._register(this.debugService.onDidEndSession(() => this.update()));
    const o = t ? this.mapFocusedSessionToSelected(t) : void 0;
    this.update(o);
  }
  getActionContext(e, t) {
    return this.getSessions()[t];
  }
  update(e) {
    e || (e = this.getSelectedSession());
    const t = this.getSessions(), i = t.map((s) => {
      const n = s.getLabel();
      return s.parentSession ? `  ${n}` : n;
    });
    this.setOptions(i.map((s) => ({ text: s })), e ? t.indexOf(e) : void 0);
  }
  getSelectedSession() {
    const e = this.debugService.getViewModel().focusedSession;
    return e ? this.mapFocusedSessionToSelected(e) : void 0;
  }
  getSessions() {
    const e = this.configurationService.getValue("debug").showSubSessionsInToolBar, t = this.debugService.getModel().getSessions();
    return e ? t : t.filter((i) => !i.parentSession);
  }
  mapFocusedSessionToSelected(e) {
    const t = this.configurationService.getValue("debug").showSubSessionsInToolBar;
    for (; e.parentSession && !t; )
      e = e.parentSession;
    return e;
  }
};
Ti = I([
  h(2, T),
  h(3, rt),
  h(4, O)
], Ti);
const Lp = M("debugToolBar.background", {
  dark: "#333333",
  light: "#F3F3F3",
  hcDark: "#000000",
  hcLight: "#FFFFFF"
}, c("debugToolBarBackground", "Debug toolbar background color.")), Ap = M("debugToolBar.border", {
  dark: null,
  light: null,
  hcDark: null,
  hcLight: null
}, c("debugToolBarBorder", "Debug toolbar border color.")), Bp = M("debugIcon.startForeground", {
  dark: "#89D185",
  light: "#388A34",
  hcDark: "#89D185",
  hcLight: "#388A34"
}, c("debugIcon.startForeground", "Debug toolbar icon for start debugging."));
function Mp() {
  const l = M("debugTokenExpression.name", { dark: "#c586c0", light: "#9b46b0", hcDark: z, hcLight: z }, "Foreground color for the token names shown in the debug views (ie. the Variables or Watch view)."), e = M("debugTokenExpression.value", { dark: "#cccccc99", light: "#6c6c6ccc", hcDark: z, hcLight: z }, "Foreground color for the token values shown in the debug views (ie. the Variables or Watch view)."), t = M("debugTokenExpression.string", { dark: "#ce9178", light: "#a31515", hcDark: "#f48771", hcLight: "#a31515" }, "Foreground color for strings in the debug views (ie. the Variables or Watch view)."), i = M("debugTokenExpression.boolean", { dark: "#4e94ce", light: "#0000ff", hcDark: "#75bdfe", hcLight: "#0000ff" }, "Foreground color for booleans in the debug views (ie. the Variables or Watch view)."), s = M("debugTokenExpression.number", { dark: "#b5cea8", light: "#098658", hcDark: "#89d185", hcLight: "#098658" }, "Foreground color for numbers in the debug views (ie. the Variables or Watch view)."), n = M("debugTokenExpression.error", { dark: "#f48771", light: "#e51400", hcDark: "#f48771", hcLight: "#e51400" }, "Foreground color for expression errors in the debug views (ie. the Variables or Watch view) and for error logs shown in the debug console."), o = M("debugView.exceptionLabelForeground", { dark: z, light: "#FFF", hcDark: z, hcLight: z }, "Foreground color for a label shown in the CALL STACK view when the debugger breaks on an exception."), r = M("debugView.exceptionLabelBackground", { dark: "#6C2022", light: "#A31515", hcDark: "#6C2022", hcLight: "#A31515" }, "Background color for a label shown in the CALL STACK view when the debugger breaks on an exception."), a = M("debugView.stateLabelForeground", { dark: z, light: z, hcDark: z, hcLight: z }, "Foreground color for a label in the CALL STACK view showing the current session's or thread's state."), d = M("debugView.stateLabelBackground", { dark: "#88888844", light: "#88888844", hcDark: "#88888844", hcLight: "#88888844" }, "Background color for a label in the CALL STACK view showing the current session's or thread's state."), u = M("debugView.valueChangedHighlight", { dark: "#569CD6", light: "#569CD6", hcDark: "#569CD6", hcLight: "#569CD6" }, "Color used to highlight value changes in the debug views (ie. in the Variables view)."), g = M("debugConsole.infoForeground", { dark: oa, light: oa, hcDark: z, hcLight: z }, "Foreground color for info messages in debug REPL console."), p = M("debugConsole.warningForeground", { dark: xn, light: xn, hcDark: "#008000", hcLight: xn }, "Foreground color for warning messages in debug REPL console."), f = M("debugConsole.errorForeground", { dark: Ki, light: Ki, hcDark: Ki, hcLight: Ki }, "Foreground color for error messages in debug REPL console."), S = M("debugConsole.sourceForeground", { dark: z, light: z, hcDark: z, hcLight: z }, "Foreground color for source filenames in debug REPL console."), w = M("debugConsoleInputIcon.foreground", { dark: z, light: z, hcDark: z, hcLight: z }, "Foreground color for debug console input marker icon."), m = M("debugIcon.pauseForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hcDark: "#75BEFF",
    hcLight: "#007ACC"
  }, c("debugIcon.pauseForeground", "Debug toolbar icon for pause.")), y = M("debugIcon.stopForeground", {
    dark: "#F48771",
    light: "#A1260D",
    hcDark: "#F48771",
    hcLight: "#A1260D"
  }, c("debugIcon.stopForeground", "Debug toolbar icon for stop.")), _ = M("debugIcon.disconnectForeground", {
    dark: "#F48771",
    light: "#A1260D",
    hcDark: "#F48771",
    hcLight: "#A1260D"
  }, c("debugIcon.disconnectForeground", "Debug toolbar icon for disconnect.")), v = M("debugIcon.restartForeground", {
    dark: "#89D185",
    light: "#388A34",
    hcDark: "#89D185",
    hcLight: "#388A34"
  }, c("debugIcon.restartForeground", "Debug toolbar icon for restart.")), C = M("debugIcon.stepOverForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hcDark: "#75BEFF",
    hcLight: "#007ACC"
  }, c("debugIcon.stepOverForeground", "Debug toolbar icon for step over.")), b = M("debugIcon.stepIntoForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hcDark: "#75BEFF",
    hcLight: "#007ACC"
  }, c("debugIcon.stepIntoForeground", "Debug toolbar icon for step into.")), D = M("debugIcon.stepOutForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hcDark: "#75BEFF",
    hcLight: "#007ACC"
  }, c("debugIcon.stepOutForeground", "Debug toolbar icon for step over.")), P = M("debugIcon.continueForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hcDark: "#75BEFF",
    hcLight: "#007ACC"
  }, c("debugIcon.continueForeground", "Debug toolbar icon for continue.")), se = M("debugIcon.stepBackForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hcDark: "#75BEFF",
    hcLight: "#007ACC"
  }, c("debugIcon.stepBackForeground", "Debug toolbar icon for step back."));
  Bc((A, j) => {
    const ui = A.getColor(wu), En = A.getColor(vu), Qd = A.getColor(Cu), Fr = A.getColor(o), Wr = A.getColor(r), Zd = A.getColor(a), el = A.getColor(d), qi = A.getColor(u), tl = A.getColor(ku);
    j.addRule(`
			/* Text colour of the call stack row's filename */
			.debug-pane .debug-call-stack .monaco-list-row:not(.selected) .stack-frame > .file .file-name {
				color: ${Qd}
			}

			/* Line & column number "badge" for selected call stack row */
			.debug-pane .monaco-list-row.selected .line-number {
				background-color: ${ui};
				color: ${En};
			}

			/* Line & column number "badge" for unselected call stack row (basically all other rows) */
			.debug-pane .line-number {
				background-color: ${ui.transparent(0.6)};
				color: ${En.transparent(0.6)};
			}

			/* State "badge" displaying the active session's current state.
			* Only visible when there are more active debug sessions/threads running.
			*/
			.debug-pane .debug-call-stack .thread > .state.label,
			.debug-pane .debug-call-stack .session > .state.label {
				background-color: ${el};
				color: ${Zd};
			}

			/* State "badge" displaying the active session's current state.
			* Only visible when there are more active debug sessions/threads running
			* and thread paused due to a thrown exception.
			*/
			.debug-pane .debug-call-stack .thread > .state.label.exception,
			.debug-pane .debug-call-stack .session > .state.label.exception {
				background-color: ${Wr};
				color: ${Fr};
			}

			/* Info "badge" shown when the debugger pauses due to a thrown exception. */
			.debug-pane .call-stack-state-message > .label.exception {
				background-color: ${Wr};
				color: ${Fr};
			}

			/* Animation of changed values in Debug viewlet */
			@keyframes debugViewletValueChanged {
				0%   { background-color: ${qi.transparent(0)} }
				5%   { background-color: ${qi.transparent(0.9)} }
				100% { background-color: ${qi.transparent(0.3)} }
			}

			.debug-pane .monaco-list-row .expression .value.changed {
				background-color: ${qi.transparent(0.3)};
				animation-name: debugViewletValueChanged;
				animation-duration: 1s;
				animation-fill-mode: forwards;
			}

			.monaco-list-row .expression .lazy-button:hover {
				background-color: ${tl}
			}
		`);
    const Ur = A.getColor(yu);
    Ur && j.addRule(`
			.debug-pane .line-number {
				border: 1px solid ${Ur};
			}
			`), Du(A.type) && j.addRule(`
			.debug-pane .line-number {
				background-color: ${ui};
				color: ${En};
			}`);
    const il = A.getColor(l), sl = A.getColor(e), nl = A.getColor(t), ol = A.getColor(i), rl = A.getColor(n), al = A.getColor(s);
    j.addRule(`
			.monaco-workbench .monaco-list-row .expression .name {
				color: ${il};
			}

			.monaco-workbench .monaco-list-row .expression .value,
			.monaco-workbench .debug-hover-widget .value {
				color: ${sl};
			}

			.monaco-workbench .monaco-list-row .expression .value.string,
			.monaco-workbench .debug-hover-widget .value.string {
				color: ${nl};
			}

			.monaco-workbench .monaco-list-row .expression .value.boolean,
			.monaco-workbench .debug-hover-widget .value.boolean {
				color: ${ol};
			}

			.monaco-workbench .monaco-list-row .expression .error,
			.monaco-workbench .debug-hover-widget .error,
			.monaco-workbench .debug-pane .debug-variables .scope .error {
				color: ${rl};
			}

			.monaco-workbench .monaco-list-row .expression .value.number,
			.monaco-workbench .debug-hover-widget .value.number {
				color: ${al};
			}
		`);
    const cl = A.getColor(Eu) || ht.fromHex("#80808060"), dl = A.getColor(g), ll = A.getColor(p), ul = A.getColor(f), hl = A.getColor(S), gl = A.getColor(w);
    j.addRule(`
			.repl .repl-input-wrapper {
				border-top: 1px solid ${cl};
			}

			.monaco-workbench .repl .repl-tree .output .expression .value.info {
				color: ${dl};
			}

			.monaco-workbench .repl .repl-tree .output .expression .value.warn {
				color: ${ll};
			}

			.monaco-workbench .repl .repl-tree .output .expression .value.error {
				color: ${ul};
			}

			.monaco-workbench .repl .repl-tree .output .expression .source {
				color: ${hl};
			}

			.monaco-workbench .repl .repl-tree .monaco-tl-contents .arrow {
				color: ${gl};
			}
		`), A.defines(w) || j.addRule(`
				.monaco-workbench.vs .repl .repl-tree .monaco-tl-contents .arrow {
					opacity: 0.25;
				}

				.monaco-workbench.vs-dark .repl .repl-tree .monaco-tl-contents .arrow {
					opacity: 0.4;
				}

				.monaco-workbench.hc-black .repl .repl-tree .monaco-tl-contents .arrow,
				.monaco-workbench.hc-light .repl .repl-tree .monaco-tl-contents .arrow {
					opacity: 1;
				}
			`);
    const Hr = A.getColor(Bp);
    Hr && j.addRule(`.monaco-workbench ${L.asCSSSelector(ld)} { color: ${Hr}; }`);
    const $r = A.getColor(m);
    $r && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${L.asCSSSelector(as)}, .monaco-workbench ${L.asCSSSelector(as)} { color: ${$r}; }`);
    const zr = A.getColor(y);
    zr && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${L.asCSSSelector(Pt)},.monaco-workbench ${L.asCSSSelector(Pt)} { color: ${zr}; }`);
    const qr = A.getColor(_);
    qr && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${L.asCSSSelector(Xe)},.monaco-workbench .debug-view-content ${L.asCSSSelector(Xe)}, .monaco-workbench .debug-toolbar ${L.asCSSSelector(Xe)} { color: ${qr}; }`);
    const Gr = A.getColor(v);
    Gr && j.addRule(`.monaco-workbench ${L.asCSSSelector(cs)}, .monaco-workbench ${L.asCSSSelector(io)}, .monaco-workbench .part > .title > .title-actions .action-label${L.asCSSSelector(cs)}, .monaco-workbench .part > .title > .title-actions .action-label${L.asCSSSelector(io)} { color: ${Gr}; }`);
    const Kr = A.getColor(C);
    Kr && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${L.asCSSSelector(ds)}, .monaco-workbench ${L.asCSSSelector(ds)} { color: ${Kr}; }`);
    const jr = A.getColor(b);
    jr && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${L.asCSSSelector(bi)}, .monaco-workbench .part > .title > .title-actions .action-label${L.asCSSSelector(bi)}, .monaco-workbench ${L.asCSSSelector(bi)} { color: ${jr}; }`);
    const Xr = A.getColor(D);
    Xr && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${L.asCSSSelector(mi)}, .monaco-workbench .part > .title > .title-actions .action-label${L.asCSSSelector(mi)}, .monaco-workbench ${L.asCSSSelector(mi)} { color: ${Xr}; }`);
    const Yr = A.getColor(P);
    Yr && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${L.asCSSSelector(ls)}, .monaco-workbench ${L.asCSSSelector(ls)}, .monaco-workbench .part > .title > .title-actions .action-label${L.asCSSSelector(so)}, .monaco-workbench ${L.asCSSSelector(so)} { color: ${Yr}; }`);
    const Jr = A.getColor(se);
    Jr && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${L.asCSSSelector(no)}, .monaco-workbench ${L.asCSSSelector(no)} { color: ${Jr}; }`);
  });
}
const Ba = "debug.actionswidgetposition", Ma = "debug.actionswidgety";
let Eo = class extends Iu {
  constructor(e, t, i, s, n, o, r, a, d, u) {
    super(r), this.notificationService = e, this.telemetryService = t, this.debugService = i, this.layoutService = s, this.storageService = n, this.configurationService = o, this.instantiationService = a, this.yCoordinate = 0, this.isVisible = !1, this.isBuilt = !1, this.stopActionViewItemDisposables = this._register(new te()), this.$el = ie("div.debug-toolbar"), this.$el.style.top = `${s.offset.top}px`, this.dragArea = E(this.$el, ie("div.drag-area" + L.asCSSSelector(Yh)));
    const g = E(this.$el, ie("div.action-bar-container"));
    this.debugToolBarMenu = d.createMenu(k.DebugToolBar, u), this._register(this.debugToolBarMenu), this.activeActions = [], this.actionBar = this._register(new oi(g, {
      orientation: 0,
      actionViewItemProvider: (p) => {
        if (p.id === Ir)
          return this.instantiationService.createInstance(Ti, p, void 0);
        if (p.id === He || p.id === lt) {
          this.stopActionViewItemDisposables.clear();
          const f = this.instantiationService.invokeFunction((S) => Mr(p, this.stopActionViewItemDisposables, S));
          if (f)
            return f;
        }
        return Rc(this.instantiationService, p);
      }
    })), this.updateScheduler = this._register(new oe(() => {
      var w;
      const p = this.debugService.state, f = this.configurationService.getValue("debug").toolBarLocation;
      if (p === 0 || f === "docked" || f === "hidden" || this.debugService.getModel().getSessions().every((m) => m.suppressDebugToolbar) || p === 1 && ((w = this.debugService.initializingOptions) != null && w.suppressDebugToolbar))
        return this.hide();
      const S = [];
      nn(this.debugToolBarMenu, { shouldForwardArgs: !0 }, S), xu(S, this.activeActions, (m, y) => m.id === y.id && m.enabled === y.enabled) || (this.actionBar.clear(), this.actionBar.push(S, { icon: !0, label: !1 }), this.activeActions = S), this.show();
    }, 20)), this.updateStyles(), this.registerListeners(), this.hide();
  }
  registerListeners() {
    this._register(this.debugService.onDidChangeState(() => this.updateScheduler.schedule())), this._register(this.configurationService.onDidChangeConfiguration((e) => {
      e.affectsConfiguration("debug.toolBarLocation") && this.updateScheduler.schedule();
    })), this._register(this.debugToolBarMenu.onDidChange(() => this.updateScheduler.schedule())), this._register(this.actionBar.actionRunner.onDidRun((e) => {
      e.error && !Sc(e.error) && this.notificationService.error(e.error), this.telemetryService.publicLog2("workbenchActionExecuted", { id: e.action.id, from: "debugActionsWidget" });
    })), this._register(le(window, ne.RESIZE, () => this.setCoordinates())), this._register(ra(this.dragArea, (e) => {
      if (new Jn(e).detail === 2) {
        const i = this.$el.clientWidth;
        this.setCoordinates(0.5 * window.innerWidth - 0.5 * i, 0), this.storePosition();
      }
    })), this._register(Tu(this.dragArea, (e) => {
      this.dragArea.classList.add("dragged");
      const t = _u(window, (s) => {
        const n = new Jn(s);
        n.preventDefault(), this.setCoordinates(n.posx - 14, n.posy - this.layoutService.offset.top);
      }), i = ra(window, (s) => {
        this.storePosition(), this.dragArea.classList.remove("dragged"), t.dispose(), i.dispose();
      });
    })), this._register(this.layoutService.onDidChangePartVisibility(() => this.setYCoordinate())), this._register(Qn.onDidChange(() => this.setYCoordinate()));
  }
  storePosition() {
    const e = Lu(this.$el).left;
    if (e) {
      const t = parseFloat(e) / window.innerWidth;
      this.storageService.store(Ba, t, 0, 1);
    }
  }
  updateStyles() {
    if (super.updateStyles(), this.$el) {
      this.$el.style.backgroundColor = this.getColor(Lp) || "";
      const e = this.getColor(Au);
      this.$el.style.boxShadow = e ? `0 0 8px 2px ${e}` : "";
      const t = this.getColor(Bu), i = this.getColor(Ap);
      t ? this.$el.style.border = `1px solid ${t}` : (this.$el.style.border = i ? `solid ${i}` : "none", this.$el.style.border = "1px 0");
    }
  }
  setYCoordinate(e = this.yCoordinate) {
    const t = this.layoutService.offset.top;
    this.$el.style.top = `${t + e}px`, this.yCoordinate = e;
  }
  setCoordinates(e, t) {
    if (!this.isVisible)
      return;
    const i = this.$el.clientWidth;
    if (e === void 0) {
      const n = this.storageService.get(Ba, 0);
      e = n !== void 0 ? parseFloat(n) * window.innerWidth : 0.5 * window.innerWidth - 0.5 * i;
    }
    e = Math.max(0, Math.min(e, window.innerWidth - i)), this.$el.style.left = `${e}px`, t === void 0 && (t = this.storageService.getNumber(Ma, 0, 0));
    const s = 35;
    if (t < s / 2 || t > s + s / 2) {
      const n = t < s;
      this.setYCoordinate(n ? 0 : s), this.storageService.store(Ma, n ? 0 : 2 * s, 0, 1);
    }
  }
  show() {
    if (this.isVisible) {
      this.setCoordinates();
      return;
    }
    this.isBuilt || (this.isBuilt = !0, this.layoutService.container.appendChild(this.$el)), this.isVisible = !0, Mu(this.$el), this.setCoordinates();
  }
  hide() {
    this.isVisible = !1, Nu(this.$el);
  }
  dispose() {
    var e;
    super.dispose(), (e = this.$el) == null || e.remove();
  }
};
Eo = I([
  h(0, Ct),
  h(1, we),
  h(2, T),
  h(3, hr),
  h(4, it),
  h(5, O),
  h(6, ce),
  h(7, K),
  h(8, Ne),
  h(9, H)
], Eo);
function Mr(l, e, t) {
  const i = t.get(Ne), s = t.get(H), n = t.get(K), o = t.get(Me), r = i.createMenu(k.DebugToolBarStop, s), a = [];
  if (nn(r, { shouldForwardArgs: !0 }, a), !a.length)
    return;
  const d = e.add(new Z("notebook.moreRunActions", c("notebook.moreRunActionsLabel", "More..."), "codicon-chevron-down", !0));
  return n.createInstance(qg, l, d, a, "debug-stop-actions", o, {});
}
const Io = [], Ie = (l, e, t, i, s, n, o) => {
  he.appendMenuItem(k.DebugToolBar, {
    group: "navigation",
    when: s,
    order: t,
    command: {
      id: l,
      title: e,
      icon: i,
      precondition: n
    },
    alt: o
  }), Io.push(he.appendMenuItem(k.ViewContainerTitle, {
    group: "navigation",
    when: x.and(s, x.equals("viewContainer", De), N.notEqualsTo("inactive"), x.equals("config.debug.toolBarLocation", "docked")),
    order: t,
    command: {
      id: l,
      title: e,
      icon: i,
      precondition: n
    }
  }));
};
he.onDidChangeMenu((l) => {
  if (l.has(k.DebugToolBar)) {
    U(Io);
    const e = he.getMenuItems(k.DebugToolBar);
    for (const t of e)
      Io.push(he.appendMenuItem(k.ViewContainerTitle, {
        ...t,
        when: x.and(t.when, x.equals("viewContainer", De), N.notEqualsTo("inactive"), x.equals("config.debug.toolBarLocation", "docked"))
      }));
  }
});
Ie(hn, un, 10, ls, N.isEqualTo("stopped"));
Ie(pn, gn, 10, as, N.notEqualsTo("stopped"), N.isEqualTo("running"));
Ie(He, di, 70, Pt, Te.toNegated(), void 0, { id: lt, title: Ui, icon: Xe, precondition: x.and(Te.toNegated(), nt) });
Ie(lt, Ui, 70, Xe, Te, void 0, { id: He, title: di, icon: Pt, precondition: x.and(Te, nt) });
Ie(bn, fn, 20, ds, void 0, N.isEqualTo("stopped"));
Ie(Sn, mn, 30, bi, void 0, N.isEqualTo("stopped"));
Ie(vn, wn, 40, mi, void 0, N.isEqualTo("stopped"));
Ie(Tr, xr, 60, cs);
Ie(jh, c("stepBackDebug", "Step Back"), 50, no, ar, N.isEqualTo("stopped"));
Ie(Xh, c("reverseContinue", "Reverse"), 55, so, ar, N.isEqualTo("stopped"));
Ie(Ir, Jh, 100, void 0, gc);
he.appendMenuItem(k.DebugToolBarStop, {
  group: "navigation",
  when: x.and(Te.toNegated(), nt),
  order: 0,
  command: {
    id: lt,
    title: Ui,
    icon: Xe
  }
});
he.appendMenuItem(k.DebugToolBarStop, {
  group: "navigation",
  when: x.and(Te, nt),
  order: 0,
  command: {
    id: He,
    title: di,
    icon: Pt
  }
});
he.appendMenuItem(k.DebugToolBarStop, {
  group: "navigation",
  when: x.or(x.and(Te.toNegated(), es, nt), x.and(Te, es)),
  order: 0,
  command: {
    id: hd,
    title: gd,
    icon: Xe
  }
});
const Q = ie;
function xd(l, e) {
  return e.sessionId = l.getId(), e;
}
function Td(l, e) {
  return e.threadId = l.getId(), xd(l.session, e), e;
}
function Np(l, e) {
  return e.frameId = l.getId(), e.frameName = l.name, e.frameLocation = { range: l.range, source: l.source.raw }, Td(l.thread, e), e;
}
function Nr(l) {
  return l instanceof ye ? Np(l, {}) : l instanceof Ve ? Td(l, {}) : ke(l) ? xd(l, {}) : void 0;
}
function Rr(l) {
  return l instanceof ye ? l.source.inMemory ? l.source.raw.path || l.source.reference || l.source.name : l.source.uri.toString() : l instanceof Ve ? l.threadId : ke(l) ? l.getId() : "";
}
function _d(l) {
  let e = l.thread.getStaleCallStack();
  e = e.length > 0 ? e : l.thread.getCallStack();
  const t = e.map((n) => n.source).filter((n) => n !== l.source);
  let i = 0;
  if (t.forEach((n) => {
    n.name === l.source.name && (i = Math.max(i, Pu(l.source.uri.path, n.uri.path)));
  }), i === 0)
    return l.source.name;
  const s = Math.max(0, l.source.uri.path.lastIndexOf(Ot.sep, l.source.uri.path.length - i - 1));
  return (s > 0 ? "..." : "") + l.source.uri.path.substring(s);
}
async function xo(l, e) {
  l.parentSession && await xo(l.parentSession, e), await e.expand(l);
}
let To = class extends Pi {
  constructor(e, t, i, s, n, o, r, a, d, u, g, p) {
    super(e, s, t, r, a, o, n, d, u, g), this.options = e, this.debugService = i, this.menuService = p, this.needsRefresh = !1, this.ignoreSelectionChangedEvent = !1, this.ignoreFocusStackFrameEvent = !1, this.autoExpandedSessions = /* @__PURE__ */ new Set(), this.selectionNeedsUpdate = !1, this.onCallStackChangeScheduler = this._register(new oe(async () => {
      const f = this.debugService.getModel().getSessions();
      f.length === 0 && this.autoExpandedSessions.clear();
      const S = f.length === 1 && f[0].getAllThreads().length === 1 ? f[0].getAllThreads()[0] : void 0, w = f.length === 1 ? f[0].getStoppedDetails() : void 0;
      w && (S || typeof w.threadId != "number") ? (this.stateMessageLabel.textContent = ks(w), this.stateMessageLabel.title = _o(w), this.stateMessageLabel.classList.toggle("exception", w.reason === "exception"), this.stateMessage.hidden = !1) : f.length === 1 && f[0].state === 3 ? (this.stateMessageLabel.textContent = c({ key: "running", comment: ["indicates state"] }, "Running"), this.stateMessageLabel.title = f[0].getLabel(), this.stateMessageLabel.classList.remove("exception"), this.stateMessage.hidden = !1) : this.stateMessage.hidden = !0, this.updateActions(), this.needsRefresh = !1, this.dataSource.deemphasizedStackFramesToShow = [], await this.tree.updateChildren();
      try {
        const m = /* @__PURE__ */ new Set();
        f.forEach((y) => {
          y.parentSession && !this.autoExpandedSessions.has(y.parentSession) && m.add(y.parentSession);
        });
        for (const y of m)
          await xo(y, this.tree), this.autoExpandedSessions.add(y);
      } catch {
      }
      this.selectionNeedsUpdate && (this.selectionNeedsUpdate = !1, await this.updateTreeSelection());
    }, 50));
  }
  renderHeaderTitle(e) {
    super.renderHeaderTitle(e, this.options.title), this.stateMessage = E(e, Q("span.call-stack-state-message")), this.stateMessage.hidden = !0, this.stateMessageLabel = E(this.stateMessage, Q("span.label"));
  }
  renderBody(e) {
    super.renderBody(e), this.element.classList.add("debug-pane"), e.classList.add("debug-call-stack");
    const t = Dn(e);
    this.dataSource = new Vp(this.debugService), this.tree = this.instantiationService.createInstance(Fu, "CallStackView", t, new Op(), new Fp(this.debugService), [
      this.instantiationService.createInstance(ms),
      this.instantiationService.createInstance(Ss),
      this.instantiationService.createInstance(ws),
      new vs(),
      new Ft(),
      new Cs()
    ], this.dataSource, {
      accessibilityProvider: new Pp(),
      compressionEnabled: !0,
      autoExpandSingleChildren: !0,
      identityProvider: {
        getId: (s) => typeof s == "string" ? s : s instanceof Array ? `showMore ${s[0].getId()}` : s.getId()
      },
      keyboardNavigationLabelProvider: {
        getKeyboardNavigationLabel: (s) => ke(s) ? s.getLabel() : s instanceof Ve ? `${s.name} ${s.stateLabel}` : s instanceof ye || typeof s == "string" ? s : s instanceof Ei ? Ft.LABEL : c("showMoreStackFrames2", "Show More Stack Frames"),
        getCompressedNodeKeyboardNavigationLabel: (s) => {
          const n = s[0];
          return ke(n) ? n.getLabel() : "";
        }
      },
      expandOnlyOnTwistieClick: !0,
      overrideStyles: {
        listBackground: this.getBackgroundColor()
      }
    }), this.tree.setInput(this.debugService.getModel()), this._register(this.tree.onDidOpen(async (s) => {
      var r;
      if (this.ignoreSelectionChangedEvent)
        return;
      const n = (a, d, u, g = {}) => {
        this.ignoreFocusStackFrameEvent = !0;
        try {
          this.debugService.focusStackFrame(a, d, u, { ...g, explicit: !0 });
        } finally {
          this.ignoreFocusStackFrameEvent = !1;
        }
      }, o = s.element;
      if (o instanceof ye) {
        const a = {
          preserveFocus: s.editorOptions.preserveFocus,
          sideBySide: s.sideBySide,
          pinned: s.editorOptions.pinned
        };
        n(o, o.thread, o.thread.session, a);
      }
      if (o instanceof Ve && n(void 0, o, o.session), ke(o) && n(void 0, void 0, o), o instanceof Ei) {
        const a = this.debugService.getModel().getSession(o.sessionId), d = a && a.getThread(o.threadId);
        if (d) {
          const u = (r = d.stoppedDetails) == null ? void 0 : r.totalFrames, g = typeof u == "number" ? u - d.getCallStack().length : void 0;
          await d.fetchCallStack(g), await this.tree.updateChildren();
        }
      }
      o instanceof Array && (this.dataSource.deemphasizedStackFramesToShow.push(...o), this.tree.updateChildren());
    })), this._register(this.debugService.getModel().onDidChangeCallStack(() => {
      if (!this.isBodyVisible()) {
        this.needsRefresh = !0;
        return;
      }
      this.onCallStackChangeScheduler.isScheduled() || this.onCallStackChangeScheduler.schedule();
    }));
    const i = Ze.any(this.debugService.getViewModel().onDidFocusStackFrame, this.debugService.getViewModel().onDidFocusSession);
    this._register(i(async () => {
      if (!this.ignoreFocusStackFrameEvent) {
        if (!this.isBodyVisible()) {
          this.needsRefresh = !0;
          return;
        }
        if (this.onCallStackChangeScheduler.isScheduled()) {
          this.selectionNeedsUpdate = !0;
          return;
        }
        await this.updateTreeSelection();
      }
    })), this._register(this.tree.onContextMenu((s) => this.onContextMenu(s))), this.debugService.state === 2 && this.onCallStackChangeScheduler.schedule(0), this._register(this.onDidChangeBodyVisibility((s) => {
      s && this.needsRefresh && this.onCallStackChangeScheduler.schedule();
    })), this._register(this.debugService.onDidNewSession((s) => {
      const n = [];
      n.push(s.onDidChangeName(() => {
        this.tree.hasNode(s) && this.tree.rerender(s);
      })), n.push(s.onDidEndAdapter(() => U(n))), s.parentSession && this.autoExpandedSessions.delete(s.parentSession);
    }));
  }
  layoutBody(e, t) {
    super.layoutBody(e, t), this.tree.layout(e, t);
  }
  focus() {
    this.tree.domFocus();
  }
  collapseAll() {
    this.tree.collapseAll();
  }
  async updateTreeSelection() {
    if (!this.tree || !this.tree.getInput())
      return;
    const e = (n) => {
      this.ignoreSelectionChangedEvent = !0;
      try {
        this.tree.setSelection([n]), this.tree.getRelativeTop(n) === null ? this.tree.reveal(n, 0.5) : this.tree.reveal(n);
      } catch {
      } finally {
        this.ignoreSelectionChangedEvent = !1;
      }
    }, t = this.debugService.getViewModel().focusedThread, i = this.debugService.getViewModel().focusedSession, s = this.debugService.getViewModel().focusedStackFrame;
    if (!t)
      i ? e(i) : this.tree.setSelection([]);
    else {
      try {
        await xo(t.session, this.tree);
      } catch {
      }
      try {
        await this.tree.expand(t);
      } catch {
      }
      const n = s || i;
      n && e(n);
    }
  }
  onContextMenu(e) {
    const t = e.element;
    let i = [];
    ke(t) ? i = Ld(t) : t instanceof Ve ? i = Ad(t) : t instanceof ye && (i = Rp(t));
    const o = { primary: [], secondary: [] }, r = this.contextKeyService.createOverlay(i), a = this.menuService.createMenu(k.DebugCallStackContext, r);
    ri(a, { arg: Rr(t), shouldForwardArgs: !0 }, o, "inline"), this.contextMenuService.showContextMenu({
      getAnchor: () => e.anchor,
      getActions: () => o.secondary,
      getActionsContext: () => Nr(t)
    });
  }
};
To = I([
  h(1, Me),
  h(2, T),
  h(3, at),
  h(4, K),
  h(5, Ue),
  h(6, O),
  h(7, H),
  h(8, st),
  h(9, ce),
  h(10, we),
  h(11, Ne)
], To);
function Ld(l) {
  return [
    [G.key, "session"],
    [wr.key, fc(l)],
    [yt.key, l.state === 2],
    [Vc.key, l.getAllThreads().length === 1]
  ];
}
var Wt;
let ms = (Wt = class {
  constructor(e, t, i) {
    this.instantiationService = e, this.contextKeyService = t, this.menuService = i;
  }
  get templateId() {
    return Wt.ID;
  }
  renderTemplate(e) {
    const t = E(e, Q(".session"));
    E(t, Q(L.asCSSSelector(Qh)));
    const i = E(t, Q(".name")), s = E(t, Q("span.state.label.monaco-count-badge.long")), n = new kt(i), o = new te(), r = o.add(new te()), a = o.add(new oi(t, {
      actionViewItemProvider: (u) => {
        if ((u.id === He || u.id === lt) && u instanceof aa) {
          r.clear();
          const g = this.instantiationService.invokeFunction((p) => Mr(u, r, p));
          if (g)
            return g;
        }
        if (u instanceof aa)
          return this.instantiationService.createInstance(Ru, u, void 0);
        if (u instanceof Ou)
          return this.instantiationService.createInstance(Vu, u, void 0);
      }
    })), d = o.add(new te());
    return { session: t, name: i, stateLabel: s, label: n, actionBar: a, elementDisposable: d, templateDisposable: o };
  }
  renderElement(e, t, i) {
    this.doRenderElement(e.element, Fe(e.filterData), i);
  }
  renderCompressedElements(e, t, i) {
    const s = e.element.elements[e.element.elements.length - 1], n = Fe(e.filterData);
    this.doRenderElement(s, n, i);
  }
  doRenderElement(e, t, i) {
    i.session.title = c({ key: "session", comment: ["Session is a noun"] }, "Session"), i.label.set(e.getLabel(), t);
    const s = e.getStoppedDetails(), n = e.getAllThreads().find((d) => d.stopped), o = this.contextKeyService.createOverlay(Ld(e)), r = i.elementDisposable.add(this.menuService.createMenu(k.DebugCallStackContext, o)), a = () => {
      i.actionBar.clear();
      const d = [], g = { primary: d, secondary: [] };
      nn(r, { arg: Rr(e), shouldForwardArgs: !0 }, g, "inline"), i.actionBar.push(d, { icon: !0, label: !1 }), i.actionBar.context = Nr(e);
    };
    i.elementDisposable.add(r.onDidChange(() => a())), a(), i.stateLabel.style.display = "", s ? (i.stateLabel.textContent = ks(s), i.session.title = `${e.getLabel()}: ${_o(s)}`, i.stateLabel.classList.toggle("exception", s.reason === "exception")) : n && n.stoppedDetails ? (i.stateLabel.textContent = ks(n.stoppedDetails), i.session.title = `${e.getLabel()}: ${_o(n.stoppedDetails)}`, i.stateLabel.classList.toggle("exception", n.stoppedDetails.reason === "exception")) : (i.stateLabel.textContent = c({ key: "running", comment: ["indicates state"] }, "Running"), i.stateLabel.classList.remove("exception"));
  }
  disposeTemplate(e) {
    e.templateDisposable.dispose();
  }
  disposeElement(e, t, i) {
    i.elementDisposable.clear();
  }
  disposeCompressedElements(e, t, i, s) {
    i.elementDisposable.clear();
  }
}, Wt.ID = "session", Wt);
ms = I([
  h(0, K),
  h(1, H),
  h(2, Ne)
], ms);
function Ad(l) {
  return [
    [G.key, "thread"],
    [yt.key, l.stopped]
  ];
}
var Ut;
let Ss = (Ut = class {
  constructor(e, t) {
    this.contextKeyService = e, this.menuService = t;
  }
  get templateId() {
    return Ut.ID;
  }
  renderTemplate(e) {
    const t = E(e, Q(".thread")), i = E(t, Q(".name")), s = E(t, Q("span.state.label.monaco-count-badge.long")), n = new kt(i), o = new te(), r = o.add(new oi(t)), a = o.add(new te());
    return { thread: t, name: i, stateLabel: s, label: n, actionBar: r, elementDisposable: a, templateDisposable: o };
  }
  renderElement(e, t, i) {
    var a;
    const s = e.element;
    i.thread.title = s.name, i.label.set(s.name, Fe(e.filterData)), i.stateLabel.textContent = s.stateLabel, i.stateLabel.classList.toggle("exception", ((a = s.stoppedDetails) == null ? void 0 : a.reason) === "exception");
    const n = this.contextKeyService.createOverlay(Ad(s)), o = i.elementDisposable.add(this.menuService.createMenu(k.DebugCallStackContext, n)), r = () => {
      i.actionBar.clear();
      const d = [], g = { primary: d, secondary: [] };
      nn(o, { arg: Rr(s), shouldForwardArgs: !0 }, g, "inline"), i.actionBar.push(d, { icon: !0, label: !1 }), i.actionBar.context = Nr(s);
    };
    i.elementDisposable.add(o.onDidChange(() => r())), r();
  }
  renderCompressedElements(e, t, i, s) {
    throw new Error("Method not implemented.");
  }
  disposeElement(e, t, i) {
    i.elementDisposable.clear();
  }
  disposeTemplate(e) {
    e.templateDisposable.dispose();
  }
}, Ut.ID = "thread", Ut);
Ss = I([
  h(0, H),
  h(1, Ne)
], Ss);
function Rp(l) {
  return [
    [G.key, "stackFrame"],
    [Pc.key, l.canRestart]
  ];
}
var Ht;
let ws = (Ht = class {
  constructor(e, t) {
    this.labelService = e, this.notificationService = t;
  }
  get templateId() {
    return Ht.ID;
  }
  renderTemplate(e) {
    const t = E(e, Q(".stack-frame")), i = E(t, Q("span.label.expression")), s = E(t, Q(".file")), n = E(s, Q("span.file-name")), o = E(s, Q("span.line-number-wrapper")), r = E(o, Q("span.line-number.monaco-count-badge")), a = new kt(i), d = new te(), u = d.add(new oi(t));
    return { file: s, fileName: n, label: a, lineNumber: r, stackFrame: t, actionBar: u, templateDisposable: d };
  }
  renderElement(e, t, i) {
    const s = e.element;
    i.stackFrame.classList.toggle("disabled", !s.source || !s.source.available || Lo(s)), i.stackFrame.classList.toggle("label", s.presentationHint === "label"), i.stackFrame.classList.toggle("subtle", s.presentationHint === "subtle");
    const n = !!s.thread.session.capabilities.supportsRestartFrame && s.presentationHint !== "label" && s.presentationHint !== "subtle" && s.canRestart;
    if (i.stackFrame.classList.toggle("has-actions", n), i.file.title = s.source.inMemory ? s.source.uri.path : this.labelService.getUriLabel(s.source.uri), s.source.raw.origin && (i.file.title += `
${s.source.raw.origin}`), i.label.set(s.name, Fe(e.filterData), s.name), i.fileName.textContent = _d(s), s.range.startLineNumber !== void 0 ? (i.lineNumber.textContent = `${s.range.startLineNumber}`, s.range.startColumn && (i.lineNumber.textContent += `:${s.range.startColumn}`), i.lineNumber.classList.remove("unavailable")) : i.lineNumber.classList.add("unavailable"), i.actionBar.clear(), n) {
      const o = new Z("debug.callStack.restartFrame", c("restartFrame", "Restart Frame"), L.asClassName(io), !0, async () => {
        try {
          await s.restart();
        } catch (r) {
          this.notificationService.error(r);
        }
      });
      i.actionBar.push(o, { icon: !0, label: !1 });
    }
  }
  renderCompressedElements(e, t, i, s) {
    throw new Error("Method not implemented.");
  }
  disposeTemplate(e) {
    e.actionBar.dispose();
  }
}, Ht.ID = "stackFrame", Ht);
ws = I([
  h(0, Vi),
  h(1, Ct)
], ws);
const Ws = class Ws {
  get templateId() {
    return Ws.ID;
  }
  renderTemplate(e) {
    return { label: E(e, Q(".error")) };
  }
  renderElement(e, t, i) {
    const s = e.element;
    i.label.textContent = s, i.label.title = s;
  }
  renderCompressedElements(e, t, i, s) {
    throw new Error("Method not implemented.");
  }
  disposeTemplate(e) {
  }
};
Ws.ID = "error";
let vs = Ws;
const Tt = class Tt {
  constructor() {
  }
  get templateId() {
    return Tt.ID;
  }
  renderTemplate(e) {
    const t = E(e, Q(".load-all"));
    return t.style.color = je(Oc), { label: t };
  }
  renderElement(e, t, i) {
    i.label.textContent = Tt.LABEL;
  }
  renderCompressedElements(e, t, i, s) {
    throw new Error("Method not implemented.");
  }
  disposeTemplate(e) {
  }
};
Tt.ID = "loadMore", Tt.LABEL = c("loadAllStackFrames", "Load More Stack Frames");
let Ft = Tt;
const Us = class Us {
  constructor() {
  }
  get templateId() {
    return Us.ID;
  }
  renderTemplate(e) {
    const t = E(e, Q(".show-more"));
    return t.style.color = je(Oc), { label: t };
  }
  renderElement(e, t, i) {
    const s = e.element;
    s.every((n) => !!(n.source && n.source.origin && n.source.origin === s[0].source.origin)) ? i.label.textContent = c(
      "showMoreAndOrigin",
      "Show {0} More: {1}",
      s.length,
      s[0].source.origin
    ) : i.label.textContent = c("showMoreStackFrames", "Show {0} More Stack Frames", s.length);
  }
  renderCompressedElements(e, t, i, s) {
    throw new Error("Method not implemented.");
  }
  disposeTemplate(e) {
  }
};
Us.ID = "showMore";
let Cs = Us;
class Op {
  getHeight(e) {
    return e instanceof ye && e.presentationHint === "label" || e instanceof Ei || e instanceof Array ? 16 : 22;
  }
  getTemplateId(e) {
    return ke(e) ? ms.ID : e instanceof Ve ? Ss.ID : e instanceof ye ? ws.ID : typeof e == "string" ? vs.ID : e instanceof Ei ? Ft.ID : Cs.ID;
  }
}
function _o(l) {
  return l.text ?? ks(l);
}
function ks(l) {
  return l.description || (l.reason ? c(
    { key: "pausedOn", comment: ["indicates reason for program being paused"] },
    "Paused on {0}",
    l.reason
  ) : c("paused", "Paused"));
}
function Na(l) {
  return typeof l.getSessions == "function";
}
function ke(l) {
  return l && typeof l.getAllThreads == "function";
}
function Lo(l) {
  return l.source.presentationHint === "deemphasize" || l.presentationHint === "deemphasize";
}
class Vp {
  constructor(e) {
    this.debugService = e, this.deemphasizedStackFramesToShow = [];
  }
  hasChildren(e) {
    if (ke(e)) {
      const t = e.getAllThreads();
      return t.length > 1 || t.length === 1 && t[0].stopped || !!this.debugService.getModel().getSessions().find((i) => i.parentSession === e);
    }
    return Na(e) || e instanceof Ve && e.stopped;
  }
  async getChildren(e) {
    if (Na(e)) {
      const t = e.getSessions();
      if (t.length === 0)
        return Promise.resolve([]);
      if (t.length > 1 || this.debugService.getViewModel().isMultiSessionView())
        return Promise.resolve(t.filter((s) => !s.parentSession));
      const i = t[0].getAllThreads();
      return i.length === 1 ? this.getThreadChildren(i[0]) : Promise.resolve(i);
    } else if (ke(e)) {
      const t = this.debugService.getModel().getSessions().filter((s) => s.parentSession === e), i = e.getAllThreads();
      return i.length === 1 ? (await this.getThreadChildren(i[0])).concat(t) : Promise.resolve(i.concat(t));
    } else
      return this.getThreadChildren(e);
  }
  getThreadChildren(e) {
    return this.getThreadCallstack(e).then((t) => {
      const i = [];
      return t.forEach((s, n) => {
        if (s instanceof ye && s.source && Lo(s) && this.deemphasizedStackFramesToShow.indexOf(s) === -1) {
          if (i.length) {
            const r = i[i.length - 1];
            if (r instanceof Array) {
              r.push(s);
              return;
            }
          }
          const o = n < t.length - 1 ? t[n + 1] : void 0;
          if (o instanceof ye && o.source && Lo(o)) {
            i.push([s]);
            return;
          }
        }
        i.push(s);
      }), i;
    });
  }
  async getThreadCallstack(e) {
    let t = e.getCallStack();
    return (!t || !t.length) && (await e.fetchCallStack(), t = e.getCallStack()), t.length === 1 && e.session.capabilities.supportsDelayedStackTraceLoading && e.stoppedDetails && e.stoppedDetails.totalFrames && e.stoppedDetails.totalFrames > 1 && (t = t.concat(e.getStaleCallStack().slice(1))), e.stoppedDetails && e.stoppedDetails.framesErrorMessage && (t = t.concat([e.stoppedDetails.framesErrorMessage])), !e.reachedEndOfCallStack && e.stoppedDetails && (t = t.concat([new Ei(e.session.getId(), e.threadId)])), t;
  }
}
class Pp {
  getWidgetAriaLabel() {
    return c(
      { comment: ["Debug is a noun in this context, not a verb."], key: "callStackAriaLabel" },
      "Debug Call Stack"
    );
  }
  getWidgetRole() {
    return "treegrid";
  }
  getRole(e) {
    return "row";
  }
  getAriaLabel(e) {
    if (e instanceof Ve)
      return c(
        { key: "threadAriaLabel", comment: ['Placeholders stand for the thread name and the thread state.For example "Thread 1" and "Stopped'] },
        "Thread {0} {1}",
        e.name,
        e.stateLabel
      );
    if (e instanceof ye)
      return c(
        "stackFrameAriaLabel",
        "Stack Frame {0}, line {1}, {2}",
        e.name,
        e.range.startLineNumber,
        _d(e)
      );
    if (ke(e)) {
      const t = e.getAllThreads().find((s) => s.stopped), i = t ? t.stateLabel : c({ key: "running", comment: ["indicates state"] }, "Running");
      return c(
        { key: "sessionLabel", comment: ['Placeholders stand for the session name and the session state. For example "Launch Program" and "Running"'] },
        "Session {0} {1}",
        e.getLabel(),
        i
      );
    }
    return typeof e == "string" ? e : e instanceof Array ? c("showMoreStackFrames", "Show {0} More Stack Frames", e.length) : Ft.LABEL;
  }
}
class Fp {
  constructor(e) {
    this.debugService = e;
  }
  isIncompressible(e) {
    return ke(e) ? !(e.compact || this.debugService.getModel().getSessions().some((i) => i.parentSession === e && i.compact)) : !0;
  }
}
ge(class extends ct {
  constructor() {
    super({
      id: "callStack.collapse",
      viewId: ts,
      title: c("collapse", "Collapse All"),
      f1: !1,
      icon: tn.collapseAll,
      precondition: N.isEqualTo(Qs(2)),
      menu: {
        id: k.ViewTitle,
        order: 10,
        group: "navigation",
        when: x.equals("view", ts)
      }
    });
  }
  runInView(e, t) {
    t.collapseAll();
  }
});
function ut(l, e, t, i, s, n) {
  he.appendMenuItem(k.DebugCallStackContext, {
    group: "inline",
    order: s,
    when: i,
    command: { id: l, title: e, icon: t, precondition: n }
  });
}
const Hi = x.or(G.isEqualTo("thread"), x.and(G.isEqualTo("session"), Vc));
ut(pn, gn, as, x.and(Hi, yt.toNegated()), 10);
ut(hn, un, ls, x.and(Hi, yt), 10);
ut(bn, fn, ds, Hi, 20, yt);
ut(Sn, mn, bi, Hi, 30, yt);
ut(vn, wn, mi, Hi, 40, yt);
ut(Tr, xr, cs, G.isEqualTo("session"), 50);
ut(He, di, Pt, x.and(wr.toNegated(), G.isEqualTo("session")), 60);
ut(lt, Ui, Xe, x.and(wr, G.isEqualTo("session")), 60);
let Ao = class extends Fc {
  constructor(e, t, i) {
    super(pd, { canAcceptInBackground: !0 }), this._debugService = e, this._viewsService = t, this._commandService = i;
  }
  _getPicks(e, t, i) {
    const s = [];
    this._debugService.getModel().getSessions(!0).filter((o) => o.hasSeparateRepl()).forEach((o, r) => {
      const a = this._createPick(o, r, e);
      a && s.push(a);
    }), s.length > 0 && s.push({ type: "separator" });
    const n = c("workbench.action.debug.startDebug", "Start a New Debug Session");
    return s.push({
      label: `$(plus) ${n}`,
      ariaLabel: n,
      accept: () => this._commandService.executeCommand(Cn)
    }), s;
  }
  _createPick(e, t, i) {
    const s = e.name, n = fi(i, s, !0);
    if (n)
      return {
        label: s,
        highlights: { label: n },
        accept: (o, r) => {
          this._debugService.focusStackFrame(void 0, void 0, e, { explicit: !0 }), this._viewsService.isViewVisible(X) || this._viewsService.openView(X, !0);
        }
      };
  }
};
Ao = I([
  h(0, T),
  h(1, Ae),
  h(2, We)
], Ao);
class Wp extends pe {
  constructor() {
    super({
      id: "editor.debug.action.toggleBreakpoint",
      label: c("toggleBreakpointAction", "Debug: Toggle Breakpoint"),
      alias: "Debug: Toggle Breakpoint",
      precondition: J,
      kbOpts: {
        kbExpr: Be.editorTextFocus,
        primary: 67,
        weight: 100
      },
      menuOpts: {
        when: J,
        title: c(
          { key: "miToggleBreakpoint", comment: ["&& denotes a mnemonic"] },
          "Toggle &&Breakpoint"
        ),
        menuId: k.MenubarDebugMenu,
        group: "4_new_breakpoint",
        order: 1
      }
    });
  }
  async run(e, t) {
    if (t.hasModel()) {
      const i = e.get(T), s = t.getModel().uri, n = i.canSetBreakpointsIn(t.getModel()), o = [...new Set(t.getSelections().map((r) => r.getPosition().lineNumber))];
      await Promise.all(o.map(async (r) => {
        const a = i.getModel().getBreakpoints({ lineNumber: r, uri: s });
        a.length ? await Promise.all(a.map((d) => i.removeBreakpoints(d.getId()))) : n && await i.addBreakpoints(s, [{ lineNumber: r }]);
      }));
    }
  }
}
class Up extends pe {
  constructor() {
    super({
      id: "editor.debug.action.conditionalBreakpoint",
      label: c(
        "conditionalBreakpointEditorAction",
        "Debug: Add Conditional Breakpoint..."
      ),
      alias: "Debug: Add Conditional Breakpoint...",
      precondition: J,
      menuOpts: {
        menuId: k.MenubarNewBreakpointMenu,
        title: c(
          { key: "miConditionalBreakpoint", comment: ["&& denotes a mnemonic"] },
          "&&Conditional Breakpoint..."
        ),
        group: "1_breakpoints",
        order: 1,
        when: J
      }
    });
  }
  async run(e, t) {
    var n;
    const i = e.get(T), s = t.getPosition();
    s && t.hasModel() && i.canSetBreakpointsIn(t.getModel()) && ((n = t.getContribution(si)) == null || n.showBreakpointWidget(s.lineNumber, void 0, 0));
  }
}
class Hp extends pe {
  constructor() {
    super({
      id: "editor.debug.action.addLogPoint",
      label: c("logPointEditorAction", "Debug: Add Logpoint..."),
      precondition: J,
      alias: "Debug: Add Logpoint...",
      menuOpts: [
        {
          menuId: k.MenubarNewBreakpointMenu,
          title: c({ key: "miLogPoint", comment: ["&& denotes a mnemonic"] }, "&&Logpoint..."),
          group: "1_breakpoints",
          order: 4,
          when: J
        }
      ]
    });
  }
  async run(e, t) {
    var n;
    const i = e.get(T), s = t.getPosition();
    s && t.hasModel() && i.canSetBreakpointsIn(t.getModel()) && ((n = t.getContribution(si)) == null || n.showBreakpointWidget(s.lineNumber, s.column, 2));
  }
}
class $p extends pe {
  constructor() {
    super({
      id: "editor.debug.action.editBreakpoint",
      label: c("EditBreakpointEditorAction", "Debug: Edit Breakpoint"),
      alias: "Debug: Edit Existing Breakpoint",
      precondition: J,
      menuOpts: {
        menuId: k.MenubarNewBreakpointMenu,
        title: c(
          { key: "miEditBreakpoint", comment: ["&& denotes a mnemonic"] },
          "&&Edit Breakpoint"
        ),
        group: "1_breakpoints",
        order: 1,
        when: J
      }
    });
  }
  async run(e, t) {
    var u;
    const i = e.get(T), s = t.getPosition(), n = i.getModel();
    if (!(t.hasModel() && s))
      return;
    const o = n.getBreakpoints({ lineNumber: s.lineNumber });
    if (o.length === 0)
      return;
    const r = o.map((g) => g.column ? Math.abs(g.column - s.column) : s.column), a = r.indexOf(Math.min(...r)), d = o[a];
    (u = t.getContribution(si)) == null || u.showBreakpointWidget(d.lineNumber, d.column);
  }
}
const Hs = class Hs extends Wu {
  constructor() {
    super({
      id: Hs.ID,
      title: {
        value: c("openDisassemblyView", "Open Disassembly View"),
        original: "Open Disassembly View",
        mnemonicTitle: c(
          { key: "miDisassemblyView", comment: ["&& denotes a mnemonic"] },
          "&&DisassemblyView"
        )
      },
      precondition: pc,
      menu: [
        {
          id: k.EditorContext,
          group: "debug",
          order: 5,
          when: x.and(F, Wc.toNegated(), N.isEqualTo("stopped"), Be.editorTextFocus, Yi, Uc)
        },
        {
          id: k.DebugCallStackContext,
          group: "z_commands",
          order: 50,
          when: x.and(F, N.isEqualTo("stopped"), G.isEqualTo("stackFrame"), Yi)
        },
        {
          id: k.CommandPalette,
          when: x.and(F, N.isEqualTo("stopped"), Yi)
        }
      ]
    });
  }
  runEditorCommand(e, t, ...i) {
    t.hasModel() && e.get(ae).openEditor(ns.instance, { pinned: !0 });
  }
};
Hs.ID = "editor.debug.action.openDisassemblyView";
let Bo = Hs;
const _t = class _t extends Fi {
  constructor() {
    super({
      id: _t.ID,
      title: {
        value: c(
          "toggleDisassemblyViewSourceCode",
          "Toggle Source Code in Disassembly View"
        ),
        original: "Toggle Source Code in Disassembly View",
        mnemonicTitle: c(
          { key: "mitogglesource", comment: ["&& denotes a mnemonic"] },
          "&&ToggleSource"
        )
      },
      f1: !0
    });
  }
  run(e, t, ...i) {
    const s = e.get(O);
    if (s) {
      const n = s.getValue("debug").disassemblyView.showSourceCode;
      s.updateValue(_t.configID, !n);
    }
  }
};
_t.ID = "debug.action.toggleDisassemblyViewSourceCode", _t.configID = "debug.disassemblyView.showSourceCode";
let Mo = _t;
const Lt = class Lt extends pe {
  constructor() {
    super({
      id: Lt.ID,
      label: Lt.LABEL,
      alias: "Debug: Run to Cursor",
      precondition: x.and(J, Wc.toNegated(), Be.editorTextFocus),
      contextMenuOpts: {
        group: "debug",
        order: 2,
        when: F
      }
    });
  }
  async run(e, t) {
    const i = t.getPosition();
    if (!(t.hasModel() && i))
      return;
    const s = t.getModel().uri, n = e.get(T), o = n.getViewModel(), r = e.get(Le);
    let a;
    const d = o.focusedStackFrame;
    d && r.extUri.isEqual(d.source.uri, s) && d.range.startLineNumber === i.lineNumber && (a = i.column), await n.runTo(s, i.lineNumber, a);
  }
};
Lt.ID = "editor.debug.action.runToCursor", Lt.LABEL = c("runToCursor", "Run to Cursor");
let _i = Lt;
const At = class At extends pe {
  constructor() {
    super({
      id: At.ID,
      label: At.LABEL,
      alias: "Debug: Evaluate in Console",
      precondition: x.and(F, Be.editorTextFocus),
      contextMenuOpts: {
        group: "debug",
        order: 0
      }
    });
  }
  async run(e, t) {
    const i = e.get(T), s = e.get(Ae), n = i.getViewModel(), o = n.focusedSession;
    if (!t.hasModel() || !o)
      return;
    const r = t.getSelection();
    let a;
    r.isEmpty() ? a = t.getModel().getLineContent(r.selectionStartLineNumber).trim() : a = t.getModel().getValueInRange(r), await o.addReplExpression(n.focusedStackFrame, a), await s.openView(X, !1);
  }
};
At.ID = "editor.debug.action.selectionToRepl", At.LABEL = c("evaluateInDebugConsole", "Evaluate in Debug Console");
let Li = At;
const Bt = class Bt extends pe {
  constructor() {
    super({
      id: Bt.ID,
      label: Bt.LABEL,
      alias: "Debug: Add to Watch",
      precondition: x.and(F, Be.editorTextFocus),
      contextMenuOpts: {
        group: "debug",
        order: 1
      }
    });
  }
  async run(e, t) {
    const i = e.get(T), s = e.get(Ae), n = e.get(ii);
    if (!t.hasModel())
      return;
    let o;
    const r = t.getModel(), a = t.getSelection();
    if (!a.isEmpty())
      o = r.getValueInRange(a);
    else {
      const d = t.getPosition(), u = await Hc(n, r, d);
      if (!u)
        return;
      o = u.matchingExpression;
    }
    o && (await s.openView(Vt), i.addWatchExpression(o));
  }
};
Bt.ID = "editor.debug.action.selectionToWatch", Bt.LABEL = c("addToWatch", "Add to Watch");
let Ai = Bt;
class zp extends pe {
  constructor() {
    super({
      id: "editor.debug.action.showDebugHover",
      label: c("showDebugHover", "Debug: Show Hover"),
      alias: "Debug: Show Hover",
      precondition: F,
      kbOpts: {
        kbExpr: Be.editorTextFocus,
        primary: Hu(2089, 2087),
        weight: 100
      }
    });
  }
  async run(e, t) {
    var s;
    const i = t.getPosition();
    if (!(!i || !t.hasModel()))
      return (s = t.getContribution(on)) == null ? void 0 : s.showHover(i, !0);
  }
}
const Ra = c(
  "editor.debug.action.stepIntoTargets.notAvailable",
  "Step targets are not available here"
), Mt = class Mt extends pe {
  constructor() {
    super({
      id: Mt.ID,
      label: Mt.LABEL,
      alias: "Debug: Step Into Target",
      precondition: x.and(cr, F, N.isEqualTo("stopped"), Be.editorTextFocus),
      contextMenuOpts: {
        group: "debug",
        order: 1.5
      }
    });
  }
  async run(e, t) {
    var w, m;
    const i = e.get(T), s = e.get(Me), n = e.get(Le), o = i.getViewModel().focusedSession, r = i.getViewModel().focusedStackFrame, a = t.getSelection(), d = (a == null ? void 0 : a.getPosition()) || r && { lineNumber: r.range.startLineNumber, column: r.range.startColumn };
    if (!o || !r || !t.hasModel() || !n.extUri.isEqual(t.getModel().uri, r.source.uri)) {
      d && ((w = ca.get(t)) == null || w.showMessage(Ra, d));
      return;
    }
    const u = await o.stepInTargets(r.frameId);
    if (!(u != null && u.length)) {
      (m = ca.get(t)) == null || m.showMessage(Ra, d);
      return;
    }
    if (a) {
      const y = [];
      for (const C of u)
        C.line && y.push({
          start: new Ci(C.line, C.column || 1),
          end: C.endLine ? new Ci(C.endLine, C.endColumn || 1) : void 0,
          target: C
        });
      y.sort((C, b) => b.start.lineNumber - C.start.lineNumber || b.start.column - C.start.column);
      const _ = a.getPosition(), v = y.find((C) => C.end && _.isBefore(C.end) && C.start.isBeforeOrEqual(_)) || y.find((C) => C.end === void 0 && C.start.isBeforeOrEqual(_));
      if (v) {
        o.stepIn(r.thread.threadId, v.target.id);
        return;
      }
    }
    t.revealLineInCenterIfOutsideViewport(r.range.startLineNumber);
    const g = t.getScrolledVisiblePosition(d), p = Uu(t.getDomNode()), f = p.left + g.left, S = p.top + g.top + g.height;
    s.showContextMenu({
      getAnchor: () => ({ x: f, y: S }),
      getActions: () => u.map((y) => new Z(
        `stepIntoTarget:${y.id}`,
        y.label,
        void 0,
        !0,
        () => o.stepIn(r.thread.threadId, y.id)
      ))
    });
  }
};
Mt.ID = "editor.debug.action.stepIntoTargets", Mt.LABEL = c(
  { key: "stepIntoTargets", comment: ["Step Into Targets lets the user step into an exact function he or she is interested in."] },
  "Step Into Target"
);
let No = Mt;
class Bd extends pe {
  constructor(e, t) {
    super(t), this.isNext = e;
  }
  async run(e, t) {
    const i = e.get(T), s = e.get(ae), n = e.get(Le);
    if (t.hasModel()) {
      const o = t.getModel().uri, r = t.getPosition().lineNumber, a = i.getModel().getBreakpoints({ enabledOnly: !0 });
      let d = this.isNext ? a.filter((u) => n.extUri.isEqual(u.uri, o) && u.lineNumber > r).shift() : a.filter((u) => n.extUri.isEqual(u.uri, o) && u.lineNumber < r).pop();
      if (d || (d = this.isNext ? a.filter((u) => u.uri.toString() > o.toString()).shift() : a.filter((u) => u.uri.toString() < o.toString()).pop()), !d && a.length && (d = this.isNext ? a[0] : a[a.length - 1]), d)
        return Zh(d, !1, !0, !1, i, s);
    }
  }
}
class qp extends Bd {
  constructor() {
    super(!0, {
      id: "editor.debug.action.goToNextBreakpoint",
      label: c("goToNextBreakpoint", "Debug: Go to Next Breakpoint"),
      alias: "Debug: Go to Next Breakpoint",
      precondition: J
    });
  }
}
class Gp extends Bd {
  constructor() {
    super(!1, {
      id: "editor.debug.action.goToPreviousBreakpoint",
      label: c("goToPreviousBreakpoint", "Debug: Go to Previous Breakpoint"),
      alias: "Debug: Go to Previous Breakpoint",
      precondition: J
    });
  }
}
class Kp extends pe {
  constructor() {
    super({
      id: "editor.debug.action.closeExceptionWidget",
      label: c("closeExceptionWidget", "Close Exception Widget"),
      alias: "Close Exception Widget",
      precondition: $c,
      kbOpts: {
        primary: 9,
        weight: 100
      }
    });
  }
  async run(e, t) {
    const i = t.getContribution(on);
    i == null || i.closeExceptionWidget();
  }
}
ge(Bo);
ge(Mo);
de(Wp);
de(Up);
de(Hp);
de($p);
de(_i);
de(No);
de(Li);
de(Ai);
de(zp);
de(qp);
de(Gp);
de(Kp);
const Oa = "\\u0000-\\u0020\\u007f-\\u009f", jp = new RegExp(
  "(?:[a-zA-Z][a-zA-Z0-9+.-]{2,}:\\/\\/|data:|www\\.)[^\\s" + Oa + '"]{2,}[^\\s' + Oa + `"')}\\],:;.!?]`,
  "ug"
), Xp = /(?:[a-zA-Z]:(?:(?:\\|\/)[\w\.-]*)+)/, Yp = /(?:(?:\~|\.)(?:(?:\\|\/)[\w\.-]*)+)/, Jp = new RegExp(`(${Xp.source}|${Yp.source})`), Qp = /((?:\~|\.)?(?:\/[\w\.-]*)+)/, Zp = /(?:\:([\d]+))?(?:\:([\d]+))?/, ef = new RegExp(
  `${vr ? Jp.source : Qp.source}${Zp.source}`,
  "g"
), tf = /:([\d]+)(?::([\d]+))?$/, sf = 2e3;
let wt = class {
  constructor(e, t, i, s, n, o, r) {
    this.editorService = e, this.fileService = t, this.openerService = i, this.pathService = s, this.tunnelService = n, this.environmentService = o, this.configurationService = r;
  }
  linkify(e, t, i, s) {
    if (t) {
      const o = e.split(`
`);
      for (let d = 0; d < o.length - 1; d++)
        o[d] = o[d] + `
`;
      o[o.length - 1] || o.pop();
      const r = o.map((d) => this.linkify(d, !1, i, s));
      if (r.length === 1)
        return r[0];
      const a = document.createElement("span");
      return r.forEach((d) => a.appendChild(d)), a;
    }
    const n = document.createElement("span");
    for (const o of this.detectLinks(e))
      try {
        switch (o.kind) {
          case "text":
            n.appendChild(document.createTextNode(o.value));
            break;
          case "web":
            n.appendChild(this.createWebLink(s ? e : void 0, o.value));
            break;
          case "path": {
            const r = o.captures[0], a = o.captures[1] ? Number(o.captures[1]) : 0, d = o.captures[2] ? Number(o.captures[2]) : 0;
            n.appendChild(this.createPathLink(s ? e : void 0, o.value, r, a, d, i));
            break;
          }
        }
      } catch {
        n.appendChild(document.createTextNode(o.value));
      }
    return n;
  }
  createWebLink(e, t) {
    const i = this.createLink(t);
    let s = ue.parse(t);
    const n = tf.exec(s.path);
    return n && (s = s.with({
      path: s.path.slice(0, n.index),
      fragment: `L${n[0].slice(1)}`
    })), this.decorateLink(i, s, e, async () => {
      if (s.scheme === ft.file) {
        const o = s.fsPath, r = await this.pathService.path, a = is(r.sep === Ot.sep && vr ? o.replace(/\\/g, Ot.sep) : o), d = ue.parse(a);
        if (!await this.fileService.exists(d))
          return;
        await this.editorService.openEditor({
          resource: d,
          options: {
            pinned: !0,
            selection: n ? { startLineNumber: +n[1], startColumn: +n[2] } : void 0
          }
        });
        return;
      }
      this.openerService.open(t, { allowTunneling: !!this.environmentService.remoteAuthority && this.configurationService.getValue("remote.forwardOnOpen") });
    }), i;
  }
  createPathLink(e, t, i, s, n, o) {
    if (i[0] === "/" && i[1] === "/")
      return document.createTextNode(t);
    const r = { selection: { startLineNumber: s, startColumn: n } };
    if (i[0] === ".") {
      if (!o)
        return document.createTextNode(t);
      const u = o.toResource(i), g = this.createLink(t);
      return this.decorateLink(g, u, e, (p) => this.editorService.openEditor({ resource: u, options: { ...r, preserveFocus: p } })), g;
    }
    if (i[0] === "~") {
      const u = this.pathService.resolvedUserHome;
      u && (i = zu(u.fsPath, i.substring(1)));
    }
    const a = this.createLink(t);
    a.tabIndex = 0;
    const d = ue.file(is(i));
    return this.fileService.stat(d).then((u) => {
      u.isDirectory || this.decorateLink(a, d, e, (g) => this.editorService.openEditor({ resource: d, options: { ...r, preserveFocus: g } }));
    }).catch(() => {
    }), a;
  }
  createLink(e) {
    const t = document.createElement("a");
    return t.textContent = e, t;
  }
  decorateLink(e, t, i, s) {
    e.classList.add("link");
    const n = this.tunnelService.canTunnel(t) ? c("followForwardedLink", "follow link using forwarded port") : c("followLink", "follow link");
    e.title = i ? Oe ? c("fileLinkWithPathMac", `Cmd + click to {0}
{1}`, n, i) : c("fileLinkWithPath", `Ctrl + click to {0}
{1}`, n, i) : Oe ? c("fileLinkMac", "Cmd + click to {0}", n) : c("fileLink", "Ctrl + click to {0}", n), e.onmousemove = (o) => {
      e.classList.toggle("pointer", Oe ? o.metaKey : o.ctrlKey);
    }, e.onmouseleave = () => e.classList.remove("pointer"), e.onclick = (o) => {
      const r = window.getSelection();
      !r || r.type === "Range" || (Oe ? o.metaKey : o.ctrlKey) && (o.preventDefault(), o.stopImmediatePropagation(), s(!1));
    }, e.onkeydown = (o) => {
      const r = new ki(o);
      (r.keyCode === 3 || r.keyCode === 10) && (r.preventDefault(), r.stopPropagation(), s(r.keyCode === 10));
    };
  }
  detectLinks(e) {
    if (e.length > sf)
      return [{ kind: "text", value: e, captures: [] }];
    const t = [jp, ef], i = ["web", "path"], s = [], n = (o, r) => {
      if (r >= t.length) {
        s.push({ value: o, kind: "text", captures: [] });
        return;
      }
      const a = t[r];
      let d = 0, u;
      for (a.lastIndex = 0; (u = a.exec(o)) !== null; ) {
        const p = o.substring(d, u.index);
        p && n(p, r + 1);
        const f = u[0];
        s.push({
          value: f,
          kind: i[r],
          captures: u.slice(1)
        }), d = u.index + f.length;
      }
      const g = o.substring(d);
      g && n(g, r + 1);
    };
    return n(e, 0), s;
  }
};
wt = I([
  h(0, ae),
  h(1, rr),
  h(2, st),
  h(3, gr),
  h(4, $u),
  h(5, nr),
  h(6, O)
], wt);
const Ro = ie;
let Oo = !0, ys, $, Vo = class extends Pi {
  constructor(e, t, i, s, n, o, r, a, d, u, g, p) {
    super(e, s, t, n, a, r, o, d, u, g), this.debugService = i, this.menuService = p, this.needsRefresh = !1, this.savedViewState = /* @__PURE__ */ new Map(), this.autoExpandedScopes = /* @__PURE__ */ new Set(), this.updateTreeScheduler = new oe(async () => {
      const f = this.debugService.getViewModel().focusedStackFrame;
      this.needsRefresh = !1;
      const S = this.tree.getInput();
      if (S && this.savedViewState.set(S.getId(), this.tree.getViewState()), !f) {
        await this.tree.setInput(null);
        return;
      }
      const w = this.savedViewState.get(f.getId());
      await this.tree.setInput(f, w);
      const y = (await f.getScopes()).find((_) => !_.expensive);
      y && this.tree.hasNode(y) && (this.autoExpandedScopes.add(y.getId()), await this.tree.expand(y));
    }, 400);
  }
  renderBody(e) {
    super.renderBody(e), this.element.classList.add("debug-pane"), e.classList.add("debug-variables");
    const t = Dn(e), i = this.instantiationService.createInstance(wt);
    this.tree = this.instantiationService.createInstance(rn, "VariablesView", t, new rf(), [this.instantiationService.createInstance(tt, i), new Ds(), new Es()], new of(), {
      accessibilityProvider: new af(),
      identityProvider: { getId: (n) => n.getId() },
      keyboardNavigationLabelProvider: { getKeyboardNavigationLabel: (n) => n.name },
      overrideStyles: {
        listBackground: this.getBackgroundColor()
      }
    }), this.tree.setInput(Oi(this.debugService.getViewModel().focusedStackFrame)), Gu.bindTo(this.tree.contextKeyService), this._register(this.debugService.getViewModel().onDidFocusStackFrame((n) => {
      if (!this.isBodyVisible()) {
        this.needsRefresh = !0;
        return;
      }
      const o = n.explicit ? 0 : void 0;
      this.updateTreeScheduler.schedule(o);
    })), this._register(this.debugService.getViewModel().onWillUpdateViews(() => {
      const n = this.debugService.getViewModel().focusedStackFrame;
      n && Oo && n.forgetScopes(), Oo = !0, this.tree.updateChildren();
    })), this._register(this.tree.onMouseDblClick((n) => this.onMouseDblClick(n))), this._register(this.tree.onContextMenu(async (n) => await this.onContextMenu(n))), this._register(this.onDidChangeBodyVisibility((n) => {
      n && this.needsRefresh && this.updateTreeScheduler.schedule();
    }));
    let s;
    this._register(this.debugService.getViewModel().onDidSelectExpression((n) => {
      const o = n == null ? void 0 : n.expression;
      o instanceof q && !(n != null && n.settingWatch) ? (s = this.tree.options.horizontalScrolling, s && this.tree.updateOptions({ horizontalScrolling: !1 }), this.tree.rerender(o)) : !n && s !== void 0 && (this.tree.updateOptions({ horizontalScrolling: s }), s = void 0);
    })), this._register(this.debugService.getViewModel().onDidEvaluateLazyExpression(async (n) => {
      n instanceof q && this.tree.hasNode(n) && (await this.tree.updateChildren(n, !1, !0), await this.tree.expand(n));
    })), this._register(this.debugService.onDidEndSession(() => {
      this.savedViewState.clear(), this.autoExpandedScopes.clear();
    }));
  }
  layoutBody(e, t) {
    super.layoutBody(t, e), this.tree.layout(e, t);
  }
  focus() {
    this.tree.domFocus();
  }
  collapseAll() {
    this.tree.collapseAll();
  }
  onMouseDblClick(e) {
    var i, s, n;
    const t = this.debugService.getViewModel().focusedSession;
    t && e.element instanceof q && t.capabilities.supportsSetVariable && !((s = (i = e.element.presentationHint) == null ? void 0 : i.attributes) != null && s.includes("readOnly")) && !((n = e.element.presentationHint) != null && n.lazy) && this.debugService.getViewModel().setSelectedExpression(e.element, !1);
  }
  async onContextMenu(e) {
    const t = e.element;
    if (!(t instanceof q) || !t.value)
      return;
    const i = new te();
    try {
      const s = await nf(this.contextKeyService, t), n = i.add(this.menuService.createMenu(k.DebugVariablesContext, s)), o = Md(t), r = [];
      ri(n, { arg: o, shouldForwardArgs: !1 }, { primary: [], secondary: r }, "inline"), this.contextMenuService.showContextMenu({
        getAnchor: () => e.anchor,
        getActions: () => r
      });
    } finally {
      i.dispose();
    }
  }
};
Vo = I([
  h(1, Me),
  h(2, T),
  h(3, at),
  h(4, O),
  h(5, K),
  h(6, Ue),
  h(7, H),
  h(8, st),
  h(9, ce),
  h(10, we),
  h(11, Ne)
], Vo);
const Md = (l) => {
  var e;
  return {
    sessionId: (e = l.getSession()) == null ? void 0 : e.getId(),
    container: l.parent instanceof Y ? { expression: l.parent.name } : l.parent.toDebugProtocolObject(),
    variable: l.toDebugProtocolObject()
  };
};
async function nf(l, e) {
  const t = e.getSession();
  if (!t || !t.capabilities.supportsDataBreakpoints)
    return Po(l, e);
  const i = [];
  $ = await t.dataBreakpointInfo(e.name, e.parent.reference);
  const s = $ == null ? void 0 : $.dataId, n = $ == null ? void 0 : $.accessTypes;
  if (!n)
    i.push([eo.key, !!s]);
  else
    for (const o of n)
      switch (o) {
        case "read":
          i.push([qc.key, !!s]);
          break;
        case "write":
          i.push([eo.key, !!s]);
          break;
        case "readWrite":
          i.push([zc.key, !!s]);
          break;
      }
  return Po(l, e, i);
}
function Po(l, e, t = []) {
  var n, o, r;
  const i = e.getSession(), s = [
    [Ku.key, e.variableMenuContext || ""],
    [an.key, !!e.evaluateName],
    [cn.key, !!(i != null && i.capabilities.supportsReadMemoryRequest) && e.memoryReference !== void 0],
    [dn.key, !!((o = (n = e.presentationHint) == null ? void 0 : n.attributes) != null && o.includes("readOnly")) || ((r = e.presentationHint) == null ? void 0 : r.lazy)],
    ...t
  ];
  return ys = e, l.createOverlay(s);
}
function Va(l) {
  return l instanceof ye;
}
class of {
  hasChildren(e) {
    return e ? Va(e) ? !0 : e.hasChildren : !1;
  }
  getChildren(e) {
    return Va(e) ? e.getScopes() : e.getChildren();
  }
}
class rf {
  getHeight(e) {
    return 22;
  }
  getTemplateId(e) {
    return e instanceof tg ? Es.ID : e instanceof fd ? Ds.ID : tt.ID;
  }
}
const $s = class $s {
  get templateId() {
    return $s.ID;
  }
  renderTemplate(e) {
    const t = E(e, Ro(".scope")), i = new kt(t);
    return { name: t, label: i };
  }
  renderElement(e, t, i) {
    i.label.set(e.element.name, Fe(e.filterData));
  }
  disposeTemplate(e) {
  }
};
$s.ID = "scope";
let Ds = $s;
const zs = class zs {
  get templateId() {
    return zs.ID;
  }
  renderTemplate(e) {
    const t = E(e, Ro(".scope"));
    return { error: E(t, Ro(".error")) };
  }
  renderElement(e, t, i) {
    i.error.innerText = e.element.name;
  }
  disposeTemplate() {
  }
};
zs.ID = "scopeError";
let Es = zs;
var $t;
let tt = ($t = class extends xi {
  constructor(e, t, i, s, n) {
    super(s, n), this.linkDetector = e, this.menuService = t, this.contextKeyService = i;
  }
  get templateId() {
    return $t.ID;
  }
  renderExpression(e, t, i) {
    Id(e, t, !0, i, this.linkDetector);
  }
  renderElement(e, t, i) {
    super.renderExpressionElement(e.element, e, i);
  }
  getInputBoxOptions(e) {
    const t = e;
    return {
      initialValue: e.value,
      ariaLabel: c("variableValueAriaLabel", "Type new variable value"),
      validationOptions: {
        validation: () => t.errorMessage ? { content: t.errorMessage } : null
      },
      onFinish: (i, s) => {
        t.errorMessage = void 0;
        const n = this.debugService.getViewModel().focusedStackFrame;
        s && t.value !== i && n && t.setVariable(i, n).then(() => {
          Oo = !1, this.debugService.getViewModel().updateViews();
        });
      }
    };
  }
  renderActionBar(e, t) {
    const i = t, s = Po(this.contextKeyService, i), n = this.menuService.createMenu(k.DebugVariablesContext, s), o = [], r = Md(i);
    ri(n, { arg: r, shouldForwardArgs: !1 }, { primary: o, secondary: [] }, "inline"), e.clear(), e.context = r, e.push(o, { icon: !0, label: !1 });
  }
}, $t.ID = "variable", $t);
tt = I([
  h(1, Ne),
  h(2, H),
  h(3, T),
  h(4, rt)
], tt);
class af {
  getWidgetAriaLabel() {
    return c("variablesAriaTreeLabel", "Debug Variables");
  }
  getAriaLabel(e) {
    return e instanceof fd ? c("variableScopeAriaLabel", "Scope {0}", e.name) : e instanceof q ? c(
      { key: "variableAriaLabel", comment: ["Placeholders are variable name and variable value respectivly. They should not be translated."] },
      "{0}, value {1}",
      e.name,
      e.value
    ) : null;
  }
}
const Nd = "debug.setVariable";
dt.registerCommand({
  id: Nd,
  handler: (l) => {
    l.get(T).getViewModel().setSelectedExpression(ys, !1);
  }
});
const Or = "workbench.debug.viewlet.action.copyValue";
dt.registerCommand({
  id: Or,
  handler: async (l, e, t) => {
    const i = l.get(T), s = l.get(ai);
    let n = "", o;
    e instanceof q || e instanceof Y ? (n = "watch", o = t || []) : (n = "variables", o = ys ? [ys] : []);
    const r = i.getViewModel().focusedStackFrame, a = i.getViewModel().focusedSession;
    if (!r || !a || o.length === 0)
      return;
    const d = a.capabilities.supportsClipboardContext ? "clipboard" : n, u = o.map(
      (g) => g instanceof q ? g.evaluateName || g.value : g.name
    );
    try {
      const g = await Promise.all(u.map((f) => a.evaluate(f, r.frameId, d))), p = Cr(g).map((f) => f.body.result);
      p.length && s.writeText(p.join(`
`));
    } catch {
      const p = o.map((f) => f.value);
      s.writeText(p.join(`
`));
    }
  }
});
const Vr = "workbench.debug.viewlet.action.viewMemory", Fo = "ms-vscode.hexeditor", cf = "hexEditor.hexedit";
dt.registerCommand({
  id: Vr,
  handler: async (l, e, t) => {
    var f;
    const i = l.get(T);
    let s, n;
    if ("sessionId" in e) {
      if (!e.sessionId || !e.variable.memoryReference)
        return;
      s = e.sessionId, n = e.variable.memoryReference;
    } else {
      if (!e.memoryReference)
        return;
      const S = i.getViewModel().focusedSession;
      if (!S)
        return;
      s = S.getId(), n = e.memoryReference;
    }
    const o = l.get(We), r = l.get(ae), a = l.get(Ct), d = l.get(kr), u = l.get(Yt), g = l.get(we);
    (await u.getExtension(Fo) || await df(a, d, u, o)) && (g.publicLog("debug/didViewMemory", {
      debugType: (f = i.getModel().getSession(s)) == null ? void 0 : f.configuration.type
    }), await r.openEditor({
      resource: eg(s, n),
      options: {
        revealIfOpened: !0,
        override: cf
      }
    }, qu));
  }
});
function df(l, e, t, i) {
  return new Promise((s) => {
    let n = !1;
    l.prompt(nc.Info, c(
      "viewMemory.prompt",
      "Inspecting binary data requires the Hex Editor extension. Would you like to install it now?"
    ), [
      {
        label: c("cancel", "Cancel"),
        run: () => s(!1)
      },
      {
        label: c("install", "Install"),
        run: async () => {
          n = !0;
          try {
            await e.withProgress({
              location: 15,
              title: c("viewMemory.install.progress", "Installing the Hex Editor...")
            }, async () => {
              for (await i.executeCommand("workbench.extensions.installExtension", Fo); !await t.getExtension(Fo); )
                await Mc(30);
            }), s(!0);
          } catch (r) {
            l.error(r), s(!1);
          }
        }
      }
    ], { sticky: !0 }).onDidClose((r) => {
      n || s(!1);
    });
  });
}
const Rd = "debug.breakWhenValueChanges";
dt.registerCommand({
  id: Rd,
  handler: async (l) => {
    const e = l.get(T);
    $ && await e.addDataBreakpoint($.description, $.dataId, !!$.canPersist, $.accessTypes, "write");
  }
});
const Od = "debug.breakWhenValueIsAccessed";
dt.registerCommand({
  id: Od,
  handler: async (l) => {
    const e = l.get(T);
    $ && await e.addDataBreakpoint($.description, $.dataId, !!$.canPersist, $.accessTypes, "readWrite");
  }
});
const Vd = "debug.breakWhenValueIsRead";
dt.registerCommand({
  id: Vd,
  handler: async (l) => {
    const e = l.get(T);
    $ && await e.addDataBreakpoint($.description, $.dataId, !!$.canPersist, $.accessTypes, "read");
  }
});
const Pd = "debug.copyEvaluatePath";
dt.registerCommand({
  id: Pd,
  handler: async (l, e) => {
    await l.get(ai).writeText(e.variable.evaluateName);
  }
});
const Fd = "debug.addToWatchExpressions";
dt.registerCommand({
  id: Fd,
  handler: async (l, e) => {
    l.get(T).addWatchExpression(e.variable.evaluateName);
  }
});
ge(class extends ct {
  constructor() {
    super({
      id: "variables.collapse",
      viewId: Zn,
      title: c("collapse", "Collapse All"),
      f1: !1,
      icon: tn.collapseAll,
      menu: {
        id: k.ViewTitle,
        group: "navigation",
        when: x.equals("view", Zn)
      }
    });
  }
  runInView(l, e) {
    e.collapseAll();
  }
});
const Et = ie;
async function Wd(l, e) {
  if (!l)
    return null;
  const i = (await l.getChildren()).filter((s) => e[0] === s.name);
  return i.length !== 1 ? null : e.length === 1 ? i[0] : Wd(i[0], e.slice(1));
}
async function lf(l, e) {
  const i = (await l.getScopes()).filter((n) => !n.expensive), s = Cr(await Promise.all(i.map((n) => Wd(n, e))));
  return s.length > 0 && s.every((n) => n.value === s[0].value) ? s[0] : void 0;
}
var qe;
let Si = (qe = class {
  constructor(e, t, i) {
    this.editor = e, this.debugService = t, this.instantiationService = i, this.allowEditorOverflow = !0, this.highlightDecorations = this.editor.createDecorationsCollection(), this.isUpdatingTree = !1, this.toDispose = [], this._isVisible = !1, this.showAtPosition = null, this.positionPreference = [1, 2], this.debugHoverComputer = this.instantiationService.createInstance(Wo, this.editor);
  }
  create() {
    this.domNode = Et(".debug-hover-widget"), this.complexValueContainer = E(this.domNode, Et(".complex-value")), this.complexValueTitle = E(this.complexValueContainer, Et(".title")), this.treeContainer = E(this.complexValueContainer, Et(".debug-hover-tree")), this.treeContainer.setAttribute("role", "tree");
    const e = E(this.complexValueContainer, Et(".tip"));
    e.textContent = c(
      { key: "quickTip", comment: ['"switch to editor language hover" means to show the programming language hover widget instead of the debug hover'] },
      "Hold {0} key to switch to editor language hover",
      Oe ? "Option" : "Alt"
    );
    const t = new hf(), i = this.instantiationService.createInstance(wt);
    this.tree = this.instantiationService.createInstance(rn, "DebugHover", this.treeContainer, new gf(), [this.instantiationService.createInstance(tt, i)], t, {
      accessibilityProvider: new uf(),
      mouseSupport: !1,
      horizontalScrolling: !0,
      useShadows: !1,
      keyboardNavigationLabelProvider: { getKeyboardNavigationLabel: (s) => s.name },
      overrideStyles: {
        listBackground: da
      }
    }), this.valueContainer = Et(".value"), this.valueContainer.tabIndex = 0, this.valueContainer.setAttribute("role", "tooltip"), this.scrollbar = new ju(this.valueContainer, { horizontal: 2 }), this.domNode.appendChild(this.scrollbar.getDomNode()), this.toDispose.push(this.scrollbar), this.editor.applyFontInfo(this.domNode), this.domNode.style.backgroundColor = je(da), this.domNode.style.border = `1px solid ${je(Xu)}`, this.domNode.style.color = je(Yu), this.toDispose.push(this.tree.onDidChangeContentHeight(() => {
      this.isUpdatingTree || this.layoutTreeAndContainer();
    })), this.toDispose.push(this.tree.onDidChangeContentWidth(() => {
      this.isUpdatingTree || this.layoutTreeAndContainer();
    })), this.registerListeners(), this.editor.addContentWidget(this);
  }
  registerListeners() {
    this.toDispose.push(Ke(this.domNode, "keydown", (e) => {
      e.equals(9) && this.hide();
    })), this.toDispose.push(this.editor.onDidChangeConfiguration((e) => {
      e.hasChanged(49) && this.editor.applyFontInfo(this.domNode);
    })), this.toDispose.push(this.debugService.getViewModel().onDidEvaluateLazyExpression(async (e) => {
      e instanceof q && this.tree.hasNode(e) && (await this.tree.updateChildren(e, !1, !0), await this.tree.expand(e));
    }));
  }
  isHovered() {
    var e;
    return !!((e = this.domNode) != null && e.matches(":hover"));
  }
  isVisible() {
    return this._isVisible;
  }
  willBeVisible() {
    return !!this.showCancellationSource;
  }
  getId() {
    return qe.ID;
  }
  getDomNode() {
    return this.domNode;
  }
  async showAt(e, t) {
    var r;
    (r = this.showCancellationSource) == null || r.cancel();
    const i = this.showCancellationSource = new Qe(), s = this.debugService.getViewModel().focusedSession;
    if (!s || !this.editor.hasModel())
      return this.hide(), 1;
    const n = await this.debugHoverComputer.compute(e, i.token);
    if (i.token.isCancellationRequested)
      return this.hide(), 2;
    if (!n.range)
      return this.hide(), 1;
    if (this.isVisible() && !n.rangeChanged)
      return 0;
    const o = await this.debugHoverComputer.evaluate(s);
    return i.token.isCancellationRequested ? (this.hide(), 2) : !o || o instanceof Y && !o.available ? (this.hide(), 1) : (this.highlightDecorations.set([{
      range: n.range,
      options: qe._HOVER_HIGHLIGHT_DECORATION_OPTIONS
    }]), this.doShow(n.range.getStartPosition(), o, t));
  }
  async doShow(e, t, i, s = !1) {
    if (this.domNode || this.create(), this.showAtPosition = e, this._isVisible = !0, !t.hasChildren || s) {
      this.complexValueContainer.hidden = !0, this.valueContainer.hidden = !1, li(t, this.valueContainer, {
        showChanged: !1,
        colorize: !0
      }), this.valueContainer.title = "", this.editor.layoutContentWidget(this), this.scrollbar.scanDomNode(), i && (this.editor.render(), this.valueContainer.focus());
      return;
    }
    this.valueContainer.hidden = !0, this.expressionToRender = t, this.complexValueTitle.textContent = t.value, this.complexValueTitle.title = t.value, this.editor.layoutContentWidget(this), this.tree.scrollTop = 0, this.tree.scrollLeft = 0, this.complexValueContainer.hidden = !1, i && (this.editor.render(), this.tree.domFocus());
  }
  layoutTreeAndContainer() {
    this.layoutTree(), this.editor.layoutContentWidget(this);
  }
  layoutTree() {
    const t = Math.min(Math.max(266, this.editor.getLayoutInfo().height * 0.55), this.tree.contentHeight + 10), i = this.tree.contentWidth, s = jn(i, 400, 550);
    this.tree.layout(t, s), this.treeContainer.style.height = `${t}px`, this.scrollbar.scanDomNode();
  }
  beforeRender() {
    if (this.expressionToRender) {
      const e = this.expressionToRender;
      this.expressionToRender = void 0, this.isUpdatingTree = !0, this.tree.setInput(e).finally(() => {
        this.isUpdatingTree = !1;
      });
    }
    return null;
  }
  afterRender(e) {
    e && (this.positionPreference = [e]);
  }
  hide() {
    this.showCancellationSource && (this.showCancellationSource.cancel(), this.showCancellationSource = void 0), this._isVisible && (Gc(document.activeElement, this.domNode) && this.editor.focus(), this._isVisible = !1, this.highlightDecorations.clear(), this.editor.layoutContentWidget(this), this.positionPreference = [1, 2]);
  }
  getPosition() {
    return this._isVisible ? {
      position: this.showAtPosition,
      preference: this.positionPreference
    } : null;
  }
  dispose() {
    this.toDispose = U(this.toDispose);
  }
}, qe.ID = "debug.hoverWidget", qe._HOVER_HIGHLIGHT_DECORATION_OPTIONS = Ju.register({
  description: "bdebug-hover-highlight",
  className: "hoverHighlight"
}), qe);
Si = I([
  h(1, T),
  h(2, K)
], Si);
class uf {
  getWidgetAriaLabel() {
    return c("treeAriaLabel", "Debug Hover");
  }
  getAriaLabel(e) {
    return c(
      { key: "variableAriaLabel", comment: ["Do not translate placeholders. Placeholders are name and value of a variable."] },
      "{0}, value {1}, variables, debug",
      e.name,
      e.value
    );
  }
}
class hf {
  hasChildren(e) {
    return e.hasChildren;
  }
  getChildren(e) {
    return e.getChildren();
  }
}
class gf {
  getHeight(e) {
    return 18;
  }
  getTemplateId(e) {
    return tt.ID;
  }
}
let Wo = class {
  constructor(e, t, i, s) {
    this.editor = e, this.debugService = t, this.languageFeaturesService = i, this.logService = s;
  }
  async compute(e, t) {
    if (!this.debugService.getViewModel().focusedSession || !this.editor.hasModel())
      return { rangeChanged: !1 };
    const s = this.editor.getModel(), n = await Hc(this.languageFeaturesService, s, e, t);
    if (!n)
      return { rangeChanged: !1 };
    const { range: o, matchingExpression: r } = n, a = this._currentRange ? !this._currentRange.equalsRange(o) : !0;
    return this._currentExpression = r, this._currentRange = re.lift(o), { rangeChanged: a, range: this._currentRange };
  }
  async evaluate(e) {
    if (!this._currentExpression) {
      this.logService.error("No expression to evaluate");
      return;
    }
    if (e.capabilities.supportsEvaluateForHovers) {
      const t = new Y(this._currentExpression);
      return await t.evaluate(e, this.debugService.getViewModel().focusedStackFrame, "hover"), t;
    } else {
      const t = this.debugService.getViewModel().focusedStackFrame;
      if (t)
        return await lf(t, Cr(this._currentExpression.split(".").map((i) => i.trim())));
    }
  }
};
Wo = I([
  h(1, T),
  h(2, ii),
  h(3, ei)
], Wo);
var pf = ".monaco-editor .zone-widget.exception-widget-container{overflow:hidden}.monaco-editor .zone-widget .zone-widget-container.exception-widget{padding:6px 10px;user-select:text;-webkit-user-select:text;white-space:pre-wrap}.monaco-editor .zone-widget .zone-widget-container.exception-widget .title{display:flex}.monaco-editor .zone-widget .zone-widget-container.exception-widget .title .label{align-items:center;display:flex;font-weight:700}.monaco-editor .zone-widget .zone-widget-container.exception-widget .title .actions{flex:1}.monaco-editor .zone-widget .zone-widget-container.exception-widget .description,.monaco-editor .zone-widget .zone-widget-container.exception-widget .stack-trace{font-family:var(--monaco-monospace-font)}.monaco-editor .zone-widget .zone-widget-container.exception-widget .stack-trace{margin-top:.5em}.monaco-editor .zone-widget .zone-widget-container.exception-widget .stack-trace a{cursor:pointer;text-decoration:underline}.monaco-workbench.mac .zone-widget .zone-widget-container.exception-widget{font-size:11px}.monaco-workbench.linux .zone-widget .zone-widget-container.exception-widget,.monaco-workbench.windows .zone-widget .zone-widget-container.exception-widget{font-size:13px}";
ot(pf, {});
const gi = ie, ff = M("debugExceptionWidget.border", { dark: "#a31515", light: "#a31515", hcDark: "#a31515", hcLight: "#a31515" }, c("debugExceptionWidgetBorder", "Exception widget border color.")), bf = M("debugExceptionWidget.background", { dark: "#420b0d", light: "#f1dfde", hcDark: "#420b0d", hcLight: "#f1dfde" }, c("debugExceptionWidgetBackground", "Exception widget background color."));
let Uo = class extends yc {
  constructor(e, t, i, s, n) {
    super(e, { showFrame: !0, showArrow: !0, isAccessible: !0, frameWidth: 1, className: "exception-widget-container" }), this.exceptionInfo = t, this.debugSession = i, this.instantiationService = n, this.applyTheme(s.getColorTheme()), this._disposables.add(s.onDidColorThemeChange(this.applyTheme.bind(this))), this.create();
    const o = new oe(() => this._doLayout(void 0, void 0), 50);
    this._disposables.add(this.editor.onDidLayoutChange(() => o.schedule())), this._disposables.add(o);
  }
  applyTheme(e) {
    this.backgroundColor = e.getColor(bf);
    const t = e.getColor(ff);
    this.style({
      arrowColor: t,
      frameColor: t
    });
  }
  _applyStyles() {
    this.container && (this.container.style.backgroundColor = this.backgroundColor ? this.backgroundColor.toString() : ""), super._applyStyles();
  }
  _fillContainer(e) {
    this.setCssClass("exception-widget");
    const t = this.editor.getOption(49);
    e.style.fontSize = `${t.fontSize}px`, e.style.lineHeight = `${t.lineHeight}px`, e.tabIndex = 0;
    const i = gi(".title"), s = gi(".label");
    E(i, s);
    const n = gi(".actions");
    E(i, n), s.textContent = this.exceptionInfo.id ? c(
      "exceptionThrownWithId",
      "Exception has occurred: {0}",
      this.exceptionInfo.id
    ) : c("exceptionThrown", "Exception has occurred.");
    let o = s.textContent;
    if (new oi(n).push(new Z("editor.closeExceptionWidget", c("close", "Close"), L.asClassName(Qu), !0, async () => {
      const a = this.editor.getContribution(on);
      a == null || a.closeExceptionWidget();
    }), { label: !1, icon: !0 }), E(e, i), this.exceptionInfo.description) {
      const a = gi(".description");
      a.textContent = this.exceptionInfo.description, o += ", " + this.exceptionInfo.description, E(e, a);
    }
    if (this.exceptionInfo.details && this.exceptionInfo.details.stackTrace) {
      const a = gi(".stack-trace"), u = this.instantiationService.createInstance(wt).linkify(this.exceptionInfo.details.stackTrace, !0, this.debugSession ? this.debugSession.root : void 0);
      a.appendChild(u), E(e, a), o += ", " + this.exceptionInfo.details.stackTrace;
    }
    e.setAttribute("aria-label", o);
  }
  _doLayout(e, t) {
    this.container.style.height = "initial";
    const i = this.editor.getOption(65), s = Math.round(i / 3), n = Math.ceil((this.container.offsetHeight + s) / i);
    this._relayout(n);
  }
  focus() {
    var e;
    (e = this.container) == null || e.focus();
  }
  hasFocus() {
    return Gc(document.activeElement, this.container);
  }
};
Uo = I([
  h(3, ce),
  h(4, K)
], Uo);
const mf = 100, Pa = 150, Sf = 500, Fa = 200;
M("editor.inlineValuesForeground", {
  dark: "#ffffff80",
  light: "#00000080",
  hcDark: "#ffffff80",
  hcLight: "#00000080"
}, c("editor.inlineValuesForeground", "Color for the debug inline value text."));
M("editor.inlineValuesBackground", {
  dark: "#ffc80033",
  light: "#ffc80033",
  hcDark: "#ffc80033",
  hcLight: "#ffc80033"
}, c(
  "editor.inlineValuesBackground",
  "Color for the debug inline value background."
));
class wf {
  constructor(e, t) {
    this.column = e, this.text = t;
  }
}
function Ud(l, e, t = 1073741824) {
  return e.length > Pa && (e = e.substring(0, Pa) + "..."), [
    {
      range: {
        startLineNumber: l,
        endLineNumber: l,
        startColumn: t,
        endColumn: t
      },
      options: {
        description: "debug-inline-value-decoration-spacer",
        after: {
          content: en,
          cursorStops: ha.None
        },
        showIfCollapsed: !0
      }
    },
    {
      range: {
        startLineNumber: l,
        endLineNumber: l,
        startColumn: t,
        endColumn: t
      },
      options: {
        description: "debug-inline-value-decoration",
        after: {
          content: vf(e),
          inlineClassName: "debug-inline-value",
          inlineClassNameAffectsLetterSpacing: !0,
          cursorStops: ha.None
        },
        showIfCollapsed: !0
      }
    }
  ];
}
function vf(l) {
  return l.replace(/[ \t]/g, en);
}
function Cf(l, e, t, i) {
  const s = /* @__PURE__ */ new Map();
  for (const r of l)
    if (s.set(r.name, r.value), s.size >= mf)
      break;
  const n = /* @__PURE__ */ new Map();
  s.forEach((r, a) => {
    const d = i.get(a);
    if (d)
      for (const u of d)
        e.containsPosition(new Ci(u, 0)) && (n.has(u) || n.set(u, []), n.get(u).indexOf(a) === -1 && n.get(u).push(a));
  });
  const o = [];
  return n.forEach((r, a) => {
    const d = r.sort((u, g) => {
      const p = t.getLineContent(a);
      return p.indexOf(u) - p.indexOf(g);
    }).map((u) => `${u} = ${s.get(u)}`).join(", ");
    o.push(...Ud(a, d));
  }), o;
}
function kf(l) {
  const e = /* @__PURE__ */ new Map();
  if (!l)
    return e;
  for (let t = 1, i = l.getLineCount(); t <= i; ++t) {
    const s = l.getLineContent(t);
    if (s.length > Sf)
      continue;
    l.tokenization.forceTokenization(t);
    const n = l.tokenization.getLineTokens(t);
    for (let o = 0, r = n.getCount(); o < r; o++)
      if (n.getStandardTokenType(o) === 0) {
        ga.lastIndex = 0;
        const d = n.getStartOffset(o), u = n.getEndOffset(o), g = s.substring(d, u), p = ga.exec(g);
        if (p) {
          const f = p[0];
          e.has(f) || e.set(f, []), e.get(f).push(t);
        }
      }
  }
  return e;
}
let Ee = class {
  constructor(e, t, i, s, n, o, r, a, d, u) {
    this.editor = e, this.debugService = t, this.instantiationService = i, this.commandService = s, this.configurationService = n, this.hostService = o, this.uriIdentityService = r, this.languageFeaturesService = d, this.hoverPosition = null, this.mouseDown = !1, this.gutterIsHovered = !1, this.altPressed = !1, this.oldDecorations = this.editor.createDecorationsCollection(), this._wordToLineNumbersMap = void 0, this.debounceInfo = u.for(d.inlineValuesProvider, "InlineValues", { min: Fa }), this.hoverWidget = this.instantiationService.createInstance(Si, this.editor), this.toDispose = [], this.registerListeners(), this.exceptionWidgetVisible = $c.bindTo(a), this.toggleExceptionWidget();
  }
  registerListeners() {
    this.toDispose.push(this.debugService.getViewModel().onDidFocusStackFrame((e) => this.onFocusStackFrame(e.stackFrame))), this.toDispose.push(this.editor.onMouseDown((e) => this.onEditorMouseDown(e))), this.toDispose.push(this.editor.onMouseUp(() => this.mouseDown = !1)), this.toDispose.push(this.editor.onMouseMove((e) => this.onEditorMouseMove(e))), this.toDispose.push(this.editor.onMouseLeave((e) => {
      const t = this.hoverWidget.getDomNode();
      if (!t)
        return;
      const i = t.getBoundingClientRect();
      (e.event.posx < i.left || e.event.posx > i.right || e.event.posy < i.top || e.event.posy > i.bottom) && this.hideHoverWidget();
    })), this.toDispose.push(this.editor.onKeyDown((e) => this.onKeyDown(e))), this.toDispose.push(this.editor.onDidChangeModelContent(() => {
      this._wordToLineNumbersMap = void 0, this.updateInlineValuesScheduler.schedule();
    })), this.toDispose.push(this.debugService.getViewModel().onWillUpdateViews(() => this.updateInlineValuesScheduler.schedule())), this.toDispose.push(this.debugService.getViewModel().onDidEvaluateLazyExpression(() => this.updateInlineValuesScheduler.schedule())), this.toDispose.push(this.editor.onDidChangeModel(async () => {
      this.updateHoverConfiguration(), this.toggleExceptionWidget(), this.hideHoverWidget(), this._wordToLineNumbersMap = void 0;
      const e = this.debugService.getViewModel().focusedStackFrame;
      await this.updateInlineValueDecorations(e);
    })), this.toDispose.push(this.editor.onDidScrollChange(() => {
      this.hideHoverWidget();
      const e = this.editor.getModel();
      e && this.languageFeaturesService.inlineValuesProvider.has(e) && this.updateInlineValuesScheduler.schedule();
    })), this.toDispose.push(this.debugService.onDidChangeState((e) => {
      e !== 2 && this.toggleExceptionWidget();
    }));
  }
  get wordToLineNumbersMap() {
    return this._wordToLineNumbersMap || (this._wordToLineNumbersMap = kf(this.editor.getModel())), this._wordToLineNumbersMap;
  }
  updateHoverConfiguration() {
    const e = this.debugService.getViewModel().focusedStackFrame, t = this.editor.getModel();
    t && this.applyHoverConfiguration(t, e);
  }
  applyHoverConfiguration(e, t) {
    var i;
    t && this.uriIdentityService.extUri.isEqual(e.uri, t.source.uri) ? (this.altListener && this.altListener.dispose(), this.altListener = le(document, "keydown", (s) => {
      if (new ki(s).keyCode === 6) {
        this.altPressed = !0;
        const o = this.hoverWidget.isVisible();
        this.hoverWidget.hide(), this.enableEditorHover(), o && this.hoverPosition && this.showEditorHover(this.hoverPosition, !1);
        const r = new eh(document, "keyup"), a = Ze.any(this.hostService.onDidChangeFocus, r.event)((d) => {
          let u;
          d instanceof KeyboardEvent && (u = new ki(d)), (!u || u.keyCode === 6) && (this.altPressed = !1, this.editor.updateOptions({ hover: { enabled: !1 } }), a.dispose(), r.dispose());
        });
      }
    }), this.editor.updateOptions({ hover: { enabled: !1 } })) : ((i = this.altListener) == null || i.dispose(), this.enableEditorHover());
  }
  enableEditorHover() {
    if (this.editor.hasModel()) {
      const e = this.editor.getModel(), t = {
        resource: e.uri,
        overrideIdentifier: e.getLanguageId()
      }, i = this.configurationService.getValue("editor.hover", t);
      this.editor.updateOptions({
        hover: {
          enabled: i.enabled,
          delay: i.delay,
          sticky: i.sticky
        }
      });
    }
  }
  async showHover(e, t) {
    const i = this.debugService.getViewModel().focusedStackFrame, s = this.editor.getModel();
    i && s && this.uriIdentityService.extUri.isEqual(i.source.uri, s.uri) ? await this.hoverWidget.showAt(e, t) === 1 && this.showEditorHover(e, t) : this.showEditorHover(e, t);
  }
  showEditorHover(e, t) {
    const i = this.editor.getContribution(th.ID), s = new re(e.lineNumber, e.column, e.lineNumber, e.column);
    i == null || i.showContentHover(s, 1, 0, t);
  }
  async onFocusStackFrame(e) {
    const t = this.editor.getModel();
    t && (this.applyHoverConfiguration(t, e), e && this.uriIdentityService.extUri.isEqual(e.source.uri, t.uri) ? await this.toggleExceptionWidget() : this.hideHoverWidget()), await this.updateInlineValueDecorations(e);
  }
  get showHoverScheduler() {
    const e = this.editor.getOption(59), t = new oe(() => {
      this.hoverPosition && !this.altPressed && this.showHover(this.hoverPosition, !1);
    }, e.delay * 2);
    return this.toDispose.push(t), t;
  }
  get hideHoverScheduler() {
    const e = new oe(() => {
      this.hoverWidget.isHovered() || this.hoverWidget.hide();
    }, 0);
    return this.toDispose.push(e), e;
  }
  hideHoverWidget() {
    !this.hideHoverScheduler.isScheduled() && this.hoverWidget.willBeVisible() && this.hideHoverScheduler.schedule(), this.showHoverScheduler.cancel();
  }
  onEditorMouseDown(e) {
    this.mouseDown = !0, !(e.target.type === 9 && e.target.detail === Si.ID) && this.hideHoverWidget();
  }
  onEditorMouseMove(e) {
    if (this.debugService.state !== 2)
      return;
    const t = e.target, i = Oe ? "metaKey" : "ctrlKey";
    this.altPressed || (t.type === 2 ? (this.editor.updateOptions({ hover: { enabled: !0 } }), this.gutterIsHovered = !0) : this.gutterIsHovered && (this.gutterIsHovered = !1, this.updateHoverConfiguration())), !(t.type === 9 && t.detail === Si.ID && !e.event[i]) && (t.type === 6 ? t.position && !Ci.equals(t.position, this.hoverPosition) && (this.hoverPosition = t.position, this.hideHoverScheduler.cancel(), this.showHoverScheduler.schedule()) : this.mouseDown || this.hideHoverWidget());
  }
  onKeyDown(e) {
    const t = Oe ? 57 : 5;
    e.keyCode !== t && this.hideHoverWidget();
  }
  async toggleExceptionWidget() {
    const e = this.editor.getModel(), t = this.debugService.getViewModel().focusedStackFrame, i = t ? t.thread.getCallStack() : null;
    if (!e || !t || !i || i.length === 0) {
      this.closeExceptionWidget();
      return;
    }
    const s = i.find((o) => !!(o && o.source && o.source.available && o.source.presentationHint !== "deemphasize"));
    if (!s || s !== t) {
      this.closeExceptionWidget();
      return;
    }
    const n = this.uriIdentityService.extUri.isEqual(s.source.uri, e.uri);
    if (this.exceptionWidget && !n)
      this.closeExceptionWidget();
    else if (n) {
      const o = await t.thread.exceptionInfo;
      o && this.showExceptionWidget(o, this.debugService.getViewModel().focusedSession, s.range.startLineNumber, s.range.startColumn);
    }
  }
  showExceptionWidget(e, t, i, s) {
    this.exceptionWidget && this.exceptionWidget.dispose(), this.exceptionWidget = this.instantiationService.createInstance(Uo, this.editor, e, t), this.exceptionWidget.show({ lineNumber: i, column: s }, 0), this.exceptionWidget.focus(), this.editor.revealRangeInCenter({
      startLineNumber: i,
      startColumn: s,
      endLineNumber: i,
      endColumn: s
    }), this.exceptionWidgetVisible.set(!0);
  }
  closeExceptionWidget() {
    if (this.exceptionWidget) {
      const e = this.exceptionWidget.hasFocus();
      this.exceptionWidget.dispose(), this.exceptionWidget = void 0, this.exceptionWidgetVisible.set(!1), e && this.editor.focus();
    }
  }
  async addLaunchConfiguration() {
    const e = this.editor.getModel();
    if (!e)
      return;
    let t, i;
    const s = () => {
      let o = 0;
      sh(e.getValue(), {
        onObjectProperty: (r) => {
          i = r;
        },
        onArrayBegin: (r) => {
          i === "configurations" && o === 0 && (t = e.getPositionAt(r + 1)), o++;
        },
        onArrayEnd: () => {
          o--;
        }
      });
    };
    if (s(), !t) {
      const { tabSize: o, insertSpaces: r } = e.getOptions(), a = e.getEOL(), d = Kc(e.uri.fsPath) === "launch.json" ? la(e.getValue(), ["configurations"], [], { tabSize: o, insertSpaces: r, eol: a })[0] : la(e.getValue(), ["launch"], { configurations: [] }, { tabSize: o, insertSpaces: r, eol: a })[0], u = e.getPositionAt(d.offset), g = u.lineNumber, p = new re(
        g,
        u.column,
        g,
        e.getLineMaxColumn(g)
      );
      e.pushEditOperations(null, [jc.replace(p, d.content)], () => null), s();
    }
    if (!t)
      return;
    this.editor.focus(), await ((o) => (e.getLineLastNonWhitespaceColumn(o.lineNumber) > o.column && (this.editor.setPosition(o), nh.LineBreakInsert.runEditorCommand(null, this.editor, null)), this.editor.setPosition(o), this.commandService.executeCommand("editor.action.insertLineAfter")))(t), await this.commandService.executeCommand("editor.action.triggerSuggest");
  }
  get removeInlineValuesScheduler() {
    return new oe(() => {
      this.oldDecorations.clear();
    }, 100);
  }
  get updateInlineValuesScheduler() {
    const e = this.editor.getModel();
    return new oe(
      async () => await this.updateInlineValueDecorations(this.debugService.getViewModel().focusedStackFrame),
      e ? this.debounceInfo.get(e) : Fa
    );
  }
  async updateInlineValueDecorations(e) {
    const t = "{0} = {1}", i = ", ", s = this.editor.getModel(), n = this.configurationService.getValue("debug").inlineValues;
    if (!(n === !0 || n === "on" || n === "auto" && s && this.languageFeaturesService.inlineValuesProvider.has(s)) || !s || !e || s.uri.toString() !== e.source.uri.toString()) {
      this.removeInlineValuesScheduler.isScheduled() || this.removeInlineValuesScheduler.schedule();
      return;
    }
    this.removeInlineValuesScheduler.cancel();
    let r;
    if (this.languageFeaturesService.inlineValuesProvider.has(s)) {
      const a = async (m, y) => {
        const _ = await e.getMostSpecificScopes(e.range), v = y ? m : m.toLowerCase();
        for (const C of _) {
          const D = (await C.getChildren()).find((P) => y ? P.name === v : P.name.toLowerCase() === v);
          if (D)
            return D.value;
        }
      }, d = {
        frameId: e.frameId,
        stoppedLocation: new re(
          e.range.startLineNumber,
          e.range.startColumn + 1,
          e.range.endLineNumber,
          e.range.endColumn + 1
        )
      }, u = new Qe().token, g = this.editor.getVisibleRangesPlusViewportAboveBelow(), p = this.languageFeaturesService.inlineValuesProvider.ordered(s).reverse();
      r = [];
      const f = /* @__PURE__ */ new Map(), S = Za(p.map((m) => g.map(
        (y) => Promise.resolve(m.provideInlineValues(s, y, d, u)).then(async (_) => {
          if (_)
            for (const v of _) {
              let C;
              switch (v.type) {
                case "text":
                  C = v.text;
                  break;
                case "variable": {
                  let b = v.variableName;
                  b || (b = s.getLineContent(v.range.startLineNumber).substring(v.range.startColumn - 1, v.range.endColumn - 1));
                  const D = await a(b, v.caseSensitiveLookup);
                  D && (C = ua(t, b, D));
                  break;
                }
                case "expression": {
                  let b = v.expression;
                  if (b || (b = s.getLineContent(v.range.startLineNumber).substring(v.range.startColumn - 1, v.range.endColumn - 1)), b) {
                    const D = new Y(b);
                    await D.evaluate(e.thread.session, e, "watch", !0), D.available && (C = ua(t, b, D.value));
                  }
                  break;
                }
              }
              if (C) {
                const b = v.range.startLineNumber;
                let D = f.get(b);
                D || (D = [], f.set(b, D)), D.some((P) => P.text === C) || D.push(new wf(v.range.startColumn, C));
              }
            }
        }, (_) => {
          ih(_);
        })
      ))), w = Date.now();
      await Promise.all(S), this.updateInlineValuesScheduler.delay = this.debounceInfo.update(s, Date.now() - w), f.forEach((m, y) => {
        if (m.length > 0) {
          m = m.sort((v, C) => v.column - C.column);
          const _ = m.map((v) => v.text).join(i);
          r.push(...Ud(y, _));
        }
      });
    } else {
      const a = await e.getMostSpecificScopes(e.range), d = await Promise.all(a.map(async (u) => {
        const g = await u.getChildren();
        let p = new re(0, 0, e.range.startLineNumber, e.range.startColumn);
        return u.range && (p = p.setStartPosition(u.range.startLineNumber, u.range.startColumn)), Cf(g, p, s, this.wordToLineNumbersMap);
      }));
      r = St(
        d.reduce((u, g) => u.concat(g), []),
        (u) => {
          var g;
          return `${u.range.startLineNumber}:${(g = u == null ? void 0 : u.options.after) == null ? void 0 : g.content}`;
        }
      );
    }
    this.oldDecorations.set(r);
  }
  dispose() {
    this.hoverWidget && this.hoverWidget.dispose(), this.configurationWidget && this.configurationWidget.dispose(), this.toDispose = U(this.toDispose), this.oldDecorations.clear();
  }
};
Ee.__decorator = I([
  ni
], Ee.prototype, "showHoverScheduler", null);
Ee.__decorator = I([
  ni
], Ee.prototype, "hideHoverScheduler", null);
Ee.__decorator = I([
  ni
], Ee.prototype, "removeInlineValuesScheduler", null);
Ee.__decorator = I([
  ni
], Ee.prototype, "updateInlineValuesScheduler", null);
Ee = I([
  h(1, T),
  h(2, K),
  h(3, We),
  h(4, O),
  h(5, cc),
  h(6, Le),
  h(7, H),
  h(8, ii),
  h(9, Zu)
], Ee);
let Ho = class {
  constructor(e, t, i) {
    this.toDispose = [];
    let s;
    const n = (o) => {
      s && (s.dispose(), s = void 0), o && (s = o.onDidProgressStart(async (r) => {
        const a = new Promise((u) => {
          const g = Ze.any(Ze.filter(o.onDidProgressEnd, (p) => p.body.progressId === r.body.progressId), o.onDidEndAdapter)(() => {
            g.dispose(), u();
          });
        });
        i.isViewContainerVisible(De) && t.withProgress({ location: De }, () => a);
        const d = e.getAdapterManager().getDebuggerLabel(o.configuration.type);
        t.withProgress({
          location: 15,
          title: r.body.title,
          cancellable: r.body.cancellable,
          priority: oh.SILENT,
          source: d,
          delay: 500
        }, (u) => {
          let g = 0;
          const p = (S) => {
            let w;
            typeof S.percentage == "number" && (w = S.percentage - g, g += w), u.report({
              message: S.message,
              increment: w,
              total: typeof w == "number" ? 100 : void 0
            });
          };
          r.body.message && p(r.body);
          const f = o.onDidProgressUpdate((S) => {
            S.body.progressId === r.body.progressId && p(S.body);
          });
          return a.then(() => f.dispose());
        }, () => o.cancel(r.body.progressId));
      }));
    };
    this.toDispose.push(e.getViewModel().onDidFocusSession(n)), n(e.getViewModel().focusedSession), this.toDispose.push(e.onWillNewSession((o) => {
      s || n(o);
    }));
  }
  dispose() {
    U(this.toDispose);
  }
};
Ho = I([
  h(0, T),
  h(1, kr),
  h(2, Ae)
], Ho);
let $o = class extends Fc {
  constructor(e, t, i, s) {
    super(bd, {
      noResultsPick: {
        label: c("noDebugResults", "No matching launch configurations")
      }
    }), this.debugService = e, this.contextService = t, this.commandService = i, this.notificationService = s;
  }
  async _getPicks(e) {
    var r, a;
    const t = [];
    if (!this.debugService.getAdapterManager().hasEnabledDebuggers())
      return [];
    t.push({ type: "separator", label: "launch.json" });
    const i = this.debugService.getConfigurationManager();
    let s;
    for (const d of i.getAllConfigurations()) {
      const u = fi(e, d.name, !0);
      u && (s !== ((r = d.presentation) == null ? void 0 : r.group) && (t.push({ type: "separator" }), s = (a = d.presentation) == null ? void 0 : a.group), t.push({
        label: d.name,
        description: this.contextService.getWorkbenchState() === 3 ? d.launch.name : "",
        highlights: { label: u },
        buttons: [{
          iconClass: L.asClassName(nd),
          tooltip: c("customizeLaunchConfig", "Configure Launch Configuration")
        }],
        trigger: () => (d.launch.openConfigFile({ preserveFocus: !1 }), pa.CLOSE_PICKER),
        accept: async () => {
          await i.selectConfiguration(d.launch, d.name);
          try {
            await this.debugService.startDebugging(d.launch, void 0, { startedByUser: !0 });
          } catch (g) {
            this.notificationService.error(g);
          }
        }
      }));
    }
    const n = await i.getDynamicProviders();
    n.length > 0 && t.push({
      type: "separator",
      label: c({
        key: "contributed",
        comment: ["contributed is lower case because it looks better like that in UI. Nothing preceeds it. It is a name of the grouping of debug configurations."]
      }, "contributed")
    }), i.getRecentDynamicConfigurations().forEach(({ name: d, type: u }) => {
      const g = fi(e, d, !0);
      g && t.push({
        label: d,
        highlights: { label: g },
        buttons: [{
          iconClass: L.asClassName(ig),
          tooltip: c("removeLaunchConfig", "Remove Launch Configuration")
        }],
        trigger: () => (i.removeRecentDynamicConfigurations(d, u), pa.CLOSE_PICKER),
        accept: async () => {
          await i.selectConfiguration(void 0, d, void 0, { type: u });
          try {
            const { launch: p, getConfig: f } = i.selectedConfiguration, S = await f();
            await this.debugService.startDebugging(p, S, { startedByUser: !0 });
          } catch (p) {
            this.notificationService.error(p);
          }
        }
      });
    }), n.forEach((d) => {
      t.push({
        label: `$(folder) ${d.label}...`,
        ariaLabel: c(
          { key: "providerAriaLabel", comment: ['Placeholder stands for the provider label. For example "NodeJS".'] },
          "{0} contributed configurations",
          d.label
        ),
        accept: async () => {
          const u = await d.pick();
          u && (await i.selectConfiguration(u.launch, u.config.name, u.config, { type: d.type }), this.debugService.startDebugging(u.launch, u.config, { startedByUser: !0 }));
        }
      });
    });
    const o = i.getLaunches().filter((d) => !d.hidden);
    o.length > 0 && t.push({ type: "separator", label: c("configure", "configure") });
    for (const d of o) {
      const u = this.contextService.getWorkbenchState() === 3 ? c("addConfigTo", "Add Config ({0})...", d.name) : c("addConfiguration", "Add Configuration...");
      t.push({
        label: u,
        description: this.contextService.getWorkbenchState() === 3 ? d.name : "",
        highlights: { label: Nc(fi(e, u, !0)) },
        accept: () => this.commandService.executeCommand(ud, d.uri.toString())
      });
    }
    return t;
  }
};
$o = I([
  h(0, T),
  h(1, _e),
  h(2, We),
  h(3, Ct)
], $o);
var yf = '.debug-pane,.debug-view-content{height:100%}.monaco-workbench .debug-action.notification:after{background-color:#c63;border:1px solid #fff;border-radius:10px;content:"";height:6px;position:absolute;right:6px;top:10px;width:6px}.monaco-workbench .part>.title>.title-actions .start-debug-action-item{align-items:center;display:flex;flex-shrink:1;line-height:20px}.monaco-workbench.mac .part>.title>.title-actions .start-debug-action-item{border-radius:4px}.monaco-workbench .part>.title>.title-actions .start-debug-action-item .codicon{flex-shrink:0;line-height:inherit}.monaco-workbench .part>.title>.title-actions .start-debug-action-item .codicon-debug-start{height:21px;padding-left:2px;width:18px}.monaco-workbench .monaco-action-bar .start-debug-action-item .configuration .monaco-select-box{border:none;cursor:pointer;line-height:inherit;margin-top:0;min-width:90px;padding-bottom:0;padding-top:0}.monaco-workbench.safari .monaco-action-bar .start-debug-action-item .configuration .monaco-select-box{margin-bottom:0}.monaco-workbench .monaco-action-bar .start-debug-action-item .configuration.disabled .monaco-select-box{cursor:auto;font-style:italic;opacity:.7}.debug-pane .line-number{padding-left:4px;padding-right:4px}.debug-pane .disabled{cursor:auto;opacity:.65}.debug-pane .monaco-list:focus .monaco-list-row.selected .load-all,.debug-pane .monaco-list:focus .monaco-list-row.selected .state.label,.debug-pane .monaco-list:focus .monaco-list-row.selected.focused .state.label{color:inherit}.debug-pane .call-stack-state-message{flex:1;margin:0 10px;overflow:hidden;text-align:right;text-overflow:ellipsis;white-space:nowrap}.debug-pane .call-stack-state-message>.label{border-radius:3px;font-size:9px;padding:1px 2px}.debug-pane .debug-call-stack .session,.debug-pane .debug-call-stack .thread{align-items:center;display:flex}.debug-pane .debug-call-stack .session>.name,.debug-pane .debug-call-stack .thread>.name{flex:1;overflow:hidden;text-overflow:ellipsis}.debug-pane .debug-call-stack .session>.state.label,.debug-pane .debug-call-stack .thread>.state.label{align-self:center;font-size:.8em;margin:0 10px;overflow:hidden;text-overflow:ellipsis;text-transform:uppercase}.debug-pane .debug-call-stack .monaco-list-row:hover .stack-frame.has-actions .file .line-number,.debug-pane .debug-call-stack .monaco-list-row:hover .state.label{display:none}.debug-pane .monaco-list-row .monaco-action-bar{display:none;flex-shrink:0;margin-right:6px}.debug-pane .monaco-list-row.focused .monaco-action-bar,.debug-pane .monaco-list-row:hover .monaco-action-bar{display:initial}.debug-pane .monaco-list-row .monaco-action-bar .action-label{padding:2px}.debug-pane .session .codicon{line-height:22px;margin-right:2px}.debug-pane .debug-call-stack .stack-frame{display:flex;overflow:hidden;padding-right:.8em;text-overflow:ellipsis}.debug-pane .debug-call-stack .stack-frame.label{font-style:italic;text-align:center}.debug-pane .debug-call-stack .stack-frame .label{flex:1;flex-shrink:0;min-width:fit-content}.debug-pane .debug-call-stack .stack-frame.subtle{font-style:italic}.debug-pane .debug-call-stack .stack-frame.label>.file{display:none}.debug-pane .debug-call-stack .stack-frame>.file{display:flex;flex-wrap:wrap;justify-content:flex-end;overflow:hidden}.debug-pane .debug-call-stack .stack-frame>.file>.line-number.unavailable{display:none}.debug-pane .debug-call-stack .stack-frame>.file>.file-name{margin-right:.8em;overflow:hidden;text-overflow:ellipsis}.debug-pane .debug-call-stack .stack-frame>.file:not(:first-child){margin-left:.8em}.debug-pane .debug-call-stack .load-all{text-align:center}.debug-pane .debug-call-stack .show-more{opacity:.5;text-align:center}.debug-pane .debug-call-stack .error{font-style:italic;overflow:hidden;text-overflow:ellipsis}.debug-pane .scope{font-size:11px;font-weight:700}.debug-pane .monaco-list-row .expression .actionbar-spacer{flex-grow:1}.debug-pane .monaco-list-row .expression .value{overflow:hidden;text-overflow:ellipsis;white-space:pre}.debug-pane .monaco-list-row .expression .value.changed{border-radius:4px}.debug-pane .monaco-inputbox{line-height:normal;width:100%}.debug-pane .inputBoxContainer{box-sizing:border-box;flex-grow:1}.debug-pane .debug-watch .monaco-inputbox{font-family:var(--monaco-monospace-font)}.debug-pane .monaco-inputbox>.ibwrapper{height:19px}.debug-pane .monaco-inputbox>.ibwrapper>.input{color:initial;padding:0}.debug-pane .watch-expression{display:flex}.debug-pane .watch-expression .expression{flex:1}.debug-pane .debug-variables .scope .error{font-family:var(--monaco-monospace-font);font-style:italic;font-weight:400;overflow:hidden;text-overflow:ellipsis}.debug-pane .monaco-list-row{line-height:22px}.debug-pane .debug-breakpoints .monaco-list-row .breakpoint{padding-left:2px}.debug-pane .debug-breakpoints .breakpoint.exception{padding-left:21px}.debug-pane .debug-breakpoints .breakpoint{align-items:center;display:flex;flex:1;padding-right:.8em}.debug-pane .debug-breakpoints .breakpoint input{flex-shrink:0}.debug-pane .debug-breakpoints .breakpoint>.codicon{align-items:center;display:flex;height:19px;justify-content:center;min-width:19px;width:19px}.debug-pane .debug-breakpoints .breakpoint>.access-type,.debug-pane .debug-breakpoints .breakpoint>.condition,.debug-pane .debug-breakpoints .breakpoint>.file-path{flex:1;margin-left:.9em;opacity:.7;overflow:hidden;text-overflow:ellipsis}.debug-pane .debug-breakpoints .breakpoint .name{overflow:hidden;text-overflow:ellipsis}.debug-pane .pane-header .breakpoint-warning{margin-left:3px}.debug-pane .pane-header .breakpoint-warning .monaco-icon-label .codicon{align-items:center;display:flex}';
ot(yf, {});
const zo = "debugStartLanguage", Df = new Xc(zo, void 0), Ef = new Xc("debuggerInterestedInActiveEditor", !1);
var zt;
let Bi = (zt = class extends Pi {
  constructor(e, t, i, s, n, o, r, a, d, u, g, p, f) {
    super(e, i, s, n, o, u, d, g, t, f), this.debugService = r, this.editorService = a, this.debugStartLanguageContext = Df.bindTo(o), this.debuggerInterestedContext = Ef.bindTo(o);
    const S = p.get(zo, 1);
    this.debugStartLanguageContext.set(S);
    const w = () => {
      const _ = this.editorService.activeTextEditorControl;
      if (Je(_)) {
        const v = _.getModel(), C = v ? v.getLanguageId() : void 0;
        if (C && this.debugService.getAdapterManager().someDebuggerInterestedInLanguage(C)) {
          this.debugStartLanguageContext.set(C), this.debuggerInterestedContext.set(!0), p.store(zo, C, 1, 1);
          return;
        }
      }
      this.debuggerInterestedContext.set(!1);
    }, m = new te();
    this._register(m), this._register(a.onDidActiveEditorChange(() => {
      m.clear();
      const _ = this.editorService.activeTextEditorControl;
      Je(_) && m.add(_.onDidChangeModelLanguage(w)), w();
    })), this._register(this.debugService.getAdapterManager().onDidRegisterDebugger(w)), this._register(this.onDidChangeBodyVisibility((_) => {
      _ && w();
    })), w();
    const y = this.keybindingService.lookupKeybinding(_r);
    $d = y ? ` (${y.getLabel()})` : "";
  }
  shouldShowWelcome() {
    return !0;
  }
}, zt.ID = "workbench.debug.welcome", zt.LABEL = c("run", "Run"), zt);
Bi = I([
  h(1, ce),
  h(2, at),
  h(3, Me),
  h(4, O),
  h(5, H),
  h(6, T),
  h(7, ae),
  h(8, K),
  h(9, Ue),
  h(10, st),
  h(11, it),
  h(12, we)
], Bi);
const Hd = ee.as(Wi.ViewsRegistry);
let $d = "";
Hd.registerViewWelcomeContent(Bi.ID, {
  content: `[${c("runAndDebugAction", "Run and Debug")}${$d}](command:${_r})`,
  when: J,
  group: Yc.Debug,
  order: 1
});
Hd.registerViewWelcomeContent(Bi.ID, {
  content: `[${c("detectThenRunAndDebug", "Show all automatic debug configurations")}](command:${Cn}).`,
  when: J,
  group: Yc.Debug,
  order: 10
});
let qo = class extends Jc {
  constructor(e, t, i, s, n, o, r, a, d, u, g, p, f, S) {
    super(De, { mergeViewWithContainerWhenSingleView: !0 }, n, g, e, d, t, u, a, r, o, S), this.progressService = i, this.debugService = s, this.contextViewService = p, this.contextKeyService = f, this.paneListeners = /* @__PURE__ */ new Map(), this.stopActionViewItemDisposables = this._register(new te()), this._register(this.debugService.onDidChangeState((w) => this.onDebugServiceStateChange(w))), this._register(this.contextKeyService.onDidChangeContext((w) => {
      w.affectsSome(/* @__PURE__ */ new Set([ah])) && this.updateTitleArea();
    })), this._register(this.contextService.onDidChangeWorkbenchState(() => this.updateTitleArea())), this._register(this.configurationService.onDidChangeConfiguration((w) => {
      w.affectsConfiguration("debug.toolBarLocation") && this.updateTitleArea();
    }));
  }
  create(e) {
    super.create(e), e.classList.add("debug-viewlet");
  }
  focus() {
    super.focus(), this.startDebugActionViewItem ? this.startDebugActionViewItem.focus() : this.focusView(Bi.ID);
  }
  getActionViewItem(e) {
    if (e.id === _r)
      return this.startDebugActionViewItem = this.instantiationService.createInstance(Do, null, e), this.startDebugActionViewItem;
    if (e.id === Ir)
      return new Ti(
        e,
        void 0,
        this.debugService,
        this.contextViewService,
        this.configurationService
      );
    if (e.id === He || e.id === lt) {
      this.stopActionViewItemDisposables.clear();
      const t = this.instantiationService.invokeFunction((i) => Mr(e, this.stopActionViewItemDisposables, i));
      if (t)
        return t;
    }
    return Rc(this.instantiationService, e);
  }
  focusView(e) {
    const t = this.getView(e);
    t && t.focus();
  }
  onDebugServiceStateChange(e) {
    this.progressResolve && (this.progressResolve(), this.progressResolve = void 0), e === 1 && this.progressService.withProgress({ location: De }, (t) => new Promise((i) => this.progressResolve = i));
  }
  addPanes(e) {
    super.addPanes(e);
    for (const { pane: t } of e)
      t.id === Qc ? (this.breakpointView = t, this.updateBreakpointsMaxSize()) : this.paneListeners.set(t.id, t.onDidChange(() => this.updateBreakpointsMaxSize()));
  }
  removePanes(e) {
    super.removePanes(e);
    for (const t of e)
      U(this.paneListeners.get(t.id)), this.paneListeners.delete(t.id);
  }
  updateBreakpointsMaxSize() {
    if (this.breakpointView) {
      const e = this.panes.every((t) => !t.isExpanded() || t === this.breakpointView);
      this.breakpointView.maximumBodySize = e ? Number.POSITIVE_INFINITY : this.breakpointView.minimumBodySize;
    }
  }
};
qo = I([
  h(0, hr),
  h(1, we),
  h(2, kr),
  h(3, T),
  h(4, K),
  h(5, _e),
  h(6, it),
  h(7, ce),
  h(8, Me),
  h(9, Yt),
  h(10, O),
  h(11, rt),
  h(12, H),
  h(13, Ue)
], qo);
ge(class extends Fi {
  constructor() {
    super({
      id: "debug.toggleReplIgnoreFocus",
      title: c("debugPanel", "Debug Console"),
      toggled: x.has(`view.${X}.visible`),
      menu: [{
        id: rh,
        group: "3_toggleRepl",
        order: 30,
        when: x.and(x.equals("viewContainer", De))
      }]
    });
  }
  async run(l) {
    const e = l.get(Ae);
    e.isViewVisible(X) ? e.closeView(X) : await e.openView(X);
  }
});
const Wa = {
  allowBreakpoint: !1,
  isBreakpointSet: !1,
  isBreakpointEnabled: !1,
  instruction: {
    address: "-1",
    instruction: c("instructionNotAvailable", "Disassembly not available.")
  },
  instructionAddress: BigInt(-1)
};
var xe;
let Go = (xe = class extends ch {
  constructor(e, t, i, s, n, o) {
    super(Zc, e, t, i), this._configurationService = s, this._instantiationService = n, this._debugService = o, this._instructionBpList = [], this._enableSourceCodeRender = !0, this._loadingLock = !1, this._disassembledInstructions = void 0, this._onDidChangeStackFrame = new B(), this._previousDebuggingState = o.state, this._fontInfo = fa.createFromRawSettings(s.getValue("editor"), Qn.value), this._register(s.onDidChangeConfiguration((r) => {
      var a;
      if (r.affectsConfiguration("editor") && (this._fontInfo = fa.createFromRawSettings(s.getValue("editor"), Qn.value)), r.affectsConfiguration("debug")) {
        const d = this._configurationService.getValue("debug").disassemblyView.showSourceCode;
        this._enableSourceCodeRender !== d ? (this._enableSourceCodeRender = d, this.reloadDisassembly(void 0)) : (a = this._disassembledInstructions) == null || a.rerender();
      }
    }));
  }
  get fontInfo() {
    return this._fontInfo;
  }
  get currentInstructionAddresses() {
    return this._debugService.getModel().getSessions(!1).map((e) => e.getAllThreads()).reduce((e, t) => e.concat(t), []).map((e) => e.getTopStackFrame()).map((e) => e == null ? void 0 : e.instructionPointerReference);
  }
  get focusedCurrentInstructionAddress() {
    var e, t;
    return (t = (e = this._debugService.getViewModel().focusedStackFrame) == null ? void 0 : e.thread.getTopStackFrame()) == null ? void 0 : t.instructionPointerReference;
  }
  get focusedInstructionAddress() {
    var e;
    return (e = this._debugService.getViewModel().focusedStackFrame) == null ? void 0 : e.instructionPointerReference;
  }
  get isSourceCodeRender() {
    return this._enableSourceCodeRender;
  }
  get debugSession() {
    return this._debugService.getViewModel().focusedSession;
  }
  get onDidChangeStackFrame() {
    return this._onDidChangeStackFrame.event;
  }
  createEditor(e) {
    this._enableSourceCodeRender = this._configurationService.getValue("debug").disassemblyView.showSourceCode;
    const t = this.fontInfo.lineHeight, i = this, s = new class {
      constructor() {
        this.headerRowHeight = 0;
      }
      getHeight(o) {
        var r;
        return i.isSourceCodeRender && ((r = o.instruction.location) != null && r.path) && o.instruction.line ? o.instruction.endLine ? t * (o.instruction.endLine - o.instruction.line + 2) : t * 2 : t;
      }
    }(), n = this._register(this._instantiationService.createInstance(xs, this));
    this._disassembledInstructions = this._register(this._instantiationService.createInstance(dh, "DisassemblyView", e, s, [
      {
        label: "",
        tooltip: "",
        weight: 0,
        minimumWidth: this.fontInfo.lineHeight,
        maximumWidth: this.fontInfo.lineHeight,
        templateId: Is.TEMPLATE_ID,
        project(o) {
          return o;
        }
      },
      {
        label: c("disassemblyTableColumnLabel", "instructions"),
        tooltip: "",
        weight: 0.3,
        templateId: xs.TEMPLATE_ID,
        project(o) {
          return o;
        }
      }
    ], [
      this._instantiationService.createInstance(Is, this),
      n
    ], {
      identityProvider: { getId: (o) => o.instruction.address },
      horizontalScrolling: !1,
      overrideStyles: {
        listBackground: lh
      },
      multipleSelectionSupport: !1,
      setRowLineHeight: !1,
      openOnSingleClick: !1,
      accessibilityProvider: new If(),
      mouseSupport: !1
    })), this.reloadDisassembly(), this._register(this._disassembledInstructions.onDidScroll((o) => {
      if (!this._loadingLock)
        if (o.oldScrollTop > o.scrollTop && o.scrollTop < o.height) {
          this._loadingLock = !0;
          const r = Math.floor(o.scrollTop / this.fontInfo.lineHeight) + xe.NUM_INSTRUCTIONS_TO_LOAD;
          this.scrollUp_LoadDisassembledInstructions(xe.NUM_INSTRUCTIONS_TO_LOAD).then((a) => {
            a && this._disassembledInstructions.reveal(r, 0), this._loadingLock = !1;
          });
        } else
          o.oldScrollTop < o.scrollTop && o.scrollTop + o.height > o.scrollHeight - o.height && (this._loadingLock = !0, this.scrollDown_LoadDisassembledInstructions(xe.NUM_INSTRUCTIONS_TO_LOAD).then(() => {
            this._loadingLock = !1;
          }));
    })), this._register(this._debugService.getViewModel().onDidFocusStackFrame((o) => {
      this._disassembledInstructions && (this.goToAddress(), this._onDidChangeStackFrame.fire());
    })), this._register(this._debugService.getModel().onDidChangeBreakpoints((o) => {
      var r, a, d;
      if (o && this._disassembledInstructions) {
        let u = !1;
        (r = o.added) == null || r.forEach((g) => {
          if (g instanceof Qi) {
            const p = this.getIndexFromAddress(g.instructionReference);
            p >= 0 && (this._disassembledInstructions.row(p).isBreakpointSet = !0, this._disassembledInstructions.row(p).isBreakpointEnabled = g.enabled, u = !0);
          }
        }), (a = o.removed) == null || a.forEach((g) => {
          if (g instanceof Qi) {
            const p = this.getIndexFromAddress(g.instructionReference);
            p >= 0 && (this._disassembledInstructions.row(p).isBreakpointSet = !1, u = !0);
          }
        }), (d = o.changed) == null || d.forEach((g) => {
          if (g instanceof Qi) {
            const p = this.getIndexFromAddress(g.instructionReference);
            p >= 0 && this._disassembledInstructions.row(p).isBreakpointEnabled !== g.enabled && (this._disassembledInstructions.row(p).isBreakpointEnabled = g.enabled, u = !0);
          }
        }), this._instructionBpList = this._debugService.getModel().getInstructionBreakpoints(), u && this._onDidChangeStackFrame.fire();
      }
    })), this._register(this._debugService.onDidChangeState((o) => {
      var r;
      (o === 3 || o === 2) && this._previousDebuggingState !== 3 && this._previousDebuggingState !== 2 && ((r = this._disassembledInstructions) == null || r.splice(0, this._disassembledInstructions.length, [Wa]), this._enableSourceCodeRender = this._configurationService.getValue("debug").disassemblyView.showSourceCode), this._previousDebuggingState = o;
    }));
  }
  layout(e) {
    var t;
    (t = this._disassembledInstructions) == null || t.layout(e.height);
  }
  goToAddress(e, t) {
    if (!this._disassembledInstructions || (e || (e = this.focusedInstructionAddress), !e))
      return;
    const i = this.getIndexFromAddress(e);
    i >= 0 ? (this._disassembledInstructions.reveal(i), t && (this._disassembledInstructions.domFocus(), this._disassembledInstructions.setFocus([i]))) : this._debugService.state === 2 && this.reloadDisassembly(e);
  }
  async scrollUp_LoadDisassembledInstructions(e) {
    var t;
    if (this._disassembledInstructions && this._disassembledInstructions.length > 0) {
      const i = (t = this._disassembledInstructions) == null ? void 0 : t.row(0).instruction.address;
      return this.loadDisassembledInstructions(i, -e, e);
    }
    return !1;
  }
  async scrollDown_LoadDisassembledInstructions(e) {
    var t, i;
    if (this._disassembledInstructions && this._disassembledInstructions.length > 0) {
      const s = (i = this._disassembledInstructions) == null ? void 0 : i.row(((t = this._disassembledInstructions) == null ? void 0 : t.length) - 1).instruction.address;
      return this.loadDisassembledInstructions(s, 1, e);
    }
    return !1;
  }
  async loadDisassembledInstructions(e, t, i) {
    if ((!e || e === "-1") && (e = this.focusedInstructionAddress), !e)
      return !1;
    const s = this.debugSession, n = await (s == null ? void 0 : s.disassemble(e, 0, t, i));
    if (s && n && this._disassembledInstructions) {
      const o = [];
      let r, a;
      for (let u = 0; u < n.length; u++) {
        const g = this._instructionBpList.find((f) => f.instructionReference === n[u].address), p = n[u];
        if (p.location && (r = p.location, a = void 0), p.line) {
          const f = {
            startLineNumber: p.line,
            startColumn: p.column ?? 0,
            endLineNumber: p.endLine ?? p.line,
            endColumn: p.endColumn ?? 0
          };
          re.equalsRange(f, a ?? null) || (a = f, p.location = r);
        }
        o.push({ allowBreakpoint: !0, isBreakpointSet: g !== void 0, isBreakpointEnabled: !!(g != null && g.enabled), instruction: p });
      }
      const d = this._disassembledInstructions.length === 1 ? 1 : 0;
      return t >= 0 ? this._disassembledInstructions.splice(this._disassembledInstructions.length, d, o) : this._disassembledInstructions.splice(0, d, o), !0;
    }
    return !1;
  }
  getIndexFromAddress(e) {
    const t = this._disassembledInstructions;
    if (t && t.length > 0) {
      const i = BigInt(e);
      if (i)
        return uh(t.length, (s) => {
          const n = t.row(s);
          return this.ensureAddressParsed(n), n.instructionAddress > i ? 1 : n.instructionAddress < i ? -1 : 0;
        });
    }
    return -1;
  }
  ensureAddressParsed(e) {
    e.instructionAddress === void 0 && (e.instructionAddress = BigInt(e.instruction.address));
  }
  reloadDisassembly(e) {
    this._disassembledInstructions && (this._loadingLock = !0, this._disassembledInstructions.splice(0, this._disassembledInstructions.length, [Wa]), this._instructionBpList = this._debugService.getModel().getInstructionBreakpoints(), this.loadDisassembledInstructions(e, -xe.NUM_INSTRUCTIONS_TO_LOAD * 4, xe.NUM_INSTRUCTIONS_TO_LOAD * 8).then(() => {
      if (this._disassembledInstructions.length > 0) {
        const t = Math.floor(this._disassembledInstructions.length / 2);
        this._disassembledInstructions.reveal(t, 0.5), this._disassembledInstructions.domFocus(), this._disassembledInstructions.setFocus([t]);
      }
      this._loadingLock = !1;
    }));
  }
}, xe.NUM_INSTRUCTIONS_TO_LOAD = 50, xe);
Go = I([
  h(0, we),
  h(1, ce),
  h(2, it),
  h(3, O),
  h(4, K),
  h(5, T)
], Go);
var qt;
let Is = (qt = class {
  constructor(e, t) {
    this._disassemblyView = e, this._debugService = t, this.templateId = qt.TEMPLATE_ID, this._breakpointIcon = "codicon-" + Di.regular.id, this._breakpointDisabledIcon = "codicon-" + Di.disabled.id, this._breakpointHintIcon = "codicon-" + Er.id, this._debugStackframe = "codicon-" + rs.id, this._debugStackframeFocused = "codicon-" + os.id;
  }
  renderTemplate(e) {
    e.style.alignSelf = "flex-end";
    const t = E(e, ie(".disassembly-view"));
    t.classList.add("codicon"), t.style.display = "flex", t.style.alignItems = "center", t.style.justifyContent = "center", t.style.height = this._disassemblyView.fontInfo.lineHeight + "px";
    const i = { element: void 0 }, s = [
      this._disassemblyView.onDidChangeStackFrame(() => this.rerenderDebugStackframe(t, i.element)),
      Ke(e, "mouseover", () => {
        var n;
        (n = i.element) != null && n.allowBreakpoint && t.classList.add(this._breakpointHintIcon);
      }),
      Ke(e, "mouseout", () => {
        var n;
        (n = i.element) != null && n.allowBreakpoint && t.classList.remove(this._breakpointHintIcon);
      }),
      Ke(e, "click", () => {
        var n;
        (n = i.element) != null && n.allowBreakpoint && (t.classList.add(this._breakpointHintIcon), i.element.isBreakpointSet ? this._debugService.removeInstructionBreakpoints(i.element.instruction.address) : i.element.allowBreakpoint && !i.element.isBreakpointSet && this._debugService.addInstructionBreakpoint(i.element.instruction.address, 0));
      })
    ];
    return { currentElement: i, icon: t, disposables: s };
  }
  renderElement(e, t, i, s) {
    i.currentElement.element = e, this.rerenderDebugStackframe(i.icon, e);
  }
  disposeTemplate(e) {
    U(e.disposables), e.disposables = [];
  }
  rerenderDebugStackframe(e, t) {
    (t == null ? void 0 : t.instruction.address) === this._disassemblyView.focusedCurrentInstructionAddress ? e.classList.add(this._debugStackframe) : (t == null ? void 0 : t.instruction.address) === this._disassemblyView.focusedInstructionAddress ? e.classList.add(this._debugStackframeFocused) : (e.classList.remove(this._debugStackframe), e.classList.remove(this._debugStackframeFocused)), e.classList.remove(this._breakpointHintIcon), t != null && t.isBreakpointSet ? t.isBreakpointEnabled ? (e.classList.add(this._breakpointIcon), e.classList.remove(this._breakpointDisabledIcon)) : (e.classList.remove(this._breakpointIcon), e.classList.add(this._breakpointDisabledIcon)) : (e.classList.remove(this._breakpointIcon), e.classList.remove(this._breakpointDisabledIcon));
  }
}, qt.TEMPLATE_ID = "breakpoint", qt);
Is = I([
  h(1, T)
], Is);
var be;
let xs = (be = class extends Qt {
  constructor(e, t, i, s, n, o) {
    super(), this._disassemblyView = e, this.editorService = i, this.textModelService = s, this.uriService = n, this.logService = o, this.templateId = be.TEMPLATE_ID, this._topStackFrameColor = t.getColorTheme().getColor(Co), this._focusedStackFrameColor = t.getColorTheme().getColor(ko), this._register(t.onDidColorThemeChange((r) => {
      this._topStackFrameColor = r.getColor(Co), this._focusedStackFrameColor = r.getColor(ko);
    }));
  }
  renderTemplate(e) {
    const t = E(e, ie(".sourcecode")), i = E(e, ie(".instruction"));
    this.applyFontInfo(t), this.applyFontInfo(i);
    const s = { element: void 0 }, n = [], o = [
      this._disassemblyView.onDidChangeStackFrame(() => this.rerenderBackground(i, t, s.element)),
      Ke(t, "dblclick", () => {
        var r;
        return this.openSourceCode((r = s.element) == null ? void 0 : r.instruction);
      })
    ];
    return { currentElement: s, instruction: i, sourcecode: t, cellDisposable: n, disposables: o };
  }
  renderElement(e, t, i, s) {
    this.renderElementInner(e, t, i, s);
  }
  async renderElementInner(e, t, i, s) {
    var a;
    i.currentElement.element = e;
    const n = e.instruction;
    i.sourcecode.innerText = "";
    const o = new ba(1e3);
    if (this._disassemblyView.isSourceCodeRender && ((a = n.location) != null && a.path) && n.line) {
      const d = this.getUriFromSource(n);
      if (d) {
        let u;
        const g = new ba(1e4), p = await this.textModelService.createModelReference(d);
        if (u = p.object.textEditorModel, i.cellDisposable.push(p), u && i.currentElement.element === e) {
          let f = n.line;
          for (; f && f >= 1 && f <= u.getLineCount(); ) {
            const S = u.getLineContent(f);
            if (g.appendString(`  ${f}: `), g.appendString(S + `
`), n.endLine && f < n.endLine) {
              f++;
              continue;
            }
            break;
          }
          i.sourcecode.innerText = g.build();
        }
      }
    }
    let r = 10;
    if (n.address !== "-1") {
      o.appendString(n.address), n.address.length < be.INSTRUCTION_ADDR_MIN_LENGTH && (r = be.INSTRUCTION_ADDR_MIN_LENGTH - n.address.length);
      for (let d = 0; d < r; d++)
        o.appendString(" ");
    }
    if (n.instructionBytes) {
      o.appendString(n.instructionBytes), r = 10, n.instructionBytes.length < be.INSTRUCTION_BYTES_MIN_LENGTH && (r = be.INSTRUCTION_BYTES_MIN_LENGTH - n.instructionBytes.length);
      for (let d = 0; d < r; d++)
        o.appendString(" ");
    }
    o.appendString(n.instruction), i.instruction.innerText = o.build(), this.rerenderBackground(i.instruction, i.sourcecode, e);
  }
  disposeElement(e, t, i, s) {
    U(i.cellDisposable), i.cellDisposable = [];
  }
  disposeTemplate(e) {
    U(e.disposables), e.disposables = [];
  }
  rerenderBackground(e, t, i) {
    var s, n;
    i && this._disassemblyView.currentInstructionAddresses.includes(i.instruction.address) ? e.style.background = ((s = this._topStackFrameColor) == null ? void 0 : s.toString()) || "transparent" : (i == null ? void 0 : i.instruction.address) === this._disassemblyView.focusedInstructionAddress ? e.style.background = ((n = this._focusedStackFrameColor) == null ? void 0 : n.toString()) || "transparent" : e.style.background = "transparent";
  }
  openSourceCode(e) {
    if (e) {
      const t = this.getUriFromSource(e), i = e.endLine ? {
        startLineNumber: e.line,
        endLineNumber: e.endLine,
        startColumn: e.column || 1,
        endColumn: e.endColumn || 1073741824
      } : {
        startLineNumber: e.line,
        endLineNumber: e.line,
        startColumn: e.column || 1,
        endColumn: e.endColumn || 1073741824
      };
      this.editorService.openEditor({
        resource: t,
        description: c("editorOpenedFromDisassemblyDescription", "from disassembly"),
        options: {
          preserveFocus: !1,
          selection: i,
          revealIfOpened: !0,
          selectionRevealType: 1,
          pinned: !1
        }
      });
    }
  }
  getUriFromSource(e) {
    const t = e.location.path;
    return t && Xn(t) ? this.uriService.asCanonicalUri(ue.parse(t)) : t && ed(t) ? this.uriService.asCanonicalUri(ue.file(t)) : sg(e.location, e.location.path, this._disassemblyView.debugSession.getId(), this.uriService, this.logService);
  }
  applyFontInfo(e) {
    hh(e, this._disassemblyView.fontInfo), e.style.whiteSpace = "pre";
  }
}, be.TEMPLATE_ID = "instruction", be.INSTRUCTION_ADDR_MIN_LENGTH = 25, be.INSTRUCTION_BYTES_MIN_LENGTH = 30, be);
xs = I([
  h(1, ce),
  h(2, ae),
  h(3, td),
  h(4, Le),
  h(5, ei)
], xs);
class If {
  getWidgetAriaLabel() {
    return c("disassemblyView", "Disassembly View");
  }
  getAriaLabel(e) {
    let t = "";
    const i = e.instruction;
    return i.address !== "-1" && (t += `${c("instructionAddress", "Address")}: ${i.address}`), i.instructionBytes && (t += `, ${c("instructionBytes", "Bytes")}: ${i.instructionBytes}`), t += `, ${c("instructionText", "Instruction")}: ${i.instruction}`, t;
  }
}
let Ko = class {
  constructor(e, t, i) {
    i.bufferChangeEvents(() => {
      this._languageSupportsDisassemleRequest = Uc.bindTo(i);
    });
    const s = () => {
      var o, r, a;
      this._onDidChangeModelLanguage && (this._onDidChangeModelLanguage.dispose(), this._onDidChangeModelLanguage = void 0);
      const n = e.activeTextEditorControl;
      if (Je(n)) {
        const d = (o = n.getModel()) == null ? void 0 : o.getLanguageId();
        (r = this._languageSupportsDisassemleRequest) == null || r.set(!!d && t.getAdapterManager().someDebuggerInterestedInLanguage(d)), this._onDidChangeModelLanguage = n.onDidChangeModelLanguage((u) => {
          var g;
          (g = this._languageSupportsDisassemleRequest) == null || g.set(t.getAdapterManager().someDebuggerInterestedInLanguage(u.newLanguage));
        });
      } else
        (a = this._languageSupportsDisassemleRequest) == null || a.set(!1);
    };
    s(), this._onDidActiveEditorChangeListener = e.onDidActiveEditorChange(s);
  }
  dispose() {
    var e;
    this._onDidActiveEditorChangeListener.dispose(), (e = this._onDidChangeModelLanguage) == null || e.dispose();
  }
};
Ko = I([
  h(0, ae),
  h(1, T),
  h(2, H)
], Ko);
let Ts = class jo {
  constructor(e, t, i, s, n) {
    this.debugService = t, this.modelService = i, this.languageService = s, this.editorWorkerService = n, this.pendingUpdates = /* @__PURE__ */ new Map(), e.registerTextModelContentProvider(vi, this), jo.INSTANCE = this;
  }
  dispose() {
    this.pendingUpdates.forEach((e) => e.dispose());
  }
  provideTextContent(e) {
    return this.createOrUpdateContentModel(e, !0);
  }
  static refreshDebugContent(e) {
    var t;
    (t = jo.INSTANCE) == null || t.createOrUpdateContentModel(e, !1);
  }
  createOrUpdateContentModel(e, t) {
    const i = this.modelService.getModel(e);
    if (!i && !t)
      return null;
    let s;
    if (e.query) {
      const o = Ji.getEncodedDebugData(e);
      s = this.debugService.getModel().getSession(o.sessionId);
    }
    if (s || (s = this.debugService.getViewModel().focusedSession), !s)
      return Promise.reject(new rc(c("unable", "Unable to resolve the resource without a debug session")));
    const n = (o) => {
      this.debugService.sourceIsNotAvailable(e);
      const r = this.languageService.createById(Dc), a = o ? c(
        "canNotResolveSourceWithError",
        "Could not load source '{0}': {1}.",
        e.path,
        o
      ) : c("canNotResolveSource", "Could not load source '{0}'.", e.path);
      return this.modelService.createModel(a, r, e);
    };
    return s.loadSource(e).then((o) => {
      if (o && o.body)
        if (i) {
          const r = o.body.content, a = this.pendingUpdates.get(i.id);
          a == null || a.cancel();
          const d = new Qe();
          return this.pendingUpdates.set(i.id, d), this.editorWorkerService.computeMoreMinimalEdits(i.uri, [{ text: r, range: i.getFullModelRange() }]).then((u) => (this.pendingUpdates.delete(i.id), !d.token.isCancellationRequested && u && u.length > 0 && i.applyEdits(u.map((g) => jc.replace(re.lift(g.range), g.text))), i));
        } else {
          const r = o.body.mimeType || ph(e)[0], a = this.languageService.createByMimeType(r);
          return this.modelService.createModel(o.body.content, a, e);
        }
      return n();
    }, (o) => n(o.message));
  }
};
Ts = I([
  h(0, td),
  h(1, T),
  h(2, pr),
  h(3, or),
  h(4, gh)
], Ts);
const xf = !0, Tf = /^[a-zA-Z][a-zA-Z0-9\+\-\.]+:/;
class Pe {
  constructor(e, t, i = !1) {
    this._parent = e, this._label = t, this.isIncompressible = i, this._children = /* @__PURE__ */ new Map(), this._showedMoreThanOne = !1;
  }
  updateLabel(e) {
    this._label = e;
  }
  isLeaf() {
    return this._children.size === 0;
  }
  getSession() {
    if (this._parent)
      return this._parent.getSession();
  }
  setSource(e, t) {
    if (this._source = t, this._children.clear(), t.raw && t.raw.sources) {
      for (const i of t.raw.sources)
        if (i.name && i.path) {
          const s = new Pe(this, i.name);
          this._children.set(i.path, s);
          const n = e.getSource(i);
          s.setSource(e, n);
        }
    }
  }
  createIfNeeded(e, t) {
    let i = this._children.get(e);
    return i || (i = t(this, e), this._children.set(e, i)), i;
  }
  getChild(e) {
    return this._children.get(e);
  }
  remove(e) {
    this._children.delete(e);
  }
  removeFromParent() {
    this._parent && (this._parent.remove(this._label), this._parent._children.size === 0 && this._parent.removeFromParent());
  }
  getTemplateId() {
    return "id";
  }
  getId() {
    const e = this.getParent();
    return e ? `${e.getId()}/${this.getInternalId()}` : this.getInternalId();
  }
  getInternalId() {
    return this._label;
  }
  getParent() {
    if (this._parent)
      return this._parent.isSkipped() ? this._parent.getParent() : this._parent;
  }
  isSkipped() {
    return this._parent ? !!this._parent.oneChild() : !0;
  }
  hasChildren() {
    const e = this.oneChild();
    return e ? e.hasChildren() : this._children.size > 0;
  }
  getChildren() {
    const e = this.oneChild();
    if (e)
      return e.getChildren();
    const t = [];
    for (const i of this._children.values())
      t.push(i);
    return t.sort((i, s) => this.compare(i, s));
  }
  getLabel(e = !0) {
    const t = this.oneChild();
    if (t) {
      const i = this instanceof Mi && e ? " • " : Ot.sep;
      return `${this._label}${i}${t.getLabel()}`;
    }
    return this._label;
  }
  getHoverLabel() {
    if (this._source && this._parent && this._parent._source)
      return this._source.raw.path || this._source.raw.name;
    const e = this.getLabel(!1), t = this.getParent();
    if (t) {
      const i = t.getHoverLabel();
      if (i)
        return `${i}/${e}`;
    }
    return e;
  }
  getSource() {
    const e = this.oneChild();
    return e ? e.getSource() : this._source;
  }
  compare(e, t) {
    return e._label && t._label ? e._label.localeCompare(t._label) : 0;
  }
  oneChild() {
    if (!this._source && !this._showedMoreThanOne && this.skipOneChild()) {
      if (this._children.size === 1)
        return this._children.values().next().value;
      this._children.size > 1 && (this._showedMoreThanOne = !0);
    }
  }
  skipOneChild() {
    return this instanceof zd;
  }
}
class Mi extends Pe {
  constructor(e, t) {
    super(e, t.name, !0), this.folder = t;
  }
}
class zd extends Pe {
  constructor(e, t, i) {
    super(void 0, "Root"), this._pathService = e, this._contextService = t, this._labelService = i;
  }
  add(e) {
    return this.createIfNeeded(e.getId(), () => new vt(this._labelService, this, e, this._pathService, this._contextService));
  }
  find(e) {
    return this.getChild(e.getId());
  }
}
const qs = class qs extends Pe {
  constructor(e, t, i, s, n) {
    super(t, i.getLabel(), !0), this._pathService = s, this.rootProvider = n, this._map = /* @__PURE__ */ new Map(), this._labelService = e, this._session = i;
  }
  getInternalId() {
    return this._session.getId();
  }
  getSession() {
    return this._session;
  }
  getHoverLabel() {
  }
  hasChildren() {
    return !0;
  }
  compare(e, t) {
    const i = this.category(e), s = this.category(t);
    return i !== s ? i - s : super.compare(e, t);
  }
  category(e) {
    if (e instanceof Mi)
      return e.folder.index;
    const t = e.getLabel();
    return t && /^<.+>$/.test(t) ? 1e3 : 999;
  }
  async addPath(e) {
    let t, i, s = e.raw.path;
    if (!s)
      return;
    this._labelService && Tf.test(s) && (s = this._labelService.getUriLabel(ue.parse(s)));
    const n = qs.URL_REGEXP.exec(s);
    if (n && n.length === 3)
      i = n[1], s = decodeURI(n[2]);
    else if (ed(s)) {
      const r = ue.file(s);
      t = this.rootProvider ? this.rootProvider.getWorkspaceFolder(r) : null, t ? (s = is(fh(r.path.substring(t.uri.path.length), Ot.sep)), this.rootProvider.getWorkspace().folders.length > 1 ? s = Ot.sep + s : t = null) : (s = is(s), vr ? s = lc(s) : s = bh(s, (await this._pathService.userHome()).fsPath));
    }
    let o = this;
    s.split(/[\/\\]/).forEach((r, a) => {
      if (a === 0 && t) {
        const d = t;
        o = o.createIfNeeded(t.name, (u) => new Mi(u, d));
      } else
        a === 0 && i ? o = o.createIfNeeded(i, (d) => new Pe(d, i)) : o = o.createIfNeeded(r, (d) => new Pe(d, r));
    }), o.setSource(this._session, e), e.raw.path && this._map.set(e.raw.path, o);
  }
  removePath(e) {
    if (e.raw.path) {
      const t = this._map.get(e.raw.path);
      if (t)
        return t.removeFromParent(), !0;
    }
    return !1;
  }
};
qs.URL_REGEXP = /^(https?:\/\/[^/]+)(\/.*)$/;
let vt = qs;
function qd(l, e) {
  const t = l.getChildren(), i = e ? !e.expanded.has(l.getId()) : !(l instanceof vt);
  return {
    element: l,
    collapsed: i,
    collapsible: l.hasChildren(),
    children: t.map((s) => qd(s, e))
  };
}
let Xo = class extends Pi {
  constructor(e, t, i, s, n, o, r, a, d, u, g, p, f, S, w) {
    super(e, i, t, o, a, n, s, f, S, w), this.editorService = r, this.contextService = d, this.debugService = u, this.labelService = g, this.pathService = p, this.treeNeedsRefreshOnVisible = !1, this.loadedScriptsItemType = mh.bindTo(a);
  }
  renderBody(e) {
    super.renderBody(e), this.element.classList.add("debug-pane"), e.classList.add("debug-loaded-scripts"), e.classList.add("show-file-icons"), this.treeContainer = Dn(e), this.filter = new Af();
    const t = new zd(this.pathService, this.contextService, this.labelService);
    this.treeLabels = this.instantiationService.createInstance(Sh, { onDidChangeVisibility: this.onDidChangeBodyVisibility }), this._register(this.treeLabels), this.tree = this.instantiationService.createInstance(wh, "LoadedScriptsView", this.treeContainer, new _f(), [new _s(this.treeLabels)], {
      compressionEnabled: xf,
      collapseByDefault: !0,
      hideTwistiesOfChildlessElements: !0,
      identityProvider: {
        getId: (a) => a.getId()
      },
      keyboardNavigationLabelProvider: {
        getKeyboardNavigationLabel: (a) => a.getLabel(),
        getCompressedNodeKeyboardNavigationLabel: (a) => a.map((d) => d.getLabel()).join("/")
      },
      filter: this.filter,
      accessibilityProvider: new Lf(),
      overrideStyles: {
        listBackground: this.getBackgroundColor()
      }
    });
    const i = (a) => this.tree.setChildren(null, qd(t, a).children);
    i(), this.changeScheduler = new oe(() => {
      this.treeNeedsRefreshOnVisible = !1, this.tree && i();
    }, 300), this._register(this.changeScheduler), this._register(this.tree.onDidOpen((a) => {
      if (a.element instanceof Pe) {
        const d = a.element.getSource();
        if (d && d.available) {
          const u = { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 };
          d.openInEditor(this.editorService, u, a.editorOptions.preserveFocus, a.sideBySide, a.editorOptions.pinned);
        }
      }
    })), this._register(this.tree.onDidChangeFocus(() => {
      this.tree.getFocus() instanceof vt ? this.loadedScriptsItemType.set("session") : this.loadedScriptsItemType.reset();
    }));
    const s = () => {
      this.isBodyVisible() ? this.changeScheduler.schedule() : this.treeNeedsRefreshOnVisible = !0;
    }, n = async (a) => {
      if (a.capabilities.supportsLoadedSourcesRequest) {
        const d = t.add(a), u = await a.getLoadedSources();
        for (const g of u)
          await d.addPath(g);
        s();
      }
    }, o = (a) => {
      this._register(a.onDidChangeName(async () => {
        const d = t.find(a);
        d && (d.updateLabel(a.getLabel()), s());
      })), this._register(a.onDidLoadedSource(async (d) => {
        let u;
        switch (d.reason) {
          case "new":
          case "changed":
            u = t.add(a), await u.addPath(d.source), s(), d.reason === "changed" && Ts.refreshDebugContent(d.source.uri);
            break;
          case "removed":
            u = t.find(a), u && u.removePath(d.source) && s();
            break;
          default:
            this.filter.setFilter(d.source.name), this.tree.refilter();
            break;
        }
      }));
    };
    this._register(this.debugService.onDidNewSession(o)), this.debugService.getModel().getSessions().forEach(o), this._register(this.debugService.onDidEndSession((a) => {
      t.remove(a.getId()), this.changeScheduler.schedule();
    })), this.changeScheduler.schedule(0), this._register(this.onDidChangeBodyVisibility((a) => {
      a && this.treeNeedsRefreshOnVisible && this.changeScheduler.schedule();
    }));
    let r;
    this._register(this.tree.onDidChangeFindPattern((a) => {
      if (this.tree.findMode !== vh.Highlight)
        if (!r && a) {
          const d = /* @__PURE__ */ new Set(), u = (g) => {
            g.element && !g.collapsed && d.add(g.element.getId());
            for (const p of g.children)
              u(p);
          };
          u(this.tree.getNode()), r = { expanded: d }, this.tree.expandAll();
        } else
          !a && r && (this.tree.setFocus([]), i(r), r = void 0);
    })), this.debugService.getModel().getSessions().forEach((a) => n(a));
  }
  layoutBody(e, t) {
    super.layoutBody(e, t), this.tree.layout(e, t);
  }
  dispose() {
    U(this.tree), U(this.treeLabels), super.dispose();
  }
};
Xo = I([
  h(1, Me),
  h(2, at),
  h(3, K),
  h(4, Ue),
  h(5, O),
  h(6, ae),
  h(7, H),
  h(8, _e),
  h(9, T),
  h(10, Vi),
  h(11, gr),
  h(12, st),
  h(13, ce),
  h(14, we)
], Xo);
class _f {
  getHeight(e) {
    return 22;
  }
  getTemplateId(e) {
    return _s.ID;
  }
}
const Gs = class Gs {
  constructor(e) {
    this.labels = e;
  }
  get templateId() {
    return Gs.ID;
  }
  renderTemplate(e) {
    return { label: this.labels.create(e, { supportHighlights: !0 }) };
  }
  renderElement(e, t, i) {
    const s = e.element, n = s.getLabel();
    this.render(s, n, i, e.filterData);
  }
  renderCompressedElements(e, t, i, s) {
    const n = e.element.elements[e.element.elements.length - 1], o = e.element.elements.map((r) => r.getLabel());
    this.render(n, o, i, e.filterData);
  }
  render(e, t, i, s) {
    const n = {
      name: t
    }, o = {
      title: e.getHoverLabel()
    };
    if (e instanceof Mi)
      o.fileKind = Tn.ROOT_FOLDER;
    else if (e instanceof vt)
      o.title = c("loadedScriptsSession", "Debug Session"), o.hideIcon = !0;
    else if (e instanceof Pe) {
      const r = e.getSource();
      r && r.uri ? (n.resource = r.uri, o.fileKind = Tn.FILE) : o.fileKind = Tn.FOLDER;
    }
    o.matches = Fe(s), i.label.setResource(n, o);
  }
  disposeTemplate(e) {
    e.label.dispose();
  }
};
Gs.ID = "lsrenderer";
let _s = Gs;
class Lf {
  getWidgetAriaLabel() {
    return c(
      { comment: ["Debug is a noun in this context, not a verb."], key: "loadedScriptsAriaLabel" },
      "Debug Loaded Scripts"
    );
  }
  getAriaLabel(e) {
    return e instanceof Mi ? c(
      "loadedScriptsRootFolderAriaLabel",
      "Workspace folder {0}, loaded script, debug",
      e.getLabel()
    ) : e instanceof vt ? c(
      "loadedScriptsSessionAriaLabel",
      "Session {0}, loaded script, debug",
      e.getLabel()
    ) : e.hasChildren() ? c(
      "loadedScriptsFolderAriaLabel",
      "Folder {0}, loaded script, debug",
      e.getLabel()
    ) : c(
      "loadedScriptsSourceAriaLabel",
      "{0}, loaded script, debug",
      e.getLabel()
    );
  }
}
class Af {
  setFilter(e) {
    this.filterText = e;
  }
  filter(e, t) {
    return this.filterText ? e.isLeaf() ? e.getLabel().indexOf(this.filterText) >= 0 ? 1 : 0 : 2 : 1;
  }
}
var Bf = ".monaco-workbench .repl{box-sizing:border-box;height:100%;overflow:hidden}.monaco-workbench .repl .repl-tree .monaco-tl-contents{user-select:text;-webkit-user-select:text;white-space:pre}.monaco-workbench .repl .repl-tree .monaco-tl-contents .expression{font-family:var(--vscode-repl-font-family);font-size:var(--vscode-repl-font-size);line-height:var(--vscode-repl-line-height)}.monaco-workbench .repl .repl-tree .monaco-tl-contents .expression .lazy-button{cursor:pointer}.monaco-workbench .repl .repl-tree .monaco-tl-twistie{background-position-y:calc(100% - var(--vscode-repl-font-size-for-twistie))}.monaco-workbench .repl .repl-tree.word-wrap .monaco-tl-contents{word-wrap:break-word;white-space:pre-wrap;word-break:break-all}.monaco-workbench .repl .repl-tree.word-wrap .monaco-tl-contents .expression.nested-variable{white-space:pre}.monaco-workbench .repl .repl-tree .monaco-tl-twistie,.monaco-workbench .repl .repl-tree .monaco-tl-twistie.collapsible+.monaco-tl-contents{cursor:pointer}.monaco-workbench .repl .repl-tree .output.expression.value-and-source{display:flex}.monaco-workbench .repl .repl-tree .output.expression.value-and-source .count-badge-wrapper,.monaco-workbench .repl .repl-tree .output.expression.value-and-source .value{margin-right:4px}.monaco-workbench .repl .repl-tree .output.expression.value-and-source .count-badge-wrapper .monaco-count-badge{min-height:16px;word-break:keep-all}.monaco-workbench .repl .repl-tree .monaco-tl-contents .arrow{left:2px;position:absolute}.monaco-workbench .repl .repl-tree .output.expression.value-and-source .source{cursor:pointer;direction:rtl;margin-left:auto;margin-right:8px;max-width:400px;overflow:hidden;text-align:right;text-decoration:underline;text-overflow:ellipsis;white-space:nowrap}.monaco-workbench .repl .repl-tree .evaluation-result.expression>.value,.monaco-workbench .repl .repl-tree .output.expression>.value{margin-left:0}.monaco-workbench .repl .repl-tree .output.expression .name:not(:empty){margin-right:6px}.monaco-workbench .repl .repl-input-wrapper{align-items:center;display:flex}.monaco-workbench .repl .repl-input-wrapper .suggest-status-bar .monaco-action-bar.right{display:none}.monaco-workbench .repl .repl-input-wrapper .repl-input-chevron{display:flex;flex-shrink:0;font-weight:600;height:100%;justify-content:center;padding:0 6px 0 8px;width:16px}.monaco-workbench .repl .repl-tree .output.expression>.ignore{font-style:italic}.monaco-workbench .repl .repl-tree .output.expression .code-bold{font-weight:700}.monaco-workbench .repl .repl-tree .output.expression .code-italic{font-style:italic}.monaco-workbench .repl .repl-tree .output.expression .code-underline{text-decoration:underline;text-decoration-style:solid}.monaco-workbench .repl .repl-tree .output.expression .code-double-underline{text-decoration:underline;text-decoration-style:double}.monaco-workbench .repl .repl-tree .output.expression .code-strike-through{text-decoration:line-through;text-decoration-style:solid}.monaco-workbench .repl .repl-tree .output.expression .code-overline{text-decoration:overline;text-decoration-style:solid}.monaco-workbench .repl .repl-tree .output.expression .code-overline.code-underline.code-strike-through{text-decoration:overline underline line-through;text-decoration-style:solid}.monaco-workbench .repl .repl-tree .output.expression .code-overline.code-underline{text-decoration:overline underline;text-decoration-style:solid}.monaco-workbench .repl .repl-tree .output.expression .code-overline.code-strike-through{text-decoration:overline line-through;text-decoration-style:solid}.monaco-workbench .repl .repl-tree .output.expression .code-underline.code-strike-through{text-decoration:underline line-through;text-decoration-style:solid}.monaco-workbench .repl .repl-tree .output.expression .code-overline.code-double-underline.code-strike-through{text-decoration:overline underline line-through;text-decoration-style:double}.monaco-workbench .repl .repl-tree .output.expression .code-overline.code-double-underline{text-decoration:overline underline;text-decoration-style:double}.monaco-workbench .repl .repl-tree .output.expression .code-double-underline.code-strike-through{text-decoration:underline line-through;text-decoration-style:double}.monaco-workbench .repl .repl-tree .output.expression .code-dim{opacity:.4}.monaco-workbench .repl .repl-tree .output.expression .code-hidden{opacity:0}.monaco-workbench .repl .repl-tree .output.expression .code-blink{animation:code-blink-key 1s cubic-bezier(1,0,0,1) infinite alternate}.monaco-workbench .repl .repl-tree .output.expression .code-rapid-blink{animation:code-blink-key .3s cubic-bezier(1,0,0,1) infinite alternate}@keyframes code-blink-key{to{opacity:.4}}.monaco-workbench .repl .repl-tree .output.expression .code-subscript{font-size:smaller;line-height:normal;vertical-align:sub}.monaco-workbench .repl .repl-tree .output.expression .code-superscript{font-size:smaller;line-height:normal;vertical-align:super}";
ot(Bf, {});
const wi = class wi {
  constructor() {
    this._parsedQueries = [];
  }
  set filterQuery(e) {
    if (this._parsedQueries = [], e = e.trim(), e && e !== "") {
      const t = Ch(e, ",").map((i) => i.trim()).filter((i) => !!i.length);
      for (const i of t)
        i.startsWith("!") ? this._parsedQueries.push({ type: "exclude", query: i.slice(1) }) : this._parsedQueries.push({ type: "include", query: i });
    }
  }
  filter(e, t) {
    if (e instanceof kn || e instanceof Dt || e instanceof q)
      return 1;
    let i = !1, s = !1;
    const n = e.toString(!0);
    for (const { type: o, query: r } of this._parsedQueries) {
      if (o === "exclude" && wi.matchQuery(r, n))
        return !1;
      o === "include" && (i = !0, wi.matchQuery(r, n) && (s = !0));
    }
    return i ? s : typeof t < "u" ? t : 1;
  }
};
wi.matchQuery = fi;
let Yo = wi;
function Gd(l, e, t, i) {
  const s = document.createElement("span"), n = l.length;
  let o = [], r, a, d, u = !1, g = 0, p = "";
  for (; g < n; ) {
    let v = !1;
    if (l.charCodeAt(g) === 27 && l.charAt(g + 1) === "[") {
      const C = g;
      g += 2;
      let b = "";
      for (; g < n; ) {
        const D = l.charAt(g);
        if (b += D, g++, D.match(/^[ABCDHIJKfhmpsu]$/)) {
          v = !0;
          break;
        }
      }
      if (v) {
        if (Ua(s, p, o, e, i, r, a, d), p = "", b.match(/^(?:[34][0-8]|9[0-7]|10[0-7]|[0-9]|2[1-5,7-9]|[34]9|5[8,9]|1[0-9])(?:;[349][0-7]|10[0-7]|[013]|[245]|[34]9)?(?:;[012]?[0-9]?[0-9])*;?m$/)) {
          const D = b.slice(0, -1).split(";").filter((P) => P !== "").map((P) => parseInt(P, 10));
          if (D[0] === 38 || D[0] === 48 || D[0] === 58) {
            const P = D[0] === 38 ? "foreground" : D[0] === 48 ? "background" : "underline";
            D[1] === 5 ? y(D, P) : D[1] === 2 && m(D, P);
          } else
            w(D);
        }
      } else
        g = C;
    }
    v === !1 && (p += l.charAt(g), g++);
  }
  return p && Ua(s, p, o, e, i, r, a, d), s;
  function f(v, C) {
    v === "foreground" ? r = C : v === "background" ? a = C : v === "underline" && (d = C), o = o.filter((b) => b !== `code-${v}-colored`), C !== void 0 && o.push(`code-${v}-colored`);
  }
  function S() {
    const v = r;
    f("foreground", a), f("background", v);
  }
  function w(v) {
    for (const C of v)
      switch (C) {
        case 0: {
          o = [], r = void 0, a = void 0;
          break;
        }
        case 1: {
          o = o.filter((b) => b !== "code-bold"), o.push("code-bold");
          break;
        }
        case 2: {
          o = o.filter((b) => b !== "code-dim"), o.push("code-dim");
          break;
        }
        case 3: {
          o = o.filter((b) => b !== "code-italic"), o.push("code-italic");
          break;
        }
        case 4: {
          o = o.filter((b) => b !== "code-underline" && b !== "code-double-underline"), o.push("code-underline");
          break;
        }
        case 5: {
          o = o.filter((b) => b !== "code-blink"), o.push("code-blink");
          break;
        }
        case 6: {
          o = o.filter((b) => b !== "code-rapid-blink"), o.push("code-rapid-blink");
          break;
        }
        case 7: {
          u || (u = !0, S());
          break;
        }
        case 8: {
          o = o.filter((b) => b !== "code-hidden"), o.push("code-hidden");
          break;
        }
        case 9: {
          o = o.filter((b) => b !== "code-strike-through"), o.push("code-strike-through");
          break;
        }
        case 10: {
          o = o.filter((b) => !b.startsWith("code-font"));
          break;
        }
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20: {
          o = o.filter((b) => !b.startsWith("code-font")), o.push(`code-font-${C - 10}`);
          break;
        }
        case 21: {
          o = o.filter((b) => b !== "code-underline" && b !== "code-double-underline"), o.push("code-double-underline");
          break;
        }
        case 22: {
          o = o.filter((b) => b !== "code-bold" && b !== "code-dim");
          break;
        }
        case 23: {
          o = o.filter((b) => b !== "code-italic" && b !== "code-font-10");
          break;
        }
        case 24: {
          o = o.filter((b) => b !== "code-underline" && b !== "code-double-underline");
          break;
        }
        case 25: {
          o = o.filter((b) => b !== "code-blink" && b !== "code-rapid-blink");
          break;
        }
        case 27: {
          u && (u = !1, S());
          break;
        }
        case 28: {
          o = o.filter((b) => b !== "code-hidden");
          break;
        }
        case 29: {
          o = o.filter((b) => b !== "code-strike-through");
          break;
        }
        case 53: {
          o = o.filter((b) => b !== "code-overline"), o.push("code-overline");
          break;
        }
        case 55: {
          o = o.filter((b) => b !== "code-overline");
          break;
        }
        case 39: {
          f("foreground", void 0);
          break;
        }
        case 49: {
          f("background", void 0);
          break;
        }
        case 59: {
          f("underline", void 0);
          break;
        }
        case 73: {
          o = o.filter((b) => b !== "code-superscript" && b !== "code-subscript"), o.push("code-superscript");
          break;
        }
        case 74: {
          o = o.filter((b) => b !== "code-superscript" && b !== "code-subscript"), o.push("code-subscript");
          break;
        }
        case 75: {
          o = o.filter((b) => b !== "code-superscript" && b !== "code-subscript");
          break;
        }
        default: {
          _(C);
          break;
        }
      }
  }
  function m(v, C) {
    if (v.length >= 5 && v[2] >= 0 && v[2] <= 255 && v[3] >= 0 && v[3] <= 255 && v[4] >= 0 && v[4] <= 255) {
      const b = new to(v[2], v[3], v[4]);
      f(C, b);
    }
  }
  function y(v, C) {
    let b = v[2];
    const D = Mf(b);
    if (D)
      f(C, D);
    else if (b >= 0 && b <= 15) {
      if (C === "underline") {
        const P = t.getColorTheme(), se = ma[b], A = P.getColor(se);
        A && f(C, A.rgba);
        return;
      }
      b += 30, b >= 38 && (b += 52), C === "background" && (b += 10), _(b);
    }
  }
  function _(v) {
    const C = t.getColorTheme();
    let b, D;
    if (v >= 30 && v <= 37 ? (D = v - 30, b = "foreground") : v >= 90 && v <= 97 ? (D = v - 90 + 8, b = "foreground") : v >= 40 && v <= 47 ? (D = v - 40, b = "background") : v >= 100 && v <= 107 && (D = v - 100 + 8, b = "background"), D !== void 0 && b) {
      const P = ma[D], se = C.getColor(P);
      se && f(b, se.rgba);
    }
  }
}
function Ua(l, e, t, i, s, n, o, r) {
  if (!l || !e)
    return;
  const a = i.linkify(e, !0, s);
  a.className = t.join(" "), n && (a.style.color = ht.Format.CSS.formatRGB(new ht(n))), o && (a.style.backgroundColor = ht.Format.CSS.formatRGB(new ht(o))), r && (a.style.textDecorationColor = ht.Format.CSS.formatRGB(new ht(r))), l.appendChild(a);
}
function Mf(l) {
  if (l % 1 === 0)
    if (l >= 16 && l <= 231) {
      l -= 16;
      let e = l % 6;
      l = (l - e) / 6;
      let t = l % 6;
      l = (l - t) / 6;
      let i = l;
      const s = 255 / 5;
      return e = Math.round(e * s), t = Math.round(t * s), i = Math.round(i * s), new to(i, t, e);
    } else if (l >= 232 && l <= 255) {
      l -= 232;
      const e = Math.round(l / 23 * 255);
      return new to(e, e, e);
    } else
      return;
}
const me = ie, Ks = class Ks {
  get templateId() {
    return Ks.ID;
  }
  renderTemplate(e) {
    E(e, me("span.arrow" + L.asCSSSelector(ng)));
    const t = E(e, me(".expression"));
    return { label: new kt(t) };
  }
  renderElement(e, t, i) {
    const s = e.element;
    i.label.set(s.value, Fe(e.filterData));
  }
  disposeTemplate(e) {
  }
};
Ks.ID = "replEvaluationInput";
let Ls = Ks;
var Gt;
let As = (Gt = class {
  constructor(e, t) {
    this.linkDetector = e, this.themeService = t;
  }
  get templateId() {
    return Gt.ID;
  }
  renderTemplate(e) {
    return { label: E(e, me(".expression")) };
  }
  renderElement(e, t, i) {
    const s = e.element;
    sn(i.label);
    const n = Gd(s.name, this.linkDetector, this.themeService, void 0);
    i.label.appendChild(n);
  }
  disposeTemplate(e) {
  }
}, Gt.ID = "replGroup", Gt);
As = I([
  h(1, ce)
], As);
const js = class js {
  get templateId() {
    return js.ID;
  }
  constructor(e) {
    this.linkDetector = e;
  }
  renderTemplate(e) {
    const t = E(e, me(".evaluation-result.expression"));
    return { value: E(t, me("span.value")) };
  }
  renderElement(e, t, i) {
    const s = e.element;
    li(s, i.value, {
      showHover: !1,
      colorize: !0,
      linkDetector: this.linkDetector
    });
  }
  disposeTemplate(e) {
  }
};
js.ID = "replEvaluationResult";
let Bs = js;
var Kt;
let Ms = (Kt = class {
  constructor(e, t, i, s) {
    this.linkDetector = e, this.editorService = t, this.labelService = i, this.themeService = s;
  }
  get templateId() {
    return Kt.ID;
  }
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    e.classList.add("output");
    const i = E(e, me(".output.expression.value-and-source"));
    return t.container = e, t.countContainer = E(i, me(".count-badge-wrapper")), t.count = new kh(t.countContainer, {}, yh), t.value = E(i, me("span.value")), t.source = E(i, me(".source")), t.toDispose = [], t.toDispose.push(le(t.source, "click", (s) => {
      s.preventDefault(), s.stopPropagation();
      const n = t.getReplElementSource();
      n && n.source.openInEditor(this.editorService, {
        startLineNumber: n.lineNumber,
        startColumn: n.column,
        endLineNumber: n.lineNumber,
        endColumn: n.column
      });
    })), t;
  }
  renderElement({ element: e }, t, i) {
    this.setElementCount(e, i), i.elementListener = e.onDidChangeCount(() => this.setElementCount(e, i)), sn(i.value), i.value.className = "value", i.value.appendChild(Gd(e.value, this.linkDetector, this.themeService, e.session.root)), i.value.classList.add(e.severity === fe.Warning ? "warn" : e.severity === fe.Error ? "error" : e.severity === fe.Ignore ? "ignore" : "info"), i.source.textContent = e.sourceData ? `${Kc(e.sourceData.source.name)}:${e.sourceData.lineNumber}` : "", i.source.title = e.sourceData ? `${this.labelService.getUriLabel(e.sourceData.source.uri)}:${e.sourceData.lineNumber}` : "", i.getReplElementSource = () => e.sourceData;
  }
  setElementCount(e, t) {
    e.count >= 2 ? (t.count.setCount(e.count), t.countContainer.hidden = !1) : t.countContainer.hidden = !0;
  }
  disposeTemplate(e) {
    U(e.toDispose);
  }
  disposeElement(e, t, i) {
    i.elementListener.dispose();
  }
}, Kt.ID = "outputReplElement", Kt);
Ms = I([
  h(1, ae),
  h(2, Vi),
  h(3, ce)
], Ms);
var jt;
let Ns = (jt = class extends xi {
  get templateId() {
    return jt.ID;
  }
  constructor(e, t, i) {
    super(t, i), this.linkDetector = e;
  }
  renderElement(e, t, i) {
    const s = e.element;
    super.renderExpressionElement(s instanceof gs ? s.expression : s, e, i);
  }
  renderExpression(e, t, i) {
    const s = e instanceof gs;
    s || !e.name ? (t.label.set(""), li(s ? e.expression : e, t.value, { showHover: !1, colorize: !0, linkDetector: this.linkDetector }), t.expression.classList.remove("nested-variable")) : (Id(e, t, !0, i, this.linkDetector), t.expression.classList.toggle("nested-variable", Jo(e)));
  }
  getInputBoxOptions(e) {
  }
}, jt.ID = "replVariable", jt);
Ns = I([
  h(1, T),
  h(2, rt)
], Ns);
const Xs = class Xs {
  constructor(e) {
    this.linkDetector = e;
  }
  get templateId() {
    return Xs.ID;
  }
  renderTemplate(e) {
    e.classList.add("output");
    const t = E(e, me(".output.expression")), i = E(t, me("span.name")), s = new kt(i), n = E(t, me("span.value"));
    return { container: e, expression: t, name: i, label: s, value: n };
  }
  renderElement(e, t, i) {
    const s = e.element;
    i.label.set(s.name ? `${s.name}:` : "", Fe(e.filterData)), s.name ? i.name.textContent = `${s.name}:` : i.name.textContent = "", li(s.value, i.value, {
      showHover: !1,
      linkDetector: this.linkDetector
    });
  }
  disposeTemplate(e) {
  }
};
Xs.ID = "rawObject";
let Rs = Xs;
function Jo(l) {
  return l instanceof q && (l.parent instanceof Dt || l.parent instanceof q);
}
class Nf extends Dh {
  constructor(e, t) {
    super(), this.configurationService = e, this.replOptions = t;
  }
  getHeight(e) {
    return this.configurationService.getValue("debug").console.wordWrap ? super.getHeight(e) : this.estimateHeight(e, !0);
  }
  estimateHeight(e, t = !1) {
    const i = this.replOptions.replConfiguration.lineHeight, s = (o) => {
      var r;
      return ((r = o.match(/\n/g)) == null ? void 0 : r.length) ?? 0;
    };
    if (((o) => typeof o.value == "string")(e) && !Jo(e)) {
      const o = e.value, r = s(o) + (t ? 0 : Math.floor(o.length / 70)) + (e instanceof ze ? 0 : 1);
      return Math.max(r, 1) * i;
    }
    return i;
  }
  getTemplateId(e) {
    return e instanceof q || e instanceof gs ? Ns.ID : e instanceof Dt ? Bs.ID : e instanceof kn ? Ls.ID : e instanceof ze ? Ms.ID : e instanceof Ye ? As.ID : Rs.ID;
  }
  hasDynamicHeight(e) {
    return Jo(e) ? !1 : e.toString().length > 0;
  }
}
function Ha(l) {
  return typeof l.getReplElements == "function";
}
class Rf {
  hasChildren(e) {
    return Ha(e) ? !0 : !!e.hasChildren;
  }
  getChildren(e) {
    return Ha(e) ? Promise.resolve(e.getReplElements()) : Promise.resolve(e.getChildren());
  }
}
class Of {
  getWidgetAriaLabel() {
    return c("debugConsole", "Debug Console");
  }
  getAriaLabel(e) {
    return e instanceof q ? c(
      "replVariableAriaLabel",
      "Variable {0}, value {1}",
      e.name,
      e.value
    ) : e instanceof ze || e instanceof kn || e instanceof Dt ? e.value + (e instanceof ze && e.count > 1 ? c(
      { key: "occurred", comment: ["Front will the value of the debug console element. Placeholder will be replaced by a number which represents occurrance count."] },
      ", occurred {0} times",
      e.count
    ) : "") : e instanceof ho ? c(
      "replRawObjectAriaLabel",
      "Debug console variable {0}, value {1}",
      e.name,
      e.value
    ) : e instanceof Ye ? c("replGroup", "Debug console group {0}", e.name) : "";
  }
}
const Xi = ie, zn = "debug.repl.history", qn = "debug.repl.filterHistory", Gn = "debug.repl.filterValue", $a = "replinputdecoration";
function pi(l) {
  l.scrollTop = l.scrollHeight - l.renderHeight;
}
const It = /* @__PURE__ */ new Set(), za = { getId: (l) => l.getId() };
var Re;
let Ni = (Re = class extends Eh {
  constructor(e, t, i, s, n, o, r, a, d, u, g, p, f, S, w, m, y, _, v) {
    const C = s.get(Gn, 1, "");
    super({
      ...e,
      filterOptions: {
        placeholder: c(
          { key: "workbench.debug.filter.placeholder", comment: ["Text in the brackets after e.g. is not localizable"] },
          "Filter (e.g. text, !exclude)"
        ),
        text: C,
        history: JSON.parse(s.get(qn, 1, "[]"))
      }
    }, S, u, g, r, d, i, w, n, m), this.debugService = t, this.storageService = s, this.modelService = o, this.textResourcePropertiesService = p, this.editorService = f, this.languageFeaturesService = _, this.logService = v, this.previousTreeScrollHeight = 0, this.replInputLineCount = 1, this.modelChangeListener = Qt.None, this.menu = y.createMenu(k.DebugConsoleContext, r), this._register(this.menu), this.history = new Ih(
      JSON.parse(this.storageService.get(zn, 1, "[]")),
      50
    ), this.filter = new Yo(), this.filter.filterQuery = C, this.multiSessionRepl = id.bindTo(r), this.replOptions = this._register(this.instantiationService.createInstance(Qo, this.id, () => this.getBackgroundColor())), this._register(this.replOptions.onDidChange(() => this.onDidStyleChange())), a.registerDecorationType("repl-decoration", $a, {}), this.multiSessionRepl.set(this.isMultiSessionView), this.registerListeners();
  }
  registerListeners() {
    this.debugService.getViewModel().focusedSession && this.onDidFocusSession(this.debugService.getViewModel().focusedSession), this._register(this.debugService.getViewModel().onDidFocusSession(async (e) => this.onDidFocusSession(e))), this._register(this.debugService.getViewModel().onDidEvaluateLazyExpression(async (e) => {
      var t;
      e instanceof q && ((t = this.tree) != null && t.hasNode(e)) && (await this.tree.updateChildren(e, !1, !0), await this.tree.expand(e));
    })), this._register(this.debugService.onWillNewSession(async (e) => {
      var i;
      const t = (i = this.tree) == null ? void 0 : i.getInput();
      (!t || t.state === 0) && await this.selectSession(e), this.multiSessionRepl.set(this.isMultiSessionView);
    })), this._register(this.debugService.onDidEndSession(async (e) => {
      await Promise.resolve(), this.multiSessionRepl.set(this.isMultiSessionView);
    })), this._register(this.themeService.onDidColorThemeChange(() => {
      this.refreshReplElements(!1), this.isVisible() && this.updateInputDecoration();
    })), this._register(this.onDidChangeBodyVisibility((e) => {
      e && (this.model || (this.model = this.modelService.getModel(Re.URI) || this.modelService.createModel("", null, Re.URI, !0)), this.setMode(), this.replInput.setModel(this.model), this.updateInputDecoration(), this.refreshReplElements(!0));
    })), this._register(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("debug.console.wordWrap") && this.tree && (this.tree.dispose(), this.treeContainer.innerText = "", sn(this.treeContainer), this.createReplTree()), e.affectsConfiguration("debug.console.acceptSuggestionOnEnter")) {
        const t = this.configurationService.getValue("debug");
        this.replInput.updateOptions({
          acceptSuggestionOnEnter: t.console.acceptSuggestionOnEnter === "on" ? "on" : "off"
        });
      }
    })), this._register(this.editorService.onDidActiveEditorChange(() => {
      this.setMode();
    })), this._register(this.filterWidget.onDidChangeFilterText(() => {
      this.filter.filterQuery = this.filterWidget.getFilterText(), this.tree && (this.tree.refilter(), pi(this.tree));
    }));
  }
  async onDidFocusSession(e) {
    var t;
    e && (It.delete(e), (t = this.completionItemProvider) == null || t.dispose(), e.capabilities.supportsCompletionsRequest && (this.completionItemProvider = this.languageFeaturesService.completionProvider.register({ scheme: vi, pattern: "**/replinput", hasAccessToAllModels: !0 }, {
      _debugDisplayName: "debugConsole",
      triggerCharacters: e.capabilities.completionTriggerCharacters || ["."],
      provideCompletionItems: async (i, s, n, o) => {
        this.setHistoryNavigationEnablement(!1);
        const r = this.replInput.getModel();
        if (r) {
          const a = r.getWordAtPosition(s), d = a ? a.word.length : 0, u = r.getValue(), g = this.debugService.getViewModel().focusedStackFrame, p = g ? g.frameId : void 0, f = await e.completions(p, (g == null ? void 0 : g.thread.threadId) || 0, u, s, d, o), S = [], w = (m) => re.fromPositions(s.delta(0, -m), s);
          if (f && f.body && f.body.targets && f.body.targets.forEach((m) => {
            if (m && m.label) {
              let y, _ = m.text || m.label;
              if (typeof m.selectionStart == "number") {
                y = 4;
                const v = typeof m.selectionLength == "number" ? m.selectionLength : 0, C = v > 0 ? "${1:" + _.substring(m.selectionStart, m.selectionStart + v) + "}$0" : "$0";
                _ = _.substring(0, m.selectionStart) + C + _.substring(m.selectionStart + v);
              }
              S.push({
                label: m.label,
                insertText: _,
                detail: m.detail,
                kind: xh.fromString(m.type || "property"),
                filterText: m.start && m.length ? u.substring(m.start, m.start + m.length).concat(m.label) : void 0,
                range: w(m.length || d),
                sortText: m.sortText,
                insertTextRules: y
              });
            }
          }), this.configurationService.getValue("debug").console.historySuggestions) {
            const m = this.history.getHistory(), y = String(m.length).length;
            m.forEach((_, v) => S.push({
              label: _,
              insertText: _,
              kind: 18,
              range: w(_.length),
              sortText: "ZZZ" + String(m.length - v).padStart(y, "0")
            }));
          }
          return { suggestions: S };
        }
        return Promise.resolve({ suggestions: [] });
      }
    }))), await this.selectSession();
  }
  getFilterStats() {
    var e, t;
    return {
      total: ((e = this.tree) == null ? void 0 : e.getNode().children.length) ?? 0,
      filtered: ((t = this.tree) == null ? void 0 : t.getNode().children.filter((i) => i.visible).length) ?? 0
    };
  }
  get isReadonly() {
    var t;
    const e = (t = this.tree) == null ? void 0 : t.getInput();
    return !(e && e.state !== 0);
  }
  showPreviousValue() {
    this.isReadonly || this.navigateHistory(!0);
  }
  showNextValue() {
    this.isReadonly || this.navigateHistory(!1);
  }
  focusFilter() {
    this.filterWidget.focus();
  }
  setMode() {
    if (!this.isVisible())
      return;
    const e = this.editorService.activeTextEditorControl;
    Je(e) && (this.modelChangeListener.dispose(), this.modelChangeListener = e.onDidChangeModelLanguage(() => this.setMode()), this.model && e.hasModel() && this.model.setLanguage(e.getModel().getLanguageId()));
  }
  onDidStyleChange() {
    var e;
    if (this.styleElement) {
      this.replInput.updateOptions({
        fontSize: this.replOptions.replConfiguration.fontSize,
        lineHeight: this.replOptions.replConfiguration.lineHeight,
        fontFamily: this.replOptions.replConfiguration.fontFamily === "default" ? Th.fontFamily : this.replOptions.replConfiguration.fontFamily
      });
      const t = this.replInput.getOption(65);
      this.styleElement.textContent = `
				.repl .repl-input-wrapper .repl-input-chevron {
					line-height: ${t}px
				}

				.repl .repl-input-wrapper .monaco-editor .lines-content {
					background-color: ${this.replOptions.replConfiguration.backgroundColor};
				}
			`;
      const i = this.replOptions.replConfiguration.fontFamily === "default" ? "var(--monaco-monospace-font)" : this.replOptions.replConfiguration.fontFamily;
      this.container.style.setProperty("--vscode-repl-font-family", i), this.container.style.setProperty("--vscode-repl-font-size", `${this.replOptions.replConfiguration.fontSize}px`), this.container.style.setProperty("--vscode-repl-font-size-for-twistie", `${this.replOptions.replConfiguration.fontSizeForTwistie}px`), this.container.style.setProperty("--vscode-repl-line-height", this.replOptions.replConfiguration.cssLineHeight), (e = this.tree) == null || e.rerender(), this.bodyContentDimension && this.layoutBodyContent(this.bodyContentDimension.height, this.bodyContentDimension.width);
    }
  }
  navigateHistory(e) {
    const t = (e ? this.history.previous() ?? this.history.first() : this.history.next()) ?? "";
    this.replInput.setValue(t), Rt(t), this.replInput.setPosition({ lineNumber: 1, column: t.length + 1 }), this.setHistoryNavigationEnablement(!0);
  }
  async selectSession(e) {
    var i, s, n;
    const t = (i = this.tree) == null ? void 0 : i.getInput();
    if (!e) {
      const o = this.debugService.getViewModel().focusedSession;
      o ? e = o : (!t || It.has(t)) && (e = this.debugService.getModel().getSessions(!0).find((r) => !It.has(r)));
    }
    if (e && ((s = this.replElementsChangeListener) == null || s.dispose(), this.replElementsChangeListener = e.onDidChangeReplElements(() => {
      this.refreshReplElements(e.getReplElements().length === 0);
    }), this.tree && t !== e)) {
      try {
        await this.tree.setInput(e);
      } catch (o) {
        this.logService.error(o);
      }
      pi(this.tree);
    }
    (n = this.replInput) == null || n.updateOptions({ readOnly: this.isReadonly }), this.updateInputDecoration();
  }
  async clearRepl() {
    var t;
    const e = (t = this.tree) == null ? void 0 : t.getInput();
    e && (e.removeReplExpressions(), e.state === 0 && (It.add(e), await this.selectSession(), this.multiSessionRepl.set(this.isMultiSessionView))), this.replInput.focus();
  }
  acceptReplInput() {
    var t;
    const e = (t = this.tree) == null ? void 0 : t.getInput();
    if (e && !this.isReadonly) {
      e.addReplExpression(this.debugService.getViewModel().focusedStackFrame, this.replInput.getValue()), pi(this.tree), this.history.add(this.replInput.getValue()), this.replInput.setValue("");
      const i = this.replInputLineCount > 1;
      this.replInputLineCount = 1, i && this.bodyContentDimension && this.layoutBodyContent(this.bodyContentDimension.height, this.bodyContentDimension.width);
    }
  }
  getVisibleContent() {
    let e = "";
    if (this.model && this.tree) {
      const t = this.textResourcePropertiesService.getEOL(this.model.uri), i = (s) => {
        s.children.forEach((n) => {
          n.visible && (e += n.element.toString().trimRight() + t, !n.collapsed && n.children.length && i(n));
        });
      };
      i(this.tree.getNode());
    }
    return _h(e);
  }
  layoutBodyContent(e, t) {
    this.bodyContentDimension = new Lh(t, e);
    const i = Math.min(this.replInput.getContentHeight(), e);
    if (this.tree) {
      const s = this.tree.scrollTop + this.tree.renderHeight >= this.tree.scrollHeight, n = e - i;
      this.tree.getHTMLElement().style.height = `${n}px`, this.tree.layout(n, t), s && pi(this.tree);
    }
    this.replInputContainer.style.height = `${i}px`, this.replInput.layout({ width: t - 30, height: i });
  }
  collapseAll() {
    var e;
    (e = this.tree) == null || e.collapseAll();
  }
  getReplInput() {
    return this.replInput;
  }
  focus() {
    setTimeout(() => this.replInput.focus(), 0);
  }
  getActionViewItem(e) {
    if (e.id === Kd) {
      const t = (this.tree ? this.tree.getInput() : void 0) ?? this.debugService.getViewModel().focusedSession;
      return this.instantiationService.createInstance(Wf, e, t);
    }
    return super.getActionViewItem(e);
  }
  get isMultiSessionView() {
    return this.debugService.getModel().getSessions(!0).filter((e) => e.hasSeparateRepl() && !It.has(e)).length > 1;
  }
  get refreshScheduler() {
    const e = /* @__PURE__ */ new Set();
    return new oe(async () => {
      if (!this.tree || !this.tree.getInput())
        return;
      await this.tree.updateChildren(void 0, !0, !1, { diffIdentityProvider: za });
      const t = this.tree.getInput();
      if (t) {
        const n = async (o) => {
          for (const r of o)
            r instanceof Ye && (r.autoExpand && !e.has(r.getId()) && (e.add(r.getId()), await this.tree.expand(r)), this.tree.isCollapsed(r) || await n(r.getChildren()));
        };
        await n(t.getReplElements());
      }
      const { total: i, filtered: s } = this.getFilterStats();
      this.filterWidget.updateBadge(i === s || i === 0 ? void 0 : c("showing filtered repl lines", "Showing {0} of {1}", s, i));
    }, Re.REFRESH_DELAY);
  }
  render() {
    super.render(), this._register(Ah({
      focusNotifiers: [this, this.filterWidget],
      focusNextWidget: () => {
        var e, t;
        this.filterWidget.hasFocus() ? (e = this.tree) == null || e.domFocus() : ((t = this.tree) == null ? void 0 : t.getHTMLElement()) === document.activeElement && this.focus();
      },
      focusPreviousWidget: () => {
        var e, t;
        this.replInput.hasTextFocus() ? (e = this.tree) == null || e.domFocus() : ((t = this.tree) == null ? void 0 : t.getHTMLElement()) === document.activeElement && this.focusFilter();
      }
    }));
  }
  renderBody(e) {
    super.renderBody(e), this.container = E(e, Xi(".repl")), this.treeContainer = E(this.container, Xi(`.repl-tree.${Bh}`)), this.createReplInput(this.container), this.createReplTree();
  }
  createReplTree() {
    this.replDelegate = new Nf(this.configurationService, this.replOptions);
    const e = this.configurationService.getValue("debug").console.wordWrap;
    this.treeContainer.classList.toggle("word-wrap", e);
    const t = this.instantiationService.createInstance(wt), i = this.tree = this.instantiationService.createInstance(
      rn,
      "DebugRepl",
      this.treeContainer,
      this.replDelegate,
      [
        this.instantiationService.createInstance(Ns, t),
        this.instantiationService.createInstance(Ms, t),
        new Ls(),
        this.instantiationService.createInstance(As, t),
        new Bs(t),
        new Rs(t)
      ],
      new Rf(),
      {
        filter: this.filter,
        accessibilityProvider: new Of(),
        identityProvider: za,
        mouseSupport: !1,
        findWidgetEnabled: !1,
        keyboardNavigationLabelProvider: { getKeyboardNavigationLabel: (n) => n.toString(!0) },
        horizontalScrolling: !e,
        setRowLineHeight: !1,
        supportDynamicHeights: e,
        overrideStyles: {
          listBackground: this.getBackgroundColor()
        }
      }
    );
    this._register(i.onDidChangeContentHeight(() => {
      i.scrollHeight !== this.previousTreeScrollHeight && i.scrollTop + i.renderHeight >= this.previousTreeScrollHeight - 2 && setTimeout(() => {
        pi(i);
      }, 0), this.previousTreeScrollHeight = i.scrollHeight;
    })), this._register(i.onContextMenu((n) => this.onContextMenu(n)));
    let s;
    this._register(i.onMouseClick(() => {
      const n = window.getSelection();
      (!n || n.type !== "Range" || s === n.toString()) && this.replInput.focus(), s = n ? n.toString() : "";
    })), this.selectSession(), this.styleElement = Mh(this.container), this.onDidStyleChange();
  }
  createReplInput(e) {
    this.replInputContainer = E(e, Xi(".repl-input-wrapper")), E(this.replInputContainer, Xi(".repl-input-chevron" + L.asCSSSelector(og)));
    const { historyNavigationBackwardsEnablement: t, historyNavigationForwardsEnablement: i } = this._register(Nh(this.scopedContextKeyService, this));
    this.setHistoryNavigationEnablement = (o) => {
      t.set(o), i.set(o);
    }, ln.bindTo(this.scopedContextKeyService).set(!0), this.scopedInstantiationService = this.instantiationService.createChild(new Ic([H, this.scopedContextKeyService]));
    const s = _c(this.configurationService);
    s.readOnly = !0, s.suggest = { showStatusBar: !0 };
    const n = this.configurationService.getValue("debug");
    s.acceptSuggestionOnEnter = n.console.acceptSuggestionOnEnter === "on" ? "on" : "off", s.ariaLabel = c("debugConsole", "Debug Console"), this.replInput = this.scopedInstantiationService.createInstance(Tc, this.replInputContainer, s, xc()), this._register(this.replInput.onDidChangeModelContent(() => {
      const o = this.replInput.getModel();
      this.setHistoryNavigationEnablement(!!o && o.getValue() === "");
      const r = o ? Math.min(10, o.getLineCount()) : 1;
      r !== this.replInputLineCount && (this.replInputLineCount = r, this.bodyContentDimension && this.layoutBodyContent(this.bodyContentDimension.height, this.bodyContentDimension.width));
    })), this._register(this.replInput.onDidFocusEditorText(() => this.updateInputDecoration())), this._register(this.replInput.onDidBlurEditorText(() => this.updateInputDecoration())), this._register(Ke(this.replInputContainer, ne.FOCUS, () => this.replInputContainer.classList.add("synthetic-focus"))), this._register(Ke(this.replInputContainer, ne.BLUR, () => this.replInputContainer.classList.remove("synthetic-focus")));
  }
  onContextMenu(e) {
    const t = [];
    ri(this.menu, { arg: e.element, shouldForwardArgs: !1 }, t), this.contextMenuService.showContextMenu({
      getAnchor: () => e.anchor,
      getActions: () => t,
      getActionsContext: () => e.element
    });
  }
  refreshReplElements(e) {
    if (this.tree && this.isVisible()) {
      if (this.refreshScheduler.isScheduled())
        return;
      this.refreshScheduler.schedule(e ? 0 : void 0);
    }
  }
  updateInputDecoration() {
    var t;
    if (!this.replInput)
      return;
    const e = [];
    if (this.isReadonly && this.replInput.hasTextFocus() && !this.replInput.getValue()) {
      const i = (t = Rh(Ac, this.themeService.getColorTheme())) == null ? void 0 : t.transparent(0.4);
      e.push({
        range: {
          startLineNumber: 0,
          endLineNumber: 0,
          startColumn: 0,
          endColumn: 1
        },
        renderOptions: {
          after: {
            contentText: c("startDebugFirst", "Please start a debug session to evaluate expressions"),
            color: i ? i.toString() : void 0
          }
        }
      });
    }
    this.replInput.setDecorationsByType("repl-decoration", $a, e);
  }
  saveState() {
    const e = this.history.getHistory();
    e.length ? this.storageService.store(zn, JSON.stringify(e), 1, 1) : this.storageService.remove(zn, 1);
    const t = this.filterWidget.getHistory();
    t.length ? this.storageService.store(qn, JSON.stringify(t), 1, 1) : this.storageService.remove(qn, 1);
    const i = this.filterWidget.getFilterText();
    i ? this.storageService.store(Gn, i, 1, 1) : this.storageService.remove(Gn, 1), super.saveState();
  }
  dispose() {
    var e, t;
    (e = this.replInput) == null || e.dispose(), (t = this.replElementsChangeListener) == null || t.dispose(), this.refreshScheduler.dispose(), this.modelChangeListener.dispose(), super.dispose();
  }
}, Re.REFRESH_DELAY = 50, Re.URI = ue.parse(`${vi}:replinput`), Re);
Ni.__decorator = I([
  ni
], Ni.prototype, "refreshScheduler", null);
Ni = I([
  h(1, T),
  h(2, K),
  h(3, it),
  h(4, ce),
  h(5, pr),
  h(6, H),
  h(7, wc),
  h(8, Ue),
  h(9, Me),
  h(10, O),
  h(11, Ga),
  h(12, ae),
  h(13, at),
  h(14, st),
  h(15, we),
  h(16, Ne),
  h(17, ii),
  h(18, ei)
], Ni);
var Ge;
let Qo = (Ge = class extends Qt {
  get replConfiguration() {
    return this._replConfig;
  }
  constructor(e, t, i, s, n) {
    super(), this.backgroundColorDelegate = t, this.configurationService = i, this.themeService = s, this.viewDescriptorService = n, this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, this._register(this.themeService.onDidColorThemeChange((o) => this.update())), this._register(this.viewDescriptorService.onDidChangeLocation((o) => {
      o.views.some((r) => r.id === e) && this.update();
    })), this._register(this.configurationService.onDidChangeConfiguration((o) => {
      (o.affectsConfiguration("debug.console.lineHeight") || o.affectsConfiguration("debug.console.fontSize") || o.affectsConfiguration("debug.console.fontFamily")) && this.update();
    })), this.update();
  }
  update() {
    const e = this.configurationService.getValue("debug").console;
    this._replConfig = {
      fontSize: e.fontSize,
      fontFamily: e.fontFamily,
      lineHeight: e.lineHeight ? e.lineHeight : Ge.lineHeightEm * e.fontSize,
      cssLineHeight: e.lineHeight ? `${e.lineHeight}px` : `${Ge.lineHeightEm}em`,
      backgroundColor: this.themeService.getColorTheme().getColor(this.backgroundColorDelegate()),
      fontSizeForTwistie: e.fontSize * Ge.lineHeightEm / 2 - 8
    }, this._onDidChange.fire();
  }
}, Ge.lineHeightEm = 1.4, Ge);
Qo = I([
  h(2, O),
  h(3, ce),
  h(4, Ue)
], Qo);
class Vf extends pe {
  constructor() {
    super({
      id: "repl.action.acceptInput",
      label: c(
        { key: "actions.repl.acceptInput", comment: ["Apply input from the debug console input box"] },
        "REPL Accept Input"
      ),
      alias: "REPL Accept Input",
      precondition: ln,
      kbOpts: {
        kbExpr: Be.textInputFocus,
        primary: 3,
        weight: 100
      }
    });
  }
  run(e, t) {
    var s;
    (s = Oh.get(t)) == null || s.cancelSuggestWidget();
    const i = Pr(e.get(Ae));
    i == null || i.acceptReplInput();
  }
}
class Pf extends pe {
  constructor() {
    super({
      id: "repl.action.filter",
      label: c("repl.action.filter", "REPL Focus Content to Filter"),
      alias: "REPL Filter",
      precondition: ln,
      kbOpts: {
        kbExpr: Be.textInputFocus,
        primary: 2084,
        weight: 100
      }
    });
  }
  run(e, t) {
    const i = Pr(e.get(Ae));
    i == null || i.focusFilter();
  }
}
class Ff extends pe {
  constructor() {
    super({
      id: "repl.action.copyAll",
      label: c("actions.repl.copyAll", "Debug: Console Copy All"),
      alias: "Debug Console Copy All",
      precondition: ln
    });
  }
  run(e, t) {
    const i = e.get(ai), s = Pr(e.get(Ae));
    if (s)
      return i.writeText(s.getVisibleContent());
  }
}
de(Vf);
de(Ff);
de(Pf);
class Wf extends Ti {
  getSessions() {
    return this.debugService.getModel().getSessions(!0).filter((e) => e.hasSeparateRepl() && !It.has(e));
  }
  mapFocusedSessionToSelected(e) {
    for (; e.parentSession && !e.hasSeparateRepl(); )
      e = e.parentSession;
    return e;
  }
}
function Pr(l) {
  return l.getActiveViewWithId(X) ?? void 0;
}
const Kd = "workbench.action.debug.selectRepl";
ge(class extends ct {
  constructor() {
    super({
      id: Kd,
      viewId: X,
      title: c("selectRepl", "Select Debug Console"),
      f1: !1,
      menu: {
        id: k.ViewTitle,
        group: "navigation",
        when: x.and(
          x.equals("view", X),
          id
        ),
        order: 20
      }
    });
  }
  async runInView(l, e, t) {
    const i = l.get(T);
    if (t && t.state !== 0 && t !== i.getViewModel().focusedSession) {
      if (t.state !== 2) {
        const s = i.getModel().getSessions().find((n) => n.parentSession === t && n.state === 2);
        s && (t = s);
      }
      await i.focusStackFrame(void 0, void 0, t, { explicit: !0 });
    }
    await e.selectSession(t);
  }
});
ge(class extends ct {
  constructor() {
    super({
      id: "workbench.debug.panel.action.clearReplAction",
      viewId: X,
      title: { value: c("clearRepl", "Clear Console"), original: "Clear Console" },
      f1: !0,
      icon: rg,
      menu: [{
        id: k.ViewTitle,
        group: "navigation",
        when: x.equals("view", X),
        order: 30
      }, {
        id: k.DebugConsoleContext,
        group: "z_commands",
        order: 20
      }]
    });
  }
  runInView(l, e) {
    e.clearRepl(), Rt(c("debugConsoleCleared", "Debug console was cleared"));
  }
});
ge(class extends ct {
  constructor() {
    super({
      id: "debug.collapseRepl",
      title: c("collapse", "Collapse All"),
      viewId: X,
      menu: {
        id: k.DebugConsoleContext,
        group: "z_commands",
        order: 10
      }
    });
  }
  runInView(l, e) {
    e.collapseAll(), e.focus();
  }
});
ge(class extends ct {
  constructor() {
    super({
      id: "debug.replPaste",
      title: c("paste", "Paste"),
      viewId: X,
      precondition: N.notEqualsTo(Qs(0)),
      menu: {
        id: k.DebugConsoleContext,
        group: "2_cutcopypaste",
        order: 30
      }
    });
  }
  async runInView(l, e) {
    const i = await l.get(ai).readText();
    if (i) {
      const s = e.getReplInput();
      s.setValue(s.getValue().concat(i)), e.focus();
      const n = s.getModel(), o = n ? n.getLineCount() : 0, r = n == null ? void 0 : n.getLineMaxColumn(o);
      typeof o == "number" && typeof r == "number" && s.setPosition({ lineNumber: o, column: r });
    }
  }
});
ge(class extends ct {
  constructor() {
    super({
      id: "workbench.debug.action.copyAll",
      title: c("copyAll", "Copy All"),
      viewId: X,
      menu: {
        id: k.DebugConsoleContext,
        group: "2_cutcopypaste",
        order: 20
      }
    });
  }
  async runInView(l, e) {
    await l.get(ai).writeText(e.getVisibleContent());
  }
});
ge(class extends Fi {
  constructor() {
    super({
      id: "debug.replCopy",
      title: c("copy", "Copy"),
      menu: {
        id: k.DebugConsoleContext,
        group: "2_cutcopypaste",
        order: 10
      }
    });
  }
  async run(l, e) {
    const t = l.get(ai), i = l.get(T), s = window.getSelection(), n = s == null ? void 0 : s.toString();
    if (n && n.length > 0)
      return t.writeText(n);
    if (e)
      return t.writeText(await this.tryEvaluateAndCopy(i, e) || e.toString());
  }
  async tryEvaluateAndCopy(l, e) {
    if (!(e instanceof Dt))
      return;
    const t = l.getViewModel().focusedStackFrame, i = l.getViewModel().focusedSession;
    if (!(!t || !i || !i.capabilities.supportsClipboardContext))
      try {
        const s = await i.evaluate(e.originalExpression, t.frameId, "clipboard");
        return s == null ? void 0 : s.body.result;
      } catch {
        return;
      }
  }
});
const Uf = M("statusBar.debuggingBackground", {
  dark: "#CC6633",
  light: "#CC6633",
  hcDark: "#BA592C",
  hcLight: "#B5200D"
}, c(
  "statusBarDebuggingBackground",
  "Status bar background color when a program is being debugged. The status bar is shown in the bottom of the window"
)), Hf = M("statusBar.debuggingForeground", {
  dark: _n,
  light: _n,
  hcDark: _n,
  hcLight: "#FFFFFF"
}, c(
  "statusBarDebuggingForeground",
  "Status bar foreground color when a program is being debugged. The status bar is shown in the bottom of the window"
)), $f = M("statusBar.debuggingBorder", {
  dark: ji,
  light: ji,
  hcDark: ji,
  hcLight: ji
}, c(
  "statusBarDebuggingBorder",
  "Status bar border color separating to the sidebar and editor when a program is being debugged. The status bar is shown in the bottom of the window"
));
let Zo = class {
  set enabled(e) {
    e !== !!this.disposable && (e ? this.disposable = this.statusbarService.overrideStyle({
      priority: 10,
      foreground: Hf,
      background: Uf,
      border: $f
    }) : (this.disposable.dispose(), this.disposable = void 0));
  }
  constructor(e, t, i, s) {
    this.debugService = e, this.contextService = t, this.statusbarService = i, this.configurationService = s, this.disposables = new te(), this.debugService.onDidChangeState(this.update, this, this.disposables), this.contextService.onDidChangeWorkbenchState(this.update, this, this.disposables), this.configurationService.onDidChangeConfiguration((n) => {
      n.affectsConfiguration("debug.enableStatusBarColor") && this.update();
    }), this.update();
  }
  update() {
    this.configurationService.getValue("debug").enableStatusBarColor ? this.enabled = zf(this.debugService.state, this.debugService.getModel().getSessions()) : this.enabled = !1;
  }
  dispose() {
    var e;
    (e = this.disposable) == null || e.dispose(), this.disposables.dispose();
  }
};
Zo = I([
  h(0, T),
  h(1, _e),
  h(2, Vh),
  h(3, O)
], Zo);
function zf(l, e) {
  return !(l === 0 || l === 1 || e.every((t) => {
    var i;
    return t.suppressDebugStatusbar || ((i = t.configuration) == null ? void 0 : i.noDebug);
  }));
}
const qf = 1024;
let er = !1, tr = !1, ir = class extends Pi {
  constructor(e, t, i, s, n, o, r, a, d, u, g, p) {
    super(e, s, t, r, a, o, n, d, u, g), this.debugService = i, this.needsRefresh = !1, this.menu = p.createMenu(k.DebugWatchContext, a), this._register(this.menu), this.watchExpressionsUpdatedScheduler = new oe(() => {
      this.needsRefresh = !1, this.tree.updateChildren();
    }, 50), this.watchExpressionsExist = yr.bindTo(a), this.variableReadonly = dn.bindTo(a), this.watchExpressionsExist.set(this.debugService.getModel().getWatchExpressions().length > 0), this.watchItemType = et.bindTo(a);
  }
  renderBody(e) {
    super.renderBody(e), this.element.classList.add("debug-pane"), e.classList.add("debug-watch");
    const t = Dn(e), i = this.instantiationService.createInstance(Os), s = this.instantiationService.createInstance(wt);
    this.tree = this.instantiationService.createInstance(rn, "WatchExpressions", t, new Gf(), [i, this.instantiationService.createInstance(tt, s)], new Kf(), {
      accessibilityProvider: new Xf(),
      identityProvider: { getId: (o) => o.getId() },
      keyboardNavigationLabelProvider: {
        getKeyboardNavigationLabel: (o) => {
          var r;
          if (o !== ((r = this.debugService.getViewModel().getSelectedExpression()) == null ? void 0 : r.expression))
            return o.name;
        }
      },
      dnd: new Yf(this.debugService),
      overrideStyles: {
        listBackground: this.getBackgroundColor()
      }
    }), this.tree.setInput(this.debugService), Ph.bindTo(this.tree.contextKeyService), this._register(this.tree.onContextMenu((o) => this.onContextMenu(o))), this._register(this.tree.onMouseDblClick((o) => this.onMouseDblClick(o))), this._register(this.debugService.getModel().onDidChangeWatchExpressions(async (o) => {
      this.watchExpressionsExist.set(this.debugService.getModel().getWatchExpressions().length > 0), this.isBodyVisible() ? (o && !o.name && (tr = !0), await this.tree.updateChildren(), tr = !1, o instanceof Y && this.tree.reveal(o)) : this.needsRefresh = !0;
    })), this._register(this.debugService.getViewModel().onDidFocusStackFrame(() => {
      if (!this.isBodyVisible()) {
        this.needsRefresh = !0;
        return;
      }
      this.watchExpressionsUpdatedScheduler.isScheduled() || this.watchExpressionsUpdatedScheduler.schedule();
    })), this._register(this.debugService.getViewModel().onWillUpdateViews(() => {
      er || this.tree.updateChildren();
    })), this._register(this.onDidChangeBodyVisibility((o) => {
      o && this.needsRefresh && this.watchExpressionsUpdatedScheduler.schedule();
    }));
    let n;
    this._register(this.debugService.getViewModel().onDidSelectExpression((o) => {
      const r = o == null ? void 0 : o.expression;
      r instanceof Y || r instanceof q && (o != null && o.settingWatch) ? (n = this.tree.options.horizontalScrolling, n && this.tree.updateOptions({ horizontalScrolling: !1 }), r.name && this.tree.rerender(r)) : !r && n !== void 0 && (this.tree.updateOptions({ horizontalScrolling: n }), n = void 0);
    })), this._register(this.debugService.getViewModel().onDidEvaluateLazyExpression(async (o) => {
      o instanceof q && this.tree.hasNode(o) && (await this.tree.updateChildren(o, !1, !0), await this.tree.expand(o));
    }));
  }
  layoutBody(e, t) {
    super.layoutBody(e, t), this.tree.layout(e, t);
  }
  focus() {
    this.tree.domFocus();
  }
  collapseAll() {
    this.tree.collapseAll();
  }
  onMouseDblClick(e) {
    if (e.browserEvent.target.className.indexOf("twistie") >= 0)
      return;
    const t = e.element, i = this.debugService.getViewModel().getSelectedExpression();
    t instanceof Y && t !== (i == null ? void 0 : i.expression) ? this.debugService.getViewModel().setSelectedExpression(t, !1) : t || this.debugService.addWatchExpression();
  }
  onContextMenu(e) {
    var o, r;
    const t = e.element, i = this.tree.getSelection();
    this.watchItemType.set(t instanceof Y ? "expression" : t instanceof q ? "variable" : void 0);
    const s = [], n = t instanceof q ? (o = t.presentationHint) == null ? void 0 : o.attributes : void 0;
    this.variableReadonly.set(!!n && n.indexOf("readOnly") >= 0 || !!((r = t == null ? void 0 : t.presentationHint) != null && r.lazy)), ri(this.menu, { arg: t, shouldForwardArgs: !0 }, s), this.contextMenuService.showContextMenu({
      getAnchor: () => e.anchor,
      getActions: () => s,
      getActionsContext: () => t && i.includes(t) ? i : t ? [t] : []
    });
  }
};
ir = I([
  h(1, Me),
  h(2, T),
  h(3, at),
  h(4, K),
  h(5, Ue),
  h(6, O),
  h(7, H),
  h(8, st),
  h(9, ce),
  h(10, we),
  h(11, Ne)
], ir);
class Gf {
  getHeight(e) {
    return 22;
  }
  getTemplateId(e) {
    return e instanceof Y ? Os.ID : tt.ID;
  }
}
function qa(l) {
  return typeof l.getConfigurationManager == "function";
}
class Kf {
  hasChildren(e) {
    return qa(e) || e.hasChildren;
  }
  getChildren(e) {
    if (qa(e)) {
      const t = e, i = t.getModel().getWatchExpressions(), s = t.getViewModel();
      return Promise.all(i.map((n) => n.name && !tr ? n.evaluate(s.focusedSession, s.focusedStackFrame, "watch").then(() => n) : Promise.resolve(n)));
    }
    return e.getChildren();
  }
}
var Xt;
let Os = (Xt = class extends xi {
  constructor(e, t, i, s) {
    super(i, s), this.menuService = e, this.contextKeyService = t;
  }
  get templateId() {
    return Xt.ID;
  }
  renderElement(e, t, i) {
    super.renderExpressionElement(e.element, e, i);
  }
  renderExpression(e, t, i) {
    const s = typeof e.value == "string" ? `${e.name}:` : e.name;
    let n;
    e.type ? n = e.type === e.value ? e.type : `${e.type}: ${e.value}` : n = e.value, t.label.set(s, i, n), li(e, t.value, {
      showChanged: !0,
      maxValueLength: qf,
      showHover: !0,
      colorize: !0
    });
  }
  getInputBoxOptions(e, t) {
    return t ? {
      initialValue: e.value,
      ariaLabel: c("typeNewValue", "Type new value"),
      onFinish: async (i, s) => {
        if (s && i) {
          const n = this.debugService.getViewModel().focusedStackFrame;
          n && (e instanceof q || e instanceof Y) && (await e.setExpression(i, n), this.debugService.getViewModel().updateViews());
        }
      }
    } : {
      initialValue: e.name ? e.name : "",
      ariaLabel: c("watchExpressionInputAriaLabel", "Type watch expression"),
      placeholder: c("watchExpressionPlaceholder", "Expression to watch"),
      onFinish: (i, s) => {
        s && i ? (this.debugService.renameWatchExpression(e.getId(), i), er = !0, this.debugService.getViewModel().updateViews(), er = !1) : e.name || this.debugService.removeWatchExpressions(e.getId());
      }
    };
  }
  renderActionBar(e, t) {
    const i = jf(this.contextKeyService, t), s = this.menuService.createMenu(k.DebugWatchContext, i), n = [], o = t;
    ri(s, { arg: o, shouldForwardArgs: !1 }, { primary: n, secondary: [] }, "inline"), e.clear(), e.context = o, e.push(n, { icon: !0, label: !1 });
  }
}, Xt.ID = "watchexpression", Xt);
Os = I([
  h(0, Ne),
  h(1, H),
  h(2, T),
  h(3, rt)
], Os);
function jf(l, e) {
  return l.createOverlay([
    [cn.key, e.memoryReference !== void 0],
    [et.key, "expression"]
  ]);
}
class Xf {
  getWidgetAriaLabel() {
    return c(
      { comment: ["Debug is a noun in this context, not a verb."], key: "watchAriaTreeLabel" },
      "Debug Watch Expressions"
    );
  }
  getAriaLabel(e) {
    return e instanceof Y ? c("watchExpressionAriaLabel", "{0}, value {1}", e.name, e.value) : c("watchVariableAriaLabel", "{0}, value {1}", e.name, e.value);
  }
}
class Yf {
  constructor(e) {
    this.debugService = e;
  }
  onDragOver(e) {
    if (!(e instanceof Sa))
      return !1;
    const t = e.elements;
    return t.length > 0 && t[0] instanceof Y;
  }
  getDragURI(e) {
    var t;
    return !(e instanceof Y) || e === ((t = this.debugService.getViewModel().getSelectedExpression()) == null ? void 0 : t.expression) ? null : e.getId();
  }
  getDragLabel(e) {
    if (e.length === 1)
      return e[0].name;
  }
  drop(e, t) {
    if (!(e instanceof Sa))
      return;
    const i = e.elements[0], s = this.debugService.getModel().getWatchExpressions(), n = t instanceof Y ? s.indexOf(t) : s.length - 1;
    this.debugService.moveWatchExpression(i.getId(), n);
  }
}
ge(class extends ct {
  constructor() {
    super({
      id: "watch.collapse",
      viewId: Vt,
      title: c("collapse", "Collapse All"),
      f1: !1,
      icon: tn.collapseAll,
      precondition: yr,
      menu: {
        id: k.ViewTitle,
        order: 30,
        group: "navigation",
        when: x.equals("view", Vt)
      }
    });
  }
  runInView(e, t) {
    t.collapseAll();
  }
});
const jd = "workbench.debug.viewlet.action.addWatchExpression", Xd = c("addWatchExpression", "Add Expression");
ge(class extends Fi {
  constructor() {
    super({
      id: jd,
      title: Xd,
      f1: !1,
      icon: ag,
      menu: {
        id: k.ViewTitle,
        group: "navigation",
        when: x.equals("view", Vt)
      }
    });
  }
  run(e) {
    e.get(T).addWatchExpression();
  }
});
const Yd = "workbench.debug.viewlet.action.removeAllWatchExpressions", Jd = c("removeAllWatchExpressions", "Remove All Expressions");
ge(class extends Fi {
  constructor() {
    super({
      id: Yd,
      title: Jd,
      f1: !1,
      icon: cg,
      precondition: yr,
      menu: {
        id: k.ViewTitle,
        order: 20,
        group: "navigation",
        when: x.equals("view", Vt)
      }
    });
  }
  run(e) {
    e.get(T).removeWatchExpressions();
  }
});
let sr = class {
  constructor(e, t, i, s) {
    this.debugService = t, this.configurationService = i, this.dialogService = s, e.onBeforeShutdown(async (n) => n.veto(this.shouldVetoShutdown(n.reason), "veto.debug"));
  }
  shouldVetoShutdown(e) {
    const t = this.debugService.getModel().getSessions().filter((s) => s.parentSession === void 0);
    return t.length === 0 || this.configurationService.getValue("debug").confirmOnExit === "never" ? !1 : this.showWindowCloseConfirmation(t.length);
  }
  async showWindowCloseConfirmation(e) {
    let t;
    return e === 1 ? t = c(
      "debug.debugSessionCloseConfirmationSingular",
      "There is an active debug session, are you sure you want to stop it?"
    ) : t = c(
      "debug.debugSessionCloseConfirmationPlural",
      "There are active debug sessions, are you sure you want to stop them?"
    ), !(await this.dialogService.confirm({
      message: t,
      type: "warning",
      primaryButton: c(
        { key: "debug.stop", comment: ["&& denotes a mnemonic"] },
        "&&Stop Debugging"
      )
    })).confirmed;
  }
};
sr = I([
  h(0, Js),
  h(1, T),
  h(2, O),
  h(3, Jt)
], sr);
const Jf = c("debugCategory", "Debug");
Mp();
ee.as(ci.Workbench).registerWorkbenchContribution(Ho, 4);
ee.as(ci.Workbench).registerWorkbenchContribution(Eo, 3);
ee.as(ci.Workbench).registerWorkbenchContribution(Ts, 4);
ee.as(ci.Workbench).registerWorkbenchContribution(Zo, 4);
ee.as(ci.Workbench).registerWorkbenchContribution(Ko, 4);
ee.as(ci.Workbench).registerWorkbenchContribution(sr, 4);
ee.as(sd.Quickaccess).registerQuickAccessProvider({
  ctor: $o,
  prefix: bd,
  contextKey: "inLaunchConfigurationsPicker",
  placeholder: c("startDebugPlaceholder", "Type the name of a launch configuration to run."),
  helpEntries: [{ description: c("startDebuggingHelp", "Start Debugging"), commandId: Cn }]
});
ee.as(sd.Quickaccess).registerQuickAccessProvider({
  ctor: Ao,
  prefix: pd,
  contextKey: "inDebugConsolePicker",
  placeholder: c("tasksQuickAccessPlaceholder", "Type the name of a debug console to open."),
  helpEntries: [{ description: c("tasksQuickAccessHelp", "Show All Debug Consoles"), commandId: md }]
});
Dr("editor.contrib.callStack", yo, 1);
Dr(si, vo, 1);
Dr(on, Ee, 2);
const W = (l, e, t, i) => {
  he.appendMenuItem(k.CommandPalette, {
    when: x.and(J, t),
    group: Jf,
    command: {
      id: l,
      title: e,
      category: Ng,
      precondition: i
    }
  });
};
W(Sd, { value: c("terminateThread", "Terminate Thread"), original: "Terminate Thread" }, F);
W(bn, fn, F, N.isEqualTo("stopped"));
W(Sn, mn, F, N.isEqualTo("stopped"));
W(lg, dg, F, x.and(cr, F, N.isEqualTo("stopped")));
W(vn, wn, F, N.isEqualTo("stopped"));
W(pn, gn, F, N.isEqualTo("running"));
W(He, di, F, x.or(Te.toNegated(), nt));
W(hn, un, F, N.isEqualTo("stopped"));
W(ug, { value: c(
  { comment: ["Debug is a noun in this context, not a verb."], key: "debugFocusConsole" },
  "Focus on Debug Console View"
), original: "Focus on Debug Console View" });
W(wd, { value: c("jumpToCursor", "Jump to Cursor"), original: "Jump to Cursor" }, dr);
W(wd, { value: c("SetNextStatement", "Set Next Statement"), original: "Set Next Statement" }, dr);
W(_i.ID, { value: _i.LABEL, original: "Run to Cursor" }, J);
W(Li.ID, { value: Li.LABEL, original: "Evaluate in Debug Console" }, F);
W(Ai.ID, { value: Ai.LABEL, original: "Add to Watch" });
W(vd, { value: c("inlineBreakpoint", "Inline Breakpoint"), original: "Inline Breakpoint" });
W(Cn, hg, x.and(J, N.notEqualsTo(Qs(1))));
W(Og, Rg);
W(Pg, Vg);
W(Wg, Fg, F);
W(md, Ug);
W($g, Hg);
W(pg, gg, F, N.isEqualTo("stopped"));
W(bg, fg, F, N.isEqualTo("stopped"));
W(Sg, mg, F, N.isEqualTo("stopped"));
W(vg, wg, F, N.isEqualTo("stopped"));
const V = (l, e, t, i, s, n, o = "navigation", r) => {
  he.appendMenuItem(l, {
    group: o,
    when: s,
    order: i,
    icon: r,
    command: {
      id: e,
      title: t,
      icon: r,
      precondition: n
    }
  });
};
V(k.DebugCallStackContext, Tr, xr, 10, G.isEqualTo("session"), void 0, "3_modification");
V(k.DebugCallStackContext, lt, Ui, 20, G.isEqualTo("session"), void 0, "3_modification");
V(k.DebugCallStackContext, hd, gd, 21, x.and(G.isEqualTo("session"), es, nt), void 0, "3_modification");
V(k.DebugCallStackContext, He, di, 30, G.isEqualTo("session"), void 0, "3_modification");
V(k.DebugCallStackContext, pn, gn, 10, x.and(G.isEqualTo("thread"), N.isEqualTo("running")));
V(k.DebugCallStackContext, hn, un, 10, x.and(G.isEqualTo("thread"), N.isEqualTo("stopped")));
V(k.DebugCallStackContext, bn, fn, 20, G.isEqualTo("thread"), N.isEqualTo("stopped"));
V(k.DebugCallStackContext, Sn, mn, 30, G.isEqualTo("thread"), N.isEqualTo("stopped"));
V(k.DebugCallStackContext, vn, wn, 40, G.isEqualTo("thread"), N.isEqualTo("stopped"));
V(k.DebugCallStackContext, Sd, c("terminateThread", "Terminate Thread"), 10, G.isEqualTo("thread"), void 0, "termination");
V(k.DebugCallStackContext, Cg, c("restartFrame", "Restart Frame"), 10, x.and(G.isEqualTo("stackFrame"), hc), Pc);
V(k.DebugCallStackContext, kg, c("copyStackTrace", "Copy Call Stack"), 20, G.isEqualTo("stackFrame"), void 0, "3_modification");
V(k.DebugVariablesContext, Vr, c("viewMemory", "View Binary Data"), 15, cn, F, "inline", kd);
V(k.DebugVariablesContext, Nd, c("setValue", "Set Value"), 10, x.or(lr, x.and(an, ur)), dn.toNegated(), "3_modification");
V(k.DebugVariablesContext, Or, c("copyValue", "Copy Value"), 10, void 0, void 0, "5_cutcopypaste");
V(k.DebugVariablesContext, Pd, c("copyAsExpression", "Copy as Expression"), 20, an, void 0, "5_cutcopypaste");
V(k.DebugVariablesContext, Fd, c("addToWatchExpressions", "Add to Watch"), 100, an, void 0, "z_commands");
V(k.DebugVariablesContext, Vd, c("breakWhenValueIsRead", "Break on Value Read"), 200, qc, void 0, "z_commands");
V(k.DebugVariablesContext, Rd, c("breakWhenValueChanges", "Break on Value Change"), 210, eo, void 0, "z_commands");
V(k.DebugVariablesContext, Od, c("breakWhenValueIsAccessed", "Break on Value Access"), 220, zc, void 0, "z_commands");
V(k.DebugWatchContext, jd, Xd, 10, void 0, void 0, "3_modification");
V(k.DebugWatchContext, yg, c("editWatchExpression", "Edit Expression"), 20, et.isEqualTo("expression"), void 0, "3_modification");
V(k.DebugWatchContext, Dg, c("setValue", "Set Value"), 30, x.or(x.and(et.isEqualTo("expression"), ur), x.and(et.isEqualTo("variable"), lr)), dn.toNegated(), "3_modification");
V(k.DebugWatchContext, Or, c("copyValue", "Copy Value"), 40, x.or(et.isEqualTo("expression"), et.isEqualTo("variable")), F, "3_modification");
V(k.DebugWatchContext, Vr, c("viewMemory", "View Binary Data"), 10, cn, void 0, "inline", kd);
V(k.DebugWatchContext, Eg, c("removeWatchExpression", "Remove Expression"), 20, et.isEqualTo("expression"), void 0, "inline", zg);
V(k.DebugWatchContext, Yd, Jd, 20, void 0, void 0, "z_commands");
he.appendMenuItem(k.EditorTitle, { submenu: k.EditorTitleRun, rememberDefaultAction: !0, title: { value: c("run", "Run or Debug..."), original: "Run or Debug..." }, icon: Ig, group: "navigation", order: -1 });
he.appendMenuItem(k.MenubarMainMenu, {
  submenu: k.MenubarDebugMenu,
  title: {
    value: "Run",
    original: "Run",
    mnemonicTitle: c({ key: "mRun", comment: ["&& denotes a mnemonic"] }, "&&Run")
  },
  order: 6
});
he.appendMenuItem(k.MenubarNewBreakpointMenu, {
  group: "1_breakpoints",
  command: {
    id: vd,
    title: c(
      { key: "miInlineBreakpoint", comment: ["&& denotes a mnemonic"] },
      "Inline Breakp&&oint"
    )
  },
  order: 2,
  when: J
});
const Qf = ee.as(Wi.ViewContainersRegistry).registerViewContainer({
  id: Ln,
  title: c(
    { comment: ["Debug is a noun in this context, not a verb."], key: "debugPanel" },
    "Debug Console"
  ),
  icon: Cd,
  ctorDescriptor: new Se(
    Jc,
    [Ln, { mergeViewWithContainerWhenSingleView: !0 }]
  ),
  storageId: Ln,
  hideIfEmpty: !0,
  order: 2
}, 1, { doNotRegisterOpenCommand: !0 });
ee.as(Wi.ViewsRegistry).registerViews([{
  id: X,
  name: c(
    { comment: ["Debug is a noun in this context, not a verb."], key: "debugPanel" },
    "Debug Console"
  ),
  containerIcon: Cd,
  canToggleVisibility: !1,
  canMoveView: !0,
  when: J,
  ctorDescriptor: new Se(Ni),
  openCommandActionDescriptor: {
    id: "workbench.debug.action.toggleRepl",
    mnemonicTitle: c(
      { key: "miToggleDebugConsole", comment: ["&& denotes a mnemonic"] },
      "De&&bug Console"
    ),
    keybindings: { primary: 3127 },
    order: 2
  }
}], Qf);
const $i = ee.as(Wi.ViewContainersRegistry).registerViewContainer({
  id: De,
  title: { value: c("run and debug", "Run and Debug"), original: "Run and Debug" },
  openCommandActionDescriptor: {
    id: De,
    mnemonicTitle: c({ key: "miViewRun", comment: ["&& denotes a mnemonic"] }, "&&Run"),
    keybindings: { primary: 3106 },
    order: 3
  },
  ctorDescriptor: new Se(qo),
  icon: xg,
  alwaysUseContainerInfo: !0,
  order: 3
}, 0), zi = ee.as(Wi.ViewsRegistry);
zi.registerViews([{ id: Zn, name: c("variables", "Variables"), containerIcon: Tg, ctorDescriptor: new Se(Vo), order: 10, weight: 40, canToggleVisibility: !0, canMoveView: !0, focusCommand: { id: "workbench.debug.action.focusVariablesView" }, when: ti.isEqualTo("default") }], $i);
zi.registerViews([{ id: Vt, name: c("watch", "Watch"), containerIcon: _g, ctorDescriptor: new Se(ir), order: 20, weight: 10, canToggleVisibility: !0, canMoveView: !0, focusCommand: { id: "workbench.debug.action.focusWatchView" }, when: ti.isEqualTo("default") }], $i);
zi.registerViews([{ id: ts, name: c("callStack", "Call Stack"), containerIcon: Lg, ctorDescriptor: new Se(To), order: 30, weight: 30, canToggleVisibility: !0, canMoveView: !0, focusCommand: { id: "workbench.debug.action.focusCallStackView" }, when: ti.isEqualTo("default") }], $i);
zi.registerViews([{ id: Qc, name: c("breakpoints", "Breakpoints"), containerIcon: Ag, ctorDescriptor: new Se(Bg), order: 40, weight: 20, canToggleVisibility: !0, canMoveView: !0, focusCommand: { id: "workbench.debug.action.focusBreakpointsView" }, when: x.or(mc, ti.isEqualTo("default"), bc) }], $i);
zi.registerViews([{ id: Fh, name: c("loadedScripts", "Loaded Scripts"), containerIcon: Mg, ctorDescriptor: new Se(Xo), order: 35, weight: 5, canToggleVisibility: !0, canMoveView: !0, collapsed: !0, when: x.and(uc, ti.isEqualTo("default")) }], $i);
ee.as(Wh.EditorPane).registerEditorPane(Uh.create(Go, Zc, c("disassembly", "Disassembly")), [new Se(ns)]);
const Zf = ee.as(Hh.Configuration);
Zf.registerConfiguration({
  id: "debug",
  order: 20,
  title: c("debugConfigurationTitle", "Debug"),
  type: "object",
  properties: {
    "debug.allowBreakpointsEverywhere": {
      type: "boolean",
      description: c(
        { comment: ["This is the description for a setting"], key: "allowBreakpointsEverywhere" },
        "Allow setting breakpoints in any file."
      ),
      default: !1
    },
    "debug.openExplorerOnEnd": {
      type: "boolean",
      description: c(
        { comment: ["This is the description for a setting"], key: "openExplorerOnEnd" },
        "Automatically open the explorer view at the end of a debug session."
      ),
      default: !1
    },
    "debug.inlineValues": {
      type: "string",
      enum: ["on", "off", "auto"],
      description: c(
        { comment: ["This is the description for a setting"], key: "inlineValues" },
        "Show variable values inline in editor while debugging."
      ),
      enumDescriptions: [
        c(
          "inlineValues.on",
          "Always show variable values inline in editor while debugging."
        ),
        c(
          "inlineValues.off",
          "Never show variable values inline in editor while debugging."
        ),
        c(
          "inlineValues.focusNoScroll",
          "Show variable values inline in editor while debugging when the language supports inline value locations."
        )
      ],
      default: "auto"
    },
    "debug.toolBarLocation": {
      enum: ["floating", "docked", "hidden"],
      markdownDescription: c(
        { comment: ["This is the description for a setting"], key: "toolBarLocation" },
        "Controls the location of the debug toolbar. Either `floating` in all views, `docked` in the debug view, or `hidden`."
      ),
      default: "floating"
    },
    "debug.showInStatusBar": {
      enum: ["never", "always", "onFirstSessionStart"],
      enumDescriptions: [c("never", "Never show debug in Status bar"), c("always", "Always show debug in Status bar"), c(
        "onFirstSessionStart",
        "Show debug in Status bar only after debug was started for the first time"
      )],
      description: c(
        { comment: ["This is the description for a setting"], key: "showInStatusBar" },
        "Controls when the debug Status bar should be visible."
      ),
      default: "onFirstSessionStart"
    },
    "debug.internalConsoleOptions": Ja,
    "debug.console.closeOnEnd": {
      type: "boolean",
      description: c(
        "debug.console.closeOnEnd",
        "Controls if the Debug Console should be automatically closed when the debug session ends."
      ),
      default: !1
    },
    "debug.terminal.clearBeforeReusing": {
      type: "boolean",
      description: c(
        { comment: ["This is the description for a setting"], key: "debug.terminal.clearBeforeReusing" },
        "Before starting a new debug session in an integrated or external terminal, clear the terminal."
      ),
      default: !1
    },
    "debug.openDebug": {
      enum: ["neverOpen", "openOnSessionStart", "openOnFirstSessionStart", "openOnDebugBreak"],
      default: "openOnDebugBreak",
      description: c("openDebug", "Controls when the debug view should open.")
    },
    "debug.showSubSessionsInToolBar": {
      type: "boolean",
      description: c(
        { comment: ["This is the description for a setting"], key: "showSubSessionsInToolBar" },
        "Controls whether the debug sub-sessions are shown in the debug tool bar. When this setting is false the stop command on a sub-session will also stop the parent session."
      ),
      default: !1
    },
    "debug.console.fontSize": {
      type: "number",
      description: c(
        "debug.console.fontSize",
        "Controls the font size in pixels in the Debug Console."
      ),
      default: Oe ? 12 : 14
    },
    "debug.console.fontFamily": {
      type: "string",
      description: c(
        "debug.console.fontFamily",
        "Controls the font family in the Debug Console."
      ),
      default: "default"
    },
    "debug.console.lineHeight": {
      type: "number",
      description: c(
        "debug.console.lineHeight",
        "Controls the line height in pixels in the Debug Console. Use 0 to compute the line height from the font size."
      ),
      default: 0
    },
    "debug.console.wordWrap": {
      type: "boolean",
      description: c(
        "debug.console.wordWrap",
        "Controls if the lines should wrap in the Debug Console."
      ),
      default: !0
    },
    "debug.console.historySuggestions": {
      type: "boolean",
      description: c(
        "debug.console.historySuggestions",
        "Controls if the Debug Console should suggest previously typed input."
      ),
      default: !0
    },
    "debug.console.collapseIdenticalLines": {
      type: "boolean",
      description: c(
        "debug.console.collapseIdenticalLines",
        "Controls if the Debug Console should collapse identical lines and show a number of occurrences with a badge."
      ),
      default: !0
    },
    "debug.console.acceptSuggestionOnEnter": {
      enum: ["off", "on"],
      description: c(
        "debug.console.acceptSuggestionOnEnter",
        "Controls whether suggestions should be accepted on Enter in the Debug Console. Enter is also used to evaluate whatever is typed in the Debug Console."
      ),
      default: "off"
    },
    launch: {
      type: "object",
      description: c(
        { comment: ["This is the description for a setting"], key: "launch" },
        "Global debug launch configuration. Should be used as an alternative to 'launch.json' that is shared across workspaces."
      ),
      default: { configurations: [], compounds: [] },
      $ref: Ri
    },
    "debug.focusWindowOnBreak": {
      type: "boolean",
      description: c(
        "debug.focusWindowOnBreak",
        "Controls whether the workbench window should be focused when the debugger breaks."
      ),
      default: !0
    },
    "debug.focusEditorOnBreak": {
      type: "boolean",
      description: c(
        "debug.focusEditorOnBreak",
        "Controls whether the editor should be focused when the debugger breaks."
      ),
      default: !0
    },
    "debug.onTaskErrors": {
      enum: ["debugAnyway", "showErrors", "prompt", "abort"],
      enumDescriptions: [c("debugAnyway", "Ignore task errors and start debugging."), c("showErrors", "Show the Problems view and do not start debugging."), c("prompt", "Prompt user."), c("cancel", "Cancel debugging.")],
      description: c(
        "debug.onTaskErrors",
        "Controls what to do when errors are encountered after running a preLaunchTask."
      ),
      default: "prompt"
    },
    "debug.showBreakpointsInOverviewRuler": {
      type: "boolean",
      description: c(
        { comment: ["This is the description for a setting"], key: "showBreakpointsInOverviewRuler" },
        "Controls whether breakpoints should be shown in the overview ruler."
      ),
      default: !1
    },
    "debug.showInlineBreakpointCandidates": {
      type: "boolean",
      description: c(
        { comment: ["This is the description for a setting"], key: "showInlineBreakpointCandidates" },
        "Controls whether inline breakpoints candidate decorations should be shown in the editor while debugging."
      ),
      default: !0
    },
    "debug.saveBeforeStart": {
      description: c(
        "debug.saveBeforeStart",
        "Controls what editors to save before starting a debug session."
      ),
      enum: ["allEditorsInActiveGroup", "nonUntitledEditorsInActiveGroup", "none"],
      enumDescriptions: [
        c(
          "debug.saveBeforeStart.allEditorsInActiveGroup",
          "Save all editors in the active group before starting a debug session."
        ),
        c(
          "debug.saveBeforeStart.nonUntitledEditorsInActiveGroup",
          "Save all editors in the active group except untitled ones before starting a debug session."
        ),
        c(
          "debug.saveBeforeStart.none",
          "Don't save any editors before starting a debug session."
        )
      ],
      default: "allEditorsInActiveGroup",
      scope: 5
    },
    "debug.confirmOnExit": {
      description: c(
        "debug.confirmOnExit",
        "Controls whether to confirm when the window closes if there are active debug sessions."
      ),
      type: "string",
      enum: ["never", "always"],
      enumDescriptions: [
        c("debug.confirmOnExit.never", "Never confirm."),
        c(
          "debug.confirmOnExit.always",
          "Always confirm if there are debug sessions."
        )
      ],
      default: "never"
    },
    "debug.disassemblyView.showSourceCode": {
      type: "boolean",
      default: !0,
      description: c(
        "debug.disassemblyView.showSourceCode",
        "Show Source Code in Disassembly View."
      )
    },
    "debug.autoExpandLazyVariables": {
      type: "boolean",
      default: !1,
      description: c(
        "debug.autoExpandLazyVariables",
        "Automatically show values for variables that are lazily resolved by the debugger, such as getters."
      )
    },
    "debug.enableStatusBarColor": {
      type: "boolean",
      description: c("debug.enableStatusBarColor", "Color status bar when debugger is active"),
      default: !0
    }
  }
});
const eb = Ii.prototype.showError;
Ii.prototype.showError = function(l, e) {
  return eb.call(this, l, e, !1);
};
function zb() {
  return {
    ...$h(),
    [ii.toString()]: new Se(np, [], !0),
    [T.toString()]: new Se(Ii, [], !0),
    [Ka.toString()]: new Se(So, [], !0)
  };
}
export {
  zb as default
};
